,api_name,api_description,input,example,error
0,hf_getautotippingangles ,"Description
This command returns the tipping angles and rotation plane of auto-tipping for selected
        elements.
","Inputs

mark_id
Selection mark, which can be 1 or 2.
symmetric_pane_normal_vector_id
A vector ID if the selected mesh is half of a symmetrical part.

","Example
*createmark elements 1 all
set returnValue [hf_getautotippingangles 1 0]
set angle [ lindex $ returnValue 0 ]
set rotationPlaneX [ lindex $ returnValue 1 ]
set rotationPlaneY [ lindex $ returnValue 2 ]
set rotationPlaneZ [ lindex $ returnValue 3 ]
set rotationAnlongX [ lindex $ returnValue 4 ]
set rotationAnlongY [ lindex $ returnValue 5 ]
set rotationAnlongZ [ lindex $ returnValue 6 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1,hm_addchildrenoflistsinmark,"Description
Add children entities of lists in a mark.
","
Inputs


mark_id
The ID of the mark.  Valid values are 1 and 2.
recursive
0 - Do not return children entities of children lists
1 - Return children entities of children lists
references_mode
Determines how to compute entities referred by children entities:
0 - No references are returned
1 - Direct containment, such as elems by comps, or nodes by sets
2 - Only applicable to comps containing nodes, and recursive content of sets and
            assemblies
3 - Direct references
4 - Direct descendants
5 - Expanded descendants

","Examples
To populate mark 1 without
        recursion:hm_addchildrenoflistsinmark 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2,hm_ae_get_partson,"Description
Returns the part IDs for given attachments.
","
Inputs


mark_id
The ID of the mark of attachments.  Valid values are 1 and 2.

","Examples
To get the parts for all attachments:
*createmark attachments 1 all
hm_ae_get_partson 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
3,hm_ae_state,"Description
Return the current state of an attachment (modified, unrealized, realized, failed).
","
Inputs


id
The ID of the attachment to query.

","Examples
To query the state of attachment 4:
hm_ae_state 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
4,hm_answernext ,"Inputs

answer
Valid values are yes, no, all (for 'yes to all') and nall (for 'no to all').

","Example
To answer yes to deleting the current model, which has not been saved:
hm_answernext yes
*deletemodel
","Errors
None.
",
5,hm_assemlist ,"Description
Returns the hierarchical structure of assemblies, and optionally standalone components and
        multibodies, along with properties, materials, groups and beamsection collectors. 
In the same way that a directory list is made up of separated sub-directories, the returned
        list consists of separated entity names. 
If the output is not requested to include the entity type, any path that ends in the
        separator character represents an empty assembly.
","Inputs

separator
The character used to separate the assemblies in the list.
full_listing
0 - Do not include components and multibodies not in assemblies, nor any materials,
            properties, beamsectcols and groups. 
1 - Include components and multibodies not in assemblies, and all materials,
            properties, beamsectcols and groups. 
This is optional. If not specified, a value of 0 is assumed.
append_entity_type
0 - Do not append the entity type to the entity output. 
1 - Append the entity type to the entity output.
This is optional. If not specified, a value of 0 is assumed. If specified as 1,
              type_separator is mandatory.
type_separator
The character used to separate the entity type names in the list. 
Only used if append_entity_type is 1. 
For example: With ‘/’ as separator and ‘:’ as type_separator: the
            output might look like:

 /assemblies:assem1/assemblies:subassem1/components:comp1


","Example
To find the hierarchy for the following structure of assemblies and components, using a
        separator of /:
hm_assemlist /
/wheel/base/Part1 /wheel/attachments/Part2 /head/Part3 /empty/
For the same example, include the full listing:
hm_assemlist / 1
/wheel/base/Part1 /wheel/attachments/Part2 /head/Part3 /empty/ /Part4
For the same example, include the full listing as well as the entity types, with a
        separator of %
hm_assemlist / 1 1 %
/assemblies%wheel/assemblies%base/components%Part1
        /assemblies%wheel/assemblies%attachments/components%Part2 /assemblies%head/components%Part3
        /assemblies%empty /components%Part4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
6,hm_attributeentitytype ,"Description
Returns the entity type number of an entity attribute on an entity for the current
        template. If the attribute does not exist on the entity, or is not an attribute from the
        current template, an error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the attribute entity type number of the entity attribute with name LSD_CID on
        property 1 for the LS-DYNA template:
hm_attributeentitytype props 1 LSD_CID -byid
To get the attribute entity type number of the entity attribute with ID 412 on property 1
        for the LS-DYNA template:
hm_attributeentitytype props 1 412 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
7,hm_attributeidentifier ,"Description
Returns the identifier flag of an attribute on an entity for the current template. If the
        attribute does not exist on the entity, or is not an attribute from the current template, an
        error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. -
byid - Search only by ID.

","Examples
To get the attribute identifier of the attribute named Rho on material 6 for the LS-DYNA template:
hm_attributeidentifier material 6 Rho -byid
To get the attribute behavior of attribute ID 118 on material 6 for the LS-DYNA template:
hm_attributeidentifier material 6 118 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
8,hm_attributeindexbehavior,"Description
Returns the behavior flag of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute behavior of the attribute with index 3 on material 6:
hm_attributeindexbehavior material 6 3 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
9,hm_attributeindexentitytypename ,"Description
Returns the entity type string of an indexed entity attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute entity type string of the entity attribute with index 4 on property
        1:
hm_attributeindexentitytypename props 1 4 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
10,hm_attributeindexsolver,"Description
Returns the solver number of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute solver number of the attribute with index 3 on material 6:
hm_attributeindexsolver material 6 3 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
11,hm_attributeindextype,"Description
Returns the attribute type number of an indexed attribute on an entity. The values returned
        have the following meanings: 
1 - integer 
2 - double 
3 - string 
4 - 1D integer array 
5 - 1D double array 
6 - entity 
7 - (not supported) 
8 - (not supported) 
9 - 2D integer array 
10 - 2D double array 
11 - string array 
12 - 1D entity array 
13 - 2D entity array
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute type number of the attribute with index 4 on property 1:
hm_attributeindextype props 1 4 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
12,hm_attributelist ,"Description
Returns a list of all attribute IDs or names assigned to a specific entity for the current
        template.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
value
The type of list to return. Valid values are: 
id - the attribute IDs 
name - the attribute names
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To list the attribute IDs for the current template assigned to mat ID 6:
hm_attributelist mats 6 id
To list the attribute names for the current template assigned to mat name 6:
hm_attributelist mats 6 name -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
13,hm_attributenamefromid ,"Description
Returns an attribute name from the attribute ID for the current template. If the attribute
        does not exist in the current template, an error is returned.
","Inputs

attribute_id
The ID of the attribute to query.

","Example
To get the attribute name of the attribute ID 100:
hm_attributenamefromid 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
14,hm_attributesolverarrayvalues ,"Description
Returns the solver code and all values for a 1D array attribute on an entity. The command
        first searches to find the specified attribute for the current template. If the attribute is
        not found for the current template, the search can be extended to search all attributes
        assigned to the entity. If the attribute does not exist on the entity, an error is
        returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.
attribute_name_or_id
The name or ID of the attribute to query. If a name is specified, the attribute must
            exist in the current template.
extend_search
By default, the attribute will only be searched for the current template. However, the
            search can be extended to search all attributes assigned to the entity. If the attribute
            is specified by name, this argument is ignored and only the current template is
            considered. Valid values are: 
0 - Search only attributes for the current template on the entity. 
1 - Search all attributes on the entity.

","Example
To get the solver code and all values of the 1D array for the attribute with name Example
        on material 6, considering only the current template:
hm_attributesolverarrayvalues material 6 Example -byid
or
hm_attributesolverarrayvalues material 6 Example -byid 0
To get the solver code and all values of the 1D array for the attribute with ID 100 on
        material 6, considering all attributes:
hm_attributesolverarrayvalues material 6 100 -byid 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
15,hm_attributetype ,"Description
Returns the attribute type number of an attribute for the current template. If the
        attribute is not an attribute from the current template, an error is returned. The values
        returned have the following meanings: 
1 - integer 
2 - double
3 - string 
4 - 1D integer array
5 - 1D double array 
6 - entity 
7 - (not supported) 
8 - (not supported) 
9 - 2D integer array 
10 - 2D double array 
11 - string array 
12 - 1D entity array 
13 - 2D entity array


","Inputs

attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.

","Examples
To get the attribute type number of the attribute named LSD_PID for the LS-DYNA template:
hm_attributetype LSD_PID
To get the attribute type number of the attribute ID 149 for the LS-DYNA template:
hm_attributetype 149
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
16,hm_bag_getconfigfromgenericname ,"Description
This command returns the bag configuration for the specified generic name.
","Inputs

name
The generic name of the bag configuration.

","Example
To get the bag configuration of ADMPart generic name:
hm_bag_getconfigfromgenericname ADMPart
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
17,hm_bag_getgenericnamefromconfig,"Description
This command returns the generic bag name for the specified bag config.
","Inputs

config
The bag configuration.

","Example
To get the generic name of bag config 4:
hm_bag_getgenericnamefromconfig 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
18,hm_baglist_byconfig,"Description
This command gets the list of bags in the model with configuration
          config.
","Inputs

config
The bag configuration. See *bagcreate for a list of bag
            configurations.
list_type
The type of list to generate (name or ID).

","Examples
To get a list of the all bag names of configuration 9 (ADMPart):
hm_baglist_byconfig 9 name
To get a list of the all bag IDs of configuration 10 (ADMMaterial):
hm_baglist_byconfig 10 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
19,hm_cardimageassignedtoentity,"Description
Returns 1 if a card can be assigned to the entities on the mark for the current template, 0
        otherwise.
","
Inputs



entity_type

The type of entity to query.

mark_id

The ID of the mark of entities to query.  Valid values are 1 and 2.

","Examples
To query components 100 and 101:
*createmark comps 1 100 101
hm_getimageassignedtoentity comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
20,hm_ce_cfglistget,"Description
Returns info on FE configurations for a specified solver, connector style and FE config
        file.
","Inputs

solver_name
The name of the solver to query. Examples include nastran, abaqus, lsdyna, etc.
style
The connector style name. Valid values are area, bolt, mass, seam and spot.
filename
The full path and filename of the FE config file. If not specified, the current. 

","Examples
To get the FE config list for Nastran spot connectors from the
        file C:/temp/feconfig.cfg:
hm_ce_cfglistget nastran spot C:/temp/feconfig.cfg
To get all current FE configs for Nastran spot connectors:
hm_ce_cfglistget nastran spot """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
21,hm_ce_checkprojection,"Description
Check if the connectors make projection. Returns the failed connector IDs.
","Inputs

ce_mark
Mark of connectors
tolerance
Tolerance value

","Example
To check if the entities to connect can be found in the specified tolerance range:
*createmark connectors 1 ""displayed"" 
set tolerance 8.0;
set ce_ids [ hm_ce_checkprojection 1 $tolerance];
The check is performed only for meshed components and surfaces added to connector.
","Errors
None.
"
22,hm_ce_datalist,"Description
Returns, in a list, all connector data displayed in the table for a single connector on
        mark and as a list of lists for multiple connectors.
","Inputs

ce_mark
The mark of connector entity(s).

","Example
To obtain connector information for connectors 1 and 2:
*createmark connectors 1 1 2;
set ce_data_list [ hm_ce_datalist 1 ];
foreach ce_data $ce_data_list {
   puts $ce_data; 
}
This function returns a list of lists containing connector data. Each list contains
        information about a single connector. The information contained in a single list is shown in
        the following order,
{ID Thickness Component Location_Entity Config Link1_info Link2_Info State}

Component
The name of the component that contains the connector.


Location_Entity
A string that specifies if the connector was created at a node/point or line.


Link_Info
The link entity information contains entity type, entity ID/name, entity rule, and
            entity state. For more information, see Connector Terminology.
              Link_Info is repeated for each link stored in the connector.


State
Specifies the realization state of a connector.

","Errors
None.
"
23,hm_ce_errorreport ,"Description
Returns the specific reason for the failed realization of a connector.
","Inputs

ce_id
The ID of the connector entity.
reportFlag
0 returns one of the failure criteria. 
1 returns all the causes for failed realization.

","Examples
To obtain a simple report for failed realization for a connector with ID 10:
set ce_id 10;
set single_err_report [ hm_ce_errorrepot $ce_id 0 ];
To get a detailed report returned as list of lists for connector with ID 10:
set ce_id 10;
	set detail_err_report [ hm_ce_errorrepot $ce_id 1 ];
This function returns a report only for the failed connectors. The state of the connector
        can be looked up using the connection information table. All failed connectors are marked
        red.
","Errors
None.
"
24,hm_ce_fedata ,"Description
Returns the weld config or the tolerance set to realize a connector.
","Inputs

ce_id
The ID of the connector.
function
One of three possible strings: 
configval - returns the configuration number 
configname - returns the configuration name 
tolerance - returns the realization tolerance

","Example
To get the current weld config set for connector with ID 1:
set ce_id 1;
set config [ hm_ce_fedata $ce_id ""configval"" ];
Currently only configval and tolerance are supported
        for the connector.
","Errors
None.
"
25,hm_ce_generatenamefrominclude,"Description
Returns a name using a base name and connector include ID.
This returns a string like <base_name>_inc<ID> where ID is the include ID of the
        connector.
","
Inputs


id
The ID of the connector to query.
base_name
The base name to append.

","Examples
To generate a name for connector 2 and the base ""hexa_comp"":
hm_ce_generatenamefrominclude 2 ""hexa_comp""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
26,hm_ce_getallfe,"Description
Returns specific FE entity type and ID(s) from a realized connector. 
","Inputs

ce_id
The ID of the connector.

","Example
To get all the realized FE types and IDs from the displayed connectors:
*createmark connectors 1 ""displayed""
set ce_list [ hm_getmark connectors 1 ];
foreach ce_id $ce_list {
     set ce_fes [ hm_ce_getallfe $ce_id ];
     puts  $ce_id  $ce_fes;
}
This function returns a list of lists that contain the realized FE from the connector
        entity. If the realized FE of the connector consists of only elements, the main list will
        contain only one sub-list: { {elems id1 id2 …} } . If the realized FE has both elements and
        systems, the main list will contain two sub-lists: { {elems id1 id2 …} and {systs id1 id2 …}
        }
","Errors
None.
"
27,hm_ce_getconfigfromconnectorcontrol,"Description
Gets the FE config name from a connector control or connector control default.
","
Inputs


entity_type
The type of entity to query.  Valid values are connectorcontrol and
            connectorcontroldefault.
name
The name of the entity to query.

","Examples
Get the FE config name from connectorcontroldefault
        rbe3_(load_transfer)_spot_nastran_template:
set fe_config [hm_ce_getconfigfromconnectorcontrol connectorcontroldefault ""rbe3_(load_transfer)_spot_nastran_template""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
28,hm_ce_getconnectorcontrollist,"Description
Returns a list of connector controls or connector control defaults for a given solver and
        style.
","
Inputs


solver
The solver name.
style
The connector style.  Valid values are app_mass, area, bolt, seam and spot.
option
0 - Return both connector control and connector control default
1 - Return connector control default only
2 - Return connector control only

","Examples
To get connector control for solver nastran and style spot:
set ctrl_list [hm_ce_getconnectorcontrollist nastran spot 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
29,hm_ce_getdefaultconnectorcontrolfromconfig,"Description
Returns the connector control default name and ID for an FE config.
","
Inputs


solver
The solver name.
style
The connector style. Valid values are app_mass, area, bolt, seam and spot.
feconfig
The FE config name

","Examples
Return the connector control default for solver nastran, style spot, and FE config ""rbe3
        (load transfer)"":
set ctrl_info [hm_ce_getdefaultconnectorcontrolfromconfig nastran spot ""rbe3 (load transfer)""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
30,hm_ce_getfe,"Description
Returns specific weld ID(s) from a realized connector.
","Inputs

ce_id
The ID of the connector entity.
ent_type
The type of entity (ELEMS, EQUATIONS, etc).
config
The weld configuration (spring - 21, weld - 3).
type
The type of weld from template (CBSUH - 6).

","Example
To get element config spring of type CBUSH from a connector of ID 1:
*createmark connectors 1 ""displayed""
set config 21;
set type 6;
set ce_list [ hm_getmark connectors 1 ];
foreach ce_id $ce_list {
  if { $ce_id == 1 } {
     set cbush_id [ hm_ce_getfe $ce_id ELEMENTS $config $type ];
     break;
 }
}
The function will return either a list of values or a single value.
","Errors
None.
"
31,hm_ce_getfeprojtrip,"Description
Returns the connector projection data for a specific layer. This includes the node ID,
        element ID, u, v, and list of weld node IDs.
This function should only be called from within a connector-registered property script. The
        projection data this function relies upon is removed immediately after connector FE
        realization.
This function is useful if the weld element card requires any of the above parameters. The
        node ID is one of the nodes of the weld, the elem ID is the element that the weld is
        connecting, and u and v give the coordinates of the weld node with respect to the elements
        face.
","Inputs

index
The index of interest in the array (corresponds to a weld).
layer
0 - Return the dependent layer
1 - Return the independent layer

","Example
To get the projection information for the independent layer from the projection data array
        for index 10:
set proj_data [ hm_ce_getfeprojtrip $index $layer];
set nodeid [ lindex $proj_data 0 ];
set elemid [ lindex $proj_data 1 ];
set u [ lindex $proj_data 2 ];
set v [ lindex $proj_data 3 ];
set weld_nodes [ lindex $proj_data 4 ];
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
32,hm_ce_getglobalsharedentitysettings,"Description
Gets the global shared entity management settings.  These settings affect the shared entity
        management auto-registration process and the shared entity cleanup process during various
        operations.
","Inputs

setting
The name of the setting to query.  See
              *CE_SetGlobalSharedEntitySettings for a list of valid
            settings.

","Example
To get the value of the auto_register setting:
hm_ce_getglobalsharedentitysettings ""auto_register""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
33,hm_ce_getlinkentities,"Description
Returns specific type of entities IDs that are added to a connector. 
","Inputs

ce_id
The ID of the connector.
ent_type
Specific entity type required.

","Example
To get all the component IDs added to connector of ID 10:
*createmark connectors 1 ""by comp"" ce_component;
set ce_list [ hm_getmark connectors 1 ];
foreach ce_id $ce_list {
    if { $ce_id == 10 } {
         set comp_list [ hm_ce_getlinkentities $ce_id COMPONENTS ];
         break; 
    }
}
The function will return a list with single or multiple entity IDs. 
","Errors
None.
"
34,hm_ce_getlinkinfo,"Description
Returns link info for a connector including entity type, IDs/names, locator rule and
        XYZs.
","Inputs

id
The ID of the connector to query.
index
The index of the link on the connector.

","Example
To get link information for connector ID 1 for all links:
set ce_id 1
set num_ents [hm_ce_numlinkentities $ce_id]
for {set count 0} {$count <= $num_ents} {incr count} {
foreach {type info state rule} [hm_ce_getlinkinfo $ce_id $count] {
lappend linkArray($type) $info
}
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
35,hm_ce_getprojcompid,"Description
Returns the component ID for the projection data layer of interest. 
","Inputs

index
The index of interest in the array (corresponds to a weld).
layer
The independent (= 1) or the dependent (= 0) layer the weld connects.

","Example
To get the component ID for index 5 and independent layer:
set comp_id [ hm_ce_getprojcompid 5 1];
This function should only be called from within a connector-registered property script
        (which is executed during connector FE realization). The projection data this function
        relies upon is removed immediately after connector FE realization. 
The component corresponds to the part the weld is connecting at that location.
",
36,hm_ce_getprojfe,"Description
Returns the weld data list (types and IDs) for the given projection array index and weld
        array index.
This should only be called from within a connector-registered property script (which is
        executed during connector FE realization). The projection data this function relies upon is
        removed immediately after connector FE realization. 
The list will contain all the welds and rigids created for that layer.
","Inputs

proj_idx
The index of interest from the projection data array.
weld_idx
The index of interest from the weld data array.

","Example
To get the type of weld element and its ID for projection array index 2 and weld array
        index 1:
set num_projs [hm_ce_getnumoffeprojinfo];
for {set pidx 0} {$pidx < $num_projs} {incr pidx} {
    if { $pidx == 2 } {
        set num_welds [hm_ce_getprojfesize $pidx];
        for {set widx 0} {$widx < $num_welds} {incr widx} {
            if {$widx == 1} {
                set weld_data_list [hm_ce_getprojfe $pidx $widx];
            }
        }
    }
}
 To get a specific config and type from the information:
set num_data [llength $weld_data_list];
for {set didx 0} {$num_data < $didx} {incr didx} {
    set entity [lindex $weld_data_list 0];
    set id [lindex $weld_data_list 1];
    # If elements
    if {$entity == 2} {
        set config [hm_getvalue elems id=$id dataname=config];
        set type [hm_getvalue elems id=$id dataname=type];         
    }
}
",
37,hm_ce_getprojnodeid,"Description
This command returns the node ID for the projection data layer of interest. The node
        corresponds to the part the weld is connecting at that location. 
This function should only be called from within a connector-registered property script
        (which is executed during connector FE realization). The projection data this function
        relies upon is removed immediately after connector FE realization.
","Inputs

index
The index of interest in the array (corresponds to a weld).
layer
The independent (1) or the dependent (0) layer the weld connects.

","Example
To get the projection node ID for index 5 and independent layer (1):
set num_of_projs [hm_ce_getnumoffeprojinfo];
set layer 1;
foreach index $num_of_projs {
     if {$index == 5} {
         set node_id [hm_ce_getprojnodeid $index $layer];
         break;
     }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
38,hm_ce_getsolverprojectionbymark,"Description
Returns the solver projection data.  The data is returned as a list of lists
        containing:
{node_id, {x, y, z}, elem_id}
 where {x, y, z} is the coordinates of the projection point.
","
Inputs



entity_type1

The first entity type.  Valid values are nodes and elems.

mark_id1

The ID of the first mark of entities.  Valid values are 1 and 2.

entity_type2

The second entity type.  Valid values are comps and elems.

mark_id2

The ID of the second mark of entities.  Valid values are 1 and 2.

option

0 - use_RBE_only=0
1 - use_RBE_only=1
2 - use_RBE_only=2
3 - use_RBE_only=3

solver_id

Must be set as 12 for OptiStruct.

","Examples
To query the projections for nodes 1-10 and comps 3 and 4:
*createmark nodes 1 1-10;
*createmark comps 2 3 4;
set node_prj_pairs [hm_ce_getsolverprojectionbymark nodes 1 comps 2 0 12];
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
39,hm_ce_getthickness,"Description
Gets the total number of layers to be connected.
","Inputs

ce_id
The ID of the connector.

","Example
To find out if the definition at the connector is 2T/3T/nT:
set ce_id [ hm_entitymaxid CONNECTORS];
set T [ hm_ce_getthickness $ce_id ];
The total thickness will influence the number of welds created at a connector.
",
40,hm_ce_getvalidabsolutepath,"Description
Returns a valid absolute path from a relative path. Returns an empty string if the relative
        path could not be converted into a valid absolute path.
","Inputs

relative_path
The relative path of the file/folder. Supported relative path tags: 
[ALTAIR_HOME] - Current installation base directory.
[CURRENTWORKINGDIR] - Current working directory. 
[EXECUTABLEDIR] - Full directory path of the application’s executable.
[hm_scripts_dir] - HM scripts directory. 
[HW_CONFIG_PATH] - Paths in HW_CONFIG_PATH environment variable.
[USER_HOME] - User home directory.

","Example
To get the absolute path for the user home relative path:
hm_ce_getvalidabsolutepath {[USER_HOME]/Some_Folder/Some_File.txt}
Returns: {C:/Users/username/Some_Folder/Some_File.txt}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
41,hm_ce_imprintelemsget,"Description
Returns imprinted elements for a connector.
","
Inputs


id
The ID of the connector to query.
reserved
Reserved for future use, must be set to 0.

","Examples
To get imprinted elements from the connector with ID 101:
set imprinted_elems [hm_ce_imprintelemsget 101 0]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
42,hm_ce_linkprojectionorderget,"Description
Returns ordered projection information from links of spot connectors.
","
Inputs


mark_or_id
The mark ID or connector ID to query.
option
0 - Return stored projection information with spot connector(s)
1 - Redo projection for spot connector(s) and return projection information
flag
id - mark_or_id is an ID
mark - mark_or_id is a mark

","Examples
To get projection information from spot connector of ID 101:
set proj_infos [hm_ce_linkprojectionorderget 101 1 id]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
43,hm_ce_mesh_imprint_option_set,"Description
Sets a mesh imprint option value.
","Inputs

name
Valid names are: 
avoid_imprint - If enabled, create patches and resolve conflicts, skip mesh imprint. 
avoid_int_snapping - If enabled, avoid snapping in meshing side. 
keep_snap - If enabled, do snapping during patch creation. 
skip_imprint - If enabled, just create patches, skip mesh imprint. 
skip_overlap_check - If enabled, skip conflict checks. 
strict_imprint - If enabled, any conflict causes an error.
value
The value of the option, 0 or 1.

","Example
To set the value of avoid_imprint to 1:
hm_ce_mesh_imprint_option_set avoid_imprint 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
44,hm_ce_organize,"Description
Organizes displayed connectors into components by their definition.
","Inputs

ce_mark
Mark of connectors.
function
Main filter category - unrealized, realized, or failed.
sub-function
Sub filter category - <2t, 2t, 3t or >3t.
compinfo
Component name or ID.
id_or_name
Flag for component name or ID (1 = name and 0 = ID).

","Example
To organize all unrealized connectors defined with 2t thickness to a specific
        component:
*createmark connectors 1 ""displayed""
hm_ce_organize 1 ""unrealized"" ""2t"" ""ce_unrealized_2t_comp"" 1
This works only for those connectors that are currently displayed.
","Errors
None.
"
45,hm_ce_read_mcf,"Description
Begins the process of reading a master connector file. Must be followed by a call to
          hm_ce_close_mcf.
","Inputs

mcf_name
The full file path and name of the .mcf file, enclosed in
            quotes.

","Example
Open test.mcf to read all the data and close the file when finished:
hm_ce_read_mcf ""C:/doc/test.mcf""
set get_all_data [hm_ce_mcf_getalldata]
hm_ce_close_mcf
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
46,hm_ce_state,"Description
Returns the current connector state (unrealized, realized or failed). 
","Inputs

ce_id
The ID of the connector.

","Example
To find the state of a set of connectors on mark and store them in a list:
*createmark connectors 1 ""displayed""
set ceList [ hm_getmark connectors 1 ];
foreach ce_id $ceList {
     lappend ce_states [ hm_ce_state $ce_id ];
}
","Errors
None.
"
47,hm_ce_type,"Description
Returns the type of a connector entity. 
Return values include point/node, line, seam and area.
","Inputs

id
The ID of the connector to query.

","Example
To get the type of connector ID 2:
hm_ce_type 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
48,hm_checkmark,"Description
This command determines if the entity of entity_type and with
          entity_id exists on mark mark_id. Valid
          mark_ids are 1 and 2. If entity_id exists on
          mark_id, a value of 1 is returned. Otherwise, a value of 0 is returned. 
If no ?option? is specified, ""by name only"" is used for entities with
        names. Otherwise, ""by id only"" is used. 
The ?panel_sensitive? option can be used when multiple panel levels have
        been pushed, either using the shortcut function keys, or the hm_pushpanel command. This
        option determines whether to use the current panel or the previous panel for the operation.
        This option is relevant only when the mark has been created from a panel entity selector
        under the above conditions. Valid panel_sensitive options are: 
0 - Use the previous panel (default). 
1 - Use the current panel.


","Examples
To determine if element with ID 100 is on mark 1 and display a message if it is:
if {[hm_checkmark elems 1 100]} {
    puts ""Element 100 is on mark 1"";
}
A mark of loads is created in the delete panel. The mask panel has been pushed using the
        command hm_pushpanel mask. A mark of loads is created in the mask panel.
        From the mask panel:
To check if load 10 is on mark 1 created from the mask panel:
if {[hm_checkmark loads 1 10 1]} {
    puts ""Load 10 is on mark 1 from the mask panel"";
}
To check if load 10 is on mark 1 created from the delete panel:
if {[hm_checkmark loads 1 100 0]} {
    puts ""Element 100 is on mark 1 from the delete panel"";
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If entity_type is invalid, you will get the following error:
hm_checkmark: invalid entity type specified
If mark_id is invalid, you will get the following error:
hm_checkmark: invalid markmask specified
",
49,hm_collisioncheck,"Description
Performs a collision detection using entities defined by
          hm_collisionentitycreate. This must be preceded by
          hm_collisoininit and one or more calls to
          hm_collisionentitycreate. 
Multiple calls to this API can be made to perform different detections.
","Inputs

mark_id_int_elems
The ID of the mark that should contain any intersected elements on output. Valid values are 1 and 2. If set to 0, no intersected elements are output. Only valid if
            elems or comps are used as input entities.
mark_id_pene_elems
The ID of the mark that should contain any penetrated elements on output. Valid values are 1 and 2. If set to 0, no penetrated elements are output. Only valid if
            elems or comps are used as input entities.
mark_id_int_surfs
The ID of the mark that should contain any intersected surfaces on output. Valid values are 1 and 2. If set to 0, no intersected surfaces are output. Only valid if
            surfaces or solids are used as input entities.
mark_id_pene_surfs
The ID of the mark that should contain any penetrated surfaces on output. Valid values are 1 and 2. If set to 0, no penetrated surfaces are output. Only valid if
            surfaces or solids are used as input entities.
mark_id_pene_nodes
The ID of the mark that should contain any penetrated nodes on output. Valid values are 1 and 2. If set to 0, no penetrated nodes are output. Only valid if nodes
            are used as input entities.
self_check
0 - Do not include self checks. 
1 - Include self checks.
reserved1
Reserved for future use. Must be set to 0.
pair_angle
The maximum allowed angle between penetrating pair normals.  Meaningful values are 0.0
            < angle < 90.0. Other values disable this functionality.
store_segments
Set to 1 to store the intersection lines formed when intersection entitites. Only
            valid when mark_id_int_elems or mark_id_int_surfs
            are non-zero. The segments can then be visualized using
              *createintersectionsegments. Default is 0.
mark_adjoining
0 - No additional marking (default). 
1 - Mark only surrounding 2D elements. Surrounded implies all of its nodes on other
            penetrated elements. 
2 - Mark all 2D elements on topology faces containing any penetrated elements. 
3 - Mark only 2D elements sharing a node with a penetrated element and on the same
            topo face.
topo_feature_angle
The angle used to identify topo faces. If set to 0.0, the global feature angle is
            utilized (default).
pair_results
If set to 1, detailed pair results are calculated and the
              hm_collisionget* and
              hm_collisionwriteresultsfile APIs can be used. If set to 0,
            detailed pair results are not calculated and the hm_collisionget* and
              hm_collisionwriteresultsfile APIs cannot be used (default).

","Examples
To find intersecting surfaces from IDs 1-10:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0
hm_collisionend
hm_getmark surfs 1
To find intersecting surfaces from IDs 1-10 and to create intersection segments:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 1
*createintersectionsegments 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-5 with a uniform thickness of 1.5, against those
        with IDs 6-10 and uniform thickness 2.0, considering edge penetration effects:
hm_collisioninit
*createmark surfs 1 1-5
hm_collisionentitycreate surfs 1 0 1 1.5 1 0 0 0 1
*createmark surfs 1 6-10
hm_collisionentitycreate surfs 1 0 1 2.0 1 0 0 0 2
hm_collisioncheck 0 0 0 1 0 0
hm_collisionend
hm_getmark surfs 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
50,hm_collisionentitycreate,"Description
Adds input entities to consider for collision detection. This must be called after
          hm_collisioninit, and before any calls to 
          hm_collisionentitycreate.
Multiple calls to this API can be made to add additional input entities to the collision
        detection.  Note that the input entities are different from the core collision entity.
        These commands do not operate on those entities, only on temporary memory.
When using the collirad collision detection engine, only one call is supported for each
          grouping_identifier.  This means that either a single call to this API
        has to be made with grouping_identifier as 0, or one call with
          grouping_identifier 1 and 2 each.
","Inputs

entity_type
The type of entity to add.
Valid values for the opcode engine are nodes, surfs, solids, elems and comps (only
            elems in comps are considered).
Valid values for the collirad engine are comps and groups.
mark_id
The ID of the mark containing the entities to add. Valid values are 1 and 2.
dimension
Defines the dimension of elements to consider. Valid only for elems and comps. Ignored
            by the collirad engine.
0 - No restriction 
2 - 2D shells only 
3 - 3D solids only
thickness_type
Defines how the thickness is applied to the input entities, in combination with
              thickness.
0 - Use the value specified by thickness. 
1 - Use component thickness. 
2 - Use element thickness. Valid only for elems and comps. 
Add 10 to these values to also apply the thickness on the outside of solid elements or
            geometry (i.e. report solid skins being close to each other, but not intruding each
            other).  Ignored by the collirad engine.
Add 20 to these values to also apply the thickness on the inside of solid elements or
            geometry, reporting a normal pointing outwards (i.e. report solids intruding each
            other).  Ignored by the collirad engine.
Add 30 to these values to also apply the thickness on the inside and outside of solid
            elements or geometry, reporting a normal pointing outwards (i.e. combine the two options
            above).  Ignored by the collirad engine.
Add 40 to these values to also apply the thickness to solid elements or geometry as if
            their skins were shell elements (i.e. report close faces with a normal pointing
            outwards, intruding faces with a normal pointing inwards). This affects the opcode
            engine, but the collirad engine always applies this logic.
Add 100 to these values to ignore penetrations of neighboring elements due to
            thicknesses being greater than element sizes.  This corresponds to using Iremgap 2 in
              Radioss contact interfaces.  This is ignored by the opcode
            engine.
Add 200 to these values to restrict the thickness of the elements to 40% of their
            size.  This also avoids undesired penetrations of neighboring elements due to
            thicknesses being greater than element sizes.  This corresponds to the behavior of some
              LS-DYNA contacts.  This is ignored by the opcode engine.
Add 300 to these values to use thickness as a thickness multiplier when using component
            or element thickness.  This is ignored by the collirad engine.
Add 400 to these values to use thickness as an add-on thickness when using component
            or element thickness.  This is ignored by the collirad engine.
All values are ignored for groups, for which thicknesses are applied as in the
            solver.
thickness
The assigned uniform thickness when thickness_flag is 0.  If
              thickness_flag has 300 or 400 added while using component or
            element thickness, thi sis used as a thickness multiplier or add-on.
Used as a multiplier for real thickness in the collirad engine.
edge_penetration
Not valid for groups for which the solver logic is applied.
0 - Do not consider edge penetrations. 
1 - Consider edge penetrations.
midside_nodes
Valid only for elems and comps. 
0 - Do not consider midside nodes. 
1 - Consider midside nodes.
split_quads
Valid only for elems and comps. 
0 - Do not split quads at the center for calculation purposes.  This is the default
            for the opcode engine, and is not available for the collirad engine.
1 - Split quads at the center for calculation purposes.  This is the default in the
            collirad engine.
used_topology
This is ignored for the collirad engine.
0 - Consider specified entities. 
1 - Consider only nodes of specified entities. 
2 - Use all edges of elements or faces. 
3 - Use only free edges of shell elements.
grouping_identifier
Entities with the same grouping identifier are not checked against each other. This is
            useful for performing checks ""by pair"". If set to 0, entities are checked against all
            others.
offset
Used to specify which element types to offset using solver properties.
0 - None. 
1 - Only bar/beam elements. 
10 - Only shell elements.
11 - Both bar/beam and shell elements.

","Examples
To find intersecting surfaces from IDs 1-10:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-5 with a uniform thickness of 1.5, against those
        with IDs 6-10 and uniform thickness 2.0, considering edge penetration effects:
hm_collisioninit
*createmark surfs 1 1-5
hm_collisionentitycreate surfs 1 0 1 1.5 1 0 0 0 1
*createmark surfs 1 6-10
hm_collisionentitycreate surfs 1 0 1 2.0 1 0 0 0 2
hm_collisioncheck 0 0 0 1 0 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating elements from components with IDs 1-5 using thickness defined on
        elements, offset defined on shell elements:
hm_collisioninit 
*createmark comps 1 1-5
hm_collisionentitycreate comps 1 0 2 0 0 0 0 0 0 10 
hm_collisioncheck 0 1 0 0 0 0 0 0 0 0 0 0
hm_collisionend
hm_highlightmark elems 1 ""h""
To find penetrating elements from all components using a thickness multiplier of 1.1 on
        thickness defined on elements:
hm_collisioninit 
*createmark comps 1 all
hm_collisionentitycreate comps 1 0 302 1.1 0 0 0 0 0 
hm_collisioncheck 0 1 0 0 0 0 0 0 0 0 0 1
hm_collisionend
hm_highlightmark elems 1 ""h""

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
51,hm_collisiongetcomponententitypaircount,"Description
Returns the number of entity pairs for a component collision pair. This must be preceded by
        a call to relevant hm_collision* commands to generate the collision data.
        In addition, the pair_results flag to
          hm_collisioncheck must be set to 1. 
For each collision type there is a list of pairs of colliding components. For each
        colliding component pair, there is a list of colliding entity pairs. Thus, their is a
        hierarchy of data with the tree looking like this: 
collision type -> component pairs -> entity pairs 
The data is therefore accessed as: 
Get the number of colliding component pairs 
Get the component IDs for each component pair 
Get the number of intersected entities for each component pair 
Get the entity types, IDs, and faces (for intersections) or the entity types, IDs,
            faces, depths and directions (for penetrations) for each intersected entity pair.


","Inputs

collision_type
The type of collision to query: 
0 - intersections 
1 - penetrations
component_index
The index of the component pair to query, starting from 0. The total number of
            component pairs for a specific collision_type can be found using
              hm_collisongetcomponentpaircount.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Examples
To find intersecting surfaces from IDs 1-10, and to get the detailed list of entities for
        each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 0]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 0 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 0 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 0 $i $j]
            }
        }
    }
}
hm_collisionend
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components, and to get the detailed list of entities for each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 1]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 1 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 1 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 1 $i $j]
            }
        }
    }
}
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
52,hm_collisiongetcomponentlinesegmentcount,"Description
Returns the line segment coordinates for a component collision pair.
Once the call to the relevant hm_collision* commands to generate the
        collision data is made, this command can follow. In addition, the
          pair_results flag to hm_collisioncheck must be set
        to 1.
For each intersecting type of collision, there is a list of pairs of intersecting
        components. For each intersecting component pair, there is a list of intersection line
        segments.
To execute this command, the below sequence of data collection is required:
Get the number of colliding component pairs
Get the number of intersection line segments for each component pair
Get the line segments for each intersected component pair


","
Inputs



component_index

The index of the component pair to query, starting from 0. The total number of
            component pairs for a specific collision_type can be found using
              hm_collisiongetcomponentpaircount.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Examples
To create nodes at the centerr of intersection line segments for intersecting comps with ID
        1 and 2:
set compList1 1;
set compList2 2;
set entityType1 elems;
set entityType2 elems;

hm_collisioninit 0 1e-5 
hm_createmark $entityType1 1 ""by comp id"" $compList1;
hm_createmark $entityType2 2 ""by comp id"" $compList2;
hm_collisionentitycreate $entityType1 1 0 0 0.0 0 0 0 0 0;
hm_collisionentitycreate $entityType2 2 0 0 0.0 0 0 0 0 0;
hm_collisioncheck 0 0 1 0 0 0 0 90.0 1 0 0 1;
set component_pair_count [ hm_collisiongetcomponentpaircount 0 0 ];
if {$component_pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set linesegmentcount [hm_collisiongetcomponentlinesegmentcount $i]
        if {$linesegmentcount != 0} {
            for {set j 0} {$j < $linesegmentcount} {incr j} {
                set linesegments [hm_collisiongetcomponentlinesegment $i $j]
                set x_0 [lindex $linesegments 0]
                set y_0 [lindex $linesegments 1]
                set z_0 [lindex $linesegments 2]
                set x_1 [lindex $linesegments 3]
                set y_1 [lindex $linesegments 4]
                set z_1 [lindex $linesegments 5]
                set curr_x [expr { ($x_0 + $x_1)/2 }]
                set curr_y [expr { ($y_0 + $y_1)/2 }]
                set curr_z [expr { ($z_0 + $z_1)/2 }]
                *createnode $curr_x $curr_y $curr_z
            }
        }
    }
}
hm_collisionend;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
53,hm_collisiongetcomponentpaircount,"Description
Returns the number of component collision pairs. This must be preceded by a call to
          relevant hm_collision* commands to generate the collision data. In
        addition, the pair_results flag to hm_collisioncheck
        must be set to 1. 
For each collision type there is a list of pairs of colliding components. For each
        colliding component pair, there is a list of colliding entity pairs. Thus, their is a
        hierarchy of data with the tree looking like this: 
collision type -> component pairs -> entity pairs 
The data is therefore accessed as: 
Get the number of colliding component pairs. 
Get the component IDs for each component pair. 
Get the number of intersected entities for each component pair. 
Get the entity types, IDs, and faces (for intersections) or the entity types, IDs,
            faces, depths and directions (for penetrations) for each intersected entity pair.


","Inputs

collision_type
The type of collision to query: 
0 - intersections 
1 - penetrations
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Examples
To find intersecting surfaces from IDs 1-10, and to get the detailed list of entities for
        each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 0]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 0 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 0 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 0 $i $j]
            }
        }
    }
}
hm_collisionend
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components, and to get the detailed list of entities for each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 1]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 1 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 1 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 1 $i $j]
            }
        }
    }
}
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
54,hm_collisioninit,"Description
Initializes the collision detection module. This must precede any calls to
          hm_collisionentitycreate and hm_collisioncheck, and
        must be followed by a call to hm_collisionend.
","Inputs

config
The configuration that defines the collision behavior. This value is obtained by
            running hm_collisiongetconfig. Default is 0.
tolerance
The tolerance to use for intersection checks (for hm_collisiongetconfig
              intersect_planar keyword) or penetration checks (for
              hm_collisiongetconfig penetrat_min_overlap keyword). If not
            specified, the default is 1.e-08.
allowable_depth
The allowable depth to use when finding and reporting interferences. If specified,
            config should be 0 and tolerance should be -1.0. If not specified, this is ignored.
min_overlap
For allowable_depth, in cases where collision entities overlap,
            there may be many intersections, and sorting out which ones are false or not is
            expensive.  This option allows for calculating percentages by measuring the number of
            intersection segments against the half the number of nodes in each collision entity. If
            both percentages exceed the min_overlap value, we do not perform the
              allowable_depthanalysis and instead report all of the intersections
            as true.

","Example
To find intersecting surfaces from IDs 1-10:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0
hm_collisionend
hm_getmark surfs 1
To find both penetrating and intersecting surfaces from IDs 1-10, using the thickness
        assigned to the surface components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 2 0 0 0
hm_collisionend
hm_getmark surfs 1
hm_getmark surfs 2
To find both penetrating and intersecting surfaces from IDs 1-10, using the thickness
        assigned to the surface components, and using an allowable depth of 0.1:
*createmark surfs 1 1-10
hm_collisioninit 0 -1 0.1
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 2 0 0 0
hm_collisionend
hm_getmark surfs 1
hm_getmark surfs 2
","Errors
None.
"
55,hm_collisionwriteresultsfile,"Description
Writes the current collision results to a file. This must be preceded by a call to relevant
          hm_collision* commands to generate the collision data. In addition, the
        pair_results flag to hm_collisioncheck must be set to 1.
","Inputs

filename
The full name and path of the file to write the results to.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results. 
Add a value of 10 to each of these to append to an existing file. By default, the file
            is overwritten.

","Example
To find intersecting surfaces from IDs 1-10 and write the results to the file
          C:/collision.txt:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 0 0 0.0 1
hm_collisionwriteresultsfile C:/collision.txt
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
56,hm_compareentities,"Description
Generates comparison results for entities positioned at any location. A maximum of one
        match is found for each source entity. This must be preceded by a call to
          hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs only.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs only.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
result_type



 
SURFS to SURFS




0 - Basic
Matched (paired) Unmatched


1 - Full (default)
Matched (paired) Overlapped Intersected Unmatched


2 - Detailed
Matched (paired) Overlapped (paired) Intersected (paired)
                      Unmatched





review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt for the general
        comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentities surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
57,hm_compareentitiesrecursive,"Description
Generates recursive comparison results for entities positioned at any location. Multiple
        matches can be found for each source entity (a source entity may match more than one target
        entity positioned at a different location). This must be preceded by a call to
          hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs only.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs only.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
result_type



 
SURFS to SURFS




0 - Basic

Matched (paired) 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the recursive comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
58,hm_compareentitiessameside,"Description
Generates comparison results for entities positioned at the same location. This must be
        preceded by a call to hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs or elems.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs or elems.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
result_type


 
SURFS to SURFS
SURFS to ELEMS ELEMS to SURFS
ELEMS to ELEMS



0 - Basic

Matched (paired) 
Unmatched


Matched (paired) 
Unmatched


Matched 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched 
Overlapped
Intersected 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the same side comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
59,hm_compareentitiestranslate,"Description
Generates comparison results for entities translated along a vector. This may find multiple
        matches, depending on the requested options. This must be preceded by a call to
          hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs or elems.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs or elems.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
vec_x
X-coordinate of translation direction.
vec_y
Y-coordinate of translation direction.
vec_z
Z-coordinate of translation direction.
distance
The translation distance to use for searching for matches.
steps
The number of steps to consider. This dictates how many increments of
              distance are searched for matches. For example, if
              distance is 45 and steps is 3, the distances 45,
            90 and 135 will be searched. Must be >= 1.
result_type


 
SURFS to SURFS
SURFS to ELEMS ELEMS to SURFS
ELEMS to ELEMS



0 - Basic

Matched (paired) 
Unmatched


Matched (paired) 
Unmatched


Matched 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched 
Overlapped
Intersected 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the translational comparison using a distance of 45 and 6 steps, of surfs 1-20 and
        101-120 along the y-direction:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiestranslate surfs 1 surfs 2 0.1 0 1 0 45 6 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
60,hm_comparegetarea,"Description
Calculates the area values for all source and target entities. This must be preceded by a
        call to a relevant hm_compareentities* command.
","Inputs

match_type
The type of match to query for the area. Valid values are: 
0 - Unmatched 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched
match_location
The location of the entities to query for the area. Valid values are: 
1 - Source entities 
2 - Target entities
transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.

","Example
To get the area of both the source and target unmatched entities for a same side comparison
        of elems 1-20 and 101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
set unmatched_source [hm_comparegetarea 0 1]
set unmatched_target [hm_comparegetarea 0 2]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
61,hm_comparegetdistance,"Description
Returns the distance value for a specific distance index. This must be preceded by a call
        to a relevant hm_compareentities* command and
          hm_comparefinddistances.
","Inputs

distance_index
The index of the distance to query, starting with 0. The number of distances can be
            found using hm_comparegetdistancecount.

","Example
To find the distance value for distance index 0 for the recursive comparison of surfs 1-20
        and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
set distance [hm_comparegetdistance 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
62,hm_comparegetdistanceentityid,"Description
Returns the entity ID for a specific distance index. This must be preceded by a call to a
        relevant hm_compareentities* command and
          hm_comparefinddistances.
","Inputs

distance_index
The index of the distance to query, starting with 0. The number of distances can be
            found using hm_comparegetdistancecount.

","Example
To find the entity ID for distance index 0 for the recursive comparison of surfs 1-20 and
        101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
set entity_id [hm_comparegetdistanceentityid 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
63,hm_comparegetdistancetransformid,"Description
Returns the transformation index for a specific distance index. This must be preceded by a
        call to a relevant hm_compareentities* command and
          hm_comparefinddistances.
","Inputs

distance_index
The index of the distance to query, starting with 0. The number of distances can be
            found using hm_comparegetdistancecount.

","Example
To find the transformation index for distance index 0 for the recursive comparison of surfs
        1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
set transform_id [hm_comparegetdistancetransformid 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
64,hm_comparegettransformationmatchcount,"Description
Returns the number of matches for a specific transformation. This must be preceded by a
        call to a relevant hm_compareentities* command.
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.

","Example
To find the number of matches for transformation 0 for the recursive comparison of surfs
        1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set num_matches [hm_comparegettransformationmatchcount 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
65,hm_comparegettransformationmatchentitycount,"Description
Returns the number of entities associated with a specific transformation and match. This
        must be preceded by a call to a relevant hm_compareentities* command.
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.
match_index
The index of the match corresponding to the transformation_index to
            query, starting with 0. The number of matches can be found using
              hm_comparegettransformationmatchcount.
match_location
The location of the match to query. Valid values are: 
1 - Source entities 
2 - Target entities

","Example
To find the number of source entities for transformation 0 and match 5 for the recursive
        comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set num_source_entities [hm_comparegettransformationmatchentitycount 0 5 1]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
66,hm_comparegettransformationmatchstate,"Description
Returns the state of a specific transformation and match. This must be preceded by a call
        to a relevant hm_compareentities* command. 
Possible return values are: 
0 - Inactive 
1 - Active
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.
match_index
The index of the match corresponding to the transformation_index to
            query, starting with 0. The number of matches can be found using
              hm_comparegettransformationmatchcount.

","Example
To find the state of transformation 0 and match 5 for the recursive comparison of surfs
        1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set match_state [hm_comparegettransformationmatchstate 0 5]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
67,hm_comparegettransformationmatrix,"Description
Returns the 4x4 transformation matrix (16 values) for a specific transformation. This must
        be preceded by a call to a relevant hm_compareentities* command.
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.

","Example
To find the transformation matrix for transformation 0 for the recursive comparison of
        surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set matrix [hm_comparegettransformationmatrix 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
68,hm_comparereadfile,"Description
Reads comparison data (transformations, match types, match entities, etc...) from a file
        into the comparison database. This must be preceded by a call to
          hm_compareinit. 
This is useful for large comparisons that take a lot of time to generate. The data can be
        saved to a file and reloaded in a new session to save time.
","Inputs

filename
The full name and path of the file to read the data from.
overwrite
0 - Do not overwrite existing comparison results 
1 - Overwrite existing comparison results

","Example
To write the comparison data file to C:/temp/my_compare.txt for the
        same side comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewritefile C:/temp/my_compare.txt
hm_compareend

To read the comparison data file from C:/temp/my_compare.txt and review the distances:
hm_compareinit
hm_comparereadfile C:/temp/my_compare.txt 1
hm_comparefinddistances 1.0 1
hm_comparesetreview 2
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
69,hm_comparesetanalysismode,"Description
Specifies whether to consider 2D shell thickness and offset for element-to-surface
        comparisons. This must precede any calls to hm_compareentities* commands. 
When non-zero, the analysis will compare 2D shell elements to three dimensional surface
        data using the shell thickness and offset information to infer a 3D shell. This 3D shell is
        then compared to the surface geometries instead of the normal 2D shell.
","Inputs

mode
0 - Normal (default) 
1 - Consider 3D shells, ignore fillets 
2 - Consider 3D shells, compare fillets

","Example
To generate a same side comparison of surfs 1-20 and elems 101-120, using the 2D shell
        thickness and offset, but ignoring fillets:
*createmark surfs 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_comparesetanalysismode 1
hm_compareentitiessameside surfs 1 elems 2 0.1 2 0
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
70,hm_comparesetflags,"Description
If enabled, the comparison module will cache extra pairwise data while performing
        comparisons between source and target.  This must be preceded by a call to a relevant
          hm_compareentities* command.
","
Inputs


flag
0 - Do not save pariwise data (default, legacy behavior)
1 - Save pariwise data

","Examples
Compare assembly 1 to assembly 2 and query the area of component
        10:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparegetcomparea 4 1 10
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
71,hm_comparesetrefacetmode,"Description
Regenerates facets on source and target surfaces for comparison purposes. This must precede
        any calls to hm_compareentities* commands. This is useful particularly
        when comparing highly curved geometries with fine meshes.
","Inputs

mode
0 - off (use defaults) 
1 - Use average element size and 5.0 max_angle

2 - Use user max_size and default max_angle

3 - Use default max_size and user max_angle

4 - Use user max_size and user max_angle
max_size (optional)
Specifies the maximum facet size to use. Used when mode is 2 or
            4.
max_angle (optional)
Specifies the maximum angle between facet normals. This is useful for increasing the
            facet density on curved surfaces. Used when mode is 3 or 4.

","Example
To generate refined facets using a facet size of 0.5 and a max angle of 5.0 for a same side
        comparison of surfs 1-20 and elems 101-120:
*createmark surfs 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_comparesetrefacetmode 4 0.5 5.0
hm_compareentitiessameside surfs 1 elems 2 0.1 2 0
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
72,hm_comparesetreviewcolor,"Description
Sets the graphical review color for comparison results. This must be followed by a call to
          hm_comparesetreview to refresh the graphics.
","Inputs

match_type
The type of match to set the color for. Valid values are: 
0 - Unmatched 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched
match_location
The location of the entities to set the color for. Valid values are: 
1 - Source entities 
2 - Target entities
color
A color value from 1-64.

","Example
To set the review colors for unmatched entities to black for both source and target
        entities for a same side comparison of elems 1-20 and 101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0:
hm_comparesetreviewcolor 0 1 1
hm_comparesetreviewcolor 0 2 1
hm_comparesetreview 1
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
73,hm_comparesetreviewmode,"Description
Sets the graphical review mode for comparison results. This must be followed by a call to
          hm_comparesetreview to refresh the graphics.
","Inputs

mode
0 - Show as grouped match types (matched, overlapped grouped and intersected,
            unmatched grouped) 
1 - Show as normal match types (default)

","Example
To set the review mode to grouped match types for a same side comparison of elems 1-20 and
        101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0:
hm_comparesetreviewmode 1
hm_comparesetreview 1
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
74,hm_comparesettransparentmode,"Description
Sets the graphical transparency mode for non-reviewed entities. This includes entities not
        part of the comparison, as well as entities turned off for review by
          hm_comparesetreviewtypes. This must be followed by a call to
          hm_comparesetreview to refresh the graphics.
","Inputs

mode
0 - Source and target entities with their review type on are shown in their review
            color. Source and target entities with their review type off, and all non-compared
            entities, are shown in black. 
1 - Source entities are shown as fully transparent. Target entities are shown in their
            review color, or as transparent if their review type is off. All non-compared entities
            are shown as transparent. 
2 - Target entities are shown as fully transparent. Source entities are shown in their
            review color, or as transparent if their review type is off. All non-compared entities
            are shown as transparent. 
3 - Both source and target entities are shown as transparent if their review type is
            off. All non-compared entities are shown as transparent.
color
0 - Transparent entities shown in gray (default if not specified). 
1 - Transparent entities shown in their review color.

","Example
To set the transparent mode to 1 for a same side comparison of elems 1-20 and 101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0:
hm_comparesettransparentmode 1
hm_comparesetreview 1
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
75,hm_comparewritepairedcomps,"Description
Writes a list of pairs of source and target components to an output file.
This helps extract relevant compare component data from
          hm_comparewriteresults.  This must be preceded by a call to a relevant
          hm_compareentities* command.
","
Inputs


filename
The full name and path of the file to write the results to.
match_type
The type of match to query for the area. Valid values are: 
0 - Unmatched 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched

","Examples
Compare assembly 1 to assembly 2 and write the paired results to
          C:/temp/paired_compare.txt:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparewritepairedcomps C:/test/paired_compare.txt 4
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
76,hm_controlcardattributedefined,"Description
Returns 1 if an attribute exists, 0 otherwise.
","Inputs

card_name
The name of the control card.
attribute_name
The name of the queried attribute in the control card.

","Errors
None.
",
77,hm_convertmarktorange,"Description
Converts a mark to an ID range and returns the ID range list with comma separators.
","
Inputs



entity_type

The entity type of the mark to convert.

mark_id

The ID of the mark to convert.  Valid values are 1 and 2.

","Examples
To return all nodes on mark 1 as an ID range:
*createmark nodes 1 all
hm_convertmarktorange nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
78,hm_createmark,"Description
This command will place entities of entity_type onto mark
          mark_id. Valid mark_ids are 1 and 2. Depending on
        the options specified, the supported entity_types will change. 
All options only return entities that are defined as active in the
        database unless otherwise noted. 
If no ?option? is specified, ""by name only"" is used for entities with
        names. Otherwise, ""by id only"" is used. 
If no ?option? is specified, both active and inactive entities may be
        selected. 
For options that allow both ids or names in the list, entities are found first using names.
        Entities not found using names are then found using IDs. 
The list of IDs, names, or parameters, depending on
          ?option?, must be quoted, e.g., ""1 2 3"" or defined using a Tcl list. When specifying entity names that contain spaces, group the name
        using brackets, e.g., {Comp name with spaces}, or use a Tcl list. 
Negative values can be used to find recently created entities (see example below). This
        funcitonality selects entities in the reverse order they are stored in the database (the
        order they are created, regardless of ID). However, any operations that affect the order of
        entities in the database (organize, reorder, etc...) will change the returned/selected
        entities. It is recommended to use this option only immediately after entity creation and
        before any other operations that may modify the database.
","Inputs

entity_type
Entity type to use. Depending on the options specified, the supported entity types
            will change.
mark_id
The ID of the mark. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to create the mark from.  If not specified, the current model is
            used.
?""options""?


","Examples
To delete components with names FRONT and SIDE:
hm_createmark comps 1 ""FRONT SIDE""
*deletemark comps 1
To delete components with names ""Name with spaces"" and SIDE:
hm_createmark comps 1 ""{Name with spaces} SIDE""
*deletemark comps 1
or
set names [list {Name with spaces} SIDE]
hm_createmark comps 1 $names
*deletemark comps 1
To mark the last 3 components that were created:
hm_createmark comps 1 ""by id only"" ""-1 -2 -3""
To delete all elements in the database:
hm_createmark elems 1 ""advanced"" ""all""
*deletemark elems 1
 To delete displayed elements:
hm_createmark elems 1 ""advanced"" ""displayed""
*deletemark elems 1
To detach the elements (by .5) that failed the quality index (you must first use the save
        failed button in the quality index panel):
hm_createmark elems 1 ""advanced"" ""retrieve""
*detachelements 1 .5
To delete all elements except the element with ID = 10:
hm_createmark elems 1 10
hm_createmark elems 1 ""advanced"" ""reverse""
*deletemark elems 1
To set all inactive assemblies to active:
hm_createmark assems 1 ""advanced"" ""inactive""
*marksuppressactive assems 1 0
To split all elements found in assemblies with IDs 10 and 20:
hm_createmark elems 1 ""by assem id"" ""10 20""
*splitelements 1 1
To split all elements found in assemblies A and B:
hm_createmark elems 1 ""by assem name"" ""A B""
*splitelements 1 1
 To delete all systems in the system collector with ID 100:
hm_createmark systems 1 ""by collector id"" ""100""
*deletemark systems 1
To delete all loads in load collector loadcol1:
hm_createmark loads 1 ""by collector name"" ""loadcol1""
*deletemark loads 1
To change elements in component with ID 200 to 2nd order:
hm_createmark elems 1 ""by comp id"" ""200""
*orderchangetosecond 1 0 0
To change elements in components named left and right to 2nd order:
set list ""left right""
hm_createmark elems 1 ""by comp name"" ""$list""
*orderchangetosecond 1 0 0
To place components X and Y on mark 1 and translate elements in these components by
        (5,0,0):
hm_createmark comps 1 ""by name only"" ""X Y""
hm_createmark elems 1 ""by comps on mark"" 1
*createvector 1 1.0 0.0 0.0
*translatemark elements 1 1 5
To split all quad4 elements in the model:
hm_createmark elems 1 ""by config"" ""quad4""
*splitelements 1 1

To mark all rigidlink elements that are of type RgdBody or ConNode. (The LsDyna template
        must be loaded.):
hm_createmark elems 1 ""by config type"" ""1 rigidlink RgdBody ConNode""
To mark elements whose component references material with ID 50 or whose property
        references material with ID 50:
hm_createmark elems 1 ""by material id"" ""50""
To mark elements that point to the property with name prop1 or, if no property is assigned
        to the element, whose component points to the property with name prop1:
hm_createmark elems 1 ""by property name"" ""prop1""
To split all elements if their center is on the X-Y plane:
hm_createmark elems 1 ""on plane"" ""0 0 0 0 0 1 .1 1 1""
*splitelements 1 1
To get a list of the elements referenced by outputblock
        OPB:hm_createmark elems 1 ""by outputblock name"" ""OPB""
set elem_list [hm_getmark elems 1]
To mark elements that share a face with elements 50 and 100 for model
        model-2:hm_createmark elems 1 ""by model"" model-2 ""50 100""
hm_appendmark elems 1 ""by model"" model-2 ""advanced"" ""by face""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
79,hm_defined,"Description
Queries whether an attribute is defined on an entity. 
","Inputs

entity_type
The type of the queried entity.
entity_name_or_id
The name or ID of the queried entity.
attribute_name
The name of the attribute.
searchType
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname:  search only by name 
-byid:   search only by ID

","Example
If the attribute with the given name is defined on this entity, the function returns 1;
        otherwise, it returns 0. 
If it cannot find the attribute on the current entity, @defined will also check the
        dictionaries; hm_defined will not do that because the dictionaries cannot
        be accessed outside of the template.
","Errors
None.
"
80,hm_diffencodings,"Description
Calculates the distance between two encoded lists representing shapes of geometries.  The
        geometries can be CAD, FE or a mixture.  Typically this is the Euclidean distance normalized
        by the number of entries in the encoding.  The encodings are generated by
          hm_encodeshape.
","
Inputs



encodings1

The first list of encodings generated by hm_encodeshape.

encodings2

The second list of encodings generated by hm_encodeshape.



encoding_algorithm

The optional encoding algorithm to use.  Valid values are:
0 - Spherical harmonics (default)



sphhar_bandwidth

Optional, valid for encoding_algorithm 0, default 16.



sphhar_fallof

Optional, valid for encoding_algorithm 0, default 2.828427.



sphhar_radii

Optional, valid for encoding_algorithm 0, default 32.



sphhar_resolution

Optional, valid for encoding_algorithm 0, default 64.

","Examples
To calculate and diff the encodings from all surfaces against all elements:
*createmark surfs 1 all
set x [hm_encodeshape surfs 1]
*createmark elems 1 all
set y [hm_encodeshape elems 1]
hm_diffencodings $x $y
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
81,hm_encodeshape,"Description
longDescription
","
Inputs



entity_type

The type of entity to generate the encoding for.  Valid values are surfs and
            elems.

mark_id

The ID of the mark containing the input entities.  Valid values are 1 and 2.



encoding_algorithm

The optional encoding algorithm to use.  Valid values are:
0 - Spherical harmonics (default)



sphhar_bandwidth

Optional, valid for encoding_algorithm 0, default 16.



sphhar_fallof

Optional, valid for encoding_algorithm 0, default 2.828427.



sphhar_radii

Optional, valid for encoding_algorithm 0, default 32.



sphhar_resolution

Optional, valid for encoding_algorithm 0, default 64.

","Examples
To calculate and diff the encodings from all surfaces against all elements:
*createmark surfs 1 all
set x [hm_encodeshape surfs 1]
*createmark elems 1 all
set y [hm_encodeshape elems 1]
hm_diffencodings $x $y
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
82,hm_entity_setvector,"Description
Set the vector ID for the weld element.
","Inputs

entityType
The type of entity to associate with the property (currently, only ELEMS are
            supported).
entityID
The ID of the entity.
vectorID
The ID of the vector.

","Example
To set vector of ID 1 to an element of ID 5:
set ent_id 5; 
set vec_id 1;
hm_entity_setvector ELEMENTS $ent_id $vec_id;
This function is currently supported for spring and gap element configuration only. 
","Errors
None.
"
83,hm_entitygettype,"Description
Returns the user-assigned entity type. The user-assigned entity type is set in the
        template.
","Inputs

entity_type
The type of the queried entity.
entity_name_or_id
The name or ID of the queried entity.
searchType
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname:  search only by name 
-byid: search only by ID

","Errors
None.
",
84,hm_entityinfo,"Description
Returns various information on entities.
","Inputs

option
Type of information requested. Valid values are:
centroid elems entity_id
Returns the element centroid as a list of three values {x y z}.


color entity_type entity_name_or_id ?search_type?
Returns the color of the entity (1-64). Only for entities that have a
                  color.


configcolors entity_type config_name_or_id
Supported for elements. Returns the color for the given config name or ID.


configs entity_type
Supported for elements and loads. If no template is loaded, returns an empty
                  value, otherwise returns a list of entity config names.


configids entity_type
Supported for elements and loads. If no template is loaded, returns an empty
                  value, otherwise returns a list of entity config IDs.


configtype entity_type config_name
Supported for elements and loads. If no template is loaded, returns an empty
                  value, otherwise returns the current type string for the specified config_name.
                  For example: 
hm_entityinfo configtype elements quad4 
hm_entityinfo configtype loads pressure


configtypeid entity_type config_name
Supported for elements and loads. If no template is loaded, returns an empty
                  value, otherwise returns the current type ID for the specified config_name. For
                  example: 
hm_entityinfo configtypeid elements quad4 
hm_entityinfo configtypeid loads pressure


configtypeids entity_type config_name
Supported for elements and loads. If no template is loaded, returns an empty
                  list, otherwise returns a list of type IDs for the specified config_name. For
                  example: 
hm_entityinfo configtypeids elements quad4 
hm_entityinfo configtypeids loads pressure


configtypes entity_type config_name
Supported for elements and loads. If no template is loaded, returns an empty
                  list, otherwise returns a list of type strings for the specified config_name. For
                  example: 
hm_entityinfo configtypes elements quad4 
hm_entityinfo configtypes loads pressure


dimension entity_type config_name_or_id
Supported for elements. Returns the dimension for the given config name or
                  ID.


dof entity_type entity_id
For rbe3 elements and equations only, returns the degree of freedom flags for
                  the independent nodes.


elementsvisible entity_type entity_name_or_id
                  ?search_type?
Returns 1 if the entity is visible, 0 otherwise. For entities that have both
                  geometry and element display states, the visibility state of elements is returned.
                  For all other entities, the general visibility state is returned.


exist entity_type entity_name_or_id ?search_type?
Returns 1 if the entity exists, 0 otherwise. If a value of -1 is passed for the
                  ID, this command will return 1 if any surface exists and 0 otherwise.


geometryvisible entity_type entity_name_or_id
                  ?search_type?
Returns 1 if the entity is visible, 0 otherwise. For entities that have both
                  geometry and element display states, the visibility state of geometry is returned.
                  For all other entities, the general visibility state is returned.


geomstyle entity_type entity_name_or_id ?search_type?
For components only, returns the geometry visual style. 
1 - Wireframe geometry 
2 - Shaded geometry and surface edges 
3 - Shaded geometry 
4 - Wireframe geometry and surface lines




graphictranslation entity_type entity_name_or_id
                    ?search_type?
For components only, returns the graphic translation x, y and z values.


id entity_type entity_name_or_id ?search_type?
Returns the ID of the entity. If search_type is not specified, the search is
                  performed by name only.


inode entity_type entity_id
For rbe3 elements and equations only, returns the independent nodes.


maxid entity_type
Returns the maximum ID used by entity_type in the HM database. This does not
                  necessarily correspond to the last created entity. 
This replaces and behaves the same as hm_entitymaxid. See also hm_entityrecorder
                  and hm_latestentityid.


name entity_type entity_name_or_id ?search_type?
Returns the name of the entity. If search_type is not
                  specified, the search is performed by ID only.


named entity_type
Returns 1 if the entity_type is a named entity, 0
                  otherwise.


style entity_type entity_name_or_id ?search_type?
For components and multibodies only, returns the visual style used. 
0 - Wireframe elements (see also hm_info
                        elementinternaledgesmode option) 
1 - Shaded elements 
2 - Shaded elements and mesh lines 
3 - Shaded elements and feature lines 
4 - Transparent elements




type points entity_id
Returns vertex, weld, or free.


visible entity_type entity_name_or_id ?search_type?
Returns 1 if the entity is visible, 0 otherwise. For entities that have both
                  geometry and element display states, the visibility state of elements is returned.
                  For all other entities, the general visibility state is returned.


weight entity_type entity_id
For rbe3 elements and equations only, returns the coefficients for the
                  independent nodes. 
For rbe3 elements, there is one value returned per independent node. 
For equations, there are 6 values (one for each DOF) returned for each
                  independent node.


all entity_type entity_name_or_id ?search_type?



everything entity_type entity_name_or_id ?search_type?
A list of commonly used values returned in the following order: 
assemblies - name id elementsvisible geometryvisible color 
components - name id elementsvisible geometryvisible color style colortype 
multibodies - name id visibility style 
materials - name id 
properties - name id




entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To display information on a selected component:
*createmarkpanel components 1 ""Select components""
set compList [ hm_getmark components 1 ]
if { ! [ Null compList ] } {
    set compId [ lindex $compList 0 ]
    set name     [ hm_entityinfo name components $compId ]
    set color    [ hm_entityinfo color components $compId ]
    set visible  [ hm_entityinfo visible components $compId ]
    set style    [ hm_entityinfo style components $compId ]
    set graphics [ hm_info graphicsmode ]
    set colormap [ hm_winfo entitycolors ]
    set msgBuff    ""component:\t$name\n""
    append msgBuff ""color:\t\t$color\n""
    append msgbuff ""visible:\t\t$visible\n""
    append msgBuff ""id:\t\t$compId\n""
    append msgBuff ""style:\t\t$style\n\n""
    append msgBuff ""graphics:\t\t$graphics\n\n""
    append msgBuff ""colormap:""
    regsub -all ""{"" $colormap """" colormap
    set cm [ split $colormap ""}"" ] 
    for { set i 0; set j 1 } { $i < 16 } { incr i; incr j } {
        append msgBuff ""\t\t$j = [ lindex $cm $i ]\n""
    }
    tk_messageBox -message $msgBuff
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
85,hm_entitymaxid,"Description
Returns the maximum internal ID in use for an entity type.
","Inputs

entity_type
The type of entity to query.
recalculate
An optional argument, indicating whether the maximum internal ID should be
            recalculated due to deleted entities. Valid values are: 
0 - Do not recalculate. 
1 - Recalculate (default).

","Example
To get the maximum internal ID for properties:
hm_entitymaxid props
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
86,hm_entityminid,"Description
Returns the minimum internal ID in use for an entity type.
","Inputs

entity_type
The type of entity to query.
recalculate
An optional argument, indicating whether the minimum internal ID should be
            recalculated due to deleted entities. Valid values are: 
0 - Do not recalculate. 
1 - Recalculate (default).

","Example
To get the minimum internal ID for properties:
hm_entityminid props
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
87,hm_entityrecorder,"Description
Records the IDs of the entities created while the recorder is enabled. This is useful for
        finding the IDs of multiple entities created during various processes. 
The recorder must be turned on to enable recording. It is also important to make sure to
        turn off the recorder. See the option argument below.
","Inputs

entity_type
The type of entity to record. If set to 0, all entity types are recorded.
option
on - Turn on the entity recorder. 
off - Turn off the entity recorder. 
ids - Get the list of IDs recorded while the recorder is on. 
count - Get the number of IDs recorded while the recorder is on.

","Example
To record the created components and get the number and list of recorded IDs:
hm_entityrecorder comps on;
<create components>
hm_entityrecorder comps off
set num_comps [hm_entityrecorder comps count]
set comp_ids [hm_entityrecorder comps ids]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
88,hm_evaluatepythonexpression,"Description
Evaluates a Python expression and returns a map (string of key values).
Currently only supported for PAM-CRASH profile.
","
Inputs


python_string
The Python string to evaluate.

","Examples
To evaluate a Python expression:
hm_evaluatepythonexpression ""R = 10 \npi = 3.142 \nArea = pi*R*R""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
89,hm_exportidmgr,"Description
Exports the ID manager rules to a CSV or XML file.
","Inputs

filename
The full name and path of the file to export.
format
0 - CSV 
1 - XML

","Example
To output the rules to C:/temp/rules.csv:
hm_exportidmgr C:/temp/rules.csv 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
90,hm_exportplyorientation,"Description
Writes the fiber orientation vector for each element in a ply to a text file.
","
Inputs



mark_id

The ID of the mark containing the plies to write. Valid values are 1 and 2.

filename

The full path and filename of the text file.

","Examples
To write the fiber orientation vector for elements in all plies:
*createmark 1 plys all
hm_exportplyorientation  1 ""C:/temp/drape.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
91,hm_fe_getdiameter,"Description
Returns the diameter value set for weld or property creation.  The value of the diameter is
        the global value set internally from the panel or through the commands.
","Example
To get the diameter value:
set diameter [ hm_fe_getdiameter ];
","Errors
None.
",
92,hm_fe_getWvsTfile,"Description
Returns the width vs thickness file for seam welds.
","
Inputs

None.
","Examples
To query the file:
set wtfile [hm_fe_getWvsTfile]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
93,hm_fe_setdvstfile,"Description
Set the diameter versus thickness file for user-defined welds. 
","Inputs

dvstfile
The name of the diameter-thickness file.

","Example
To set the diameter versus thickness file:
set dtfile ""d:\my_dvst_file.txt""
hm_fe_setdvstfile $dtfile;
This is stored globally and is applicable to all the connectors realized using the
        user-defined weld option. The diameter is used for creating ACM or CWELD.
","Errors
None.
"
94,hm_findadvancedselectiongroups,"Description
Finds advanced selection entities and separates them into selection method specific
        groups.
","
Inputs



entity_type

The type of entity to query.  Must be set to surfs.

mark_id

The ID of the mark of entities to query.  Valid values are 1 and 2.

method

The advanced selection method. Valid values are:
""by attached""
by face""
""by face across t junctions""
This value can be omitted, in which case ""by attached"" is used.

angle

The feature angle value used for faces detection. The value can be omitted, in which
            case the default feature angle value is used.

","Examples
To find all groups of connected surfaces:
*createmark surfs 1 all
hm_findadvancedselectiongroups surfs 1 ""by attached""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
95,hm_findclosestpointonline,"Description
For a given point on a line, returns the closest other point on that same line: 
xc yc zc dist 
where xc, yc and zc are the coordinates of the point on the line closest to input point,
        and dist is the distance between the original and projected points.
","Inputs

x y z
The coordinates of the known point.
line_id
ID of the line.
return_type
0 - Returns xc, yc, xc and dist as described above. This is the default if not
            specified. 
1 - Returns xc, yc, xc and arclen, where arclen is the arc length parameter,
            normalized between 0 and 1, that indicates the position of the found point along the
            length of the line.

","Example
To find the point closest to a point with coordinates (2676, -737, 605) and located on line
        7:
hm_findclosestpointonline 2676 -737 605 7
2.6777E+003 -7.3989E+002 6.0481E+002 3.3889E+000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
96,hm_findconnectedpatches,"Description
Finds connected patches of elements and returns the elements in each connected patch as a
        list. For example: 
{1 2 3 4} {5 6 7 8 9} {10 11}
","Inputs

entity_type
The type of entity to query. Only elements are currently supported.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To get the connected element patches for the displayed elements:
*createmark elems 1 displayed
set conn_elem_lists [hm_findconnectedpatches elems 1]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
97,hm_findprojected,"Description
This API projects a mark of nodes (or the nodes of a mark of elements) along either a user
        defined vector or the normal of each target element, and determines whether each node is
        within the thickness of the target elements. The overlapping nodes, the overlapped elements,
        or both are placed on the result mark depending on the option used. The values of the
        closest distance between the overlapping nodes and the overlapped elements can be plotted in
        the graphics. 
This API can be used for semi-diverse tasks such as finding which nodes of bar elements are
        touching a mark of shell elements, determining how close to the hood of a car the engine
        components are, and determining the closest distance between two meshes (although true
        element to element distances are not calculated, only node to element distances). 
This API uses a highly efficient search tree algorithm and multi-threading which makes it
        suitable for large models.
","Inputs

project_type
The source entity type for the projected nodes. Valid values are elems or nodes. If
            elems are selected, the elements' nodes are used.
project_mark
The ID of the mark containing the nodes to be projected. Valid values are 1 and 2.
target_mark
The ID of the mark containing the target elements. Valid values are 1 and 2. Only shell and solid element are supported.
use_actual_thickness
0 - All elements will be given the thickness set using the
              thickness argument 
1 - The solver thickness will be used for all elements. All elements which have a zero
            thickness (and all faces of solid elements) are given a nominal thickness of 1000.0
            times less than the maximum thickness found on the mark.
thickness
If use_actual_thickness is set to 0, this value is given to all
            elements and solid faces. 
If use_actual_thickness is set to 0 and this value is set to 0.0,
            the thickness of all elements and solid faces is assumed to be infinite. 
If use_actual_thickness is set to 1 and this value is greater than
            0.0, this value is used as a multiplier to the solver thickness such that element
            thickness = solver thickness * (this value) / 2.0
tolerance
This value is used as a fraction of the element size within which nodes are considered
            overlapping if they are near an element's edges but not inside the element. A value of
            0.01 allows nodes which are within 1% of element size of an element to be treated as
            overlapping. A good value for this option is 0.01.
project_normal
0 - Projects nodes along a vector defined by project_x, project_y, and project_z. 
1 - Projects nodes along a vector defined by the normal of each target element .
2 - Projects nodes directly to the elements along the shortest path.
project_x
Project vector x component. Used only if project_normal is 0.
project_y
Project vector y component. Used only if project_normal is 0.
project_z
Project vector z component. Used only if project_normal is 0.
mark_target
0 - Turns off any active plotting. No analysis will be performed. 
1 - Marks overlapped elements to the result mark and plots the absolute distance on
            the overlapped elements. 
2 - Marks overlapping nodes to the result mark and plots the absolute distance on the
            overlapping nodes. 
3 - Marks overlapped elements and overlapping nodes to the result mark and plots the
            absolute distance on both the overlapped elements and the overlapping nodes. 
4 - Same as 1 but distance plotted is +/- based on vector or normal direction. 
5 - Same as 2 but distance plotted is +/- based on vector or normal direction. 
6 - Same as 3 but distance plotted is +/- based on vector or normal direction.
output_mark
The ID of the mark containing the overlapping nodes and/or elements. Valid values are 1 and 2.
?plot_results?
0 - No plotting. 
1 - Plot results to the screen. 
Note that if this option is set to 1, the API will store the closest distance between
            overlapping nodes and elements. Since more nodes and elements must be checked, this
            option will run slower than simply marking all overlapping nodes and/or elements.
?legend_red?
Setting this value to something other than zero will show all overlapping nodes or
            elements which are closer than this value to be shown in red. If
              mark_target is set to 4, 5, or 6, this value is best left set to
            0.0. This option is only used if plot_results is set to 1.
?legend_yellow?
Setting this value to something other than zero will show all overlapping nodes or
            elements which are closer than this value to be shown in yellow or orange. If
              mark_target is set to 4, 5, or 6, this value is best left set to
            0.0. This option is only used if plot_results is set to 1.
?results_file?
The full path and name of the results file to be generated in HyperMesh binary results format (.res).
?output_file?
The full path and name of the results file to be generated in plain text format. This
            file will contain the overlapping nodes and/or elements as well as their closest
            distances if plot_results is set to 1.

","Example
Generate a plot of the closest distance between two components on the target elements. Note
        that the thickness is set to 0.0 (infinite) for all elements, the element normals are used
        for projection, and the results are set to be shown on the target elements with the
        direction as + or -:
*createmark nodes 1 ""by collector id"" 6
*createmark elems 2 ""by collector id"" 1
hm_findprojected nodes 1 2 0 0.0 0.01 1 0.0 0.0 0.0 4 1 1 0 0 C:/Temp/closest.res C:/Temp/closest.txt
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
98,hm_flangedetectionend,"Description
Clears memory and ends the flange detection module. This must be preceded by any calls to
          hm_flangedetectioninit and other hm_flangedetection*
        APIs. 
""Major"" database changes made while inside of the flange detection module will invalidate
        and delete any results.
","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
99,hm_flangedetectionfindmates,"Description
Runs the flange detection mating functions for finding flanges mating 'groups'. This must
        be preceded by a call to hm_flangedetectionfindflanges. 
max_search_dist and min_search_dist are mandatory.
        All other parameters are optional and have default values. Parameters can be specified in
        any order.
","
Inputs


max_search_dist=<distance>
The maximum distance for the proximity search.
min_search_dist=<distance>
The minimum distance for the proximity search.
mode=<value>
0 - Perform flange-to-flange mating only (default)
1 - Perform flange-to-everything mating
percent_mate_area_tol=<value>
The minimum mating area percentage required for valid mating.  Default value 0.1.


search_scope=<value>
0 - No filter (default) 
1 - Limit mating check to parent assembly

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
100,hm_flangedetectiongetflangemates,"Description
Returns indices of flanges that directly mate with the specified flange.  This must be
        preceded by a call to hm_flangedetectionfindmates. 
","
Inputs



index

The index of the flange to query, starting from 0.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
101,hm_flangedetectiongetmatingentities,"Description
Returns the entities for two mating flanges. This must be preceded by a call to
          hm_flangedetectionfindmates.
The entities are returned as two lists, one for each flange.
","
Inputs



index1

The index of the first flange, starting from 0.

index2

The index of the second flange, starting from 0.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
102,hm_flangedetectiongetnumberofflanges,"Description
Returns the number of found flanges. This must be preceded by a call to
          hm_flangedetectionfindflanges.
","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
103,hm_flangedetectioninit,"Description
Initializes the flange detection module. This must precede any calls to other
          hm_flangedetection* APIs, and must be followed by a call to
          hm_flangedetectionend. 
""Major"" database changes made while inside of the flange detection module will invalidate
        and delete any results.
","
Inputs


entity_type
The type of entities to find flanges for. Valid values are comps, surfs, and
            elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
consider_geom=<mode>
Used when entity_type is comps:
0 - Use elements from the comps (default if not specified)
1 - Use geometry from the comps

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
104,hm_formnodelistsfrommark ,"Description
Forms ordered node lists from a mark of nodes. 
The return consists of a list-of-lists, with each sub-list being an ordered node list.
","Inputs

entity_type
Must be set to nodes.
mark_id
 The ID of the mark containing the input nodes. Valid values are 1 and 2.
?error_mark_id?
The ID of the mark to use for storing any nodes which cannot be formed into a list.
            Valid values are 0 (default, do not store), 1 and 2.
?use_edge_topo?
0 - Do not use the edge selection from the last call to
              *createmarkpanel for nodes. 
1 - Use the edge selection from the last call to *createmarkpanel
            for nodes (default).

","Example
To form node lists from nodes selected by the user via
        *createmarkpanel:
*createmarkpanel nodes 1 ""Select nodes to form lists""
hm_formnodelistsfrommark nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
105,hm_get2delemchecktestval,"Description
Returns the test values from the Check Elems panel.
","Inputs

check_type
The type of check to query. Valid values are: 
length1d 
lengthmore1d 


aspect2d 
chordal2d 
jacobian2d 
length2d 
lengthmore2d 
minanglequad2d 
maxanglequad2d 
minangletria2d 
maxangletria2d 
skew2d 
equiaskew2d 
areaskew2d 
cellsquish2d 
taper2d 
warpage2d 


aspect3d 
tetcollapse3d 
jacobian3d 
length3d 
lengthmore3d 
minanglequad3d 
maxanglequad3d 
minangletria3d 
maxangletria3d 
skew3d 
equiaskew3d 
volskew3d 
cellsquish3d 
volAR3d 
warpage3d



","Example
To get the value of the 2D aspect test value:
hm_get2delemchecktestval aspect2d
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
106,hm_getaddendumid,"Description
Returns the IDs of the addendum surfaces.
","Example
To get the IDs of the addendum surfaces:
hm_getaddendumid
","Errors
None.
",
107,hm_getadjsurfacesfromsurface,"Description
Returns the surfaces adjacent to the specified surface.
","Inputs

surface_id
The ID of the surface to query.

","Example
To get the adjacent surfaces for surface 100:
hm_getadjsurfacesfromsurface 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
108,hm_getallmodels,"Description
Returns the names of the primary and all the secondary models.
","
Inputs
None.","Examples
To get the names of all models:
hm_getallmodels
",ErrorsNone.
109,hm_getangle,"Description
Returns the angle between three nodes/points.
","Inputs

entity_type
The type of entity to query. Valid values are nodes and points.
id1
The ID of the first entity.
id2
The ID of the second entity.
id3
The ID of the third entity.

","Example
To get the angle between nodes 100, 101 and 102:
hm_getangle nodes 100 101 102
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
110,hm_getattachedsolidelemfaces,"Description
Returns information about solid elements attached to shell element faces. 
For a given shell element, this command is used to get the connected solid element ID and
        the corresponding face index of the solid element. The return list contains, for each input
        shell element with an attached solid element face the input shell element ID, connected
        solid element ID and the solid element face index. For example: 
{1 20 0} {5 17 4} {3 1 2}
","Inputs

entity_type
The type of entity to query. Valid entity types are elems and comps. 
Only shell elements are considered.
mark_id
The ID of the mark to query. Valid values are 1 and 2.
normal_flag
0 - Get connected solid element face with normal in the same direction as input shell
            element normals 
1 - Get connected solid element face with normal in the opposite direction as input
            shell element normals

","Example
To get the attached solid element faces for all displayed elements, using opposite
        normals:
*createmark elems 1 displayed
set attachedelem_lst [hm_getattachedsolidelemfaces elems 1 1]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
111,hm_getbackgroundgradient,"Description
Returns the gradient background type. Valid return values are: 
121 
diagonal1 
diagonal2 
vertical


","Example
To get the background gradient type:
hm_getbackgroundgradient
","Errors
None.
",
112,hm_getbestcirclecenter,"Description
This command calculates and returns the center point coordinates and radius of the circle
        that approximates the input set of lines, nodes or points. If the input entities are found
        to be on a straight line then an error is returned. The calculated information is returned
        as a list of four values, that specify x, y, z coordinates of the calculated circle center,
        and the radius of the circle.
","Inputs

entity_type
Type of input entities. Valid values are nodes, points, or lines.
ent_mark
The mark of input entities. 
any_tol
Parameter specifying whether the best fit is verified against the currently set
            geometry cleanup tolerance. Valid values are: 
0 - Error is returned if input entities are not on the circle within geometry cleanup
            tolerance. 
1 - Tolerance is ignored and best fit circle is always calculated.
panel_sensitive (optional)
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid panel_sensitive options are: 
0 - Use the previous panel (default). 
1 - Use the current panel.

","Examples
To get the center and radius of the circle passing through nodes 11, 12 and 14:
*createmark nodes 1 11 12 14
hm_getbestcirclecenter nodes 1
To get the center and radius of the circle that approximates line 21:
*createmark lines 1 21
hm_getbestcirclecenter lines 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
113,hm_getboundingbox,"Description
This command returns the six values defining the bounding box from the specified entities
        and options: 
x_min y_min z_min x_max y_max z_max 
The box values are determined depending on the following options.
","Inputs

entity_type
The type of entity to find the bounding box for. See the list of supported entities
            for this command.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
entity_flag
This is a bit value used when entity_type is assems or comps. 
For assems, this specifies whether to consider nodes/elems, geometry, connectors
            and/or multibodies/ellipsoids. 
For comps, this specifies whether to consider nodes/elems, geometry and/or connectors. 
It is ignored for all other entity_types and should be set to 0,
            but there is no error if bit values are specified that do not correspond to the current
              entity_type. 
The bit values are summed as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3). 
Bit0:0 - Do not consider nodes/elems. 
1 - Consider nodes/elems.


Bit1:0 - Do not consider geometry. 
1 - Consider geometry. 


Bit2:0 - Do not consider connectors 
1 - Consider connectors. 


Bit3:0 - Do not consider multibodies/ellipsoids. 
1 - Consider multibodies/ellipsoids.


system_id
The ID of the local coordinate system to return the values relative to. A value of 0
            is the global system. Currently only rectangular systems are supported.
box_type
The type of bounding box to return. Currently, only a value of 0 is supported, which
            indicates to return the coordinates of the box oriented along the axes of the specified
            system.

","Examples
To get the bounding box for the displayed elements oriented relative to the global
        system:
*createmark elems 1 displayed
hm_getboundingbox elems 1 0 0 0
To get the bounding box for the geometry in comps 1-4 oriented relative to rectangular
        system 100:
*createmark comps 1-4
hm_getboundingbox elems 1 2 100 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
114,hm_getcardimageoptions,"Description
Returns information about certain options supported by a card image.
","Inputs

entity_type
The type of entity to query. Currently supported for props.
card_image
The name of the card image to query e.g. P1_SHELL. Only card images for the current
            template are supported.
option
The option value to query for the entity type. Valid values for props are: 
material
Returns 1 if the entity allows a direct material assignment, 0 otherwise.


beamsection
Returns 1 if the entity allows a direct beamsect assignment, 0 otherwise.


beamsection_attrib
If beamsection option returns 1 this returns the attribute to use to assign the
                  beamsection, 0 otherwise.


thickness
Returns 1 if the panel allows a direct material assignment, 0 otherwise.


thickness_attrib
If thickness option returns 1 this returns the attribute to use to assign the
                  thickness value, 0 otherwise.



","Examples
Radioss examples:
hm_getcardimageoptions props P1_SHELL material
0
hm_getcardimageoptions props P1_SHELL beamsection
0
hm_getcardimageoptions props P1_SHELL beamsection_attrib
0
hm_getcardimageoptions props P1_SHELL thickness
1
hm_getcardimageoptions props P1_SHELL thickness_attrib
431
OptiStruct examples:
hm_getcardimageoptions props PBEAM material
1
hm_getcardimageoptions props PBEAM beamsection
1
hm_getcardimageoptions props PBEAM beamsection_attrib
3186
hm_getcardimageoptions props PSHELL thickness
0
hm_getcardimageoptions props PSHELL thickness_attrib
0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
115,hm_getcentroid,"Description
Returns the geometric centroid for selected entities.
","Inputs

entity_type
The type of entity to query. Valid values are surfaces and solids.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To get the centroid of all surfaces:
*createmark surfs 1 all
hm_getcentroid surfs 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
116,hm_getclosedshelllayerelems,"Description
This command separates top and bottom layer elements of thin closed-shell solids and puts
        elements of respective layers on element marks 1 and 2. The command expects each solid to be
        contained in a single component, i.e., any input solid should not be spread across multiple
        components. This command is slightly tolerant towards imperfectly closed shells and
        therefore the input need not be completely watertight.
","Inputs

entity_type
Must be set to comps.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To get the top and bottom layers for comps 54 and 55:
*createmark comps 1 ""by id"" 54 55
hm_getclosedshelllayerelems comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
117,hm_getclosestpointsbetweenlinesurface,"Description
Find the shortest distance between a line and a surface, and return line and surface points
        corresponding to this distance.
","Inputs

lineID
ID of the line.
surfID
ID of the surface.

","Example
The result depends on whether the line and surface intersect. If they do not, then the
        return value is a list of 7 values:
{ xs ys zs xc yc zc dist}
Where ""xs"", ""ys"", ""zs"" are coordinates of the closest point on the surface, ""xc"", ""yc"",
        ""zc"" are coordinates of the closest point on the line and ""dist"" is the distance between
        those points.
If the line does intersect the surface, all intersection points are returned as a list of
        values: 
{xs1 ys1 zs1 xc1 yc1 zc1 xs2 ys2 zs2 xc2 yc2 zc2 … } 
This case returns 6 values for each intersection point, but no distance is appended at the
        end of the list.
To find the closest points between a line with ID 1 and a surface with ID 2:
hm_getclosestpointsbetweenlinesurface 1 2
This example returns the following:
2.682E+003 -7.365E+002 6.050E+002 2.685E+003 -7.350E+002 6.040E+002 6.910E+000
In this case the line and surface do not intersect, and the closest distance between them
        equals 6.91.
","Errors
None.
"
118,hm_getcog,"Description
Returns the mass center-of-gravity coordinates for the selected entities. The coordinates
        are always returned relative to the global axes.
","Inputs

entity_type
The type of entity to query. Currently supported for comps and elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To get the COG for components 1-5:
*createmark comps 1 1-5
hm_getcog comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
119,hm_getcommandfile,"Description
Returns the full path and file name of the command file.
","Example
To get the command file path and name:
set command_file [hm_getcommandfile]
","Errors
None.
",
120,hm_getconfigtypeincol,"Description
This command returns as a list the unique config and type combinations for the entities
        inside a collector. The list returns a list containing alternating config and type values
        for the entities of entity_type contained in the collector. The values
        are returned sorted by increasing config and increasing type within each config. For
        example, for a component collector containing tria3 elements (config 103) of type 1, tria3
        elements of type 2, and quad4 elements (config 104) of type 3, the values returned would be: 
103 1 103 2 104 3
","Inputs

collector_type
The type of collector to query. Valid values are comps, groups and loadcols.
entity_type
The type of entities in the collector_type to return the config and
            type values for. The valid value for collector_type comps and groups
            is elems. The valid values for collector_type loadcols are equations
            and loads.
name_or_id
The name or ID of the queried collector_type.
?search_type?
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname: search only by name
-byid: search only by ID

","Example
To get the config, type and count of all elements in the component collector named
          my_comp: 
set var [hm_getconfigtypecountincol comps elems my_comp -byname]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
121,hm_getcoordinatesfromnearestsurface,"Description
This command finds the point on one of surfaces (specified by the list of surface IDs
          surf_id_list) closest to the point specified by coordinates x, y, z.
        The command returns the result as a list of four values. The first, second and third value
        in the list specify the x, y and z coordinates of the closest point correspondingly. The
        fourth value in the list is the ID of the surface on which the closest point is found.
","Inputs

x
The x coordinate.
y
The y coordinate.
z
The z coordinate.
surf_id_list 
The ID of the surface on which the closest point is found.

","Example
To find coordinates of the point on surface 12 that is closest to the location specified by
        x=1, y=3, z=5:
hm_getcoordinatesfromnearestsurface 1 3 5 12
On surfaces with IDs 12, 14, 15 find the point closest to global origin point (x=0, y=0,
        z=0):
hm_getcoordinatesfromnearestsurface 0 0 0 [ list 12 14 15 ]
To create node on surface with ID 10, closest to the point specified by x=1, y=3, z=5:
set closest_pnt [ hm_getcoordinatesfromnearestsurface 1 3 5 10 ]
set x [ lindex $closest_pnt 0 ]
set y [ lindex $closest_pnt 1 ]
set z [ lindex $closest_pnt 2 ]
*createnode $x $y $z
","Errors
Incorrect usage of hm_getcoordinatesfromnearestsurface results in a
          Tcl error. The function returns an error when the list of input
        surfaces (surf_id_list) is empty or some of IDs specified in
          surf_id_list does not belong to any surface in the model. To detect
        errors, you can use the Tcl catch command:
if { [ catch { hm_getcoordinatesfromnearestsurface $x $y $z $surf_list } ] } {
# Handle error here
}
"
122,hm_getcriteria,"Description
Query the values of global mesh quality criteria.
","
Inputs


criteria
The name of the criteria to query.  Valid values can be found in
              *criteria_update.
There are also a few special criteria names:


global_solver
The global calculation method to be used for all quality parameters.
legend_colors
The legend colors for all thresholds.


If no criteria value is given, all criteria values are returned.

","Examples
To get the 2D min size:
hm_getcriteria min_size_2d
To get the 3D aspect ratio:
hm_getcriteria aspect_ratio_3d
To get all values:
hm_getcriteria
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
123,hm_getcrossreferencedentitiesmark ,"Description
Finds entities that reference the entities on the specified mark. This includes collected
        references, data name references and attribute entity references. Each type of entity that
        references the specified input entities is returned in a list, and the found entities are
        then placed on the specified mark for those entity types. See the list of supported entities
        for hm_getcrossreferencedentities.
","Inputs

entity_type
The type of entity to query.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
reference_flag
The type of cross-reference entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2). 
Bit0
0 - Do not consider collected entity cross-references.
1 - Consider collected entity cross-references. If the specified entity is not a
                  collected entity, nothing will be returned for this bit.


Bit1
0 - Do not consider data name entity cross-references.
1 - Consider data name entity cross-references. If the specified entity is not
                  referenced by any data names, nothing will be returned for this bit.


Bit2
0 - Do not consider attribute entity cross-references.
1 - Consider attribute entity cross-references. If the specified entity is not
                  referenced by any entity attributes, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found cross-referenced entities on. Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.
exclude_regions
0 - Include region entities in the search (default).
1 - Exclude region entities in the search (default).

","Examples
To get all entities that cross-reference componenst 100-110 on mark 1 and highlight them on
        the screen:
*createmark comps 2 100-110
foreach entity_type [hm_getcrossreferencedentitiesmark comps 2 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity cross-references for components with IDs 100-110 on mark
        2:
*createmark comps 1 100-110
hm_getcrossreferencedentitiesmark comps 1 1 2 0 0 -byid
To get only data name entity cross-references for components with IDs 100-110 on mark
        1:
*createmark comps 2 100-110
hm_getcrossreferencedentitiesmark 2 100 2 1 0 0 -byid
To get only attribute entity cross-references for components with IDs 100-110 on mark
        1:
*createmark comps 2 100-110
hm_getcrossreferencedentitiesmark comps 2 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
124,hm_getdefaultcardimage,"Description
Returns the default card image for the specified entity type for
        the current template/profile. No value is returned if there is no default. The default
          card image is used by *createentity when
        another card image is not specified.
","Inputs

entity_type
The type of entity to query. All entity types are valid.

","Example
To get the default card image for properties:
hm_getdefaultcardimage props
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
125,hm_getdiameterfromfile,"Description
Returns the diameter for the specified thickness from the DVST file.
","Inputs

thickness
The thickness for which diameter is required
dvstfile
The diameter vs. thickness file name.

","Example
To get the diameter for a thickness of 1.0 from the file:
set thickness 1.0;
set dtfile ""d:\my_dvstfile.txt"";
set diameter [ hm_getdiameterfromfile $thickness $dtfile ];
For the format for the diameter thickness file see the HyperMesh online help. 
","Errors
None.
"
126,hm_getdiepartid,"Description
Returns the IDs of the die part surfaces.
","Example
To get the IDs of the die part surfaces:
hm_getdiepartid
","Errors
None.
",
127,hm_getdistance,"Description
Returns the distance between two nodes/points relative to a local coordinate system. This
        returns four values indicating the total distance and the three component values between the
        input nodes/points, relative to a local coordinate system. If the system is rectangular, the
        component values returned are x, y, and z. If the system is cylindrical, the component
        values returned are r, t, and z. If the system is spherical, the component values returned
        are r, t, and p
","Inputs

entity_type
The type of entity to query. Valid values are nodes and points.
id1
The ID of the first entity.
id2
The ID of the second entity.
syst_id
The ID of the local coordinate system to use. If the value is specified as 0, the
            global coordinate system is used.

","Example
To get the distance between nodes 25 and 100 relative to spherical coordinate system 3:
foreach {tot r t p} [hm_getdistance nodes 25 100 3] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
128,hm_getdistancefromnearestsurface,"Description
Gets the distance of the given point from the nearest of the surfaces with IDs specified as
        arguments.
","Inputs

point_xyz
The list of x, y, z coordinates of the point.
surf_id_list
List of surface IDs.

","Examples
The function returns a list consisting of two values. The first value is the distance to
        the closest surface. The second value is ID of the closest surface.
To get closest to the point with coordinates (10, 20, 30) point on the surface with ID
        13:
hm_getdistancefromnearestsurface [list 10 20 30] 13
To get closest surface from the set with IDs 13 14 15:
hm_getdistancefromnearestsurface [list 10 20 30] [list 13 14 15]
To get closest to the point with ID 2 point on the surface with ID 13:
hm_getdistancefromnearestsurface [hm_getvalue points id=2 dataname=coordinates] 13
","Errors
None.
"
129,hm_getdrawbeadattribute,"Description
Returns the attributes of the drawbar or drawbead created by the die module. The return
        value is a list of twelve parameters: 
Flag that identifies the insertion surface type (on_surf_type): 
1 - Addendum
2 - Binder 


The tolerance value used to build the drawbar or the drawbead (tol). 
The x-component of the normal vector to the insertion surface (dirx). 
The y-component of the normal vector to the insertion surface (diry). 
The z-component of the normal vector to the insertion surface (dirz). 
The value of the right radius used to build the drawbar or the drawbead shape
            (right_radius). 
The value of the left radius used to build the drawbar or the drawbead shape
            (left_radius). 
The value of the right fillet used to build the drawbar or the drawbead shape
            (right_fillet). 
The value of the left fillet used to build the drawbar or the drawbead shape
            (left_fillet). 
The value of the hat length used to build the drawbar or the drawbead shape
            (hat_length). 
The ID of the guide line used to build the drawbar or the drawbead shape (line_id). 
The ID of the point used to identify the position (above or below the insertion
            surface) of the drawbar or the drawbead (ref_point_id).


","Example
To get the drawbar attribute of the drawbar component with ID 15:
lassign [hm_getdrawbeadattribute 15] on_surf_type tol dirx diry dirz right_radius left_radius right_fillet left_fillet hat_length line_id ref_point_id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
130,hm_getduplicateelements,"Description
Returns a list of duplicate elements as a list of lists. The duplicate elements are
        determined per theoptions argument. The format of the returned values is
        a list of lists, sorted from lowest to highest ID. Each list corresponds to the duplicate
        elements at that ""location"". For example, if element 1 is a duplicate with elements 2 and 3,
        and element 4 is a duplicate with elements 5, 6 and 7, the return would be a list of length
        2, with each sub-list containing the duplicates: 
{1 2 3} {4 5 6 7}
","Inputs

input_mark_id
The ID of the mark of elements to consider. Only elements on this mark will be
            considered for use in finding duplicates. Valid values are 1 and 2.
output_mark_id
The ID of the mark to put duplicate elements on. Valid values are 0, 1 and 2. If set
            to 0, the output mark is not used.
options
Currently unsupported. Must be set to 0.

","Example
To find duplicates for the displayed elements and put all of them on mark 2:
*createmark elems 1 displayed
set duplicates [hm_getduplicateelements 1 2 0]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
131,hm_getedgeloops2,"Description
Returns the chain of boundary entities of the given type. The return is a ""list of loops"".
        Each loop is an ordered list of either surface edge or element node IDs that define each
        loop. The first value in each loop list is the loop type. For example, a list that starts
        with number 32 means the list consists of entities (nodes or edges) representing an
        x-connection type ‘closed’ loop. The remaining values are the ordered node/surface edge IDs
        defining the loop. If the loop is closed, the first and last ID are the same.
This API is similar to hm_getedgeloops. The difference is that, in
        defining the connection types at the boundary, hm_getedgeloops takes into
        account all the elements/surfaces in the model, while hm_getedgeloops2
        considers only the given input as if the rest of the model does not exists. Thus, if the
        edge of a surface is connected to another surface that is not in the input, then that edge
        is considered to be a ‘free’ edge; i.e. as if it is not stitched to any other edge. In this
        sense, the boundary entities (nodes or edges) of input entities are classified according to
        their connection type of being ‘free’, ‘t-connection’ or ‘x-connection’. 
For example: 
{2 41 36 4 35 39 40 41} closed loop of free type entities
{4 42 67} open loop of t-connection type entities
","
Inputs


entity_type
The type of entity to query. Valid values are surfaces and elements.
markid=<mark_id>
The ID of the mark containing the entities to query. Valid values are 1 and 2.
looptype=<loop_type>
The type of loop types to find. Bit values are used and the value is calculated as
            (1*Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5). If not specified, all loop
            types are returned. 
Bit0
0 - Do not consider open free edge loops
1 - Consider open free edge loops


Bit1
0 - Do not consider closed free edge loops
1 - Consider closed free edge loops


Bit2
0 - Do not consider open t-connections
1 - Consider open t-connections


Bit3
0 - Do not consider closed t-connections
1 - Consider closed t-connections


Bit4
0 - Do not consider open x-connections
1 - Consider open x-connections


Bit5
0 - Do not consider closed x-connections
1 - Consider closed x-connections



","Examples
Example:
Example
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
132,hm_getelemcheckbounds,"Description
This command returns the lower bound and upper bound values of the specified element check
        from the selected elements. Only the elements on mark_id and of the
        specified dimension are considered when calculating the lower and upper bound values.
","Inputs

mark_id
The ID of the mark containing the elements. Valid values are 1 and 2.
dimension
The dimension of the elements on mark_id to consider. Valid values
            are: 
1 - 1D elements 
2 - 2D elements 
3 - 3D elements 
If no elements of the specified dimension are on mark_id, an error
            is returned.
check_type
The type of element check to return the bounds from. The allowable values depend on
            the dimension specified:
dimension = 1: 
length 
timestep


dimension = 2: 
addedmass 
aspect 
cellsquish 
chordaldev 
equiskew 
jacobian 
length 
maxinterangle
maxlength
mininterangle
minlength
skew 
taper 
timestep 
volumeareaskew 
warpage 


dimension = 3: 
addedmass 
altitudeaspect 
aspect 
cellsquish 
equiskew 
jacobian 
length 
maxinterangle
maxlength
mininterangle
minlength
ortho_3d
size_ratio_3d
skew 
tetracollapse 
timestep 
volumeareaskew 
volumetricskew 
warpage


?time_failure?
The value to use as a threshold beyond which the input elements should be considered
            to have failed the test. This is required only when check_type is set
            to addedmass.

","Examples
To get the min and max length of all displayed 1D bar elements:
*createmark elems 1 ""by config"" bar
*createmark elems 2 displayed
*markintersection elems 1 elems 2
foreach {lower upper} {[hm_getelemcheckbounds 1 1 length]} {}
To get the lower and upper length values for all first order 2D elements:
*createmark elems 1 ""by config"" tria3 quad4
foreach {lower upper} {[hm_getelemcheckbounds 1 2 length]} {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
133,hm_getelemchecksummary3d,"Description
This command returns the element quality summary for the selected 3D elements. The return
        values are grouped into 3 parts: 
The number of counted elements. 
The number elements that failed passing the selected measurement(s). 
A summary of the selected quality measurements. For every quality measurement, it
            includes three items: 


The name of the quality measurement. 
The number of elements that failed passing this measurement. 
The quality value of the worst element using this measurement.


","Inputs

mark_id
The ID of the mark containing the elements to query.
option
This parameter constructs a table of quality measurements that are used to determine
            the summary. Each measurement includes the measurement name, failed value and solver ID
            (currently only HyperMesh solver ID = 0 is supported). Valid
            quality measurements include: 
aspect_ratio 
cell_squish 
equi_skew 
jacobian 
max_interior_angle 
min_interior_angle 
ortho_3d
size_ratio_3d
skew 
tet_collapse 
vol_ar 
vol_skew 
warpage

For every item, you can chose to only input the name and some values; in this case, the
        remainder will use the default values.
","Example
To count the displayed elements with tet_collapse <= 0.01 and vol_skew >=0.90:
*createmark elems 1 displayed
set table ""tet_collapse 0.01 vol_skew 0.90""
set elem_sum [hm_getelemchecksummary3d 1 $table]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
134,hm_getelementcheckmethod,"Description
This command returns the ID of the method (solver) used to calculate the specified element
        quality check. For element quality check parameters, their meanings and allowable values,
        see the *elementchecksettings command.
","Inputs

check_name
Specifies the element quality check parameter to query. Valid values are: 
angle 
aspect_2d 
aspect_3d 
cell_squish_2d 
cell_squish_3d 
chord_dev 
equi_skew_2d 
equi_skew_3d 
jacobian_2d 
jacobian_3d 
min_len_2d 
min_len_3d 
ortho_3d
size_ratio_3d
skew_2d 
skew_3d 
solver 
taper 
tetra_collapse 
time_step 
warpage


get_method_mode
An optional parameter specifying the mode of retrieving of the returned method. Valid
            values are: 
0 - Returns the method stored globally, regardless of global or individual solver
            mode. 
1 - Return the method specified by the global solver (if an individual solver mode is
            not being used). 
2 - Return the actual method used in calculations. This is the default value.

","Example
To retrieve the method currently being used for calculation of the aspect ratio for 2D
        elements:
set aspect2dmethod [ hm_getelementcheckmethod  aspect_2d]
To retrieve the method currently being used for calculation of the Jacobian for 2D
        elements:
set jacobian_method [ hm_getelementcheckmethod  jacobian_2d]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
135,hm_getelementnormal,"Description
Returns the normal vector of the specified element vertex/edge/face.
","Inputs

element_id
The ID of the 2D/3D element to query.
query_type


vertex - query_index is the index of a vertex (node) of a
                2D/3D element. 
edge - query_index is the index of an edge of a 2D element. 
face - query_index is the index of a face of a 3D
                element.


query_index
The index of the vertex (node), edge or face. The index is 1-based and is ordered the
            same as the nodes/edges/faces defining the element.

","Examples
To get the normal of shell element 100 edge index 1:
hm_getelementnormal 100 edge 1
To get the normal of solid element 300 face index 2:
hm_getelementnormal 300 face 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
136,hm_getelementvolumes,"Description
Returns lists of shell element volumes and baffle elements in each volume. 
The output is in the following format: 
{{volume1_elem_ids}{baffle1_elem_ids}} {{volume2_elem_ids}{baffle2_elem_ids}}...
{{volumeN_elem_ids}{baffleN_elem_ids}} 
Where volume_elem_ids are the IDs of elements that constitute a single
        volume, and baffle_elem_ids are the IDs of baffle elements corresponding
        to a particular volume.
","Inputs

entity_type
Currently supported for elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.

","Example
To get the list of volumes and baffles for displayed elements:
*createmark elems 1 ""displayed""
hm_getelementvolumes elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
137,hm_getentityalias,"Description
Returns the alias for a specified entity type.
","Inputs

entity_type
The entity type to query.

","Example
To get the alias for modules:
hm_getentityalias modules
parts
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
138,hm_getentitybundleinfo,"Description
Returns information about entity bundles.
","Inputs

option ?arg1? ?arg2? ... ?argN?
One of the following options:
-list - Returns a Tcl array of the defined entity bundle
            names
-isdefined <name> - Returns true/false, if there is a bundle definition by that
            name
-definition <name> - Returns an array of the entity types for that bundle
            definition
-definition <name> <datanumber> - Returns the entity type for that data number
            (starts from 0)
-isinbundle <name> <datanumber> <id> - Returns true/false, if that entity is
            in the bundle
-anyinbundle <name> - Returns true/false, if there is anything in the bundle
-anyinbundle <name> <datanumber> - Returns true/false, if there is anything in
            that data of the bundle
-count <name> <datanumber> - Returns how many entities are in that data of the
            bundle
-getids <name> <datanumber> - Returns a Tcl array of that
            data of the bundle
-markids <name> <datanumber> <mark> - Adds the entities of that data of the
            bundle to the specified mark

","Example
To return the list of entity types, in order, that constitute the definition of the bundle
        named ""material bundle"":
hm_getentitybundleinfo -definition ""material bundle""
To find the bundle named ""material bundle"" and answer ""true"" if there is any entity stored
        in its first data
        item:hm_getentitybundleinfo -anyinbundle ""material bundle"" 0
To find the bundle named ""material bundle"" and return a Tcl list of the
        IDs stored in its first data
        item:hm_getentitybundleinfo -getids ""material bundle"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
139,hm_getentitycreationid,"Description
This command returns a valid entity ID that can be used to renumber both the creating and
        mapping entities. If the command returns 0, it means the new entity can use any ID. If the
        command returns a valid ID, both the new entity and mapped entity need to be renumbered to
        use the returned ID.
","Inputs

entity_type_c
The entity type for the creating entity.
pool_id
The solver ID pool number for the creating entity. A value of 0 indicates no solver ID
            pool.
entity_type_m
The entity type for the mapping entity.
entity_id
The entity ID for the mapping entity. A value of 0 indicates the command should find
            an ID for renumbering both the creating and mapping entities.

","Example
To create a new component named myComp whose ID should map with its assigned property ID of
        100:
set propID 100
set newID [hm_getentitycreationid comps 0 props $propID]
*createentity comps name=myComp color=5;
set compID [hm_entityinfo id comps ""myComp""];
if { $ newID != 0 } {
    if { $propID != $ newID } {
        #Renumber the property
        *createmark properties 1 ""by id only"" $propID;
        *renumbersolverid properties 1 $newID 1 0 0 0 0 0;
    }
    if { $compID != $ newID } {
        #Renumber the component
        *createmark comps 1 ""by name only"" myComp
        *renumbersolverid comps 1 $newID 1 0 0 0 0 0;
    }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
140,hm_getentityname,"Description
This command returns the fully qualified HyperMesh entity name for the specified entity_type_id. Each
        entity type in HyperMesh is assigned a unique
        ID. This ID is converted to the entity type name using this command. 
If entity_type_id is not valid, undefined will be returned. 
This is the inverse of the hm_getentitytype command. 
","Inputs

entity_type_id
The unique entity type ID.

","Examples
To get the name of entity type 1 (nodes):
hm_getentityname 1
To get the name of entity type 11 (properties):
hm_getentityname 11
","Errors
None.
"
141,hm_getentitytype,"Description
This command returns the HyperMesh entity ID for the specified
          entity_type_id. Each entity type in HyperMesh is assigned a unique ID. The entity type name is converted to the entity type ID using
        this command. 
If entity_type is not valid, undefined will be returned. 
This is the inverse of the hm_getentityname command. 
","Inputs

entity_type
The unique entity type ID.

","Examples
To get the type ID of nodes (1):
hm_getentitytype nodes
 To get the type ID of properties (11):
hm_getentitytype properties
","Errors
None.
"
142,hm_getentitytypedictionary,"Description
Certain entity card images have organizational types defined in the templates which are
        used by the panels and the browsers to filter and organize the available entity card images
        (dictionaries). This command returns a list of available types defined in the current
        template for the specified entity_type. 
The command hm_getentitycardimagedictionary can then be used to get a
        list of card images that are of the specified type.
","Inputs

entity_type
Currently supported for props and mats.

","Example
To return the list of organizational types for props defined in the current template:
hm_getentitytypedictionary props
","Errors
None.
"
143,hm_getentitytypes,"Description
Returns a list of entity types based on the specified option.
","Inputs

option
The type of entity types to return. Valid values are: 
all - all entity types are returned 
named - only named entity types are returned

","Example
To get the named entity types:
hm_getentitytypes named
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
144,hm_getfacesbyarea,"Description
Gets the faces with an area smaller or equal to the specified value. 
","Inputs

double
Maximum area that you specify.

","Example
hm_getfacesbyarea 40
","Errors
None.
"
145,hm_getfacesfromedge,"Description
Gets all faces connected to the edge whose ID is supplied as the argument.
","Inputs

line_id
ID of the edge.

","Example
To get faces connected to the edge with ID 2:
hm_getfacesfromedge 2
","Errors
None.
"
146,hm_getfacesfromvertex,"Description
Gets all faces connected to the point whose ID is supplied as the argument. 
","Inputs

point_id
The point ID. 
The function returns a list containing IDs of faces connected to the vertex
            points.

","Example
To get faces connected to the vertex with ID 2:
hm_getfacesfromvertex 2
","Errors
None.
"
147,hm_getfilletfacesbyprofile,"Description
Returns the faces containing fillets with a selected profile edge. 
","Inputs

entity_type
Must be set to lines.
mark_id
The ID of the mark containing the profile lines that define the fillets. Valid values are 1 and 2.

","Example
To get the faces with fillets with profile lines 5 and 15:
*createmark lines 1 5 15
hm_getfilletfacesbyprofile lines 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
148,hm_getFLid,"Description
Returns the IDs of the flange lines.
","Example
To get the IDs of the flange lines:
hm_getFLid
","Errors
None.
",
149,hm_getgeometrynodes,"Description
Get a list of associated nodes from the set of geometric entities. 
","Inputs

geometry_list
Geometric entities description list in a form: 
entityType1 ID1_1 ID1_2 ... entityType2 ID2_1 ID2_2 .. entityType1,
              entityType2. The types of entities. Can be surfs, lines, or points. 
ID1_1, ID1_2, ... IDs of the entities of the type entityType1,
            entityType2, ... 
ID2_1, ID2_2..  List containing node IDs of all the nodes that are
            associated with any of geometric entities specified by the input parameters list.

","Example
To get nodes associated to the surface with ID 12:
hm_getgeometrynodes 12
To get nodes associated to the line with ID 13:
hm_getgeometrynodes [list lines 13]
To get nodes associated to the line with ID 13, including its endpoints:
hm_getgeometrynodes [concat lines 13 points [hm_getverticesfromedge 13]]
Parameters specifying the type of entities can appear any place in the parameter list. They
        define the type for all entities that follow in the list, until the next occurrence of type
        parameter. 
If no type parameter is specified at the beginning of the parameter list, surfs type is
        assumed for all parameters until the first occurring type parameter. 
Nodes have a unique association. If the node is associated to the vertex, no association
        with the edge connected to this vertex will be reported for this node. Also, if the node is
        associated to the edge, no association to the surface connected to the edge will be reported
        for this node. In order to get all nodes associated to the line including its endpoints,
        both the line and its vertices should be included in the list of input geometric entities. 
Geometric entities can be duplicated in the input list but associated node IDs are unique
        in the output.
","Errors
None.
"
150,hm_getgeomwithlargestitch,"Description
The stitch distance between edges, and between vertices are measured and the ones with
        ‘large gaps’ are identified. The term ‘large gap’ refers to those stitches where the
        distance is larger than the input tolerance. Returned values, in order, are:
The largest stitch distance among the edges that are identified as ‘large gap’. If no
            large gap found, 0.0 is returned.
The largest stitch distance among the vertices that are identified as ‘large gap’. If
            no large gap found, 0.0 is returned.
The average stitch distance among the edges that are identified as ‘large gap’. If no
            large gap found, 0.0 is returned.
The average stitch distance among the vertices that are identified as ‘large gap’. If
            no large gap found, 0.0 is returned.
The list of all surfaces which has large stitch gaps with neighbor surfaces.
The list of all lines with large stitch gaps.
The list of all vertices with large stitch gaps.


","
Inputs



tolerance

The distance between stitched edges or vertices are compared against this tolerance.
            If it is not given, or is less than or equal to 0.0, then the geometry cleanup tolerance
            is used. 

","Examples
To get all surfaces, lines and vertices for which the stitch distance is larger than
        0.5:
hm_getgeomwithlargestitch 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
151,hm_gethistorylimit,"Description
Returns the maximum number of steps allowed to be recorded in the history. If a value of 0
        is returned, history is disabled. If a value of -1 is returned, there is no step limit.
","Example
To get the number of steps allowed to be recorded in the history:
hm_gethistorylimit
","Errors
None.
",
152,hm_gethistorymemoryusage ,"Description
Returns the current amount of memory used for recording history.
","Example
To get the current amount of memory used for recording history:
hm_gethistorymemoryusage
","Errors
None.
",
153,hm_gethmfileversion ,"Description
Returns the binary file version string for a specified HyperMesh database. The string is comprised of 2 parts, major-minor, where:
major is the major file version. It is itself comprised of two parts,
            release.binary.
minor is the minor file version.

For example:  13.02-110
","Inputs

filename
The full path and filename of the database file. Paths with spaces must be enclosed in
            quotes.

","Example
To get the file version for C:\temp\test.hm:
hm_gethmfileversion  C:/temp/test.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
154,hm_getidpools,"Description
Returns a list of pool IDs or names for the specified entity type. The pool IDs and names
        are returned in the same order.
","Inputs

entity_type
The type of entity to query.
return_type (optional)
Argument that specifies whether to return pool IDs or names. Valid values are name and
            ID (default if not specified).

","Examples
To get the pool ID list for elements:
hm_getidpools elems
orhm_getidpools elems id
To get the pool name list for
        properties:hm_getidpools props name
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
155,hm_getincludeentities ,"Description
Selects entities and returns the entity types contained in a specified include file. The
        return value is the list of entity types found in the specified include. The actual entities
        are populated on the specified mark.
","Inputs

include_id
The ID of the include file to query. A value of 0 indicates the master model.
mark_id
The ID of the mark that contains the found entities. Valid values are 1 and 2.

","Example
To find all of the entities in include 1 and delete them:
hm_markclearall 1
set ent_types [hm_getincludeentities 1 1]
foreach ent_type $ent_types {
    catch {*deletemark $ent_type 1}
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
156,hm_getincludes ,"Description
Returns a list of include IDs or names. Only one argument may be specified at a time. If no
        argument is specified, the IDs are returned.
The IDs and names are returned in the same order.
","Inputs

byshortname
Returns the list of includes by their short names.
byfullname
Returns the list of includes by their full path names.
byshortnameexportpair
Returns the list of includes by their short names, along with the export flag for
            each.
byshortnamesolverflagpair
Returns the list of includes by their short names, along with the solver flag for
            each.
byshortnamealwaysmergeflagpair
Returns the list of includes by their short names, along with the always merge flag
            for each.

","Example
To get the list of include IDs:
hm_getincludes
To get the list of include short names:
hm_getincludes -byshortname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
157,hm_getincludesentities,"Description
Selects entities and returns the entity types contained in specified include files. The
        return value is the list of entity types found in the specified includes. The actual
        entities are populated on the specified mark.
","
Inputs


<select_type>=<selection>
The entity or entities that are to be queried. There are several ways to provide the
            entities to be queried. Only one option can be used at a time:
includeids=<ids>
The IDs of the includes to query.
includenames=<names>
The names of the includes to query.


outputmark=<mark_id>
The ID of the mark that contains the found entities. Valid values are 1 and 2.

","Examples
To find all of the entities in include IDs
        1,2,3,4:hm_getincludesentities includeids={1 2 3 4} outputmarkid=1
To find all of the entities in include names inc1, inc2, inc3,
        inc4:hm_getincludesentities includenames={inc1 inc2 inc3 inc4} outputmarkid=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
158,hm_getinputoffsetid,"Description
Returns the current value of the import offset specified with
          *feinputoffsetid.
","Inputs

entity_type
The type of entity to query.

","Example
To get the offset value for elements:
hm_getinputoffsetid elems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
159,hm_getinternalidlist ,"Description
This command returns the internal HyperMesh IDs for a list of
        solver IDs and a solver ID pool. This command is only applicable to templates and entity
        types that have ID pools.
","Inputs

id_pool
The pool ID or name. By default, the value is assumed to be the pool ID. This is
            controlled by the optional search_type argument.
solver_id_list
The list of solver IDs to query. All IDs must belong to the specified pool.
search_type
Defines whether id_pool is specified as a pool name or a pool ID.
            Valid values are -bypoolid and -bypoolname. If not specified, it defaults to
            -bypoolid.

","Examples
To get the internal HM IDs of pool ID 1 and solver IDs 2, 3 and 4:
hm_getinternalidlist 1 ""2 3 4""
or
hm_getinternalidlist 1 ""2 3 4"" -bypoolid
To get the internal HM IDs of pool PROP_IDPOOL and solver IDs 17 and 20:
hm_getinternalidlist PROP_IDPOOL ""17 20"" -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
160,hm_getlineendpoint ,"Description
Returns the components of the line end point. If the line is a closed loop, the start and
        end points will return the same value.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the end of the line with ID 341:
set list [hm_getlineendpoint 341]
set x [lindex $list 0]
set y [lindex $list 1]
set z [lindex $list 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
161,hm_getlinepointsatdistance,"Description
For a given line, test point, and distance, this command finds all of the line points that
        are at the specified distance from the test point.
","Inputs

lineID
ID of the line.
dist
Distance from the test point.
x, y, z
Coordinates of the test point.

","Example
The result is returned as a list of values: { x1 y1 z1 x2 y2 z2 … }where ""xn"" ""yn"" ""zn"" are
        coordinates of points on the line that are at distance ""dist"" from the test point defined by
        ""x"", ""y"", ""z"".
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
162,hm_getlinetangentatcoordinate ,"Description
Returns the closest point, components of the tangent vector and the angle between the
        tangent vector and the z-axis at the point on the line closest to the input coordinates..
        The first 3 return values are the closest point coordinates, the next 3 are the tangent
        vector components, and the last return value is the angle.
","Inputs

line_id
The ID of the line.
x, y, z
The (x,y,z) coordinates of the point.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis nearest the coordinates (100,50,25) for the line with ID 341:
foreach {x y z tg_x tg_y tg_z ang}[hm_getlinetangentatcoordinate 341 100 50 25{}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
163,hm_getlinetgstartpoint ,"Description
Returns the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the line start point. The first 3 return values are the tangent vector
        components, and the 4th return value is the angle.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the start of the line with ID 341:
foreach {tg_x tg_y tg_z ang} [hm_getlinetgstartpoint 341] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
164,hm_getlist ,"Description
Returns an ordered list of entities from an entity list.
","Inputs

entity_type
The type of entity list to query. Valid values are elems, laminates, lines, nodes,
            plies and surfs.
list_id
The ID of the list to query. Valid values are 1 and 2.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the list has been created from a panel entity selector under the
            above conditions. Valid options are:
0 - Use the previous panel (default).
1 - Use the current panel.


model_name
The optional model to get the list from.  If not specified, the current model is
            used.

","Examples
To create a line from a user specified list of
        nodes:*createlistpanel nodes 1 ""Select nodes for the line:""
set node_list [ hm_getlist nodes 1 ];
if { ! [ Null node_list ] } {
*linecreatefromnodes 1 0 150 5 179
}
To create, query, and clear a list from nodes 2, 10, and 3 for model
        model-2:*createlist nodes 1 ""by model"" model-2 2 10 3
set my_list [hm_getlist nodes 1 0 model-2]
*clearlist nodes 1 ""by model"" model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
165,hm_getlockedentities ,"Description
This command returns locked entity IDs across all submodels.
","Inputs

entity_type
The type of entity to query locks for.
data_name
The data name to query locks for. Currently only supported for ""id"".

","Example
To query ID locks for all elements:
hm_getlockedentities elems id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
166,hm_getmarkall ,"Description
Returns a list of lists containing the populated entity type and entity IDs for the
        specified mark. The first value in each returned list is the entity type, and the remaining
        values are the entity IDs of that type. For example, if mark 1 is populated with elements
        1-5 and comps 101-105, the returned values would
        be:{elems 1 2 3 4 5} {comps 101 102 103 104 105}
","Inputs

mark_id
The ID of the mark to query. Valid values are 1 and 2.
model_name
The optional model to get all marks for. If not specified, the current model is
            used.

","Example
To find all of the entities on mark 1:hm_getmarkall 1
To find all of the entities on mark 1 for model
        model-2:hm_getmarkall 1 model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
167,hm_getmarkfromtable ,"Description
This command returns the list of entity IDs that exist in the table with
          table_name.
","Example
To create a table named elem_table containing elements in the component wingbox and
        retrieve the values from the table:
*createmark elems 1 all
hm_marktotable elems 1 elem_table
set elems [hm_getmarkfromtable elem_table]
","Errors
If table_name is invalid, you will get the following
        error:hm_getmarkfromtable: the table 'table_name' was not found.
",
168,hm_getmatching,"Description
Performs a comparison and returns matching results.
Returns a matching pair of comps or parts passed along with the percentage match.  The
        reference/target entities are sequenced first in the output, followed by matching source
        entities, and subsequently followed by the matching percentage.  If a source entity matches
        with more than one target, the pairs with maximum match percentage are returned.  A source
        returned with one reference is not part of any other match pair.
","
Inputs


entity_type
The type of entity to copmare. Valid values are comps or parts.
mark_id
The ID of the mark of entities to compare. Valid values are 1 and 2.
areaCalcMethod=<value>
Specifies how the matching area percentage is calculated:
ByLowestId - Calcualte with respect to the entity with the lowest ID (default)
ByHighestId - Calcualte with respect to the entity with the highest ID
This is ignored when searchMethod=ByEncoding.
compareType=<value>
Specifies with what entities the comparison happens:
0 - Use both CAD and FE from the input selection
1 - Prefer CAD over FE. This will pick FE only if the input has only FE.
2 - Use only CAD
3 - Prefer FE over CAD. This will pick CAD only if the input has only CAD.
4 - Use only FE
deformationTolerance=<value>
The match tolerance value (default 0.0).
When searchMethod=ByEncoding this is used to determine if the
            distance between the encodings of the source and target are less than this value.



encoding_algorithm

The optional encoding algorithm to use when
            searchMethod=ByEncoding.  Valid values are:
0 - Spherical harmonics (default)


matchingPercentThreshold=<value>
The matching area threshold above which matching pairs are returned (default is node
            tolerance).
When searchMethod=ByEncoding, this is reported as (1 –
              differenceinencoding/deformationTolerance=<value>)
referenceEntityMarkId=<value>
The ID of the mark of reference/target entities. Valid values are 1 and 2.
If not specified, the entire source is considered.
If specified, referenceEntityType is required.
referenceEntityType=<value?
The type of reference/target entity. Valid values are comps or parts.
If not specified, the entire source is considered.
If specified, referenceEntityMarkId is required.
searchMethod=<value>
Specifies how the matching is done:
ByArea - Matching is done with repect to area (default)
ByEncoding - 
ByTopo - Matching is done with repect to exact topo matches



sphhar_bandwidth

Optional, valid for encoding_algorithm 0, default 16.



sphhar_fallof

Optional, valid for encoding_algorithm 0, default 2.828427.



sphhar_radii

Optional, valid for encoding_algorithm 0, default 32.



sphhar_resolution

Optional, valid for encoding_algorithm 0, default 64.

","Examples
To compare part 4 to part 6 using a tolerance of
        1.0:*createmark parts 1 ""by ids"" 4
*createmark parts 2 ""by ids"" 6
hm_getmatching parts 1 referenceEntityType=parts referenceEntityMarkId=2 matchingPercentThreshold=0.0 deformationTolerance=1.0
To compare part 4 to part 6 using the encoding search with a tolerance of 0.6 and using
        both CAD and
        FE:*createmark parts 1 ""by ids"" 4
*createmark parts 2 ""by ids"" 6
hm_getmatching parts 1 referenceEntityType=parts referenceEntityMarkId=2 deformationTolerance=0.6 searchMethod=ByEncoding compareType=0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
169,hm_getmaxgapwidth,"Description
Returns the approximate maximum distance between a pair of node lists. This is useful for
        determining the gap width to be used for filling the gap between the node lists.
","Inputs


list_id1
The ID of the first node list. Valid values are 1 and 2.
list_id2
The ID of the second node list. Valid values are 1 and 2.


","Examples
To get the maximum gap width between two node lists:
*createlist nodes 1 1-20
*createlist nodes 2 45-80
hm_getmaxgapwidth 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
170,hm_getmeshedgeparams ,"Description
This command returns all of the relevant automesh settings applied to a surface edge by
          *set_meshedgeparams. If no automesh settings are applied, no values are
        returned. The returned values are (in order):

elem_density
alg_type
bias_style
bias
min_size
max_size
chordal_dev
max_angle

","Inputs

edge_id
The global edge ID of the surface edge to query.

","Example
To get the automesh parameters assigned to edge with ID 15:
hm_getmeshedgeparams 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
171,hm_getmeshvolumesinfo ,"Description
This command returns the number of volumes and multiple lists containing the element IDs
        and volume indices for each input element.
","Inputs

mark_id
The mark of elements to find volumes for. Valid values are 1 and 2.
mode
0: internal voids considered as ""voids"" and do not make a new volume
1: internal voids considered as new volumes

The output from this command is in the following format:
{n} {elem_id1 volume_i1 volume_j1} {elem_id2 volume_i2 volume_j2} ...
{n} - The number of identified volumes.
{elem_id volume_i volume_j} - List containing the ID of the shell element and a pair of
        volumes of corresponding element sides. The first volume (i) corresponds to the volume on
        the shell element side with normal pointing out. A volume of 0 represents free space (no
        volume).
If 0 volumes are detected, only {n} is returned.
","Example
To orient all shell elements so that the normal points toward the inside of the volume with
        the smallest ID (or inside if there is only one volume):
*createmark elements 1 displayed
set volumes_list [hm_getmeshvolumesinfo 1 0]
set num_volumes [lindex $volumes_list 0]
set volumes_list [lreplace $volumes_list 0 0]
set reverse_list""""
foreach elem $volumes_list{
    set elemid [lindex $elem 0] 
    set vol1 [lindex $elem 1]
    set vol2 [lindex $elem 2]
    if {$vol1 > $vol2} {
        lappend reverse_list $elemid
    }
}
if { [llength $reverse_list ] } {
    *clearmark elements 2
    eval *createmark elements 2 $reverse_list
    eval *normalsreverse elements 2 1.e-10
    *clearmark elements 2
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
172,hm_getmidsurfaceinfo,"Description
Returns information related to geometric midsurfaces.
","
Inputs


query_type=<value>
The type of query to perform:
find_midsurface - Finds midsurfaces corresponding to
              input_entity_type comps, surfs or solids.  The return is the list
            of output_entity_type IDs.
find_parent_geometry - Finds comps, surfs or solids corresponding to
              input_entity_type midsurfaces.  The return is the list of
              output_entity_type IDs.
is_midsurface - Checks if a given input_entity_type of comps or
            surfs consists of midsurfaces only, non-midsurfaces only, or both.  The return is yes,
            no or mixed.
input_mark=<value>
The ID of the mark of input entities.  Valid values are 1 and 2.
input_entity_type=<value>
The type of input entity on input_mark.  Valid values are given in
              query_type.  If there is only one possible value, this can be
            omitted.
output_entity_type=<value>
The type of ouptut entity.  Valid values are given in query_type.
            If there is only one possible value, this can be omitted.

","Examples
To get the list of middle surfaces corresponding to solid with ID
        19:*createmark solids 1 19
hm_getmidsurfaceinfo query_type=find_midsurface input_mark=1 input_entity_type=solids
To get the component containing the original geometry for the middle surface with  ID
        19:*createmark surfs 1 19
hm_getmidsurfaceinfo query_type=find_parent_geometry input_mark=1 input_entity_type=comps
To see if the surface with ID 19 is a
        midsurface:*createmark surfs 1 19
hm_getmidsurfaceinfo query_type=is_midsurface input_mark=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
173,hm_getmodelcheckconcernentityidresultentityid ,"Description
Finds the concerned non projecting untied nodes for a given contact group/interface. Untied
        node IDs are placed on mark 2.
","Inputs

display_name
The display name of the check to query. Currently supported values are:
? ""Un-Tied nodes in Contact Tied"" for LS-DYNA
? ""Un-Tied nodes in interface type2"" for Radioss


contact_id
ID of the contact for which untied nodes are to be found. This must be one of the
            contact IDs listed in the Model Checker browser after a Model Checker run.

","Examples
To find untied nodes for contact with ID 123:
For LS-DYNA:
hm_getmodelcheckconcernentityidresultentityid ""Un-Tied nodes in Contact Tied"" 123
For Radioss:
hm_getmodelcheckconcernentityidresultentityid ""Un-Tied nodes in interface type2"" 123
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
174,hm_getmodelcheckcheckresult,"Description
Returns the result for a given check.
The result consists of:
<flag> - True if check is run and false otherwise
<number of failed entities> - The count of failed entities
<entity IDs> - The IDs of the failed entities


For example: true 4 46 47 48 49
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

","Examples
To get the result for the ""Unused materials"" check:
hm_getmodelcheckcheckresult ""Unused Materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
175,hm_getmodelcheckcorrectiondisplayname,"Description
Returns the correction names for a given check.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

","Examples
To get the correction names for the ""Unused materials"" check:
hm_getmodelcheckcorrectiondisplayname ""Unused Materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
176,hm_getmodelcheckcorrectvalue,"Description
Returns the value for a given correction.
","
Inputs



correction_display_name

The GUI display name of the correction. This is case sensitive.

","Examples
To get the value for the ""Delete unused materials"" correction:
hm_getmodelcheckcorrectvalue ""Delete unused materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
177,hm_getmodelcheckdisplaynames,"Description
Returns check display names.
","
Inputs



check_type

The type of check, ERROR, WARNING, INFO or ALL. If blank then all checks of all types
            are returned.

entity_type

The type of entity.  If ALL, then checks for all entity types in the profile are
            returned.

","Examples
To get the check names for all check and entity
        types:hm_getmodelcheckdisplaynamesor
        hm_getmodelcheckdisplaynames ALL
To get the check names for ERROR for mats:
hm_getmodelcheckdisplaynames ERROR mats
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
178,hm_getmodelcheckfailedcount ,"Description
Returns the number of entities failing a given model checker check. 
","Inputs

check_name
The name of the check, as given in the model checker config file.

","Example
To get the number of entities failing the ""Number of defined materials"" check:
hm_getmodelcheckfailedcount ""Number of defined materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
179,hm_getmodelchecksupportedentities,"Description
Returns the list of entity types that have checks for the current profile, using the loaded
        default config file or user defined custom config file.
","
Inputs
None.","Examples
Example 
hm_getmodelchecksupportedentities
",ErrorsNone.
180,hm_getmoi ,"Description
Returns the tensorial moment-of-inertia Ixx, Iyy, Izz, Ixy, Ixz, Iyz values for the
        selected entities.
","Inputs

entity_type
The type of entity to query. Currently supported for comps and elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
location_flag (optional)
Specifies the location about which the MOI is calculated. Valid values are:
0 - Global (0,0,0). Default.
1 - COG location.
2 - Node specified by node_id argument.


node_id (optional)
Specifies the node location about which the MOI is calculated if location_flag=2.
            Ignored otherwise.
axes_flag (optional)
Specifies the axes to report the MOI values relative to. Valid values are:
0 - Global axes. Default.
1 - Principal axes
2 - System specified by system_id argument.


system_id (optional)
Specifies the system ID to report the MOI values relative to if axes_flag=2. Ignored
            otherwise.
reserved_1
Reserved for future use. Must be set to 0.
reserved_2
Reserved for future use. Must be set to 0.

","Example
To get the MOI for components 1-5:
*createmark comps 1 1-5
hm_getmoi comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
181,hm_getmydocumentsdir ,"Description
This command returns the full path to the current user’s ""My Documents"" folder. This
        command is only supported on Windows platforms. 
","Example
hm_getmydocumentsdir
","Errors
This command does not return any errors that can be handled.
",
182,hm_getnodalthickness ,"Description
Gets the thickness of the node whose ID is given as the argument. 
","Inputs

entityType
The type of the entity. Only nodes are currently supported.
nodeID
ID of the node. 

","Example
This function queries the surface definition to obtain the thickness at a given node
        location. To obtain the thickness value using this function, the node should be associated
        with a geometric surface that was created using midsurface extraction tools in HyperMesh. The function returns ""-1"" if the thickness at that location
        could not be obtained.
hm_getnodalthickness node 73
","Errors
None.
"
183,hm_getnodessharedbyothercomps ,"Description
This command returns the nodes on the input components that are shared by other
        components.
","Inputs

comp_mark_id
The ID of the mark containing the components with the nodes of interest. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the components with the nodes of interest. Valid values are 1 and 2.
exclude

0 - Do not exclude any nodes.
1 - Exclude nodes on mass, rigid and joint elements.


","Example
To find the nodes from component 100 shared by other components:
*createmark comps 1 100
hm_getnodessharedbyothercomps 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
184,hm_getoffset ,"Description
This command returns the offset value of the specified element.
","Inputs

elem_id
The ID of the element to query.

","Example
To get the offset for element 100:
hm_getoffset 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
185,hm_getoption,"Description
This command returns the value of certain HyperMesh
        options.
","Inputs

option
The option to query. See *setoption for a full list of options and possible
            values.
default
If set to 1, returns the default value instead of the current value, where
            supported.

","Example
To query the cleanup tolerance:
hm_getoption cleanup_tolerance
To query the color of non-mappable solids:
hm_getoption display_color-15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
186,hm_getplanarfaces ,"Description
Returns a list of planar face IDs.  These faces can be converted to surfaces using hm_getsurfacefromface.
","Example
To get the list of all planar face IDs:
set pfaces [hm_getplanarfaces];
","Errors
None.
",
187,hm_getPOLid ,"Description
Returns the IDs of the POL lines.
","Example
To get the IDs of the POL lines:
hm_getPOLid
","Errors
None.
",
188,hm_getprefixbasenamesuffixforgivencompname,"Description
Returns the split name as prefix, base name and suffix for the specified component name and
        separator.
","
Inputs



name

The name of the component.

separator

The character to be used to split the component name. The prefix is everything before
            the first instance of this character, the suffix is everything alphanumeric after the
            second instance of this character, and the base name is everything in between.

","Examples
To get the prefix, base name, and suffix for a given name using - as the separator:
hm_getprefixbasenamesuffixforgivencompname abc-defgh-ijk.123 ""-""
  {abc defgh ijk}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
189,hm_getprojceid ,"Description
Returns the ID of the connector from the FE weld data array for a given index. This command
        should only be used from within a connector-registered property script (which is executed
        during connector FE realization). The projection data this function relies upon is removed
        immediately after connector FE realization.
","Inputs

index
The index of the weld in the FE weld data array.

","Example
To get the connector ID for the 10th index in the weld data array:
set ce_id [hm_getprojceid 10]; 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
190,hm_getqualitycriteriaelementsizeinfo,"Description
Returns element size info for a quality criteria file. Optionally, checks the match of the
        quality criteria to a given element size. A list of 4 values is returned: 
return_code, criteria_elemsize, criteria_min_elemsize, criteria_max_elemsize 
Where return_code is: 
0 - Criteria file exists and matches check_elem_size (if available).
1 - Criteria file exists but does not match check_elem_size.
2 - Criteria file exists but does not have any size checks enabled.
3 - Criteria file does not exist, or is not set if ""dummy"" is specified.
-1 - Min size or max size is not enabled in the criteria file.


","Inputs

criteria_file
The full name and path of the criteria file to query. If ""dummy"" or an empty string is
            given, this returns info for the currently loaded quality criteria.
?check_element_size? (optional)
Element size to check against the quality criteria.

","Example
 To check if the criteria file C:/temp/mycrit.criteria exists and
        matches a size of 10.0:
hm_getqualitycriteriaelementsizeinfo C:/temp/mycrit.criteria 10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
191,hm_getredoactions ,"Description
Returns the history actions on the redo list.
","Example
To get the history actions on the redo list:
hm_getredoactions
","Errors
None.
",
192,hm_getreferencedentitiesmark,"Description
Finds entities that are referenced by the entities on the specified mark. This includes
        collected references, data name references and attribute entity references. Each type of
        entity that is referenced by the specified input entities is returned in a list, and the
        found entities are placed on the specified mark for those entity types. See the list of
        supported entities for hm_getreferencedentities.
","Inputs

entity_type
The type of entity to query.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
reference_flag
The type of referenced entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2).
Bit0
0 - Do not consider collected entity references. 
1 - Consider collected entity references. If the specified entity is not a
                  collector or is empty, nothing will be returned for this bit.
Bit1
0 - Do not consider data name entity references. 
1 - Consider data name entity references. If the specified entity does not have
                  any data name references, nothing will be returned for this bit.
Bit2
0 - Do not consider attribute entity references. 
1 - Consider attribute entity references. If the specified entity does not have
                  any attribute entity references, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found referenced entities on. Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.

","Examples
To get all entities referenced by components with IDs 100-110 on mark 1 and highlight them
        on the screen:
*createmark comps 2 100-110
foreach entity_type [hm_getreferencedentitiesmark comps 2 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity references for components with IDs 100-110 on mark 2:
*createmark comps 1 100-110
hm_getreferencedentitiesmark comps 1 1 2 0 0 -byid
To get only data name entity references for components with IDs 100-110 on mark 1:
*createmark comps 2 100-110
hm_getreferencedentitiesmark comps 2 2 1 0 0 -byid
To get only attribute entity references for components with IDs 100-110 on mark 1:
*createmark comps 2 100-110
hm_getreferencedentitiesmark comps 2 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
193,hm_getreplacequerryonentities ,"Description
This command can be used to query information about a part replace preview operation. This
        must always be used in conjunction with the *replacentitywithentity
        command.
","Inputs

option
1 - Get the replace status of all replaced entities. The status are 1 (not OK), 2 (OK)
            and 3 (partial OK). 
2 - Get the replace entity list. 
3 - Get the replace pass/fail status for common nodes shared between the replace
            component and other components.

","Examples
To get the replace status for all entities:
hm_getreplacequerryonentities 1
{loadcols {3 7 } {2 2 } {{1 of 1nodes replaced} {4 of 4 loads replaced} }} {groups { 2 1 } {2 2 } {{Master - 1 of 1 comps replaced} {Master - on all10 of 10 nodes 
replaced( Set - slave_set(grp1))} }} {outputblocks { 1 2 } {2 2 } {{4 of 4 nodes replaced} {4 elements replaced by69 elements} }}
To get the replace entity list:
hm_getreplacequerryonentities  2
{loadcols 3 7 } {systcols 1 } {groups 2 1 } {outputblocks 1 2 } {elements 7614 7615 7624 7616 7617 7618 7619 7620 7621 7622 7623 } {components 135 } {sets 1 7 2 9 13 4 15 16 18 20 } {contactsurfs 1 11 12 }
To get the pass/fail status:
hm_getreplacequerryonentities  3
{PASS 162473 162476 162497 162509 162516 162528 162530 162533 162535 162536 162538 162593 162650 162658 162676 162704 162707 162728 253082 } {FAIL }
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
194,hm_getribsid ,"Description
Returns the IDs of the rib lines.
","Example
To get the IDs of the rib lines:
hm_getribsid
","Errors
None.
",
195,hm_getsolidmappablestate,"Description
Returns the mappable state of the specified solid. The following values can be returned: 
-1 - Not evaluated for mappability. 
0 - Unmappable 
1 - 1-direction mappable 
3 - 3-direction mappable
","Inputs

solid_id
The ID of the solid geometry to query.

","Example
To get the mappable state of solid 10:
hm_getsolidmappablestate 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
196,hm_getsolver ,"Description
Returns the name or ID of the solver as provided by the template
          *codename() command. If no name is provided, or no template is loaded,
        ""none"" is returned.
","Inputs

value
An optional argument that specifies the type of value to return. 
ID - return the template ID 
name - return the template name (default) 

","Examples
To get the name of the current solver:
set solver_name [hm_getsolver]
or
set solver_name [hm_getsolver name]
To get the name of the current solver:
set solver_id [hm_getsolver id]
","Errors
None.
"
197,hm_getsolverfileprofilename,"Description
Returns the profile name for an FE input file.  This is based on the file extension. If the
        file extension is ambiguous, then it identifies the profile name based on the file extension
        and the solver format. If the file extension is missing, then it identifies the profile name
        based only on the solver format.
","
Inputs


filename
The full path and filename of the FE solver file, enclosed in quotes.

","Examples
To get the solver profile name for C:/temp/test.dat:
hm_getsolverfileprofilename ""C:/temp/test.dat""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
198,hm_getsolverid2 ,"Description
Returns the solver ID and pool name for the specified HyperMesh
        internal ID. If there is no solver ID and pool for the specified entity, the internal ID and
        a blank ID pool are returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The internal ID or name of the entity to query.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the solver ID and pool name for property with internal ID 4:
hm_getsolverid2 props 4
or
hm_getsolverid2 props 4 -byid
To get the solver ID and pool name for a material with name 1:
hm_getsolverid2 mats 1
or
hm_getsolverid2 mats 1 -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
199,hm_getsolverusessegmentsets,"Description
Queries whether the current solver profile supports segment sets (1) or not (0).
","
Inputs

None.
","Examples
None.
","Errors
None.
"
200,hm_getsurfacecurvatureforedges,"Description
Returns information about the curvature of surfaces attached to edges. The output is a list
        of lists, with each list item containing the following information:
edge_id surface1_id surface1_curvature_max surface1_curvature_min
          surface1_curvature_avg surface2_id surface2_curvature_max surface2_curvature_min
          surface2_curvature_avg surface1_curvature_at_max_break_point
          surface2_curvature_at_max_break_point surface1_curvature_at_min_break_point
          surface2_curvature_at_min_break_point break_angle_max break_angle_min
          break_angle_avg
max_break_point and min_break_point refer to the edge
        points with corresponding max and min curvature breaks.  Only shared and suppressed edges
        are considered, results are not returned for free and non-manifold edges.  For suppressed
        edges, the adjacent face IDs are output for surface1_id and
          surface2_id. These IDs are presented as negative numbers to allow for
        easy identification. Results for break angle are presented in degrees.
The options use a name=value syntax and can be provided in any order.
","
Inputs



curv_method=<curve_method>

A string specifying the approximate calculation of the adjacent surface curvature
            using offset. Valid strings are:
by_chord (default) - The circle radius is evaluated by the edge test point, offset
                point and angle between the surface normal at the test point and the chordal segment
                defined by the test and offset points.
by_3pts - The circle radius is evaluated by the edge test point, offset point and
                middle surface point.
by_normal - The circle radius is evaluated by the angle between the surface
                normals at the edge test point and offset point and offset arc distance.



mark=<mark_id>

The ID of the mark containing the surface edges to consider. Valid values are 1 and 2.
            If not specified or 0, all edges are considered.

min_edgepts_span=<distance>

A positive number specifying the minimal distance between the edge test points where
            the break information is evaluated. If not specified, it is auto defined. A smaller
            value allows for more detailed information for an edge.

offset=<size>

The value of offset across an edge inward to the adjacent surfaces, used for
            evaluation of curvature of the surfaces. The offset is applied at several test points
            along the edge. Valid values are:
A positive real number
autodefined (default)
global_element_size



offset_method=<offset_method>

A string specifying the how the offset inward from adjacent surfaces is performed.
            Valid strings are:
in_surface (default) - The offset is limited by the surface opposite edge. It
                stops on the opposite surface edge if it is reached at a distance smaller than the
                specified offset value. Suppressed edges are disregarded and offset is performed
                over those edges.
in_face - The offset is limited by the face opposite edge. It stops on the
                opposite face edge if it is reached at a distance smaller than the specified offset
                value. Suppressed edges are considered.
in_face_monot - Same as in_face but the offset is also limited by the distance
                from the edge test point where the curvature changes monotonically. If the face has
                an inflection point, the offset stops at this point.
no_offset - The offset is not performed at all and the local surface curvature is
                found analytically in a surface point adjacent to the edge test point.
over_surface - The offset is not limited by the adjacent surface boundary. It is
                performed until the specified offset value is reached and stops only on non-manifold
                edges.



straight_edge_max_pts=<number_of_points>

The maximum number of test points for straight edges. If not specified a value of 10
            is used. If 0, the number of test points for straight edges is not limited.

","Examples
To return the curvature for surfaces attached to all edges:
hm_getsurfacecurvatureforedges
To return the curvature for surfaces attached to edges 1-100:
*createmark lines 1 1-100
hm_getsurfacecurvatureforedges mark=1
To return the curvature for surfaces attached to edges 1-100, using an offset size of
        4.5:
*createmark lines 1 1-100
hm_getsurfacecurvatureforedges mark=1 offset=4.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
201,hm_getsurfacefromface ,"Description
Gets the surface containing the face whose ID is supplied as the argument. 
","Inputs

face_id 
ID of the face.

","Example
The function returns an ID of the surface containing the face with input ID value.
To get surface containing the face with ID 2:
hm_getsurfacefromface 2
","Errors
None.
"
202,hm_getsurfacenormalatcoordinate,"Description
Returns the closest point and the components of the normal vector at the point on the line
        closest to the input coordinates.. The first 3 return values are the closest point
        coordinates, and the last 3 are the normal vector components.
","Inputs

surf_id
The ID of the surface.
x, y, z
The (x,y,z) coordinates of the point.

","Example
To get the components of the normal vector nearest the coordinates (100,50,25) for the
        surface with ID 341:
foreach {x y z n_x n_y n_z} [hm_getsurfacenormalatcoordinate 341 100 50 25] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
203,hm_getsurfacesbyedgelength ,"Description
Gets the surfaces that have an edge with a length smaller or equal to the specified
        value.
","Inputs

double
Length of an edge that you specify.

","Example
hm_getsurfacesbyedgelength 20
","Errors
None.
"
204,hm_getsurfacesfromsolid ,"Description
Returns the list of surface IDs associated with a specified solid ID.
","Inputs

id
The ID of the solid to query.
?type?
An optional string to specify which surfaces are returned.  Valid values are bounding,
            partition, fin and all (default).

","Example
To get a list of surfaces associated with solid of ID 1:
hm_getsurfacesfromsolid 1
 This command returns information necessary for running other commands related to surface
        and solid creation. 
","Errors
None.
"
205,hm_getsurfacesurfaceangle,"Description
This command finds the closest points, P1 and P2, on surfaces surf1_id
        and surf2_id, respectively, to the point, Q, given by the coordinates
          (x_coord, y_coord, z_coord). Next, it finds the vectors V1 and V2 which
        are normal to the given surfaces at points P1 and P2. The angle between V1 and V2, measured
        in degrees, is returned as the result. Note that the point Q does not have to be on either
        surface to find this angle.
","Example
To find the angle between surface 413 and line 156 at point (4.7, 6.88, 9.4): 
hm_getsurfacesurfaceangle 413 156 4.7 6.88 9.4 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
206,hm_getsurfaceuvatcoordinate,"Description
Returns the nearest surface u,v coordinate from a given x, y, z location.
The coordinate is projected to the nearest point on the input surface and returns its
        normalized u, v coordinates, the coordinates of the projected point and a string specifying
        the position of the projected point on the surface.  The returned string can be one of:
Point snapped to Edge
Point snapped to Edge End
Point snapped to Edge Start
Point snapped interior to the Surface
Point snapped to Vertex


","
Inputs


surface_id
The ID of the surface to query.
x
The x coordinate of the point.
y
The y coordinate of the point.
z
The z coordinate of the point.

","Examples
To query the u,v coordinate of the point (1702.4653, 403.6108, 777.5562) projected on
        surface
        26:hm_getsurfaceuvatcoordinate 26 1702.4653 403.6108 777.5562
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
207,hm_getthickness ,"Description
This command returns the thickness value for an entity.
","Inputs

entity_type
The type of entity to query. Valid values are comps, elems and props. 
For an entity_type of components the following applies: 
If the component has a property directly assigned, the thickness of the property is
            returned. 
If no property is assigned to the component, nothing is returned. 
For an entity_type of elements the following applies: 
If the element has a property assigned, the thickness of the property is returned. 
If no property is assigned directly to the element, use the component rules as
            above.
entity_id
The ID of the entity to query.
ply_id
Optional argument that allows for additional control for querying the thickness of
            individual plies of composites. 
Used as follows for metallic properties:If not specified, returns the thickness. 
If specified as 1, returns the thickness as (a). 
Any other value will return an error. 
Used as follows for composite properties: 
If not specified, returns the total thickness (sum of all ply thicknesses). 
If a valid ply is specified, returns the thickness of that ply. 
Any other value will return an error.

","Examples
Get the thickness value of component 11 which has a PSHELL property with thickness of
        0.25:
hm_getthickness comps 11
	0.25

hm_getthickness comps 11 1
	0.25

hm_getthickness comps 11 2
	2 is not a valid ply ID.
Get the thickness value of component 15 which has a PCOMP property with 4 plys (thickness
        values of 0.1, 0.25, 0.25, 0.1, total of 0.7):
hm_getthickness comps 15
	0.7

hm_getthickness comps 15 1
	0.1

hm_getthickness comps 15 2
	0.25

hm_getthickness comps 15 3
	0.25

hm_getthickness comps 15 4
	0.1

hm_getthickness comps 15 5
	5 is not a valid ply ID.
Get the thickness value of element 20 which has a PSHELL property with thickness of
        0.25:
hm_getthickness elems 20
	0.25

Get the thickness value of element 20 which does not have a property assigned but belongs
        to a component that has a PSHELL property with thickness of 0.25:
hm_getthickness elems 20
	0.25
Get the thickness value of element 20 which does not have a property assigned and belongs
        to a component that does not have a property assigned:
hm_getthickness elems 20
	""""

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
208,hm_getTLid ,"Description
Returns the IDs of the trim lines.
","Example
To get the IDs of the trim lines:
hm_getTLid
","Errors
None.
",
209,hm_gettrimmedbinderid ,"Description
Returns the IDs of the trimmed binder surfaces.
","Example
To get the IDs of the trimmed binder surfaces:
hm_gettrimmedbinderid
","Errors
None.
",
210,hm_gettypeswithunresolvedids ,"Description
Returns a list of entity types that currently have unresolved IDs.
","Example
To get the list of entity types with unresolved IDs, and to query the IDs:
foreach entity_type [hm_gettypeswithunresolvedids] {
    set ids($entity_type) [hm_getunresolvedids $entity_type]
}
","Errors
None.
",
211,hm_getunmeshedsurfstomark,"Description
Places the unmeshed surfaces from the input mark onto the output mark.
","
Inputs



input_mark_id

The ID of the mark containing the input surfaces to consider.  Valid values are 1 and
            2.

output_mark_id

The ID of the mark containing the unmeshed surfaces.  Valid values are 1 and 2.

","Examples
To find the unmeshed surfaces from component with ID 200 and place them on mark 2:
*createmark surfaces 1 ""by collector id"" 200
hm_getunmeshedsurfstomark 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
212,hm_getunresolvedidcrossreferences ,"Description
Returns entities that are referring to an unresolved ID. The return value is a list of 3
        values for each cross-referenced entity: 
{entity_type id_pool_name ids} 
For entities with ID pools the IDs returned are the solver IDs. Otherwise, the IDs are the
        internal IDs. If there is no ID pool for the specified entity type, """" will be returned for
          id_pool_id.
","Inputs

entity_type
The type of entity to query.
entity_id
The ID of the entity to query.
?id_pool_id?
The ID of the ID pool to query. If specified, entity_id is taken as
            a solver ID. If not specified, entity_id is taken as an internal
            ID.

","Example
To get the list of entity types cross-referencing material unresolved ID 100:
hm_getunresolvedidcrossreferences materials 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
213,hm_getunusedoremptyentities ,"Description
Returns empty or unused entities, and places them on a mark. The return value is a list of
        lists. Each sub-list contains the empty or unused entity type as its first value, and the
        found entity IDs as the remainder of the sub-list. For example:
{sets 1 2} {comps 3} {mats 3 4}
","Inputs

mode=<mode>
The query mode. Valid values are empty and unused.
outputmark=<mark_id>
The ID of the mark to use for the output entities.
<select_type>=<selection>
The entity or entities that are to be queried. There are several ways to provide the
            entities to be queried. Only one option can be used at a time:
id=<id>
The ID of the single entity to query.
name=<name>
The name of the single entity to query.
mark=<mark_id>
The ID of the mark containing the entities to query. If specified, this must be
                  different from outputmark.


type=<entity_type>
The type of entity to query. If not specified, all entities in the database are
            queried.

","Examples
To get the empty sets out of sets ids 1 2 3:
*createmark sets 1 1 2 3
hm_getunusedoremptyentities mode=empty type=sets inputmark=1 outputmark=2 
To query all unused entities in database:
hm_getunusedoremptyentities mode=unused outputmark=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
214,hm_getuvbounds ,"Description
Returns the parametric uv coordinate bounds associated with the referenced surface.. The u
        and v values are returned as a list containing four values. The first two values in the list
        are the range for u, and the last two values are the range for v.
This is most useful to determine the bounds of trimmed surfaces, where the trimmed
        surface’s parametric space is a subset of the untrimmed surface’s parametric space. It can
        be used in conjunction with hm_getuvcoordinates. 
This command is only valid for single surfaces or surfaces generated by trimming one
        original surface and suppressing edges. It is not valid for the generic case of surfaces
        composed from different parametric patches by suppressing edges only (for example, two
        separate surfaces stitched together, then edges suppressed).
","Inputs

surf_id
The ID of the surface.
scaled (optional)
Used when the referenced surface is a trimmed surface. If the value is set to 0
            (default), the uv bounds returned will be in reference to the parametric space of
            original untrimmed surface. If the scale value is set to 1, the uv bounds returned will
            be in reference to the parametric space of the trimmed surface. 

","Example
To get the uv bounds of surface 1:
hm_getuvbounds 1
","ErrorsNone.Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
215,hm_getuvvectors,"Description
Returns the parametric uv vectors at a node, point or xyz location on the referenced
        surface. The u and v vectors are returned as a list containing six values. The first three
        values are u_x, u_y and u_z. The second three values are v_x, v_y and v_z. The vectors are
        normalized and are relative to the global coordinate system. 
This command is only valid for single surfaces or surfaces generated by trimming one
        original surface and suppressing edges. It is not valid for the generic case of surfaces
        composed from different parametric patches by suppressing edges only (for example, two
        separate surfaces stitched together, then edges suppressed).
","Inputs

surf_id
The ID of the surface.
input_mode
Specifies how the input location is being defined. Valid values are: 
""by xyz"" - the location is specified using x,y,z coordinates. 
""by node"" - the location is specified using a node. 
""by point"" - the location is specified using a point.
options
Depending on the input_mode, these vary. Valid values for each input mode are: 
""by xyz""
x y z 
The x,y,z coordinates of interest, in global coordinates. The location is
                  projected onto the surface if it does not directly lie on the surface.
""by node""
node_id
The ID of the node of interest. The node must either be associated to the input
                  surface, or to no surface at all. If it is not associated to any surface, it is
                  projected internally onto the surface.
""by point""
point_id
The ID of the point of interest. The point must either be associated to the
                  input surface, or to no surface at all. If it is not associated to any surface, it
                  is projected internally onto the surface.


scaled
Optional argument used when the referenced surface is a trimmed surface. If the value
            is set to 0 (default), the uv vectors returned will be in reference to the parametric
            space of original untrimmed surface. If the scale value is set to 1, the uv vectors
            returned will be in reference to the parametric space of the trimmed surface.

","Examples
To get the uv vectors at (100,0,0) on surface 1:
hm_getuvvectors 1 ""by xyz"" 100 0 0
To get the uv vectors at node 100 on surface 1:
hm_getuvvectors 1 ""by node"" 100
 To get the uv vectors at point 100 on surface 1:
hm_getuvvectors 1 ""by point"" 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
216,hm_getverticesfromedge ,"Description
Get surface edge endpoints.
","Inputs

edgeID
The ID of the surface edge.

","Example
List containing two IDs of edge endpoints.
hm_getverticesfromedge 12
For a closed edge that starts and ends at the same point, the returned list still contains
        two entries, both equal to the same point ID. 
The points order in the returned list reflects the parametric direction of the edge; the
        first point corresponds to the smallest parameter value. 
","Errors
None.
"
217,hm_getwhollycontainedcollectormark ,"Description
This command returns the collectors that wholly contain the input entities.
","Inputs

entity_type


The type of entity to query. Valid values are: 
elems (output is components) 
loads (output is load collectors) 
curves (output is plots) 
systs (output is system collectors) 
vectors (output is vector collectors)


entity_mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
collector_mark_id
The ID of the mark containing the collectors that wholly contain the input entities.
            The collector type is dependent on the specified entity_type. Valid values are 1 and 2.
reverse


0 - Find only wholly contained collectors. 
1 - Find not-wholly contained collectors.



","Examples
To find the components that wholly contain elements 1-100:
*createmark elems 1 1-100
hm_getwhollycontainedcollectormark elems 1 1 0
To find the components that simply contain elements 1-100:
*createmark elems 1 1-100
hm_getwhollycontainedcollectormark elems 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
218,hm_hierarchy,"Description
Returns the hierarchical structure of assemblies, components and multibodies, along with
        properties, materials, groups and beamsection collectors. 
The returned list contains entries of the form: {root name_or_id entity_type
          list_of_children_indices}. There is an entry for each supported entity. 
The root value is returned as 1 for entities at the root (top) of the
        hierarchy, or 0 otherwise. Only assemblies, components and multibodies have a hierarchy and
        have the possibility of returning 1. 
The name_or_id value is the name or ID of the entity. This is controlled
        by the  name_or_id option. 
The entity_type value is the type of entity from the list of supported
        entities. 
The list_of_children_indices value is a list of indices of the children of
        the entity. The indices refer to the location of the entity in the returned list. The
        indices are 0 based. Only assemblies can return a non-empty list if they have children.
","Inputs

name_or_id
The string ""name"" if the list is to be returned using entity names, or ""id"" if the
            list is to be returned using entity IDs.

","Example
To find the hierarchy for the following structure of assemblies and components:

Figure 1. 

hm_hierarchy name
{0 Part1 components {}} {0 base assemblies 0} {0 Part2 components {}} {0 attachments
        assemblies 2} {1 wheel assemblies {1 3}} {0 Part3 components {}} {1 head assemblies 5} {1
        empty assemblies {}} {1 Part4 components {}} {4 6 7 8}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
219,hm_historysupporttofile ,"Description
Writes out to a file the commands that are supported for history.
","Inputs

filename
The full path and file name of the output file.
support_level
The type of history support to write the commands for. Valid values are: 
-1 - Commands that do not modify the database and therefore do not affect history 
 0 - Commands that are not supported for history 
 1 - Commands that are supported for history

","Example
To write out the list of unsupported commands to
          C:\temp\unsupported.txt:
hm_historysupporttofile C:/temp/unsupported.txt 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
220,hm_holedetectionfindholes ,"Description
Runs the hole detection functions for finding holes and tubes based on input entities and
        parameters. This must be preceded by calls to
          hm_holedetectioninit, hm_holedetectionsetentities,
        and hm_holedetectionsetholeparams or
          hm_holedetectionsettubeparams.
","Inputs

find
Bit value defining the types of holes and tubes to find (Bit0 + 2*Bit1 + 4*Bit2):
Bit0
0 - Do not find holes 
1 - Find holes
Bit1
0 - Do not find 2D tubes 
1 - Find 2D tubes
Bit2
0 - Do not find 3D tubes 
1 - Find 3D tubes



","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
221,hm_holedetectiongetholedetails,"Description
Returns details about a specific hole/tube. This must be preceded by a call to
          hm_holedetectionfindholes.
","Inputs

index
The index of the hole to get details for, starting from 0 up to the number of found
            holes minus 1.
General
            hole:0 0 {center x/y/z} {axis x/y/z} {entities ordered lines/nodes} {0 - No washer elements, 1 - Washer elements; Always 0 for geometry holes}
Circular
            hole:0 1 radius {center x/y/z} {axis x/y/z} {entities ordered lines/nodes} {0 - No washer elements, 1 - Washer elements; Always 0 for geometry holes}
Rounded
            hole:0 2 radius1 {center1 x/y/z} radius2 {center2 x/y/z} length {center x/y/z} {axis x/y/z} {entities ordered lines/nodes} {0 - No washer elements, 1 - Washer elements; Always 0 for geometry holes}
Square
            hole:0 3 length {center x/y/z} {axis x/y/z} {entities ordered lines/nodes} {0 - No washer elements, 1 - Washer elements; Always 0 for geometry holes}
Rectangular
            hole:0 4 length width {center x/y/z} {axis x/y/z} {entities ordered lines/nodes} {0 - No washer elements, 1 - Washer elements; Always 0 for geometry holes}
General
            tube:1 0 {center_top x/y/z} {axis_top x/y/z} {rim_entities_top ordered lines/nodes} depth {tube_entities surfaces/shells/solids and face indicies} capped_flag {center_bottom x/y/z} {axis_bottom x/y/z} {rim_entities_bottom ordered lines/nodes}
Circular
            tube:1 1 radius_top {center_top x/y/z}  {axis_top x/y/z} {rim_entities_top ordered lines/nodes} depth {tube_entities surfaces/shells/solids and face indicies} capped_flag radius_bottom {center_bottom x/y/z}  {axis_bottom x/y/z} {rim_entities_bottom ordered lines/nodes}
Rounded
            tube:1 2 radius1_top {center1_top x/y/z} radius2_top {center2_top x/y/z}  length_top {center_top x/y/z}  {axis_top x/y/z}  {rim_entities_top ordered lines/nodes} depth {tube_entities surfaces/shells/solids and face indicies} capped_flag radius1_bottom {center1_bottom x/y/z} radius2_bottom {center2_bottom x/y/z} length_bottom {center_bottom x/y/z}  {axis_bottom x/y/z} {rim_entities_bottom ordered lines/nodes}
Square
            tube:1 3 length_top {center_top x/y/z}  {axis_top x/y/z}  {rim_entities_top ordered lines/nodes} depth {tube_entities surfaces/shells/solids and face indicies} capped_flag length_bottom {center_bottom x/y/z}  {axis_bottom x/y/z}  {rim_entities_bottom ordered lines/nodes} 
Rectangular
            tube:1 4 length_top width_top {center_top x/y/z}  {axis_top x/y/z}  {rim_entities_top ordered lines/nodes} depth {tube_entities surfaces/shells/solids and face indicies} capped_flag length_bottom width_bottom {center_bottom x/y/z}  {axis_bottom x/y/z}  {rim_entities_bottom ordered lines/nodes} 

","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
222,hm_holedetectiongetmatedetails,"Description
Returns details about a specific hole/tube mating 'group'. This must be preceded by a call
        to hm_holedetectionfindmates.
","Inputs

index
The index of the mate to get details for, starting from 0 up to the number of found
            mating groups minus 1. 
The details are returned as follows:
total_length {center_top x/y/z} {center x/y/z} {center_bottom x/y/z}
                number_of_indices {ordered_indices top-to-bottom}
Where total_length is the complete length of the hole/tube chain,
                measured from hole-to-hole and including the depth of any tubes, and center is the
                center of the hole/tube chain which lies on the center-line connecting holes/tubes.
              



","Example
To write out all geometric shell mate details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
hm_holedetectionfindmates
set n [hm_holedetectiongetnumberofmates]
if { $n > 0 } {
puts $holesfile ""Number of mates = $n""
puts $holesfile ""Mate details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetmatedetails $i]""
}
} else {
puts $holesfile ""Holes mates not detected.""
}
hm_holedetectionend
close $holesfile

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
223,hm_holedetectiongetnumberofmates ,"Description
Returns the number of found hole/tube mating 'groups'. This must be preceded by a call to
          hm_holedetectionfindmates.
","Example
To write out all geometric shell mate details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
hm_holedetectionfindmates
set n [hm_holedetectiongetnumberofmates]
if { $n > 0 } {
puts $holesfile ""Number of mates = $n""
puts $holesfile ""Mate details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetmatedetails $i]""
}
} else {
puts $holesfile ""Holes mates not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
224,hm_holedetectionidentifyhole,"Description
Returns the hole index for a given node or line.  This must be preceded by a call to
          hm_holedetectionfindholes.
","
Inputs



id

The ID of the node or line to query.

","Example
To query the hole associated with surface edge 123:
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set h [hm_holedetectionidentifyholes 123]
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
225,hm_holedetectionsetentities,"Description
Adds entities to find holes in. Can be called multiple times with different entity
        types/selections and each call appends to any previous selections. Selections are cleared on
        any call to  hm_holedetectioninit/hm_holedetectionend. 
This must be preceded by a call to hm_holedetectioninit.
","Inputs

entity_type
The type of entities to find holes in. Valid values are comps, surfs, solids and
            elems. If comps are specified, both geometry and FE are considered.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
226,hm_holedetectionsettubeparams,"Description
Defines parameters for finding tubes in both geometry and FE. Multiple calls to this
        command can be made to override or redefine the parameters for each hole shape. Settings are
        cleared on any call to hm_holedetectioninit/hm_holedetectionend. 
This must be preceded by a call to hm_holedetectioninit. 
Only tube_shape and tube_type are mandatory. All
        other parameters are optional and have default values. Parameters can be specified in any
        order.
","Inputs

tube_shape=<>
The shape of tube the parameters are being defined for. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Do not consider general tubes 
1 - Consider general tubes
Bit1
0 - Do not consider circular tubes 
1 - Consider circular tubes
Circular tubes: The distance from any of its nodes to the calculated center must
                  not differ from the calculated radius by more than
                    max_geom_dev_percent. Also, no edge must make an angle
                  greater than  max_smooth_edge_angle with either adjoining
                  edge.
Bit2
0 - Do not consider rounded tubes 
1 - Consider rounded tubes
Rounded tubes: The distance from any of its nodes on the rounded ends to the
                  respective calculated centers must not differ from the calculated radii by more
                  than max_geom_dev_percent. The radii must be within
                    max_geom_dev_percent of each other. Also, no edge must make
                  an angle greater than max_smooth_edge_angle with either
                  adjoining edge. Opposite straight sides must have lengths within
                    max_geom_dev_percent of each other.
Bit3
0 - Do not consider square tubes 
1 - Consider square tubes
Square tubes: At every node except four, no edge must make an angle greater than
                    max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent of 90 degrees. And, all
                  four sides must have lengths within max_geom_dev_percent of
                  their average.
Bit4
0 - Do not consider rectangular tubes 
1 - Consider rectangular tubes
Rectangular tubes: At every node except four, no edge must make an angle greater
                  than max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent of 90 degrees. Opposite
                  pairs of sides must have lengths within max_geom_dev_percent of
                  each other.


tube_type=<>
0 - General 
1 - Open 
2 - Capped on one side
?feature_angle=<>?
Used to identify each connected sequence of feature edges. Specifically a feature edge
            is one whose adjoining faces form an angle greater than this value. Acceptable values
            are [0.0, 180], otherwise closer extreme is used. Default value -30.0.
?max_geom_dev_percent=<>?
See tube_shape. Acceptable values are [0.0, 100.0], otherwise
            closer extreme is used. If less than 0.0, this check is skipped. Default value -1.
?max_height=<>?
The distance between the center of the rims cannot exceed this value. If less than or
            equal to 0.0, this check is skipped. Default value 0.0.
?max_offset_angle=<>?
For FE tubes, neither normal associated with each rim differs by more than this angle
            from primary axis. If less than or equal to 0.0, check is avoided - a value of 45.0 is
            suggested. Default value 0.0.
?max_offset_plane_dev=<>?
Applied to each rim. No node on the perimeter of a tube must exceed this distance from
            the mean plane. If less than or equal to 0.0, this check is skipped. Default value
            0.0.
?max_planar_dim=<>?
Applied to each rim. The maximum planar dimension of tube hole cannot exceed this
            value. If less than or equal to 0.0, this check is skipped. Default value 0.0.
?max_smooth_edge_angle=<>?
See tube_shape. Acceptable values are [0.0, 90.0], otherwise closer
            extreme is used. If less than 0.0, this check is skipped. Default value -1.
?min_cone_angle=<>?
The inward facing normal direction of all faces comprising the wall of the tube must
            make this angle with respect to the primary axis. The primary axis is between the
            centers of the rims. If less than or equal to 0.0, this check is skipped. A value of
            45.0 is recommended. Default value 0.0.
?min_planar_dim=<>?
Applied to each rim. The minimum planar dimension of the tube must exceed this value.
            If less than or equal to 0.0, this check is skipped. Default value 0.0.
?min_height=<>?
The distance between the center of the rims must exceed this value. If less than or
            equal to 0.0, this check is skipped. Default value 0.0.

","Example
To write out all geometric general tube details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsettubeparams tube_shape=31 tube_type=0
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
227,hm_info,"Description
This command returns general information about HyperMesh
        options and paths.
","Inputs

-appinfo info_option
Valid info_option values are:
ALTAIR_HOME: Current installation base directory.
ARCHITECTURE: Current system architecture.
COPYRIGHT: The HyperWorks copyright text.
CURRENTWORKINGDIR: Current working directory.
DISPLAYVERSION: The full application version number (e.g. 10.0b40).
EXECUTABLEDIR: Full directory path of the application’s executable. Same as
                HMBIN_DIR.
EXECUTABLEPATH: Full directory path and file name of the application’s
                executable.
FILEVERSION: The exact version string created by the template variable
                  hmversion during export.
HMBIN_DIR: Full directory path of the application’s executable. Same as
                EXECUTABLE_DIR.
LICENSE_FEATURE: Application’s license feature.
LICENSEVERSION: Application’s license version.
NAME: Get the applications name.
PATCH_NUMBER: The base application patch number (e.g. 101, 102).
SPECIFIEDPATH type: Full path name of the specified type. Valid
                type values are:
altair_lic.dat 
EXTERNALFUNCS_DIR 
EXTERNALREADERS_DIR 
EXTERNALWRITERS_DIR 
hm 
hm_dll_readers 
hm_feinput_readers 
hm_mac 
hm_module 
hm_scripts_dir 
hm_user_profiles 
hm40_translator 
hw_help_dir 
hw_readers 
hw_tcl_common 
hyperbeam 
hypercrash 
mv_solver_writers 
nastran_to_abaqus_converter 
radioss_launchdir 
standard_statistics_template 
tcl_lib 
TEMPLATES_DIR 
tk_lib 
TRANSLATORS_DIR 
wish




SUPPORTEMAIL: The HyperMesh tech
                support email address.
TITLE: Title of the application.
VERSION: The base application version number (e.g. 10.0).
XDISPLAYNAME: The name of the current X display.


analysisfileset
Returns 1 if the global results file is set; 0 otherwise. Identical to
              resultfileset.
cardprev_displayed
Returns 1 if the card previewer is displayed; 0 otherwise.
commandfilename
Full path and file name of the command file from the ""files"" panel. This option cannot
            be used in HyperMesh Batch Mode.
currentcollector type
Returns the current collector ID of the specified type or 0 for no current collector.
            Valid type values are beamsectcol, comp, loadcol, module, multibody, systcol, and
            vectorcol.
currentcomponent
Returns the current component collector ID.
currentinclude
Returns the current include file shortname.
currentfile
Full path and file name of the current HyperMesh database. Identical to hmfilename.
database_empty
Returns 1 if the database is empty; 0 otherwise.
database_modified
Returns 1 if the database has been modified since the last save operation; 0
            otherwise.
elems_cleanup
Returns 1 if the user is in the quality index panel; 0 otherwise.
emptylist entity_type
Returns the list of empty entities of the given entity_type. Valid
              entity_type values are: assems and comps
 entity_types_allowing_undefined
Returns the entity types that are supported as allowing undefined entities.
executing_command
Returns 1 if HyperMesh is currently in
            the process of executing a command; 0 otherwise.
exportfilename
Full path and file name of the export file from the ""files"" panel. This option cannot
            be used in HyperMesh Batch Mode.
exporttemplate
Full path and file name of the export template from the ""files"" panel. This option
            cannot be used in HyperMesh Batch
            Mode.
functionlock
Returns 1 if HyperMesh is currently in
            the function lock mode due to being in a secondary menu like automeshing; 0
            otherwise.
geomstyle
Returns the geometry color mode value set by *settopologydisplaytype.
hmfilename
Full path and file name of the current HyperMesh database. Identical to currentfile.
hyperstudy_running
Returns 1 if HyperStudy is currently in the process of running after being launched
            from HyperMesh; 0 otherwise.
importfilename
Full path and file name of the import file from the ""files"" panel. This option cannot
            be used in HyperMesh Batch Mode.
importtranslator
Full path and file name of the import translator from the ""files"" panel. This option
            cannot be used in HyperMesh Batch
            Mode.
istemplateloaded
Returns 1 if a template file is loaded; 0 otherwise.
lastselectedentity entity_type
Returns the ID of the entity of the specified entity_type that has been selected using
              *createentitypanel. This command must be called immediately after
            the *createentitypanel command. If there are any errors or no entity
            has been selected, the value returned will be 0.
macrofilename
Full path and file name of the macro file. This option cannot be used in HyperMesh Batch Mode.
macromenupage
Returns the page number that the Utility tab is currently set to.
plottingdisplay
Returns 1 if HyperMesh is currently
            involved in a plotting process that makes use of the alternative display list (fill plot
            for hidden lines, contour, etc…); 0 otherwise.
prompting
Returns 1 if HyperMesh is currently
            prompting the user for an immediate response using an Overlay or a Popup; 0
            otherwise.
pushtofront entity_type
Returns the value set by *pushtofront for the specified entity
            type. Currently only supported for tags.
readingfile
Returns 1 if HyperMesh is currently in
            the process of reading an HM file; 0 otherwise.
resultfilename
Full path and file name of the result file.
resultfileset
Returns 1 if the global results file is set; 0 otherwise. Identical to
              analysisfileset.
reviewmode
Returns the review mode value set by *setreviewmode.
somethingtoreject
Returns 1 if the reject operation will have any effect if executed now; 0
            otherwise.
templatecodename
The name reported from the current template’s *codename()
            command.
templatefilename
Full path and file name of the current tempate file.
templateid
The ID reported from the current template’s *codename()
            command.
templatetype
Current template type. This is one of the predefined template types, currently one of
            the following: nastran, abaqus, marc, autodv, hyperopt, pamcrash, patran, ansys, lsdyna,
            dytran, simex, phlex, pdm, masterfile, or none. Some template type names are not
            reported. For example, a madymo template will be reported as an lsdyna template.
tempnam
Full path and file name of a temporary file. The value returned from each call is
            unique.
unusedlist entity_type
Returns the list of unused entities of the given entity_type. The
            list will contain names for named entity types and IDs for all other types. Valid
              entity_type values are curves, contactsurfs, ellipsoids. mats,
            mbjoints, props, and systs.
writeviewcommands
Returns the value set by hm_writeviewcommands or the
            -nowriteviewcommands start-up option.

","Examples
To get the path to the Altair home directory:
set trans_dir [hm_info -appinfo ALTAIR_HOME]
To get the path to the translators directory:
set trans_dir [hm_info -appinfo SPECIFIEDPATH TRANSLATORS_DIR]
To get the current vector collector:
set cur_veccol [hm_info currentcollector vectorcol]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
228,hm_iscurrentmodelprimary,"Description
Query if the current model is primary or secondary.  Returns true if it is primary, and
        false if it is secondary.
","
Inputs
None.","Examples
To query if the current model is primary:
hm_iscurrentmodelprimary
",ErrorsNone.
229,hm_isentitysupportedforaction ,"Description
Determines if a particular entity type is supported for a certain action. A return value of
        0 means it is not supported. A return value of 1 means it is supported.
","Inputs

entity_type
The type of entity to query.
action
The action to query. Currently supported actions are REVIEW, SHIIR and CARDEDIT.

","Examples
To query if nodes are supported for SHIIR:
hm_isentitysupportedforaction nodes SHIIR
To query if components are supported for CARDEDIT:
hm_isentitysupportedforaction comps CARDEDIT
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
230,hm_ispointinsidesolid,"Description
This command returns 1 if the point is found to be inside the solid, -1 if the point is
        outside the solid and 0 if the point is on the solid’s boundary.
","Inputs

x 
y 
z
The (x,y,z) coordinates of the point.
solid_id
The ID of the solid geometry.

","Example
To check whether the point with coordinates 10, 20, 30 is inside the solid with ID 1:
hm_ispointinsidesolid 10 20 30 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
231,hm_issurfacemappable,"Description
Checks whether the given surface can be mapped or not and returns the map shape and
        vertices of the shape.
The output consists of an integer defining the map shape, and a list of vertices for map
        shapes other than circular.
0 - If the shape is not mappable
1 - If the map shape is triangular
2 - If the map shape is rectangular
3 - If the map shape is pentagonal
4 - If the map shape is circular
","
Inputs



surface_id

The ID of the surface to query.

element_size

The element size of interest for the surface.

","Examples
To check if surface 1 is mappable with size 2.5:
hm_issurfacemappable 1 2.5
2 {10 13 12 11}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
232,hm_jobs_addServer,"Description
This command is used add a server. The same information will be saved for later use in the
        server config file.
","Inputs

name
The name of the server to be added.
host
The host/IP of the server. Note that the ""local"" server is always available by
            default.
port
The port number on which the server will communicate.

","Example
To add a server named HWUL with IP 122.0.0.1 and port number 17084:
hm_jobs_addServer HWUL 122.0.0.1 17084
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
233,hm_jobs_canSubmit,"Description
Checks if a job can be submitted on the server without authentication. If a server is
        already authenticated in a session, the next time a job is submitted to the same server by
        the same user authentication is not required. Returns 0 if authentication is required, 1
        otherwise.
This is not applicable for local job submission.
","Inputs

name
The name of the server to query.

","Example
To query server HWUL:
hm_jobs_canSubmit HWUL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
234,hm_jobs_getJobStatus,"Description
Returns the present status of a job on a server. If the job is not available or has been
        terminated, an empty list is returned.
","Inputs

server_job_id
The server job ID returned after submitting a job that is to be queried.

","Example
To query job ID 122366.admin:
hm_jobs_getJobStatus 122366.admin
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
235,hm_jobs_getServerList,"Description
Returns the list of servers added by HyperWorks Desktop.
Note that the ""local"" server is always available by default in the servers list and can
        neither be deleted nor edited.
","Example
To get the list of added servers:
hm_jobs_getServerList
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
236,hm_jobs_removeServer,"Description
This command is used remove a server. The same information will be removed from the server
        config file.
","Inputs


name
The name of the server to be removed.


","Example
To remove the server named HWUL:
hm_jobs_removeServer HWUL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
237,hm_jobs_setServiceProperty,"Description
Sets a service property for the PBS-sensor. This is useful for changing the startup time,
        log info, and so on.
","Inputs


service_name
The name of the service to update.
value
The value to update to.


","Examples
To set a service property to increase the startup time to 240:
hm_jobs_setServiceProperty ""startup_timeout"" 240
To write the debug logs to user
        directory:hm_jobs_setServiceProperty ""debug"" true
To start the PBS-sensor
        implicitly:hm_jobs_setServiceProperty ""implicit_start"" true
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
238,hm_jobs_submitBatchmeshJob,"Description
Submits a BatchMesh job to the server.
Returns the job ID upon successful submission, or null on failure.
Always set the current server on which the job needs to be submitted by using
          hm_jobs_setCurrentServer before submitting a job. To run jobs locally
        using PBS-sensor, set the current server as ""local"". Jobs submitted using the local server
        will run in sequential order.
","Inputs


app_id
The application name to which the job has to be submitted to (for example,
              BatchMesh).
version
The BatchMesh version to use (for example, 2021).
job_name
The name of the job to submit.
input_file
The full name and path of the input file.
output_path
The full path where the output should go.
translator
The name of the BatchMesh translator to use.
criteria_file
The full name and path of the BatchMesh criteria file.
param_file
The full name and path of the BatchMesh param file.
args
Any additional BatchMesh command line arguments.


","Examples
To submit a BatchMesh job on the server:
hm_jobs_submitBatchmeshJob BatchMesh 14.0 ""new_job"" ""C:/temp/input/MASTER.hm"" ""C:/temp/output"" ""hm"" ""C:/temp/input/general_10mm.criteria"" ""C:/temp/input/general_10mm.param"" """"

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
239,hm_jobs_submitOptistructJob,"Description
Submits a OptiStruct job to the server.
Returns the job ID upon successful submission, or null on failure.
Always set the current server on which the job needs to be submitted by using
          hm_jobs_setCurrentServer before submitting a job. To run jobs locally
        using PBS-sensor, set the current server as ""local"". Jobs submitted using the local server
        will run in sequential order. For local job submission, the
          additional_files and zip_flag arguments can be
        passed as null strings, and the master file should hold all the information related to the
        additional files.
","Inputs


app_id
The application name to which the job has to be submitted to (for example, OptiStruct).
version
The OptiStruct version to use (for example, 2021).
job_name
The name of the job to submit.
memory
The memory required for the job to run.
cpu
The number of CPUs to be used.
input_file
The full name and path of the input file.
output_path
The full path where the output should go.
additional_files
A string containing any required additional files that need to be uploaded.
zip_flag
Must be set as ""true"" if any .zip file is passed, ""false""
              otherwise.
args
Any additional OptiStruct command line arguments.


","Examples
To submit a OptiStruct job on the server:
hm_jobs_submitOptistructJob OptiStruct 14.0 ""new_job"" 1000 2 ""C:/temp/input/MASTER.fem"" ""C:/temp/output"" ""{C:/temp/input/slave1.fem} {C:/temp/input/slave2.fem}"" false ""-maxlen 3000""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
240,hm_latestentityid ,"Description
Returns the ID of the last created entity. An option is also available to return the ID of
        previously created entities (up to 99).
","Inputs

entity_type
The type of entity to return the last created ID for.
num (optional)
Queries a specific entity created previously before the last entity. The max is 99.
            Default is 0 (last entity).

","Examples
To get the latest created component:
hm_latestentityid comps
To get the previous latest and first previous 10th created component:
*createmark lines 1 100
#Create two nodes on the line
*nodecreateonlines lines 1 2 0 0
#Get the last created node
set node1 [hm_latestentityid nodes]
#Get the first previously created node
set node2 [hm_latestentityid nodes]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
241,hm_linegetordernodes,"Description
This command returns a list of lists for all input free edges. The first element of each
        list is the ID of the free edge and subsequent elements of that list are the IDs of the
        associated nodes.
For example, the output for two orphan edges of IDs 115822 and 115823 with associated nodes
        8,9 and 10,11 is { 115822 8 9} { 115823 10 11}
","
Inputs



mark_id

The ID of the mark of lines.  Valid values are 1 and 2.
Only free lines are considered.

tolerance

The tolerance to compare association of nodes with respect to an orphan line. In the
            absence of this argument, best associated nodes will be returned.

","Examples
Find nodes for all free lines using a tolerance of 0.5:
*createmark lines 1 all
hm_linegetordernodes 1 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
242,hm_mapelementstoplane ,"Description
This command performs fast unfolding of a given set of connected shell elements onto a
        plane, while minimizing deformation for each element. The result is returned as a list with
        a number of entries equal to the number of nodes in the set of selected elements: { { id1 x1
        y1 } { id2 x2 y2} ... }. Each entry in the list consists of the node ID and mapped node u-v
        coordinates onto the plane.
","Inputs

mark_id
The ID of the mark containing the shell elements to map. Valid values are 1 and 2.
panel_sensitive (optional)
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid values are: 
0 - Use the previous panel (default). 
1 - Use the current panel.

","Example
To get the mapping for all elements to a plane, and to translate the nodes to that
        plane:
*createmark elems 1 all
set node_map2d [ hm_mapelementstoplane 1 ]

# Move each node to its 2D position (flatten the mesh)
foreach node $node_map2d {
# Node id, and calculated u, v on a plane
set node_id [ lindex $node 0 ]
set node_u  [ lindex $node 1 ]
set node_v  [ lindex $node 2 ]

# Current coordinates
set node_x  [ hm_getvalue nodes id=$node_id dataname=globalx]
set node_y  [ hm_getvalue nodes id=$node_id dataname=globaly]
set node_z  [ hm_getvalue nodes id=$node_id dataname=globalz]

# u will be new node's x, v will be new node's y, new z will be 0
set vector_x [ expr $node_u - $node_x ]
set vector_y [ expr $node_v - $node_y ]
set vector_z [ expr - $node_z ]
*createvector 1 $vector_x $vector_y $vector_z

# Calculate translation distance used by 'translatemark' (vector magnitude is ignored there)
set dist [expr sqrt( $vector_x * $vector_x + $vector_y * $vector_y + $vector_z * $vector_z )]

# Select and translate the node
*createmark nodes 1 $node_id
*translatemark nodes 1 1 $dist
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
243,hm_markclear,"Description
This command clears all entity IDs of the passed entity type from the specified mark.
","Inputs

entity_type
The type of entity mark to clear.
mark_id
The ID of the mark. Valid values are 1 and 2.
panel_sensitive (optional)
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid values are: 
0 - Use the previous panel (default). 
1 - Use the current panel.
model_name
The optional model to clear the mark from. If not specified, the current model is
            used.

","Example
To clear the components on mark 2 before creating a new
        mark:hm_markclear comps 2
hm_createmark comps 2 ""advanced"" ""all""
To clear the components on mark 2 before creating a new mark for model
        model-2:hm_markclear comps 2 0 model-2
hm_createmark comps 2 ""by model"" model-2 ""advanced"" ""all""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
244,hm_marklength,"Description
This command returns the number of entities on the specified mark.
","Inputs

entity_type
The type of entity mark to query.
mark_id
The ID of the mark. Valid values are 1 and 2.
panel_sensitive (optional)
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid values are: 
0 - Use the previous panel (default). 
1 - Use the current panel.

","Example
 To count the components on mark 2:
hm_marklength comps 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
245,hm_marksearchmode ,"Description
For entities that have both a name and ID, they can be searched by name first then ID or by
        ID first then name. mode determines this search order for
          *appendmark and *createmark commands.
Valid modes are
0 - Search for names first, then ID (HM default). 
1 - Search for ID first, then name.


This command does not affect hm_appendmark or
          hm_createmark.
","Examples
If the database contains the following components:
name = ""1"", id = 100
name = ""100"", id = 1
The following commands will mark the first component (name =""1""):
hm_marksearchmode 0
*createmark comps 1 1
The following commands will mark the second component (name = ""100""):
hm_marksearchmode 1
*createmark comps 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If mode is invalid, you will get the following error:
hm_marksearchmode: valid values are 0 and 1.
",
246,hm_me_childrenget,"Description
Returns the first-level children module IDs.
","Inputs


id
The ID of the module to query.


","Example
To get the first-level children modules for module 10:
hm_me_childrenget 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
247,hm_me_entitiesget,"Description
Returns the entity IDs of a specific entity type contained in a module.
","Inputs


id
The ID of the module to query.
entity_type
The type of entity to query.


","Example
To get the properties contained in module
        10:hm_me_entitiesget 10 props
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
248,hm_me_modulesgetFromUid ,"Description
Returns the list of module IDs for a given UID.
","Inputs

uid
The module UID to query.

","Example
To get the module IDs from Module_UID1:
hm_me_modulesgetFromUid Module_UID1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
249,hm_me_rootget ,"Description
Returns the session-level root module ID.
","Example
To get the session-level root module ID:
hm_me_rootget
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
250,hm_measureshortestdistance2,"Description
This command measures the shortest distance between a coordinate location and an entity
        selection. The return is a list of values: 
d dx dy dz id x y z
d - The value of the shortest distance 
dx - The x value of the shortest distance, measured relative to the specified local
            system 
dy - The y value of the shortest distance, measured relative to the specified local
            system 
dz - The z value of the shortest distance, measured relative to the specified local
            system 
id1 - ID of the closest entity from the mark 
x1 y1 z1 - Coordinates of the closest location on entity id1


","Inputs

x
The x input coordinate location.
y
The y input coordinate location.
z
The z input coordinate location.
entity_type
The type of entity on the mark. Valid values are nodes, elements, points, lines,
            surfaces and solids.
mark_id
The ID of the mark. Valid values are 1 and 2.
reserved
Reserved for future use. Must be set to 0.
system_id
The ID of a local coordinate system to use for reporting the distance values dx, dy,
            dz, x1, y1 and z1. If the value is specified as 0, the global coordinate system is used
            (default).

","Examples
To get the shortest distance between (0,10,0) and nodes 100-200:
*createmark nodes 1 100-200
hm_measureshortestdistance2 0 10 0 nodes 2 0 0
 To get the shortest distance between (5,0,1) and lines 1-10, with the distance output
        relative to system ID 5:
*createmark lines 1 1-10
hm_measureshortestdistance2 5 0 1 lines 1 0 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
251,hm_modelcheckneedscorrection,"Description
Returns 1 if an auto correction is required for a given check. Checks with auto correction
        should be run and have failed entities before running this command.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.
 If not specified, then all checks in the current profile are considered and if any of
            them require correction and support auto correction, 1 will be returned.

","Examples
To get the correction status for the ""Unused materials"" check:
hm_modelcheckneedscorrection ""Unused Materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
252,hm_modent_getchildren,"Description
Get a mark of hierarchical children entities from a modular entity.
","
Inputs


entity_id
The ID of the modular entity.
mark_id
The ID of the mark to output the children entities.
recursive
0 - Return only the first level of hierarchical children.
1 - Return all levels of hierarchical children.

","Examples
To return all children on mark 1 for subsystem 2:
hm_modent_getchildren 2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
253,hm_modent_getcontententitytypes,"Description
Returns a list of entity types contained in a modular entity.
","
Inputs


entity_type
The modular entity type.  Currently only supported for subsystems.
entity_id
The ID of the modular entity.

","Examples
To return the entity types for subsystem 2:
hm_modent_getcontententitytypes subsystems 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
254,hm_modent_getentityparent,"Description
Returns the hierarchical modular entity parent of a specific entity.
","
Inputs


entity_type
The type of entity to query.
entity_id
The ID of the entity to query.
parent_entity_type
The type of parent entity to query.  Valid values are subsystemconfigurations,
            subsystems, and subsystemsets.

","Examples
To return the parent subsystem of component 1000:
hm_modent_getentityparent comps 1000 subsystems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
255,hm_modent_getmodifiedbyids,"Description
Returns a list of modular entities modified after a representation has been realized.
","
Inputs


entity_type
The modular entity type.  Currently only supported for subsystems.
mark_id
The ID of the mark containing the modular entities.  Valid values are 1 and 2.

","Examples
To get the list of subsystems modified after a representation has been realized:
*modent_addrepresentations subsystems 3 ""crash5"" ""C:/representations/Subsystem1_Crash5mm.k "" ""Ls-Dyna""
*modent_realizerepresentation subsystems 3 ""crash5""
*createmark comps 1 “by id only” 1 2 3
*modent_addcontentsbymark subsystems 3 comps 1 

hm_modent_getmodifiedbyids subsystems 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
256,hm_morph_getdomainangle ,"Description
 Returns the angle between two specified edge domains. Optional argument allows the user to
        input a normal vector to be used to measure the angle.
","Inputs

domainId1
The ID of one edge domain.
domainId2
The ID of a different edge domain.
x y z(optional)
Normal vector which will be used to calculate the angle between the domains. Default
            vector is normal to the end points of the two domains.

","Examples
To find the angle between domains with ID 2 and 3:
hm_morph_getdomainangle 2 3
To find the angle between two domains with ID 2 and 3 and measured normal to a vector that
        runs 1.0 in the x direction, 0.5 in the y direction, and 0.0 in the z direction:
hm_morph_getdomainangle 2 3 1.0 0.5 0.0
Only the angle from one end to the other end, using the connecting node as the vertex, is
        measured. Curvature is ignored.
","Errors
None.
"
257,hm_morph_getdomainlength,"Description
Returns the length of a specified edge domain. Optional argument allows the user to input a
        vector along which to measure the length.
","Inputs

domainId
The ID of an edge domain.
x y z (optional)
Vector along which the length will be measured. Default vector is from one end of the
            domain towards the other.

","Examples
To get the length of a domain with ID 2:
hm_morph_getdomainlength 2
To get the length of a domain with ID 2 and measured along a vector that runs 1.0 in the x
        direction, 0.5 in the y direction, and 0.0 in the z direction:
hm_morph_getdomainlength 2 1.0 0.5 0.0
Only the length from end to end is measured. Curvature is ignored.
","Errors
None.
"
258,hm_morph_gethandledomains ,"Description
Returns the domain IDs for the specified handle.
","Inputs

handle_id
The ID of the handle to query.

","Example
To get the domain IDs for a handle with ID 2:
hm_morph_gethandledomains 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
259,hm_morph_getinfo ,"Description
Returns certain options/values from HyperMorph.
","Inputs

option
There are different options available. Each requires its own format:
domaincount
domain_type
domain_type
The type of domain to count. Valid values are:
0 - All domains 
1 - 1D domains 
2 - 2D domains 
3 - 3D domains 
4 - Global domains 
5 - Edge domains 
7 - General domains


excludedelements list
Returns a list of all excluded element IDs.
excludedelements mark
mark_id
The query will return nothing, but all excluded elements will be placed on
                        the specified mark_id.
parameter
parameter_name
parameter_name
The parameter to query. See the documentation for
                                *morphupdateparameter and
                                *morphupdateparameterstring for a list of supported
                              values.


testlimits
elem_type test_id
The query will return four arguments corresponding to the information
                        stored for the element checks used by *morphshapesmooth.
                        The first will be either ""active"" or ""inactive"" denoting the status of the
                        element test. The next three will be real numbers denoting the limits for
                        the warning, error, and invalid elements criteria.
elem_type
0 - trias 
1 - quads 
2 - tetras 
3 - pyras 
4 - pentas 
5 - hexas
test_id
0 - aspect ratio 
1 - skew 
2 - minimum angle 
3 - maximum angle 
4 - warpage 
5 - tetra collapse 
6 - jacobian


undolist current
Returns the current position in the undo/redo list.
undolist maximum
Returns the length of the undo/redo list. 





","Examples
To obtain the status and limits for the quad element Jacobian test:
hm_morph_getinfo testlimits 1 6
To get the number of 2D domains:
hm_morph_getinfo domaincount 2
To get the facecolor setting:
hm_morph_getinfo parameter facecolor
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
260,hm_morph_getmvoledgenodes,"Description
Returns the IDs of the nodes along a specified morph volume edge.
","Inputs

edge_id
The ID of the morph volume edge. 

","Example
To find the node IDs for morph volume edge 5:
hm_morph_getmvoledgenodes 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
261,hm_morph_getnodehandle ,"Description
Returns the handle ID for the specified node if a handle exists at that node.
","Inputs

node_id
The ID of the node to query.

","Example
To get the handle ID for a node with ID 2:
hm_morph_getnodehandle 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
262,hm_pathmanager,"Description
Returns all search paths, and runs a specified procedure with each path (including
        filename) as input.
","Inputs

filename
The name of the file targeted by the procedure. The command searches for this file in
            the following directories (in the order listed): 
The paths specified in the environment variable HW_CONFIG_PATH 
The user's home directory 
The current working directory


procname
The Tcl procedure to run. This is run for each returned path. The
            full path and filename are passed as input to the procedure.

","Example
To run the ::showpath Tcl procedure (which displays the file path of a
        specific file) on all paths for the file called setup.dat:
hm_pathmanager setup.dat ::showpath
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
263,hm_projectpointtosegment,"Description
Returns the closest point to a specific point on a segment.
","Inputs

px, py, pz
Defines a point with three coordinate values.
sx1, sy1, sz1
The segment start point.
sx2, sy2, sz2
The segment end point.

","Example
hm_projectpointtosegment 0.0 0.0 0.0 -1.0 2.0 0.0 1.0 2.0 0.0
Result: 0.0  2.0 0.0
","Errors
None.
"
264,hm_proximityend,"Description
Clears the proximity calculation data and memory. 
This must be preceded by a call to hm_proximityinit.
","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
None.
",
265,hm_proximitygetcomponentelementpaircount ,"Description
Returns the number of element pairs for a specific component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
266,hm_proximitygetcomponentpaircount ,"Description
Returns the number of proximity component pairs. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
267,hm_proximityinit ,"Description
Checks the proximity between elements or components, and stores the results internally.
        Other APIs can be used to query the results. 
This must precede any calls to other hm_proximityget*/hm_proximitymark*
        APIs, and must be followed by a call to hm_proximityend.
","Inputs

entity_type
The type of entity to query. Valid values are elements and components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
max_distance
The maximum distance beyond which proximity is not reported.
mode
1 - Global proximity (default behavior if not specified) 
2 - Proximity between components (entity_type should be components
            only) 
3 - Self proximity within component (entity_type should be
            components only)
check_side
1 - Check both sides of the elements 
2 - Check the element normal side only 
3 - Check 'outward volume' side (default behavior if not specified) 
4 - check 'inward volume' side
proximity_scheme
0 - Checks basic proximity along a ray from the element center along the normal
            direction.
1 - Checks comprehensive proximity.  Reports any proximity within an imaginary
            offsetted volume of the element (default behaviour if not specified).
proximity_by_edge
0 - Ignores proximity for nearby edges (default behaviour if not specified).
1 - Considers proximity for nearby edges.
min_angle_limit
If the angle between the proximate element pairs is less than this value, such pairs
            are not reported.
max_angle_limit
If the angle between the proximate element pairs is greater than this value, such
            pairs are not reported.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
268,hm_proximitymarkcomponentallelementpairs ,"Description
Marks the element pairs for a specific component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.
mark_id1
The output mark on which the elements for the first component are placed.
mark_id2
 The output mark on which the elements for the second component are placed. 

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
269,hm_proximitymarktargetproximityelements,"Description
Marks all the target elements within proximity to the given mark.
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","
Inputs



mark_id

The ID of the mark to which the elements will be placed.  Valid values are 1 and
            2.

","Examples
To output the target proximity elements to mark 1 and highlight them:
*createmark comps 1 all 
hm_proximityinit comps 1 2.5
hm_proximitymarktargetproximityelements 1
hm_highlightmark elems 1 h
hm_proximityend
",
270,hm_runcommandfile ,"Description
This command can be used to execute a HyperMesh command file
          (*.cmf) from within aTcl script. In the case
        there is an error in one of the lines of the command file, the command execution continues
        without prompting if the user wants to continue.
","Inputs

filename
The full path and filename of the command file. Note that forward slashes (/) are
            required in the path and filename, the name must be wrapped in curly braces {}, or the
            backwards slash (\) must be escaped. Paths with spaces must be enclosed in quotes or
            curly braces. These are Tclrequirements.
prompt (optional)
Argument specifying whether to ignore the *answer command in the
            command file (default, 0) or to honor the *answer command when
            present (1).

","Examples
To run the command file command1.cmf in folder
          C:/solidedit:
hm_runcommandfile C:/solidedit/command1.cmf
or
hm_runcommandfile {C:\solidedit\command1.cmf}
or
hm_runcommandfile C:\\solidedit\\command1.
To run the command file command1.cmf in folder ""C:/solid
          edit:""
hm_runcommandfile ""C:/solid edit/command1.cmf""
or
hm_runcommandfile {C:/solid edit/command1.cmf}
","Errors
None.
"
271,hm_setdieattribute ,"Description
Sets the die attribute for an entity. 
","Inputs

die_attribute
Valid values are: 
drawbead 
drawbar
entity_id
The ID of the entity.

","Example
To set the die attribute for the drawbar with ID 100:
hm_setdieattribute drawbar 100
","Errors
None.
"
272,hm_setmodelcheckcorrectionstatus,"Description
Sets the applied status for the specified Model Check correction display name.
","Inputs

display_name
The check display name.
display_name_correction
The correction display name.
status


0 - Not applied
1 - Applied
2 - Partially applied



","Example
To set the applied status for the check named ""Unused Materials"" and correction named
        ""Delete Unused Materials"" to applied (1):
hm_setmodelcheckcorrectionstatus ""Unused Materials"" ""Delete Unused Materials"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
273,hm_setsolver ,"Description
Sets theHyperMesh solver interface name in order to access
        entity information available for that solver.
","Inputs

name
Solver name keyword: 
abaqus 
ansys 
autodv 
dytran 
hyperopt 
ideas 
lsdyna 
marc 
masterfile 
moldflow 
nastran 
optistruct
pamcrash 
pamcrash2g 
patran 
pdm 
phlex 
simex



","Examples
Suppose LS-DYNA solver template is actually loaded here:
set loadedsolver [ hm_getsolver ];
Getting attributes for OptiStruct:
hm_setsolver optistruct;
set opt_thickness [ hm_getvalue comps id=3 dataname=PSHELL_T]; 
Resetting back to the original solver name:
hm_setsolver $loadedsolver; 
Note: This command does not actually load the solver template. It is intended only to
        temporarily switch solver type, get attribute information, and reset the solver name back to
        the original name.This operation is typically required during conversion between
        solvers.
","Errors
None.
"
274,hm_tableappend ,"Description
Appends the contents of a HyperMesh table to another HyperMesh table of the same entity type. Creates a destination table if
        it does not exist.
","Inputs

table1
Destination table.
table2
TCL_OK(0) if successful. TCL_ERROR(1) otherwise

","Example
To combine the content of two HyperMesh tables:
# Creating 2 tables
*createmark comp 1 1
hm_marktotable comp 1 t1
*createmark comp 1 2
hm_marktotable comp 1 t2
# Appending t2 to t1
hm_tableappend t1 t2       
# T1 now contains comp 1 and 2.

","Errors
None.
"
275,hm_tableclearall ,"Description
Clear all tables (all memory is freed). 
","Errors
None.
",,
276,hm_tabledifference ,"Description
Finds the difference of two HyperMesh tables of the same entity
        type (subtracts the contents of the second table from the first table) and places the result
        in the first table.
","Inputs

table1
First table.
table2
Second table. 
TCL_OK(0) if successful. TCL_ERROR(1) otherwise

","Example
This command can be used to find entities unique for a table: 
# Creating 2 tables
*createmark comp 1 1 2
hm_marktotable comp 1 t12
*createmark comp 1 2
hm_marktotable comp 1 t2
hm_tabledifference t12 t2;  
# T12 contains only comp 1 now

","Errors
None.
"
277,hm_tablelist ,"Description
Use hm_tableclear or hm_tableclearall to remove the
        table from the list. When the current model is deleted, or a new model is loaded, all tables
        are cleared. 
","Errors
None.
",,
278,hm_tabletomark ,"Description
This command appends the entity IDs stored in table_name to mark
          mark_id. Valid mark_ids are 1 and 2. 
The ?panel_sensitive? option can be used when multiple panel levels have
        been pushed, either using the shortcut function keys, or the hm_pushpanel
        command. This option determines whether to use the current panel or the previous panel for
        the operation. This option is relevant only when the mark has been created from a panel
        entity selector under the above conditions. Valid panel_sensitive options
        are: 
0 - Use the previous panel (default). 
1 - Use the current panel. 
Tables are not stored within a HyperMesh database
          (.hm file). When the current model is deleted or a new model is
        loaded, all tables are cleared. 
If a table contains an entity that is subsequently deleted, the entity is removed from the
        table. Renumbering does not modify the entity IDs stored in the table.
","Example
To put the elements from table elem_table on element mark 1:
hm_tabletomark elem_table 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If table_name does not exist, you will get the following error:
hm_marktotable: the table <table_name> was not found.
If mark_id is invalid, you will get the following error:
hm_marktotable: invalid mark mask <mark_id> specified, must be either 1 or 2.
If mark_id is empty, and ?force? is not specified or
        is specified as 0:
hm_marktotable: no entities were found on the mark.

",
279,hm_undefinedmatchingcriteria,"Description
Returns the supported undefined matching criteria for a given entity type (name, id or
        none).
","Inputs

entity_type
The type of entity to query.  All entity types are valid.

","Example
To get the undefined matching type for components:
hm_undefinedmatchingcriteria components
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
280,hm_wadlinescheckentities ,"Description
Checks front and rear entities for validity. This must be preceded by a call to
          hm_wadlinessetentities. 
If entities are valid, 0 is returned. If any front entities are in the rear group, or vice
        versa, non-zero is returned.
","Example
To setup and check WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
if {[hm_wadlinescheckentities] == 0} {
  puts ""Entities are valid.""
}
hm_wadlinesend
","Errors
None.
",
281,hm_wadlinesgetadulttestzone,"Description
Returns the coordinates of the adult test zone boundary.
This must be run after hm_wadlinesinit and setting all necessary options
        with hm_wadlinessetparameters.
","
Inputs

None.
","Examples
To setup and extract the adult test zone:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
set zone_vertices [hm_wadlinesgetadulttestzone]
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
282,hm_wadlinesgetdebugtracelines,"Description
Creates the debug lines used to create different types of reference lines, and returns the
        coordinates.
","
Inputs


line_type
The type of reference line to create the debug lines for:
0 - Bonnet leading edge reference line (BLERL)
1 - Bonnet rear reference line (BRRL)
2 - Left side reference line (LSRL)
3 - Right side reference line (RSRL)
4 - Upper bumper reference line (UBRL)
5 - Lower bumper reference line (LBRL)
8 - Internal bumper reference line (IBRL)
offset_distance
If specified, then it will create debug trace lines for respective offset reference
            lines.  For example, with offset distance of 82.5mm offset lines will be constructed for
            the left side reference offset line with 82.5mm distance from LSRL.
protocol_method
0 - Euro-NCAP
1 - Homologation
2 - GTR/ECER
3 - UN-R127
4 - CNCAP

","Examples
To get the debug trace lines for the left side reference
        line:hm_wadlinesgetdebugtracelines 2
To get the debug trace lines for the offset bonnet rear reference line with a distance of
        82.5:hm_wadlinesgetdebugtracelines 1 82.5
To get the debug trace lines for the offset bonnet rear reference line with a distance of
        82.5 for the GTR protocol
        method:hm_wadlinesgetdebugtracelines 1 82.5 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
283,hm_wadlinesgetgridpointsleg,"Description
Returns grid points for either upper or lower leg impact analysis. The output is a series
        of four numbers for each grid point. The first number will be the column value, such as -2.
        The next three numbers will be the x, y, and z values of the grid point. 
It will use the front entities set using hm_wadlinessetentities and the
          corner_angle set with hm_wadlinessetparameters to
        determine the ""Corner of Bumper."" If hm_wadlinessetbumper has been used,
        the outermost ends of those entities will be determined. All points for the internal bumper
        reference line will fit laterally between either the ""Corner of Bumper"" or the outermost
        ends of the bumper entities, whichever is larger. This is the ""Edge of Bumper Test Zone."" 
For version 7.0, the front reference line will be used to determine upper leg grid points
        and the upper bumper reference line will be used to determine lower leg grid points. 
For version 8.0, a WAD line of a specified distance will be used for the upper leg grid
        points and the internal bumper reference line will be used to determine the lower leg grid
        points. Note that the hm_wadlinesgetinternalbumperline API does not need
        to be called prior to calling this API. If the internal bumper reference line has not been
        generated it will automatically be calculated and used. 
Note that not all options below are used for every version and upper/lower option.
","Inputs

height
0 - Lower leg 
1 - Upper leg
spacing
The lateral distance, starting from the vehicle center line, at which the points will
            be placed.
version
Used for Euro NCAP protocol, 7.0, 8.0 or 8.2.
end_gap
For the lower leg (height = 0), if the distance between the last grid point placed at
            the given spacing value and the Edge of Bumper Test Zone is greater than
              end_gap, an additional grid point is placed at
              end_gap distance away from the last grid point. For the upper leg
              (height = 1), any grid points placed within the
              end_gap distance of the Edge of Bumper Test Zone are removed.
            Default 50.0.
clearance
Only used for the upper leg (height = 1) for version 8.0. If the distance between the
            Edge of Bumper Test Zone and the last grid point is greater than the clearance, an
            additional grid point is placed at end_gap distance inboard of the
            end of the Edge of Bumper Test Zone. Default 75.0.
height_option
For the upper leg (height = 1), place the distance of the WAD line
            to be used in this field. Default 775.0. 
For the lower leg (height = 0), place the maximum height of the
            internal bumper reference line in this field. Default 520.0.
max_depth
For the lower leg (height = 0), sets the maximum depth of the
            internal bumper reference line (the maximum rearward distance a point can be from the
            first point of contact and still be used to find the height of the bumper entities)
            (default 10.0). This is unused for the upper leg (height = 1).
method
The method to use for measuring. If left blank and
              hm_wadlinessetoptions has been used to set the protocol_method,
            that value is used. 
0 - Euro NCAP (default if not specified) 
1 - Homologation 
2 - ECER 
3 - UN-R127 for corners, Euro NCAP elsewhere

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 82.5 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 182.0 -1.0 0.0 0.0 0.0 -1.0 0.0
hm_createmark components 1 ""by id"" ""100000199 100000200 290000007 410000016 411000016 420000004 420000005 420000006 420000007 420000008 420000009 420000010 420000011 420000012 420000013 420000014 420000015 420000016 420000019 420000020""
hm_createmark components 2 ""by id"" ""100000003 100000010 100000022 100000113""
hm_wadlinessetentities comps 1 comps 2
hm_createmark components 1 ""by id"" ""407000001 407000002""
hm_wadlinessetbumper comps 1
hm_wadlinesgetgridpointsleg 0 100.0 7.0
hm_wadlinesgetgridpointsleg 1 100.0 7.0
hm_wadlinesgetgridpointsleg 0 100.0 8.0
hm_wadlinesgetgridpointsleg 1 100.0 8.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
284,hm_wadlinesgetleggridline,"Description
Returns a series of three doubles denoting the points for the line calculated by the
        previous call to hm_wadlinesgetgridpointsleg. This API must be called
        after a call to hm_wadlinesgetgridpointsleg. The line that is returned is
        based on the arguments passed in to hm_wadlinesgetgridpointsleg: 
height=0, version=7.0: Upper Bumper Reference Line 
height=0, version=8.0: Internal Bumper Reference Line 
height=1, version=7.0: Front Reference Line 
height=1, version=8.0: WAD Line 
These lines may have extra points added to them due to the requirements of the grid point
        marking standards compared to lines extracted using the
          hm_wadlinesgetreferenceline API. The extra points will ensure that any
        type of line (linear or smooth) will pass through all of the grid points. Thus, if you are
        drawing the markup lines for the grid points, use this API instead of the reference line API
        to get the lines. 
Note than any line stored after one call to the
          hm_wadlinesgetgridpointsleg API is overwritten by subsequent calls to
        the hm_wadlinesgetgridpointsleg API.
","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 82.5 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 182.0 -1.0 0.0 0.0 0.0 -1.0 0.0
hm_createmark components 1 ""by id"" ""100000199 100000200 290000007 410000016 411000016 420000004 420000005 420000006 420000007 420000008 420000009 420000010 420000011 420000012 420000013 420000014 420000015 420000016 420000019 420000020""
hm_createmark components 2 ""by id"" ""100000003 100000010 100000022 100000113""
hm_wadlinessetentities comps 1 comps 2
hm_createmark components 1 ""by id"" ""407000001 407000002""
hm_wadlinessetbumper comps 1
hm_wadlinesgetgridpointsleg 0 100.0 7.0
hm_wadlinesgetleggridline
hm_wadlinesgetgridpointsleg 1 100.0 7.0
hm_wadlinesgetleggridline
hm_wadlinesgetgridpointsleg 0 100.0 8.0
hm_wadlinesgetleggridline
hm_wadlinesgetgridpointsleg 1 100.0 8.0
hm_wadlinesgetleggridline
hm_wadlinesend

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
285,hm_wadlinesgetsectionmax ,"Description
Returns the most outward intercept of a cross section of the model as measured in a given
        direction. A plane, located at the given origin and with the given normal, is cut through
        the model and points are generated where all elements and surface facet edges are bisected
        by the plane. The dot product of each point and the given direction is used to determine
        which point is the maximum point lying in the plane. 
This is intended to assist in the positioning of impact devices.
","Inputs

origin_x, origin_y, origin_z
Define the origin of the plane used to cut the cross section.
plane_x, plane_y, plane_z
Define the normal vector of the plane used to cut the cross section.
dir_x, dir_y, dir_z
Define the vector used to evaluate the each point on the cross section.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetsectionmax 0 0 0 1 0 0 0 1 0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
286,hm_wadlinesgetwadpointtapeline,"Description
Returns coordinate data defining a line made by the measuring tape running from the ground
        to the specified WAD point along the vehicle. The data will be returned as a list of
        doubles. Every three doubles are the X, Y, and Z coordinates of a point along the line. The
        line runs from the ground to the specified WAD point.
","
Inputs



lateral_location

The lateral location for the tape line, using the centerline of the vehicle as the
            origin. The location given must be a multiple of the spacing parameter set with
              hm_wadlinessetparameters. For example, if the value of spacing is
            100.0, the values of the lateral_location must be 0.0, 100.0, -100.0, 200.0, -200.0,
            300.0, etc...

distance

The distance from ground level to a WAD point, as measured along the vehicle.

","Examples
To setup and extract WAD point tape line data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadpointtapeline -700.0 1700.0
hm_wadlinesgetwadpointtapeline -600.0 1700.0
hm_wadlinesgetwadpointtapeline -500.0 1700.0
hm_wadlinesgetwadpointtapeline -400.0 1700.0
hm_wadlinesgetwadpointtapeline -300.0 1700.0
hm_wadlinesgetwadpointtapeline -200.0 1700.0
hm_wadlinesgetwadpointtapeline -100.0 1700.0
hm_wadlinesgetwadpointtapeline    0.0 1700.0
hm_wadlinesgetwadpointtapeline  100.0 1700.0
hm_wadlinesgetwadpointtapeline  200.0 1700.0
hm_wadlinesgetwadpointtapeline  300.0 1700.0
hm_wadlinesgetwadpointtapeline  400.0 1700.0
hm_wadlinesgetwadpointtapeline  500.0 1700.0
hm_wadlinesgetwadpointtapeline  600.0 1700.0
hm_wadlinesgetwadpointtapeline  700.0 1700.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
287,hm_wadlinesispointintestzone,"Description
Returns whether a point is inside a test zone by taking in the coordinates of the zone
        boundary returned byhm_wadlinesgetadulttestzone and
          hm_wadlinesgetchildtestzone, along with the impact direction of the
        impact point. The impact point and zone boundary are projected to a plane perpendicular to
        the impact direction, then tested to find if the projection of the impact point is within
        the polygon defined by the zone boundary.
Num_pts should always be provided before the points option
","
Inputs


normal
The normal direction x/y/z of the plane to which the zone boundary and test point is
            projected. This is expected to be along the impact direction of the impact point.
num_pts
The number of points defining the zone boundary.  Must be provided before
              points.
points
The ordered x/y/z coordinate values of all points of the zone boundary.
testpoint
The x/y/z coordinates of the impact point to be tested.
tolerance
Test points that are within this tolerance to the zone boundary are also returned as
            inside the zone boundary. Default 1e-6.

","Examples
To test if design point 38 is inside a zone boundary:
set id 38
set pos [hm_getvalue designpoint id=$id dataname=position]
hm_wadlinesispointintestzone testpoint {*}$pos normal 0 0 1 num_pts 10 points 1343.514343661 709.91761797527 973.43251742578 1334.7036682323 703.07456401521 973.15886027621 1327.8482379749 697.4142871779 972.93366355648 1323.86674249 694.00118686161 972.79787178914 1310.125533079 681.68252694578 972.30776823337 1309.4710911285 681.07217688483 972.28348517521 1301.5068502671 673.437787072 971.97974746194 1297.3418689169 669.34475639184 971.81690435206 1293.2547572113 665.2922768409 971.65567458753 1289.222029365 661.21716017109 971.49354419
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
288,hm_wadlinessetfrontentitiesforcollision,"Description
Sets the front entities to be used to create the bonnet rear reference line.
BRRL spheres are rolled on the windscreen to collide with the front entities of the
        vehicle. Points of contact of these spheres with the front entities are used to construct
        the BRRL.
This API must be used after initializing the wadlines analysis using
          hm_wadlinesinit.
","
Inputs


entity_type
The type of entities being set for collision.  Valid values are comps.
mark_id
The ID of the mark containing the entities set for collision.  Valid values are 1 and
            2.

","Examples
To set the front entities for collision to comps 102 and 103:
*createmark comps 1 102 103
hm_wadlinessetfrontentitiesforcollision comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
289,hm_wadlinessethood,"Description
Sets the entities for the hood used to create the reference line.
This API must be used after initializing the wadlines analysis using
          hm_wadlinesinit.
","
Inputs


entity_type
The type of entities being set for the hood.  Valid values are comps, surfs and
            elems.
mark_id
The ID of the mark containing the hood entities.  Valid values are 1 and 2.

","Examples
To set the hood entities to comps 102 and 103:
*createmark comps 1 102 103
hm_wadlinessethood comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
290,hm_wadlinessetparameters,"Description
Sets basic parameters for a WAD lines analysis.
","Inputs

side_angle
The angle used to determine the side reference line (default 45.0).
front_angle
The angle used to determine the front reference line (default 50.0).
spacing
The distance between section cuts used to determine the WAD lines and reference lines
            (default 100.0).
rear_reference_radius
The size of the ball rolled along the windshield to find the rear reference line
            (default 100.0).
reference_resolution
The spacing between cross-sections used to determine the reference lines (default
            spacing/2).
upper_bumper_angle
The angle used to determine the upper bumper reference line (default 20.0).
lower_bumper_angle
The angle used to determine the lower bumper reference line (default 25.0).
corner_angle
The angle used to determine the corner reference lines (default 60.0).

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
291,hm_wadlinessetwindscreen,"Description
Sets the rear entities (windshield) to be used to create the bonnet rear reference
        line.
BRRL spheres are rolled on the windscreen to collide with the front entities of the
        vehicle. Points of contact of these spheres with the front entities are used to construct
        the BRRL.
This API must be used after initializing the wadlines analysis using
          hm_wadlinesinit.
","
Inputs


entity_type
The type of entities being set for the windscreen.  Valid values are comps.
mark_id
The ID of the mark containing the entities for the windscreen.  Valid values are 1 and
            2.

Comment.
","Examples
Example:
To set the windscreen entities to comps 102 and 103:
*createmark comps 1 102 103
hm_wadlinessetwindscreen comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
292,hm_writemeshcontroltemplate,"Description
Writes out the Mesh Controls template file. This is an XML formatted file. This contains
        all of the mesh control information, except for the entity selection.
","Inputs

filename
The full name and path of the file to write.

","Example
To write out the file to C:/temp/meshcontrol.xml:
hm_writemeshcontroltemplate C:/temp/meshcontrol.xml
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
293,hm_xformnodetolocal,"Description
This command returns the coordinates of node_id relative to the
        coordinate system syst_id. 
This is useful for finding distances relative to local coordinate systems.
","Inputs

node_id
The coordinates of node_id relative to the coordinate system
              syst_id are returned.
syst_id
If syst_id is a rectangular system, x, y, and z are returned. If
              syst_id is a cylindrical system, r, t, and z are returned. If
              syst_id is a spherical system, r, t, and p are returned.
              syst_id of 0 returns the global x, y, and z coordinates.

","Example
To get the coordinates of node ID 50 relative to system ID 5:
hm_xformnodetolocal 50 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If node_id does not exist, you will get the following error:
        Node node_id could not be found.
If syst_id does not exist, you will get the following error:
        System syst_id could not be found.
"
294,hm_xformvectoratpointtolocal,"Description
This command returns the three local components of a globally defined vector.
This command can be used in conjunction with
          hm_xformvectoratpointtoglobal to convert a vector from one coordinate
        system to another.
","Inputs

x y z
The x, y, and z values should be given relative to the global coordinate system.
syst_id
The local system to transform into is given by syst_id. If
              syst_id is a rectangular system, x, y, and z are returned. If
              syst_id is a cylindrical system, r, t, and z are returned. If
              syst_id is a spherical system, r, t, and p are returned.
node_id
The base of the vector is specified by node_id which must be a node
            in the current model.

","Example
To convert the vector (1,0,0) at base node 10 defined in rectangular system ID 5 to the
        cylindrical system ID 8:
set g_xyz [hm_xformvectoratpointtoglobal 1 0 0 5 10]
set g_x [lindex $g_xyz 0]
set g_y [lindex $g_xyz 1]
set g_z [lindex $g_xyz 2]
set l_rtz [hm_xformvectoratpointtolocal $g_x $g_y $g_z 8 10]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If syst_id does not exist, you will get the following error:
        System syst_id could not be found.
If node_id does not exist, you will get the following error:
        Node node_id could not be found.
"
295,hm_xpointvectorlocal,"Description
Transforms a vector into a local system and returns the x value of the transformed vector.
      
","Inputs

system_id 
The ID of the system into which the vector should be transformed.
x y z
The coordinates of the point where the vector is located in the global system. 
vx vy vz
The components of the vector to be transformed.

","Errors
None.
",
296,hm_ypointvectorlocal,"Description
Transforms a vector into a local system and returns the y value of the transformed vector. 
","Inputs

system_id
The ID of the system into which the vector should be transformed.
x y z
The coordinates of the point where the vector is located in the global system. 
vx vy vz
The components of the vector to be transformed.

","Errors
None.
",
297,hm_zpointvectorlocal,"Description
Transforms a vector into a local system and returns the z value of the transformed vector. 
","Inputs

system_id
The ID of the system into which the vector should be transformed.
x y z
The coordinates of the point where the vector is located in the global system. 
vx vy vz
The components of the vector to be transformed.

","Errors
None.
",
298,hf_getautotippingangles,"Description
This command returns the tipping angles and rotation plane of auto-tipping for selected
        elements.
","Inputs

mark_id
Selection mark, which can be 1 or 2.
symmetric_pane_normal_vector_id
A vector ID if the selected mesh is half of a symmetrical part.

","Example
*createmark elements 1 all
set returnValue [hf_getautotippingangles 1 0]
set angle [ lindex $ returnValue 0 ]
set rotationPlaneX [ lindex $ returnValue 1 ]
set rotationPlaneY [ lindex $ returnValue 2 ]
set rotationPlaneZ [ lindex $ returnValue 3 ]
set rotationAnlongX [ lindex $ returnValue 4 ]
set rotationAnlongY [ lindex $ returnValue 5 ]
set rotationAnlongZ [ lindex $ returnValue 6 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
299,hm_allentitiesinfo,"Inputs

entityType
Type of entity.

","Example
For the model on the left (assemblies denoted with folders, components with sheets),
        commands hm_allentities assemblies and hm_allentities
          components would generate the respective outputs on the right.

Figure 1. 

{base 1 1 1 3} {attachments 2 1 1 3} {wheel 3 0 0 3} {head 4 1 1 3} {empty 5 0 0 3}
{Part1 1 1 1 7 -1 -1} {Part2 4 1 1 10 -1 -1} {Part4 7 1 1 13 -1 -1} {Part3 9 1 1 15 -1 -1}	
",,
300,hm_assemlist,"Description
Returns the hierarchical structure of assemblies, and optionally standalone components and
        multibodies, along with properties, materials, groups and beamsection collectors. 
In the same way that a directory list is made up of separated sub-directories, the returned
        list consists of separated entity names. 
If the output is not requested to include the entity type, any path that ends in the
        separator character represents an empty assembly.
","Inputs

separator
The character used to separate the assemblies in the list.
full_listing
0 - Do not include components and multibodies not in assemblies, nor any materials,
            properties, beamsectcols and groups. 
1 - Include components and multibodies not in assemblies, and all materials,
            properties, beamsectcols and groups. 
This is optional. If not specified, a value of 0 is assumed.
append_entity_type
0 - Do not append the entity type to the entity output. 
1 - Append the entity type to the entity output.
This is optional. If not specified, a value of 0 is assumed. If specified as 1,
              type_separator is mandatory.
type_separator
The character used to separate the entity type names in the list. 
Only used if append_entity_type is 1. 
For example: With ‘/’ as separator and ‘:’ as type_separator: the
            output might look like:

 /assemblies:assem1/assemblies:subassem1/components:comp1


","Example
To find the hierarchy for the following structure of assemblies and components, using a
        separator of /:
hm_assemlist /
/wheel/base/Part1 /wheel/attachments/Part2 /head/Part3 /empty/
For the same example, include the full listing:
hm_assemlist / 1
/wheel/base/Part1 /wheel/attachments/Part2 /head/Part3 /empty/ /Part4
For the same example, include the full listing as well as the entity types, with a
        separator of %
hm_assemlist / 1 1 %
/assemblies%wheel/assemblies%base/components%Part1
        /assemblies%wheel/assemblies%attachments/components%Part2 /assemblies%head/components%Part3
        /assemblies%empty /components%Part4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
301,hm_attributeentitytype,"Description
Returns the entity type number of an entity attribute on an entity for the current
        template. If the attribute does not exist on the entity, or is not an attribute from the
        current template, an error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the attribute entity type number of the entity attribute with name LSD_CID on
        property 1 for the LS-DYNA template:
hm_attributeentitytype props 1 LSD_CID -byid
To get the attribute entity type number of the entity attribute with ID 412 on property 1
        for the LS-DYNA template:
hm_attributeentitytype props 1 412 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
302,hm_attributeindexentitytypename,"Description
Returns the entity type string of an indexed entity attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute entity type string of the entity attribute with index 4 on property
        1:
hm_attributeindexentitytypename props 1 4 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
303,hm_attributelist,"Description
Returns a list of all attribute IDs or names assigned to a specific entity for the current
        template.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
value
The type of list to return. Valid values are: 
id - the attribute IDs 
name - the attribute names
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To list the attribute IDs for the current template assigned to mat ID 6:
hm_attributelist mats 6 id
To list the attribute names for the current template assigned to mat name 6:
hm_attributelist mats 6 name -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
304,hm_attributesolverarrayvalues,"Description
Returns the solver code and all values for a 1D array attribute on an entity. The command
        first searches to find the specified attribute for the current template. If the attribute is
        not found for the current template, the search can be extended to search all attributes
        assigned to the entity. If the attribute does not exist on the entity, an error is
        returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.
attribute_name_or_id
The name or ID of the attribute to query. If a name is specified, the attribute must
            exist in the current template.
extend_search
By default, the attribute will only be searched for the current template. However, the
            search can be extended to search all attributes assigned to the entity. If the attribute
            is specified by name, this argument is ignored and only the current template is
            considered. Valid values are: 
0 - Search only attributes for the current template on the entity. 
1 - Search all attributes on the entity.

","Example
To get the solver code and all values of the 1D array for the attribute with name Example
        on material 6, considering only the current template:
hm_attributesolverarrayvalues material 6 Example -byid
or
hm_attributesolverarrayvalues material 6 Example -byid 0
To get the solver code and all values of the 1D array for the attribute with ID 100 on
        material 6, considering all attributes:
hm_attributesolverarrayvalues material 6 100 -byid 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
305,hm_bag_getconfigfromgenericname,"Description
This command returns the bag configuration for the specified generic name.
","Inputs

name
The generic name of the bag configuration.

","Example
To get the bag configuration of ADMPart generic name:
hm_bag_getconfigfromgenericname ADMPart
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
306,hm_ce_fedata,"Description
Returns the weld config or the tolerance set to realize a connector.
","Inputs

ce_id
The ID of the connector.
function
One of three possible strings: 
configval - returns the configuration number 
configname - returns the configuration name 
tolerance - returns the realization tolerance

","Example
To get the current weld config set for connector with ID 1:
set ce_id 1;
set config [ hm_ce_fedata $ce_id ""configval"" ];
Currently only configval and tolerance are supported
        for the connector.
","Errors
None.
"
307,hm_getcrossreferencedentitiesmark,"Description
Finds entities that reference the entities on the specified mark. This includes collected
        references, data name references and attribute entity references. Each type of entity that
        references the specified input entities is returned in a list, and the found entities are
        then placed on the specified mark for those entity types. See the list of supported entities
        for hm_getcrossreferencedentities.
","Inputs

entity_type
The type of entity to query.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
reference_flag
The type of cross-reference entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2). 
Bit0
0 - Do not consider collected entity cross-references.
1 - Consider collected entity cross-references. If the specified entity is not a
                  collected entity, nothing will be returned for this bit.


Bit1
0 - Do not consider data name entity cross-references.
1 - Consider data name entity cross-references. If the specified entity is not
                  referenced by any data names, nothing will be returned for this bit.


Bit2
0 - Do not consider attribute entity cross-references.
1 - Consider attribute entity cross-references. If the specified entity is not
                  referenced by any entity attributes, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found cross-referenced entities on. Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.
exclude_regions
0 - Include region entities in the search (default).
1 - Exclude region entities in the search (default).

","Examples
To get all entities that cross-reference componenst 100-110 on mark 1 and highlight them on
        the screen:
*createmark comps 2 100-110
foreach entity_type [hm_getcrossreferencedentitiesmark comps 2 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity cross-references for components with IDs 100-110 on mark
        2:
*createmark comps 1 100-110
hm_getcrossreferencedentitiesmark comps 1 1 2 0 0 -byid
To get only data name entity cross-references for components with IDs 100-110 on mark
        1:
*createmark comps 2 100-110
hm_getcrossreferencedentitiesmark 2 100 2 1 0 0 -byid
To get only attribute entity cross-references for components with IDs 100-110 on mark
        1:
*createmark comps 2 100-110
hm_getcrossreferencedentitiesmark comps 2 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
308,hm_getgeomtopologytype,"Description
Returns the topology type of a geometric entity.  Return types include:


points - none, vertex, fixed
lines - none, free, shared, nonmanifold, suppressed
surfs - free, bounding, partition, fin
solids - 1dmappable, 3dmappable, unmappable, ignoredmappable


","Inputs

entity_type
The type of entity to query.  Valid values are points, lines, surfs and solids.
id
The ID of the entity to query.

","Example
To query the topology of surface 100:
hm_getgeomtopologytype surfs 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
309,hm_gethmfileuserprofile,"Description
Returns the user profile information saved in the specified HyperMesh database. The string is comprised of 3 parts, application,
        profile and subprofile. For example: HyperMesh RadiossBlock
        Block140
","Inputs

filename
The full path and filename of the database file. Paths with spaces must be enclosed in
            quotes.

","Example
To get the user profile for C:\temp\test.hm:
hm_gethmfileuserprofile  C:/temp/test.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
310,hm_getidpoolnumber,"Description
Returns the ID pool number for a given solver and ID pool name.
","Inputs

solver_id
The solver template ID. If set to 0 the current template is used.
pool_name
The solver pool name to query.

","Example
To get pool number of LS-DYNA element ID pool
        ELEMENT_SOLID_IDPOOL:
hm_getidpoolnumber 9  ELEMENT_SOLID_IDPOOL 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
311,hm_getincludeentities,"Description
Selects entities and returns the entity types contained in a specified include file. The
        return value is the list of entity types found in the specified include. The actual entities
        are populated on the specified mark.
","Inputs

include_id
The ID of the include file to query. A value of 0 indicates the master model.
mark_id
The ID of the mark that contains the found entities. Valid values are 1 and 2.

","Example
To find all of the entities in include 1 and delete them:
hm_markclearall 1
set ent_types [hm_getincludeentities 1 1]
foreach ent_type $ent_types {
    catch {*deletemark $ent_type 1}
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
312,hm_getinternalid,"Description
This command returns the internal HyperMesh ID for a solver ID
        and solver ID pool. This command is only applicable to templates and entity types that have
        ID pools.
","Inputs

id_pool
The pool ID or name. By default, the value is assumed to be the pool ID. This is
            controlled by the optional search_type argument.
solver_id
The solver ID to query.
search_type
Defines whether id_pool is specified as a pool name or a pool ID.
            Valid values are -bypoolid and -bypoolname. If not specified, it defaults to
            -bypoolid.

","Examples
To get the internal HM ID of pool ID 1 and solver ID 2:
hm_getinternalid 1 2
or
hm_getinternalid 1 2 -bypoolid
To get the internal HM ID of pool PROP_IDPOOL and solver ID 17:
hm_getinternalid PROP_IDPOOL 17 -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
313,hm_getlinearclenpoint,"Description
This command finds and returns the coordinates of the point of the line
          line_id, whose arc-length distance from the point P with coordinates
          (x_coord, y_coord, z_coord) is arc_distace. If point
        P is not on the line then an error is returned. Otherwise, the result is returned in a list
        that contains 4 entries. The first 3 are the coordinates of the point and the last one is a
        flag. Possible flag values are 0, -1 and -2. Flag value 0 means that the result point is
        found to be on the line. If the result point happens to be off the line because the given
          arc_distace is too large, then flag gets values -1 or -2 depending on
        whether the result is off the start point or off the end point of the line, respectively. In
        this case, the returned point is the start or the end point of the line depending on the
        case.
","Example
To get the coordinates of the point of line 2751, that is at an arc-length distance of 8.5
        from the point (10.2, 32.5, 2) that lies on the line:
getlinearclenpoint 2751 8.5 10.2  32.5  2 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
e.
",
314,hm_getlinelineangle,"Description
Returns the angle between two lines at one of their intersection points. If the specified
        point is found to be on both lines, then it calculates the angle between the lines at this
        point and returns its value in degrees. Otherwise, an error is returned.
","Inputs

line_id1
The ID of the first line.
line_id2
The ID of the second line.
x y z
The coordinates of the intersection point.

","Example
To find the angle between line 43 and line 58 at point (4.7, 6.88, 9.4): 
hm_getlinelineangle 43 58 4.7 6.88 9.4 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
315,hm_getlinetangentatcoordinate,"Description
Returns the closest point, components of the tangent vector and the angle between the
        tangent vector and the z-axis at the point on the line closest to the input coordinates..
        The first 3 return values are the closest point coordinates, the next 3 are the tangent
        vector components, and the last return value is the angle.
","Inputs

line_id
The ID of the line.
x, y, z
The (x,y,z) coordinates of the point.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis nearest the coordinates (100,50,25) for the line with ID 341:
foreach {x y z tg_x tg_y tg_z ang}[hm_getlinetangentatcoordinate 341 100 50 25{}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
316,hm_getlinetgstartpoint,"Description
Returns the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the line start point. The first 3 return values are the tangent vector
        components, and the 4th return value is the angle.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the start of the line with ID 341:
foreach {tg_x tg_y tg_z ang} [hm_getlinetgstartpoint 341] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
317,hm_getlist,"Description
Returns an ordered list of entities from an entity list.
","Inputs

entity_type
The type of entity list to query. Valid values are elems, laminates, lines, nodes,
            plies and surfs.
list_id
The ID of the list to query. Valid values are 1 and 2.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the list has been created from a panel entity selector under the
            above conditions. Valid options are:
0 - Use the previous panel (default).
1 - Use the current panel.


model_name
The optional model to get the list from.  If not specified, the current model is
            used.

","Examples
To create a line from a user specified list of
        nodes:*createlistpanel nodes 1 ""Select nodes for the line:""
set node_list [ hm_getlist nodes 1 ];
if { ! [ Null node_list ] } {
*linecreatefromnodes 1 0 150 5 179
}
To create, query, and clear a list from nodes 2, 10, and 3 for model
        model-2:*createlist nodes 1 ""by model"" model-2 2 10 3
set my_list [hm_getlist nodes 1 0 model-2]
*clearlist nodes 1 ""by model"" model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
318,hm_getlockedentities,"Description
This command returns locked entity IDs across all submodels.
","Inputs

entity_type
The type of entity to query locks for.
data_name
The data name to query locks for. Currently only supported for ""id"".

","Example
To query ID locks for all elements:
hm_getlockedentities elems id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
319,hm_getmarkall,"Description
Returns a list of lists containing the populated entity type and entity IDs for the
        specified mark. The first value in each returned list is the entity type, and the remaining
        values are the entity IDs of that type. For example, if mark 1 is populated with elements
        1-5 and comps 101-105, the returned values would
        be:{elems 1 2 3 4 5} {comps 101 102 103 104 105}
","Inputs

mark_id
The ID of the mark to query. Valid values are 1 and 2.
model_name
The optional model to get all marks for. If not specified, the current model is
            used.

","Example
To find all of the entities on mark 1:hm_getmarkall 1
To find all of the entities on mark 1 for model
        model-2:hm_getmarkall 1 model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
320,hm_getmarkfromtable,"Description
This command returns the list of entity IDs that exist in the table with
          table_name.
","Example
To create a table named elem_table containing elements in the component wingbox and
        retrieve the values from the table:
*createmark elems 1 all
hm_marktotable elems 1 elem_table
set elems [hm_getmarkfromtable elem_table]
","Errors
If table_name is invalid, you will get the following
        error:hm_getmarkfromtable: the table 'table_name' was not found.
",
321,hm_getmemoryinfo,"Description
This command returns a list of system memory information. This is available on Windows and
          Linux platforms only.
","Example
To get the system memory information:
hm_getmemoryinfo
","Errors
None.
",
322,hm_getmeshfaceparams,"Description
This command returns all of the relevant automesh settings applied to a surface face by
          *set_meshfaceparams. If no automesh settings are applied, no values are
        returned. The returned values are (in order):
shape_type
elem_type
alg_type
elem_size
smooth_method
smooth_tol
size_control
skew_control


","Inputs

face_id
The global face ID of the surface face to query.

","Example
To get the automesh parameters assigned to face with ID 15:
hm_getmeshfaceparams 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
323,hm_getmidsurfcomp,"Description
Returns the name of the component in the model that contains middle surfaces and no other
        surfaces.  If such a component does not exist, or if there are more than one such
        components, the command returns ""Middle Surface"".
","Example
To get the middle surface component:
hm_getmidsurfcomp
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
324,hm_getmodelcheckfailedcount,"Description
Returns the number of entities failing a given model checker check. 
","Inputs

check_name
The name of the check, as given in the model checker config file.

","Example
To get the number of entities failing the ""Number of defined materials"" check:
hm_getmodelcheckfailedcount ""Number of defined materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
325,hm_getmodelchkvaluelevellimitcriteriaattribute,"Description
This command returns model check values for level, limit, criteria and attributes for the
        specified check display name.
","Inputs

display_name
The display name of the check to query.

","Example
To get the attribute values for check ""Material E is not defined"":
hm_getmodelchkvaluelevellimitcriteriaattribute ""Material E is not
          defined""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
326,hm_getmydocumentsdir,"Description
This command returns the full path to the current user’s ""My Documents"" folder. This
        command is only supported on Windows platforms. 
","Example
hm_getmydocumentsdir
","Errors
This command does not return any errors that can be handled.
",
327,hm_getnodegeometry,"Description
Get the simplest geometry entity associated with the node.
","Inputs

nodeID
The ID of the node.

List containing two values. The first value is a type of geometry. It can have a value of
        none, point, line, or surface. The second value is an ID of the entity.
","Example
hm_getnodegeometry 1
returns:
none 0
If the node is associated with more than one geometric entity, only the simplest one is
        returned by this command. For example, using this command for a node located on the edge of
        a surface would return ""line"" and the line’s ID, because the line is simpler (fewer
        dimensions) than the surface. (A corner node would return a point because the corner is a
        vertex.)
","Errors
None.
"
328,hm_getoccupiedentitiesinrange,"Description
Returns the list of occupied IDs in a specific range. The values are returned as a
        compacted list using ranges and commas where applicable.
","Inputs

entity_type
The type of entity to query.
pool_id
The ID of the entity pool to query.
range
The ID range within the specified pool to query. This should be encapsulated in
            quotes.

","Example
To get the element IDs in use in pool 2 for the range 100-200:
hm_getoccupiedentitiesinrange elems 2 ""100-200""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
329,hm_getoffsetZ0,"Description
This command returns the offset Z0 value of the specified element.
","Inputs

elem_id
The ID of the element to query.

","Example
hm_getoffsetZ0 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
330,hm_getplaneintercepts,"Description
Given a mark of entities, a plane definition, and a vector, returns the maximum and minimum
        coordinates on the cross-section defined by the virtual intersection of the entities with
        the plane, in the vector direction.
","Inputs

entity_type
The type of entities to consider. Valid values are elems, surfs and comps (elems take
            priority over surfs).
mark_id
The ID of the mark containing the input entities.
normal_x 
normal_y 
normal_z
Defines the normal direction of the input plane
base_x 
base_y 
base_z
 Defines the base location of the input plane and vector.
vec_x 
vec_y 
vec_z
Defines the vector direction.

","Example
To get the plane intercept coordinates for the plane defined by normal (1,0,0) base (0,0,0)
        and along the direction (0,1,0) for all displayed elements:
*createmark elems 1 displayed
hm_getplaneintercepts elems 1 1 0 0 0 0 0 0 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
331,hm_getprincipalaxes,"Description
Returns the principal axes direction cosine values for the selected entities. The values
        are always returned relative to the global axes. The values are returned as 1st_direction_x
        1st_direction_y 1st_direction_z 2nd_direction_x 2nd_direction_y 2nd_direction_z
        3rd_direction_x 3rd_direction_y 3rd_direction_z.
","Inputs

entity_type
The type of entity to query. Currently supported for comps and elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
location_flag
Optional. Specifies the location about which the principal axes are calculated. Valid
            values are: 
0 - Global (0,0,0). Default. 
1 - COG location. 

","Example
To get the principal axes for components 1-5:
*createmark comps 1 1-5
hm_getprincipalaxes comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
332,hm_getqephtimestep,"Description
This command returns the time step calculated from QEPH elements in a component.
","Inputs

name
The name of the component

","Example
To get the time step from component named ""Flange"":
hm_getqephtimestep ""Flange""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
333,hm_getreferencedentities,"Description
Finds entities that are referenced by the specified entity. This includes collected
        references, data name references and attribute entity references. Each type of entity that
        is referenced by the specified input entity is returned in a list, and the found entities
        are placed on the specified mark for those entity types. See the list of supported entities
        for this command.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
reference_flag
The type of referenced entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2). 
Bit0
0 - Do not consider collected entity references. 
1 - Consider collected entity references. If the specified entity is not a
                  collector or is empty, nothing will be returned for this bit.
Bit1
0 - Do not consider data name entity references. 
1 - Consider data name entity references. If the specified entity does not have
                  any data name references, nothing will be returned for this bit.
Bit2
0 - Do not consider attribute entity references. 
1 - Consider attribute entity references. If the specified entity does not have
                  any attribute entity references, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found referenced entities on.Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are:
-byname - Search only by name. 
-byid - Search only by ID.



","Examples
To get all entities referenced by component with ID 100 on mark 1 and highlight them on the
        screen:
foreach entity_type [hm_getreferencedentities comps 100 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity references for component with ID 100 on mark 2:
hm_getreferencedentities comps 100 1 2 0 0 -byid
To get only data name entity references for component with ID 100 on mark 1:
hm_getreferencedentities comps 100 2 1 0 0 -byid
To get only attribute entity references for component with ID 100 on mark 1:
hm_getreferencedentities comps 100 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
334,hm_getribsid,"Description
Returns the IDs of the rib lines.
","Example
To get the IDs of the rib lines:
hm_getribsid
","Errors
None.
",
335,hm_getsolver,"Description
Returns the name or ID of the solver as provided by the template
          *codename() command. If no name is provided, or no template is loaded,
        ""none"" is returned.
","Inputs

value
An optional argument that specifies the type of value to return. 
ID - return the template ID 
name - return the template name (default) 

","Examples
To get the name of the current solver:
set solver_name [hm_getsolver]
or
set solver_name [hm_getsolver name]
To get the name of the current solver:
set solver_id [hm_getsolver id]
","Errors
None.
"
336,hm_getsolverid,"Description
Returns the solver ID and pool name for the specified HyperMesh
        internal ID. If there is no solver ID and pool for the specified entity, an error is
        returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The internal ID or name of the entity to query.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the solver ID and pool name for property with internal ID 4:
hm_getsolverid props 4
or
hm_getsolverid props 4 -byid
To get the solver ID and pool name for a material with name 1:
hm_getsolverid mats 1
or
hm_getsolverid mats 1 -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
337,hm_getsolverids,"Description
Returns the solver ID and pool names for the specified HyperMesh internal ID. If there is no solver ID and pool for the specified entity, the internal ID
        and a blank ID pool are returned.
","Inputs

entity_type
The type of entities to query.
entity_ids
The list of internal IDs to query. The return values will be in the same order as the
            input list.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.
groupbypoolname
By default, the command returns the entity IDs in the order of the list, with a list
            item containing two sub-lists for each input ID (the sublists contain the solver ID and
            the pool name). If the string groupbypoolname is passed, the return
            values are grouped together by pool name, with two items returned for each pool found,
            the first being the pool name, and the second being the list of solver IDs found for
            that pool.

","Examples
To get the solver IDs and pool names for property with internal IDs 4 and 5:
hm_getsolverids props ""4 5""
or
hm_getsolverids props ""4 5"" -byid
To get the solver IDs and pool names for material with names 1 and 2:
hm_getsolverid mats ""1 2""
or
hm_getsolverid mats ""1 2"" -byname
To get the solver IDs and pool names for material with names 1 and 2 and group by pool
        name:
hm_getsolverid mats ""1 2"" groupbyname
or
hm_getsolverid mats ""1 2"" -byname groupbyname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
338,hm_getsurfacefromface,"Description
Gets the surface containing the face whose ID is supplied as the argument. 
","Inputs

face_id 
ID of the face.

","Example
The function returns an ID of the surface containing the face with input ID value.
To get surface containing the face with ID 2:
hm_getsurfacefromface 2
","Errors
None.
"
339,hm_getsurfacesbyedgelength,"Description
Gets the surfaces that have an edge with a length smaller or equal to the specified
        value.
","Inputs

double
Length of an edge that you specify.

","Example
hm_getsurfacesbyedgelength 20
","Errors
None.
"
340,hm_getsurfacesfromsolid,"Description
Returns the list of surface IDs associated with a specified solid ID.
","Inputs

id
The ID of the solid to query.
?type?
An optional string to specify which surfaces are returned.  Valid values are bounding,
            partition, fin and all (default).

","Example
To get a list of surfaces associated with solid of ID 1:
hm_getsurfacesfromsolid 1
 This command returns information necessary for running other commands related to surface
        and solid creation. 
","Errors
None.
"
341,hm_getsurfacethicknessvalues,"Description
This command returns the midsurface thickness and offset values for nodes, points, or
        elements. 
An error is returned if a non-topological point or node or an element not associated to any
        surface, is given as input.
","Inputs

entity_type
The type of entity to query. Valid values are nodes, points and elems.
entity_id
The ID of the entity to query. 
For nodes and points, the return result is a list with the number of list values equal
            to the number of surfaces connected to the entity. Each value is a list itself with
            three sub-values. The first value is the ID of associated surface, the second value is
            the thickness of the surface at the node or point location (-1 if not defined), and the
            third value is the thickness offset. 
For elements, only a single list value is returned, also with three sub-values
            indicating the surface ID, the thickness at the element centroid, and the offset at the
            element centroid.
mark_id
The ID of the mark containing the entities to query. Valid values are 1 and 2.

For nodes and points, the return result is a list with the number of list values equal
            to the total number of surfaces connected to each entity. Each value is a list itself
            with four sub-values. The first value is the ID of the or node, the second value is the
            ID of the associated surface, the third value is the thickness of the surface at the
            node or point location (-1 if not defined), and the fourth value is the thickness
            offset. 
For elements, the return result is a list with the number of list values equal to the
            total number of elements. For element_method 0-3, four sub-values
            indicating the element ID, the surface ID, the thickness of the element (-1 if not
            defined), and the offset of the element are returned. For
              element_method 4, the element ID is returned as the first
            sub-value. For each node of the element, a sub-list is returned containing the node ID,
            the thickness at the node and the offset at the node for the element. For example:
            {elem_id1 {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}} {elem_id2 {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}} … {elem_idn {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}}.
element_method
Only allowed for element mark_id based usage. This determines how the thickness and
            offset values are measured for elements (ignored when the mark only contains nodes or
            points). Valid values are: 
0 - Thickness and offset are measured at the element centroid. 
1 - Thickness and offset are measured as a weighted average of the element’s nodes. If
            an element spans multiple surfaces, -1 is returned for the surface ID, thickness and
            offset. 
2 - Thickness is measured at the element's nodes and the minimum value is used. The
            offset value from this node is also reported. If an element spans multiple surfaces, -1
            is returned for the surface ID, thickness and offset. 
3 - Thickness is measured at the element's nodes and the maximum value is used. The
            offset value from this node is also reported. If an element spans multiple surfaces, -1
            is returned for the surface ID, thickness and offset. 
4 - The thickness of each element node is returned. For elements that don't span
            surfaces but have nodes on shared/non-manifold edges or shared vertices, the reported
            values should all come from the same ""common surface"" of the element. For elements that
            do span surfaces, values for nodes on an edge/vertex between the shared surfaces, the
              ambiguous_values argument is used. For surfaces that don't have
            thickness, -1 is returned for the thickness and offset of any nodes associated with that
            surface.
ambiguous_values
Defines what to do when an element that spans multiple surfaces and a node of that
            element is on an edge/vertex between the shared surfaces. This option is only used for
              element_method=4 when a ""common surface"" or a ""most common surface""
            cannot be determined. Surfaces that don't have a thickness are ignored and not
            considered in the calculations. If all surfaces have no thickness, -1 is returned for
            all nodes. 
1 - Report the average value at nodes from spanned surfaces. 
2 - Report the minimum value at nodes from spanned surfaces. 
3 - Report the maximum of value at nodes from spanned surfaces.

","Examples
Suppose that the node with ID 100 is located on a shared edge between surfaces having IDs
        10 and 11. To retrieve the list of surfaces, thicknesses and offsets:
set node_thick [ hm_getsurfacethicknessvalues nodes 100 ]
To get the surface, thickness and offset at the centroid for element 50:
set elem_thick [ hm_getsurfacethicknessvalues elems 50 ]
 To get the surface, thickness and offset as the weighted node average for element 50:
*createmark elems 1 50
set elem_thick [ hm_getsurfacethicknessvalues elems 1 1 ]
To get the surface, thickness and offset for all displayed nodes:
*createmark nodes 1 displayed
set node_thick [ hm_getsurfacethicknessvalues nodes 1 0 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
342,hm_getTLid,"Description
Returns the IDs of the trim lines.
","Example
To get the IDs of the trim lines:
hm_getTLid
","Errors
None.
",
343,hm_gettypeswithunresolvedids,"Description
Returns a list of entity types that currently have unresolved IDs.
","Example
To get the list of entity types with unresolved IDs, and to query the IDs:
foreach entity_type [hm_gettypeswithunresolvedids] {
    set ids($entity_type) [hm_getunresolvedids $entity_type]
}
","Errors
None.
",
344,hm_getunoffsetablenodes,"Description
Saves to the user list the unoffsetable nodes. Useful for CFD BL meshing. 
Consider a node and all its surrounding elements. The visibility angle of an element is the
        signed angle between the node normal and the element normal after subtracting 90 degrees.
        The visibility angle of the node is the minimum of the element visibility angle for all
        surrounding elements. The best visibility angle of the node is the maximum of the node
        visibility angle for all choices on the node normal. A node having zero or negative best
        visibility angle is considered absolutely unoffsetable. A node having its best visibility
        angle less than angle_threshold is considered unoffsetable.
","Inputs

entity_type
The type of entity to query. Valid values are comps and elems.
mark_id
The ID of the mark containing the entities to query. Valid values are 1 and 2.
angle_threshold
 A value >=0.0 and < 45.0 that defines the threshold visibility angle in degrees
            for determining a node is unoffsetable.

","Example
To find all unoffsetable nodes in comp1 using an angle threshold of 2.5:
*createmark comps 1 comp1
hm_getunoffsetablenodes comps 1 2.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
345,hm_getunresolvedids,"Description
Returns the unresolved IDs for a specific entity type and optional ID pool. The values are
        returned as a list per ID pool:
{id_pool_id1 solver_ids1...} {id_pool_id2 solver_ids2...} ... {id_pool_idN solver_idsN...}
If there is no ID pool for the specified entity type, """" will be returned for
        id_pool_id.
","Inputs

entity_type
The type of entity to query.
?id_pool_id?
The ID of the ID pool to query. If empty, all ID pools are considered.

","Examples
To get the list of entity types with unresolved IDs, and to query the IDs:
foreach entity_type [hm_getunresolvedidcrossreferences] {
set ids($entity_type) [hm_getunresolvedids $entity_type]
}
To get the list of entity types with unresolved IDs, and to query the IDs for pool 1
        only:
foreach entity_type [hm_getunresolvedidcrossreferences] {
set ids($entity_type) [hm_getunresolvedids $entity_type 1]
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
346,hm_getuvbounds,"Description
Returns the parametric uv coordinate bounds associated with the referenced surface.. The u
        and v values are returned as a list containing four values. The first two values in the list
        are the range for u, and the last two values are the range for v.
This is most useful to determine the bounds of trimmed surfaces, where the trimmed
        surface’s parametric space is a subset of the untrimmed surface’s parametric space. It can
        be used in conjunction with hm_getuvcoordinates. 
This command is only valid for single surfaces or surfaces generated by trimming one
        original surface and suppressing edges. It is not valid for the generic case of surfaces
        composed from different parametric patches by suppressing edges only (for example, two
        separate surfaces stitched together, then edges suppressed).
","Inputs

surf_id
The ID of the surface.
scaled (optional)
Used when the referenced surface is a trimmed surface. If the value is set to 0
            (default), the uv bounds returned will be in reference to the parametric space of
            original untrimmed surface. If the scale value is set to 1, the uv bounds returned will
            be in reference to the parametric space of the trimmed surface. 

","Example
To get the uv bounds of surface 1:
hm_getuvbounds 1
","ErrorsNone.Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
347,hm_getvalue,"Description
Queries data names, attributes, and metadata on entities. It will return the value of any
        type of data name, attribute, or metadata of an entity. In addition, this command will also
        return the value at a specific index for array type of data names, attributes, and
        metadata.
","Inputs

entity_type
The type of entity to query.
<select_type>=<selection>
The entity or entities that are to be queried. There are several ways to provide the
            entities to be queried. Only one option can be used at a time:
id=<id>
The ID of the single entity to query.
name=<name>
The name of the single entity to query.
mark=<mark_id>
The ID of the mark containing the entities to query.
list=<list_id>
The ID of the list containing the entities to query.
user_ids={<id1> <id2> ... <idN>}
The IDs of one or more entities to query.
user_names={<name1> <name2> ... <nameN>}
The names of one or more entities to query.


dataname=<data name or attribute name/ID>
The dataname=value data name and/or attribute pair that defines the relevant data to
            query. For attributes, this can be either the attribute name or ID.  If not specified,
            one of the metadata_value... options must be used.
column=<column_index>
This is the optional column index for a 2D array. Used together with row_index, it
            returns the value at the specified row_index and column_index.
locationunit={<entity_id>, <face_index>}
Valid only for engineering loads.  This is required if a non-uniform load is being
            queried.  If the load is applied on a regular set, only
              <entity_id> is needed.  If the load is applied on solid element
            faces, then <face_index> is also required.


entity_id
The ID of the entity to query.
face_index
The index of the solid element face.


metadata_value=<metadata_name>
This is to query the metadata value for a specified metadata name. This is valid for
            all types of metadata.
metadata_value_count=<metadata_name>
This is to query the metadata count for a specified metadata name. This is valid for
            all types of metadata.
metadata_value_ids=<metadata_name>
This is to query the metadata entity IDs for a specified metadata name. This is valid
            for entity and entity array metadata.
metadata_value_type=<metadata_name>
This is to query the metadata entity type for a specified metadata name. This is valid
            for entity and entity array metadata.
modelname=<name_of_model>
This is the optional model name to query when there are multiple models in the
            database.  If not specified, the current model is used.
row=<row_index>
This is the optional row index for a 1D or 2D array. For 1D array, it returns the
            single value at the specified index. For a 2D array, it will return the entire row.

","Examples
 Get the node IDs in a set named
        node_set:hm_getvalue sets name=node_set dataname=ids
 Get the name of entity set with ID
        1:hm_getvalue sets id=1 dataname=name
Get the attribute Rho of material ID
        1:hm_getvalue mats id=1 dataname=Rho
Get the attribute 183 of material ID
        1:hm_getvalue mats id=1 dataname=183
Get materialid for components on mark
        1:hm_getvalue comps mark=1 dataname=materialid
Get node1 for elements 1 and 2 on list
        1:hm_getvalue elems list=1 dataname=node1
Get materialid for components with names ""mid"" and
        ""center"":hm_getvalue comps user_names={mid center} dataname=materialid
Get submodel types for include file
        10:hm_getvalue includes id=10 dataname=typesundersubmodel
Get the attribute Rho of material ID 1 for model
        model-2:hm_getvalue mats id=1 dataname=Rho modelname=model-2
Get a magnitude value for non-uniform distributed load 5 on node
        15:hm_getvalue loads id=5 dataname=magnitude locationunit={15}
Get a magnitude value for non-uniform distributed load 5 on element 25 face
        2:hm_getvalue loads id=5 dataname=magnitude locationunit={25,2}
Get the metadata value for an integer metadata with the name mymeta_int on a
        component:hm_getvalue comps id=1 metadata_value=mymeta_int
Get the metadata value for an entity metadata with the name mymeta_entity on a
        component:hm_getvalue comps id=1 metadata_value=mymeta_entity 
Get the metadata value entity count for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_count=mymeta_entityarray
Get the metadata value entity IDs for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_ids=mymeta_entityarray
Get the metadata value entity types for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_type=mymeta_entityarray
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
348,hm_getwhollycontainedcollectormark,"Description
This command returns the collectors that wholly contain the input entities.
","Inputs

entity_type


The type of entity to query. Valid values are: 
elems (output is components) 
loads (output is load collectors) 
curves (output is plots) 
systs (output is system collectors) 
vectors (output is vector collectors)


entity_mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
collector_mark_id
The ID of the mark containing the collectors that wholly contain the input entities.
            The collector type is dependent on the specified entity_type. Valid values are 1 and 2.
reverse


0 - Find only wholly contained collectors. 
1 - Find not-wholly contained collectors.



","Examples
To find the components that wholly contain elements 1-100:
*createmark elems 1 1-100
hm_getwhollycontainedcollectormark elems 1 1 0
To find the components that simply contain elements 1-100:
*createmark elems 1 1-100
hm_getwhollycontainedcollectormark elems 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
349,hm_historysupporttofile,"Description
Writes out to a file the commands that are supported for history.
","Inputs

filename
The full path and file name of the output file.
support_level
The type of history support to write the commands for. Valid values are: 
-1 - Commands that do not modify the database and therefore do not affect history 
 0 - Commands that are not supported for history 
 1 - Commands that are supported for history

","Example
To write out the list of unsupported commands to
          C:\temp\unsupported.txt:
hm_historysupporttofile C:/temp/unsupported.txt 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
350,hm_holedetectionfindholes,"Description
Runs the hole detection functions for finding holes and tubes based on input entities and
        parameters. This must be preceded by calls to
          hm_holedetectioninit, hm_holedetectionsetentities,
        and hm_holedetectionsetholeparams or
          hm_holedetectionsettubeparams.
","Inputs

find
Bit value defining the types of holes and tubes to find (Bit0 + 2*Bit1 + 4*Bit2):
Bit0
0 - Do not find holes 
1 - Find holes
Bit1
0 - Do not find 2D tubes 
1 - Find 2D tubes
Bit2
0 - Do not find 3D tubes 
1 - Find 3D tubes



","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
351,hm_holedetectiongetnumberofmates,"Description
Returns the number of found hole/tube mating 'groups'. This must be preceded by a call to
          hm_holedetectionfindmates.
","Example
To write out all geometric shell mate details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
hm_holedetectionfindmates
set n [hm_holedetectiongetnumberofmates]
if { $n > 0 } {
puts $holesfile ""Number of mates = $n""
puts $holesfile ""Mate details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetmatedetails $i]""
}
} else {
puts $holesfile ""Holes mates not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
352,hm_holedetectionsetholeparams,"Description
Defines parameters for finding 2D holes in both geometry and FE. Multiple calls to this
        command can be made to override or redefine the parameters for each hole shape. Settings are
        cleared on any call to hm_holedetectioninit/hm_holedetectionend. 
This must be preceded by a call to hm_holedetectioninit. 
Only hole_shape is mandatory. All other parameters are optional and have
        default values. Parameters can be specified in any order.
","Inputs

hole_shape=
The shape of hole the parameters are being defined for. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Do not consider general holes 
1 - Consider general holes
Bit1
0 - Do not consider circular holes 
1 - Consider circular holes
Circular holes: The distance from any of its nodes to the calculated center must
                  not differ from the calculated radius by more than
                    max_geom_dev_percent and max_geom_dev_abs
                  (if enabled). Also, no edge must make an angle greater than
                    max_smooth_edge_angle with either adjoining edge.
Bit2
0 - Do not consider rounded holes. 
1 - Consider rounded holes.
Rounded holes: The distance from any of the nodes on the rounded ends to the
                  respective calculated centers must not differ from the calculated radii by more
                  than max_geom_dev_percent and
                    max_geom_dev_abs (if enabled). The radii must be within
                    max_geom_dev_percent of each other. Also, no edge must make
                  an angle greater than max_smooth_edge_angle with either
                  adjoining edge. Opposite straight sides must have lengths within
                    max_geom_dev_percent of each other.
Bit3
0 - Do not consider square holes. 
1 - Consider square holes.
Square holes: At every node except four, no edge must make an angle greater than
                    max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent and
                    max_geom_angle_dev_abs (if enabled) of 90 degrees. And, all
                  four sides must have lengths within max_geom_dev_percent and
                    max_geom_dev_abs (if enabled) of their average. The sides
                  must have a relative deviation from straight lines of not more than
                    max_straightness_dev_percent.
Bit4
0 - Do not consider rectangular holes.
1 - Consider rectangular holes.
Rectangular holes: At every node except four, no edge must make an angle greater
                  than max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent and
                    max_geom_angle_dev_abs (if enabled) of 90 degrees. Opposite
                  pairs of sides must have lengths within max_geom_dev_percent
                    and max_geom_dev_abs (if enabled) of each other. The sides
                  must have a relative deviation from straight lines of not more than
                    max_straightness_dev_percent.


?hole_type=<>?
The hole type to consider. If 0 (default), the holes type check is skipped. Bit values
            are used and the value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3).
Bit0
0 - Do not consider surface holes. 
1 - Consider surface holes.
Surface holes: Holes with small angle deviation of axis of adjacent surface
                  normals.
Bit1
0 - Do not consider flanged surface holes 
1 - Consider flanged surface holes
Flanged surface holes: Holes with bent edges (stiffness ring rib).
Bit2
0 - Do not consider cylindrical holes. 
1 - Consider cylindrical holes.
Cylindrical holes: Free edge loops of cylinders.
Bit3
0 - Do not consider conical holes. 
1 - Consider conical holes.
Conical holes: Free edge loops of cones.


?max_avg_adj_surf_angle=<>?
Maximal average angle deviation of holes axial direction of adjacent surfaces normals.
            Acceptable values are [0.0, 90.0]. If less than 0.0, this check is skipped. Default
            value 45 degrees.
?max_big_planar_dim=<>?
This threshold applies to the rounded (elongated) and rectangular holes. The maximum
            planar dimension of the hole cannot exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.
?max_geom_angle_dev_abs=<>?
Sets the absolute angle threshold for deviation of corner angles of rectangular holes
            from right angle, see holes shape. Acceptable values are [0.0, 90.0], otherwise the
            closer extreme is used. If less than 0.0, this check is skipped. Default value -1.
?max_geom_dev_abs=<>?
Sets the absolute threshold for linear hole shape deviation, see hole_shape. If less
            than 0.0, this check is skipped. Default value -1.
?max_geom_dev_percent=<>?
Sets the relative threshold for hole linear and angle shape deviation, see hole_shape.
            Acceptable values are [0.0, 100.0], otherwise the closer extreme is used. If less than
            0.0, this check is skipped. Default value -1.
?max_offset_plane_dev=<>?
No node on the perimeter of a hole must exceed this distance from the mean plane. If
            less than or equal to 0.0, this check is skipped. Default value 0.0.
?max_planar_dim=<>?
The maximum width of the hole cannot exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.
?max_smooth_edge_angle=<>?
See hole_shape. Acceptable values are [0.0, 90.0], otherwise the closer extreme is
            used. If less than 0.0, this check is skipped. Default value -1.
?max_straightness_dev_percent=<>?
Sets the relative threshold for the chordal deviation of the sides of rectangular
            holes of straight lines, see hole shape. Acceptable values are [0.0, 100.0], otherwise
            the closer extreme is used. If less than 0.0, this check is skipped. Default value
            -1.
?min_planar_dim=<>?
The minimum width of the hole must exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.

","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
353,hm_isentitydatanameparameterized,"Description
Determines if a specific data name or attribute is parameterized. A return value of 0 means
        it is not parameterized. A return value of 1 means it is parameterized.
","Inputs

entity_type
The type of entity to query.
id
The ID of the entity to query.
data_name_or_attribute
The data name or template attribute name/ID to query.
row_index (optional)
Row index for a 1D or 2D array. For a 1D array, it checks the parameterization at the
            specified row index. For a 2D array, it will check for the entire row. 
This should be blank for non-array data names/attributes.
column_index (optional)
Column index for a 2D array. Used together with row_index, it
            checks the parameterization at the specified row_index and
              column_index. 
This should be blank for non-array data names/attributes.

","Example
To check the parameterization of attribute with name LSD_DA1 for entity set 5:
hm_isentitydatanameparameterized sets 5 LSD_DA1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
354,hm_ishistorysupported,"Description
Returns the history support level for the specified command. The return values are as
        follows: 
-1 - Command does not modify the database and therefore does not affect history 
0 - Command is not supported for history 
1 - Command is supported for history


","Inputs

command
The name of the HyperMesh Tcl Modify Command command to query.

","Example
To query the support level of *displaynone:
hm_ishistorysupported *displaynone
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
355,hm_latestentityid,"Description
Returns the ID of the last created entity. An option is also available to return the ID of
        previously created entities (up to 99).
","Inputs

entity_type
The type of entity to return the last created ID for.
num (optional)
Queries a specific entity created previously before the last entity. The max is 99.
            Default is 0 (last entity).

","Examples
To get the latest created component:
hm_latestentityid comps
To get the previous latest and first previous 10th created component:
*createmark lines 1 100
#Create two nodes on the line
*nodecreateonlines lines 1 2 0 0
#Get the last created node
set node1 [hm_latestentityid nodes]
#Get the first previously created node
set node2 [hm_latestentityid nodes]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
356,hm_markbyfeature,"Description
Put entities on the specified output mark based on entities on the input mark selection and
        specified feature parameters.
","Inputs

input_mark_id
The ID of the input mark. Valid values are 1 and 2.
output_mark_id
The ID of the output mark to put the entities selected by feature. Valid values are 1 and 2.
param_string
This string contain keyword/value pairs, separated by whitespace. Valid keywords are:
feature_mode
This is mandatory input parameter. Valid values are: 
1 - Put on output mark lines representing circles.  Input mark entity type
                      is lines.
2 - Put on output mark lines representing circles.  Input mark entity type
                      is surfaces.
3 - Put on output mark surfaces representing cylinders.  Input mark entity
                      type is surfaces.
4 - Put on output mark surfaces representing fillets.  Input mark entity
                      type is surfaces.
5 - Put on output mark surfaces representing valve seats.  Input mark
                      entity type is surfaces.
6 - Put on output mark surfaces that contain internal discontinuities and
                      high curvature areas.  Input mark entity type is surfaces.


min_radius (optional)
This parameter filters output lines or surfaces by minimal curvature radius.
                  Valid values are any value > 0.0, or a value < 0.0 to specify any radius.
max_radius (optional)
This parameter filters output lines or surfaces by maximal curvature radius.
                  Valid values are any value > 0.0, or a value < 0.0 to specify any radius.
internal_only (optional)
Used only for feature_mode 1 or 2. If set to 1, all outer
                  circles on surfaces will be excluded from the output.
closed_cylinder (optional)
Used only for feature_mode 3. If set to 1, all non closed
                  cylinder surfaces will be excluded from the output.
valve_output (optional)
Used only for feature_mode 5. If set to 1, all surfaces
                  representing the cylinder part of a valve seat will be excluded from the output.
                



","Examples
To put on mark 2 all lines representing circles with radius between 1.0 and 15.0:
*createmark lines 1 all
hm_markbyfeature 1 2 ""feature_mode 1 min_radius 1.0 max_radius 15.0""
To put on mark 2 all surfaces representing closed cylinders with any radius:
*createmark surfaces 1 all
hm_markbyfeature 1 2 ""feature_mode 3 closed_cylinder 1 min_radius -1.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
357,hm_markremove,"Description
This command removes entities from the specified mark. Only entity IDs are allowed, and
        there are no advanced removal methods.
","Inputs

entity_type
The type of entity mark to remove.
mark_id
The ID of the mark. Valid values are 1 and 2.
list
The entity IDs to remove. When specifying the list using a Tcl
            variable, the eval Tcl command must precede the
              hm_markremove command (see example below). This expands (substitutes) the
              Tcl list before executing the command.

","Example
To remove the components with IDs 1 and 5 from mark 2:
hm_markremove comps 2 1 5
or, using a list:
set comps ""1 5""
eval hm_markremove comps 2 $comps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
358,hm_me_modulesgetFromUid,"Description
Returns the list of module IDs for a given UID.
","Inputs

uid
The module UID to query.

","Example
To get the module IDs from Module_UID1:
hm_me_modulesgetFromUid Module_UID1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
359,hm_metadata,"Description
This command returns metadata, based off of query parameters.
","Inputs

findbyname name ?entity_type?
Returns all metadata with the specified name. If entity_type is
            specified, all metadata with the specified name and attached to that entity type is
            returned.
findbytype entity_type
 Returns all metadata attached to entities of the specified entity type.
findbymark entity_type mark_id
Returns all metadata attached to the entities on the mark. 
findall
Returns all metadata.

","Examples
 To find all metadata named .ALTAIR.HW.CATIA.TAG:
hm_metadata findbyname .ALTAIR.HW.CATIA.TAG
To find all metadata named .ALTAIR.HW.CATIA.TAG attached to
        surfaces:
To find all metadata named .ALTAIR.HW.CATIA.TAG attached to surfaces:
hm_metadata findbyname .ALTAIR.HW.CATIA.TAG surfs
To find all metadata attached to solids:
hm_metadata findbytype solids
To find all metadata attached to the displayed surfaces:
*createmark surfs 1 ""displayed""
hm_metadata findbymark surfs 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
360,hm_morph_getdomainarcangle,"Description
Returns the arc angle of a specified edge domain. Optional arguments allow the arc angle to
        be calculated using a line, node, or base point and axis to find the center of
        curvature.
","Inputs

domainID
The ID of an edge domain.
?BaseAndAxis?
x, y, z - Base point is x, y, z. 
dx, dy, dz - Axis is along dx, dy, dz.
?(Line) entityId?
line entity Id - Specify 'line' and the line ID.
?(Node) entityId?
node entity Id - Specify 'node' and the node ID.
?<blank>?
<none> - Default approximates the center of the edge domain.

","Examples
To get the arc angle of a domain with ID 2:
hm_morph_getdomainarcangle 2
To get the arc angle a domain with ID 2 and measured at 2.0, 5.0, 0.0 and normal to a
        vector that runs 1.0 in the x direction, 0.5 in the y direction, and 0.0 in the z
        direction:
hm_morph_getdomainarcangle 2 2.0 5.0 0.0 1.0 0.5 0.0
To get the arc angle of a domain with ID 2 and measured using node ID 12 as the center
        node:
hm_morph_getdomainarcangle 2 node 12
To get the arc angle of a domain with ID 2 and measured using line ID 3 as the center
        line:
hm_morph_getdomainarcangle 2 line 3
","Errors
None.
"
361,hm_morph_getinfo,"Description
Returns certain options/values from HyperMorph.
","Inputs

option
There are different options available. Each requires its own format:
domaincount
domain_type
domain_type
The type of domain to count. Valid values are:
0 - All domains 
1 - 1D domains 
2 - 2D domains 
3 - 3D domains 
4 - Global domains 
5 - Edge domains 
7 - General domains


excludedelements list
Returns a list of all excluded element IDs.
excludedelements mark
mark_id
The query will return nothing, but all excluded elements will be placed on
                        the specified mark_id.
parameter
parameter_name
parameter_name
The parameter to query. See the documentation for
                                *morphupdateparameter and
                                *morphupdateparameterstring for a list of supported
                              values.


testlimits
elem_type test_id
The query will return four arguments corresponding to the information
                        stored for the element checks used by *morphshapesmooth.
                        The first will be either ""active"" or ""inactive"" denoting the status of the
                        element test. The next three will be real numbers denoting the limits for
                        the warning, error, and invalid elements criteria.
elem_type
0 - trias 
1 - quads 
2 - tetras 
3 - pyras 
4 - pentas 
5 - hexas
test_id
0 - aspect ratio 
1 - skew 
2 - minimum angle 
3 - maximum angle 
4 - warpage 
5 - tetra collapse 
6 - jacobian


undolist current
Returns the current position in the undo/redo list.
undolist maximum
Returns the length of the undo/redo list. 





","Examples
To obtain the status and limits for the quad element Jacobian test:
hm_morph_getinfo testlimits 1 6
To get the number of 2D domains:
hm_morph_getinfo domaincount 2
To get the facecolor setting:
hm_morph_getinfo parameter facecolor
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
362,hm_morphupdatecheck,"Description
This command maintains the database with respect to HyperMorph
        entities. It checks for changes in the database on which HyperMorph entities depend, and if it finds any it calls commands that
        update those entities to account for the changes. For instance, if elements are deleted for
        a domain, this command will update all dependent domains, potentially add or remove handles,
        and recalculate the influences for all the affected domains. 
This command needs to be called before any morphing commands are called and after any
        commands are called which affect HyperMorph entities or the
        entities on which they depend. When HyperMesh is run
        interactively this command is called when you enter and leave any HyperMorph panel, the delete panel, or the
          shape panel. If HyperMesh is being run through
        an interface, this command can be called when any model is loaded into HyperMesh, before and after every HyperMorph command (the ones with ""morph"" in them), and after anything is deleted to ensure proper
        functioning.
","Example
To calculate and perform any necessary HyperMorph updates:
hm_morphupdatecheck
","Errors
None.
",
363,hm_proximitygetcomponentpair,"Description
Returns a specific proximity component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
364,hm_proximityinit,"Description
Checks the proximity between elements or components, and stores the results internally.
        Other APIs can be used to query the results. 
This must precede any calls to other hm_proximityget*/hm_proximitymark*
        APIs, and must be followed by a call to hm_proximityend.
","Inputs

entity_type
The type of entity to query. Valid values are elements and components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
max_distance
The maximum distance beyond which proximity is not reported.
mode
1 - Global proximity (default behavior if not specified) 
2 - Proximity between components (entity_type should be components
            only) 
3 - Self proximity within component (entity_type should be
            components only)
check_side
1 - Check both sides of the elements 
2 - Check the element normal side only 
3 - Check 'outward volume' side (default behavior if not specified) 
4 - check 'inward volume' side
proximity_scheme
0 - Checks basic proximity along a ray from the element center along the normal
            direction.
1 - Checks comprehensive proximity.  Reports any proximity within an imaginary
            offsetted volume of the element (default behaviour if not specified).
proximity_by_edge
0 - Ignores proximity for nearby edges (default behaviour if not specified).
1 - Considers proximity for nearby edges.
min_angle_limit
If the angle between the proximate element pairs is less than this value, such pairs
            are not reported.
max_angle_limit
If the angle between the proximate element pairs is greater than this value, such
            pairs are not reported.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
365,hm_removedieattribute,"Description
Removes the die attribute from an entity.
","Inputs

die_attribute
Valid values are: 
addendum 
binder 
fl 
tl
entity_id
The ID of the entity.

","Example
To remove the die attribute from the binder with ID 100:
hm_removedieattribute binder 100
","Errors
None.
"
366,hm_saveusermark,"Description
This command stores the IDs of entity_type that exist on
          mark_id on the user mark. Valid mark_ids are 1 and
        2. Only one user mark exists for each entity_type. 
The ?panel_sensitive? option can be used when multiple panel levels have
        been pushed, either using the shortcut function keys, or the hm_pushpanel
        command. This option determines whether to use the current panel or the previous panel for
        the operation. This option is relevant only when the mark has been created from a panel
        entity selector under the above conditions. Valid panel_sensitive options
        are: 
0 - Use the previous panel (default). 
1 - Use the current panel. 
The user mark is accessed either through the command hm_getusermark or
        through panel input collectors, hm_createmark and
          hm_appendmark via the ""retrieve"" option.
","Example
To save the user mark of properties 1,3 and 5:
m_createmark props 1 ""by id only"" ""1 3 5""
hm_saveusermark props 1
To create a mark of elements 1-3, save it to the element user mark and retrieve it
        later:
hm_createmark elems 1 ""1 2 3""
hm_saveusermark elems
hm_markclear elems 1
…
hm_getusermark elems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If mark_id is invalid, you will get the following error:
hm_saveusermark: invalid markmask specified
",
367,hm_setsolver,"Description
Sets theHyperMesh solver interface name in order to access
        entity information available for that solver.
","Inputs

name
Solver name keyword: 
abaqus 
ansys 
autodv 
dytran 
hyperopt 
ideas 
lsdyna 
marc 
masterfile 
moldflow 
nastran 
optistruct
pamcrash 
pamcrash2g 
patran 
pdm 
phlex 
simex



","Examples
Suppose LS-DYNA solver template is actually loaded here:
set loadedsolver [ hm_getsolver ];
Getting attributes for OptiStruct:
hm_setsolver optistruct;
set opt_thickness [ hm_getvalue comps id=3 dataname=PSHELL_T]; 
Resetting back to the original solver name:
hm_setsolver $loadedsolver; 
Note: This command does not actually load the solver template. It is intended only to
        temporarily switch solver type, get attribute information, and reset the solver name back to
        the original name.This operation is typically required during conversion between
        solvers.
","Errors
None.
"
368,hm_tableappend,"Description
Appends the contents of a HyperMesh table to another HyperMesh table of the same entity type. Creates a destination table if
        it does not exist.
","Inputs

table1
Destination table.
table2
TCL_OK(0) if successful. TCL_ERROR(1) otherwise

","Example
To combine the content of two HyperMesh tables:
# Creating 2 tables
*createmark comp 1 1
hm_marktotable comp 1 t1
*createmark comp 1 2
hm_marktotable comp 1 t2
# Appending t2 to t1
hm_tableappend t1 t2       
# T1 now contains comp 1 and 2.

","Errors
None.
"
369,hm_tableclearall,"Description
Clear all tables (all memory is freed). 
","Errors
None.
",,
370,hm_tableintersection,"Description
 Finds subset of entities common to two HyperMesh tables of the
        same entity type and places it into the first table.
","Inputs

table1
First table.
table2
Second table. 
TCL_OK(0) if successful. 
TCL_ERROR(1) otherwise 

","Example
This command can be used to find entities common for two HyperMesh tables.
# Creating 2 tables
*createmark comp 1 1 2 
hm_marktotable comp 1 t12
*createmark comp 1 2 3
hm_marktotable comp 1 t23
# Copying table
hm_tablecopy t12 tcom;
hm_tableintersection tcom t23; 
# tcom contains comp 2 now

","Errors
None.
"
371,hm_tablelookup,"Description
 Search a table for an entity ID. The constant 1 is returned if the ID is found. Otherwise,
        0 is returned. 
","Inputs

tableName
The name of the table.
id
The ID to search for. 

","Example
When the current model is deleted, or a new model is loaded, all tables are cleared. See
          hm_marktotable for a sample use of hm_tablelookup. 
","Errors
None.
"
372,hm_triplecos,"Description
Get the cosine angle of two vectors.
","Inputs

X0 y0 z0 
x1 y1 z1 
Definition of two vectors. 
A double value of cosine angle between these two vectors.

","Example
hm_triplecos  0.0  0.0 1.0  1.0 0.0 0.0 
result: 0.0   
","Errors
None.
"
373,hm_wadlinesgetsectionmax,"Description
Returns the most outward intercept of a cross section of the model as measured in a given
        direction. A plane, located at the given origin and with the given normal, is cut through
        the model and points are generated where all elements and surface facet edges are bisected
        by the plane. The dot product of each point and the given direction is used to determine
        which point is the maximum point lying in the plane. 
This is intended to assist in the positioning of impact devices.
","Inputs

origin_x, origin_y, origin_z
Define the origin of the plane used to cut the cross section.
plane_x, plane_y, plane_z
Define the normal vector of the plane used to cut the cross section.
dir_x, dir_y, dir_z
Define the vector used to evaluate the each point on the cross section.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetsectionmax 0 0 0 1 0 0 0 1 0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
374,hf_getdrawbeadforce ,"Description
This command returns the locking condition, restraint force, closure force and final
        force.
","Inputs

material_name
Name for the material
thickness
Blank thickness
height
Draw bead height
radius
Draw bead radius
shoulder_radius
Shoulder radius
friction
Friction
type
Shape type: 
1 - round 
2 - step 
3 - square

","Example
set returnValue [hf_getdrawbeadforce ""CRDQ"" 1.0 1.0 6.25 6.25 0.125 1]
set locking [ lindex $ returnValue 0 ]
set restraint [ lindex $ returnValue 1 ]
set closure [ lindex $ returnValue 2 ]
set final [ lindex $ returnValue 3 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
375,hm_ae_findattachmentsfromFEs,"Description
Returns resolved link entity information.
","
Inputs


entity_type
The type of entity to find atachments for.  Valid values are elements.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
select
Flag to select attachments found in connector browser (1) or not (0).

","Examples
Find attachments for realized elements 4 and 5:
*createmark elems 1 4 5
hm_ae_findattachmentsfromFE elems 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
376,hm_ae_getfe,"Description
Returns the elements from the realized attachment.
","
Inputs


id
The ID of the attachment to query.
entity_type
The type of entity to query.  Valid values are elements.

","Examples
To get the elements from attachment 2:
hm_ae_getfe 1 elems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
377,hm_allentitiesinfo ,"Inputs

entityType
Type of entity.

","Example
For the model on the left (assemblies denoted with folders, components with sheets),
        commands hm_allentities assemblies and hm_allentities
          components would generate the respective outputs on the right.

Figure 1. 

{base 1 1 1 3} {attachments 2 1 1 3} {wheel 3 0 0 3} {head 4 1 1 3} {empty 5 0 0 3}
{Part1 1 1 1 7 -1 -1} {Part2 4 1 1 10 -1 -1} {Part4 7 1 1 13 -1 -1} {Part3 9 1 1 15 -1 -1}	
",,
378,hm_appendmark,"Description
Appends entities on a mark based on user supplied options.
In addition to the options below, all of the options for hm_createmark
        are also supported.  See that topic for more details on those options, and general behaviors
        of both commands.
","Inputs

entity_type
Entity type to use. Depending on the options specified, the supported entity types
            will change.
mark_id
The ID of the mark.  Valid values are 1 and 2.
""by model"" <model_name>
The optional model to append the mark from.  If not specified, the current model is
            used.
?""options""?


","Examples
To delete the elements adjacent to the elements in components with names FRONT and
        SIDE:hm_createmark elems 1 ""by comp name"" ""FRONT SIDE""
hm_createmark elems 2 ""[hm_getmark elems 1]""
hm_appendmark elems 1 ""advanced"" ""by adjacent""
*markdifference elems 1 elems 2
*deletemark elems 1
To translate all of the elements attached to element 40404 by
        (5,0,0):hm_createmark elems 1 40404
hm_appendmark elems 1 ""advanced"" ""by attached""
*createvector 1 1.0 0.0 0.0
*translatemark elements 1 1 5
To mark elements that share a face with elements 50 and
        100:hm_createmark elems 1 ""50 100""
hm_appendmark elems 1 ""advanced"" ""by face""
To mark elements that share a face with elements 50 and 100 for model
        model-2:hm_createmark elems 1 ""by model"" model-2 ""50 100""
hm_appendmark elems 1 ""by model"" model-2 ""advanced"" ""by face""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
379,hm_attributebehavior ,"Description
Returns the behavior flag of an attribute on an entity for the current template. If the
        attribute does not exist on the entity, or is not an attribute from the current template, an
        error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute behavior of the attribute named Rho on material 6 for the LS-DYNA template:
hm_attributebehavior material 6 Rho -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
380,hm_attributeentitytypename,"Description
Returns the entity type string of an entity attribute on an entity for the current
        template. If the attribute does not exist on the entity, or is not an attribute from the
        current template, an error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the attribute entity type string of the entity attribute with name LSD_CID on
        property 1 for the LS-DYNA template:
hm_attributeindexentitytypename props 1 LSD_CID -byid
To get the attribute entity type string of the entity attribute with ID 412 on property 1
        for the LS-DYNA template:
hm_attributeindexentitytypename props 1 412 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
381,hm_attributeidfromname,"Description
Returns an attribute ID from the attribute name for the current template. If the attribute
        does not exist in the current template, an error is returned.
","Inputs

attribute_name
The name of the attribute to query.

","Example
To get the attribute ID of the OptiStruct PSHELL_T
        attribute:
hm_attributeidfromname PSHELL_T
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
382,hm_attributeindexentitytype,"Description
Returns the entity type number of an indexed entity attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute entity type number of the entity attribute with index 4 on property
        1:
hm_attributeindexentitytype props 1 4 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
383,hm_attributeindexidentifier,"Description
Returns the identifier flag of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute identifier of the attribute with index 3 on material 6:
hm_attributeindexidentifier material 6 3 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
384,hm_attributeindexstatus ,"Description
Returns the status flag of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute status of the attribute with index 3 on material 6:
hm_attributeindexstatus material 6 3 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
385,hm_attributeindextypename,"Description
Returns the attribute type string of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute type string of the attribute with index 4 on property 1:
hm_attributeindextypename props 1 4 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
386,hm_attributelistall,"Description
Returns a list of all attribute IDs, names, types or type names for the current
        template.
","Inputs

value
The type of list to return. Valid values are: 
id - the attribute ID 
name - the attribute name 
type - the attribute type number 
typename - the attribute type string

","Examples
To list the IDs of all the attributes in the current template:
hm_attributelistall id
To list the names of all the attributes in the current template:
hm_attributelistall name
To list the type number of all the attributes in the current template:
hm_attributelistall type
To list the type name of all the attributes in the current template:
hm_attributelistall typename
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
387,hm_attributereferencecount,"Description
Returns the number of times an entity is referenced as an entity attribute.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the number of times material 6 is referenced as an entity attribute:
hm_attributereferencecount material 6 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
388,hm_attributestatus,"Description
Returns the status flag of an attribute on an entity for the current template. If the
        attribute does not exist on the entity, or is not an attribute from the current template, an
        error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the attribute status of the attribute named Rho on material 6 for the LS-Dyna
        template:
hm_attributestatus material 6 Rho -byid
To get the attribute status of attribute ID 118 on material 6 for the LS-Dyna template:
hm_attributestatus material 6 118 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
389,hm_attributetypename,"Description
Returns the attribute type string of an attribute for the current template. If the
        attribute is not an attribute from the current template, an error is returned.
","Inputs

attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.

","Examples
To get the attribute type string of the attribute named LSD_PID for the LS-DYNA template:
hm_attributetypename LSD_PID
To get the attribute type string of the attribute ID 149 for the LS-DYNA template:
hm_attributetypename 149
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
390,hm_bag_getentitytypes,"Description
This command returns the types of entities in a bag.
","Inputs

name_or_id
The name or ID of the queried bag entity.
?search_type?
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname - Search only by name 
-byid  - Search only by ID

","Example
If a bag ossetup1 consists of optimization responses and desvarlinks, then the following
        command will return ""desvarlinks optiresponses"":
hm_bag_getentitytypes ossetup1 -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
391,hm_bag_getsupportedconfiglist,"Description
This command returns a list of the supported bag configs.
","Inputs

?-byname?
By default, HyperMeshreturns the bag config. If this
            option is specified, the generic name for each bag config is returned instead.

","Examples
To get the list of generic names for all supported bag configurations:
hm_bag_getsupportedconfiglist -byname
To get list of supported bag configs:
hm_bag_getsupportedconfiglist
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
392,hm_batchexportenginefile,"Description
Exports Radioss engine and starter files.
","Inputs

type
The type of file to write: 
1 - Export engine file only 
2 - Export engine file and starter model file separately. 
3 - Export engine file and starter model file as a single file.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes. 
This is the starter file name. The engine file name is derived from this name.
export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes. Required only for type=2 and
              type=3.

","Examples
To export only the engine file (the engine file name starterD01 is derived from the model
        file name starterD00. starterD01 will be the name of the engine file that will be
        exported):
hm_batchexportenginefile 1 ""C:/my_files/starterD00"" ""[hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/radioss/radioss110.blk""
To export both the starter and engine files separately (the starter file is named
        starterD00 and the engine file is named starterD01):
hm_batchexportenginefile 2 ""C:/my_files/starterD00"" ""[hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/radioss/radioss110.blk""
To export both the starter and engine files as a single file (named starterD00):
hm_batchexportenginefile 3 ""C:/my_files/starterD00"" ""[hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/radioss/radioss110.blk""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
393,hm_ce_alldetailsget,"Description
Returns all custom details assigned to a connector.
","Inputs

id
The ID of the connector to query.
reserved
Reserved for future use. Must be set to 0.

","Example
To get all the details associated with connector ID 1:
hm_ce_alldetailsget 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
394,hm_ce_checklinkentities,"Description
Returns the names or IDs of entities added to the connector that currently do not exist in
        the database. 
If any entities of a certain type are not present in the database, those are not returned.
        If all entities of a certain type are not present, an empty list is returned.
","Inputs

id
The ID of the connector to query.
entity_type
The type of entity to check. Valid values are assems, comps, elems, nodes, surfs and
            tags.
return_type
0 - Return the entity IDs 
1 - Return the entity names (supported only for assems, comps and tags)

","Example
To check if components added to connector ID 1 exist:
hm_ce_checklinkentities 1 comps 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
395,hm_ce_close_mcf,"Description
Ends the process of reading a master connector file, triggered by
          hm_ce_read_mcf.
","Example
Open test.mcf to read all the data and close the file when
        finished:
hm_ce_read_mcf ""C:/doc/test.mcf""
set get_all_data [hm_ce_mcf_getalldata]
hm_ce_close_mcf
","Errors
None.
",
396,hm_ce_detailget,"Description
Returns the value of a double, string or integer attribute on an entity for the current
        template. If the attribute does not exist on the entity, or is not an attribute from the
        current template, an error is returned.
","Inputs

id
The ID of the connector to query.
detail_type
The data type for standard or user defined detail: int, intarray, uint, uintarray,
            double, doublearray, string, stringarray, triple, or triplearray.
detail_name
A user-defined detail, or the name for one of standard details from the following
            table:

Table 1. 

Detail Name
Type
Range
Meaning




ce_allowadjacent
int
0,1
Allow adjacent projection flag


ce_appliedmass
double
>=0.0
Applied mass value


ce_appliedmassdis
int
0,1,2,3
Applied mass distribution type: 0=div. by nodes
1=all
                        nodes
2=div. by area
3=unit area



ce_areaconstthickness
double
>=0.0
Constant thickness of area


ce_areastacksize
int
>=0
Density of area connector


ce_areathicknesstype
int
0,1,2,3
Thickness type of area connector:0=(T1+T2)/2
1=shell
                        gap
2=mid-thickness
3=constant



ce_boltmaxdiameter
double
>=0.0
Max. diameter for bolt hole


ce_boltmindiameter
double
>=0.0
Min. diameter for bolt hole


ce_collectorid
int
>0
Comp ID of the connector entity


ce_collectorname
string
N/A
Comp name of the connector entity


ce_configname
string
N/A
FE config name of the realized connector


ce_configval
int
>=0
FE config value of the realized connector


ce_connectivity
string
Independent, FE connecivity dependent,use_shell_node, etc.
Connector’s FE connectivity


ce_cords
triple array
N/A
Coordinates of the connector


ce_density
int
>=0
Density value of line or seam


ce_diameter
double
>=0.0
FE diameter


ce_fesolver
string
Nastran, etc.
FE solver name


ce_fetype
int
>=0
Realized FE type value defined in ""feconfig.cfg""
                      file


ce_fetypename
string
N/A
Realized FE type name defined in ""feconfig.cfg""
                      file


ce_fevectorreverse
int
0,1
Vector reverse flag


ce_forcecollinear
int
0,1
Force collinear flag


ce_group
unit array
N/A
Lists the connector and any grouped to it


ce_half_spacing
int
0,1
Half-spacing offset flag for seams or lines


ce_ijk
triple
N/A
Connector’s projection vector


ce_layers
int
-,+,0
Connector’s defined thickness


ce_nonnormal
int
0,1
Allow non-normal projection flag


ce_numlinks
int
>0
Connector's number of current links


ce_offset
double
>=0.0
End offset value for a line


ce_positionstring
string
N/A
A list containing the entity_type followed by the entity IDs selected to
                      create the connector.


ce_projection_info
string
N/A
Projection information stored from last realization


ce_propertyid
int
>=0
FE property ID


ce_propertyscript
string
N/A
Property script name and path


ce_remesh
int
0,1
1 for mesh-independent, 0 otherwise


ce_size
double
>0,0
Connector display size


ce_snaptonode
int
0,1
 


ce_spacing
double
>0.0
Spacing value for lines or seams


ce_state
string
realizedunrealized
failed

Connector entity state


ce_style
string
spotbolt
app_mass
seam
area

Connector style


ce_systems
int
0,1
FE build system flag


ce_trimsurfeachside
int
0,1
Trim surf each side flag for area


ce_tolerance
double
>=0.0
Tolerance value specified during FE realization


ce_type
string
node/pointline
seam
area

Connector entity type based on its creation


ce_usercontrol
int
0,1
User control flag






","Examples
To get the ID of the collector containing the connector:
hm_ce_detailget 1 int ce_collectorid
To get the list of internal test point coordinates:
hm_ce_detailget 1 triplearray ce_cords
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
397,hm_ce_fe_config,"Description
Gets the weld config defined for the connector.
","Inputs

ce_id
The ID of the connector. 
type_or_name
Flag to return number ( = 0) or name (= 1).

","Example
To get the config for the last connector created:
set ce_id [ hm_entitymaxid CONNECTORS ];
set type_or_name 0;
set config [ hm_ce_fe_config $ce_id $type_or_name];
Returns the weld config stored for connector realization. To get the name of the weld
        configuration, use flag as 1.
","Errors
None.
"
398,hm_ce_findduplicates,"Description
Returns a list of connectors that are considered to be duplicates of other connectors,
        within a given tolerance.
","Inputs

tolerance
The maximum distance between connectors to be considered as duplicate.
mark_id
The ID of the mark containing the connectors to consider. Valid values are 1 and 2.
location_type
The connector location type. Currently only supported for ""point"".

","Example
To get all duplicate connectors within a tolerance of 0.05:
*createmark connectors 1 all
hm_ce_findduplicates 0.05 1 point
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
399,hm_ce_generatenamefromsubsystem,"Description
Returns a name using a base name and connector subsystem ID.
This returns a string like <base_name>_ss<ID> where ID is the subsystem ID of the
        connector.
","
Inputs


id
The ID of the connector to query.
base_name
The base name to append.

","Examples
To generate a name for connector 2 and the base ""hexa_comp"":
hm_ce_generatenamefromsubsystem 2 ""hexa_comp""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
400,hm_ce_getcesnotorganizedinconnectorgroups,"Description
Returns the IDs of connectors not organized in any ConnectorGroup.
","
Inputs
None.","Examples
set unorganized_connectors [hm_ce_getcesnotorganizedinconnectorgroups]
",ErrorsNone.
401,hm_ce_getconnectorcontrol,"Description
Returns the type, ID, and name of the connector control/connector control default assigned
        to a given connector.
","
Inputs


id
The ID of the connector to query.

","Examples
To get the connector control or connector control default for the connector with ID
        101:
set ctrl_info [hm_ce_getconnectorcontrol 101]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
402,hm_ce_getcords,"Description
Returns the location of the connector.
","Inputs

ce_id
The ID of the connector.

","Example
To get the coordinate of the connector with ID of 1:
*createmark connectors 1 ""by comp"" ce_component
set ce_list [ hm_getmark connectors 1];
foreach ce_id $ce_list {
     if {  $ce_id == 1 } {
        set ce_cords_1 [ hm_ce_getcords $ce_id ];
       break;
     }
}
","Errors
None.
"
403,hm_ce_getediabsorbedmassgrplist,"Description
Returns the group list for the absorbed mass connectors.
","
Inputs

None.
","Examples
To get the absorbed mass groups:
set edi_absorbed_mass_grps [hm_ce_getediabsorbedmassgrplist]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
404,hm_ce_getfeprojfeatureelems,"Description
Returns the independent or dependent layer of feature elements. Returns an empty string if
        there are no elements. 
This is supported for: spot ""acm"" ""style = 5"" (feature elements are washer elements) 
This should only be called from within a connector-registered property script. The
        projection data this relies upon is destroyed immediately after connector FE
        realization.
","Inputs

index
The index of interest in the array (corresponds to a weld).
layer
0 - Return the dependent layer 
1 - Return the independent layer

","Example
To get the independent layer feature elements for index 5:
hm_ce_getfeprojfeatureelems 5 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
405,hm_ce_getfeprojweldnodes,"Description
Returns the independent or dependent layer of nodes belonging to weld elements. Returns an
        empty string if there are no elements. 
This is supported for: 


Radioss 71 acm (shell gap contact + coating) 
LS-DYNA 122 mat196 (single row) 
Seam and area adhesives 


This should only be called from within a connector-registered property script. The
        projection data this relies upon is destroyed immediately after connector FE
        realization.
","Inputs

index
The index of interest in the array (corresponds to a weld).
layer
0 - Return the dependent layer 
1 - Return the independent layer

","Example
To get the independent layer weld element nodes for index 5:
hm_ce_getfeprojweldnodes 5 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
406,hm_ce_gethmholes,"Description
Get bolt holes information from components. 
","Inputs

mark
Component mark
upbound
Maximum diameter to be considered a bolt hole
lowbound
Minimum diameter to be considered a bolt hole
outerFlag
Output the nodes of the outer circle around bolt holes (yes = 1, no = 0)
elementFlag
Output the elements around bolt holes (yes = 1, no = 0)
orderFlag
Output nodes in order (yes = 1, no = 0)

","Example
To get the bolt holes between 0.0 to 15.0 from comps 1, 2:
*createmark(comps, 1) 1, 2
hm_ce_gethmholes 1 15.0 0.0 0 0 0
The results—Including componet ids, the centers of bolt holes, and node ids around bolt holes—would look like this:
{1 {{4.69760749465 -4.81066850679 5.0} {3107 4357 4359 4363 4361 4370 4376 4368 4366 3300 4369 4371 4364}} 
{{-5.75024512823 4.10484549438 5.0} {3108 4383 4390 4389 4397 4392 4398 4386 4387 4388 4384 3152 4385}} 
} 
{2 {{4.69760749465 -4.81066850679 0.0} {1768 1769 1770 1771 1772 1760 1761 1762 1763 1764 1765 1766 1767}}
}
","Errors
None.
"
407,hm_ce_getlinkentityinfo,"Description
This command returns specific entity information such as entity type, entity name/ID,
        entity meshed state and re-connect rule. The values are returned as a list in the order
        type, info, state, rule.
","Inputs

id
The ID of the connector.
index
The link index into the connector.

","Example
To get entity information for connector ID 1 for all links:
set ce_id 1
set num_ents [hm_ce_numlinkentities $ce_id]
for {set count 0} {$count <= $num_ents} {incr count} {
  foreach {type info state rule} [hm_ce_getlinkentityinfo $ce_id $count] {
    lappend linkArray($type) $info
  }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
408,hm_ce_getnumoffeprojinfo,"Description
Returns the number of projection data stored in the array (size of array). 
","Example
To get the number of projection data array size:
set num_of_projs [ hm_ce_getnumoffeprojinfo ];
This function should only be called from within a connector-registered property script
        (which is executed during connector FE realization). The projection data this function
        relies upon is removed immediately after connector FE realization. 
The number of projection data array size is equal to the total number of welds created in
        the model.
",,
409,hm_ce_getprojectiondata,"Description
The returned data is organized into a single master list. Each element of this master list
        is a sublist that contains the requested connector ID, point ID, or node ID, and a list of
        the successfully created projections (the proj_list) for the given ID. The format of a
        single sublist is given as follows:
{ {connector/point/node_id}  $proj_list } 
Where proj_list for 2 projections = {{comp1_id}{elem1_id}{x1 y1 z1}{u1 v1}} {{comp_2_id}{elem2_id}{x2 y2 z2}{u2 v2}}
The potentially large list this function may return, may not be the best-suited data format
        for most processing cases. Therefore, it is highly recommended that you use the
        ::CE::GetProjectionData Tclwrapper function instead. This function
        accepts the same set of parameters that the hm_ce_getprojectiondata function requires, but
        instead of returning a single large master list, it returns a randomly accessible array. The
        array is accessible through its use of the connector/point/node ID as the index, and at this
        index is the $proj_list.
","Inputs

entType1
Entity type on mark 1 for which projection is sought.
mark1
Mark of connectors/points/nodes that define the locations of interest.
entType2
Entity type on mark 2 to which the connectors/points/nodes are to be projected (comps
            only).
mark2
Mark of components to be projected onto.
numproj
Number of projections requested at the specified points (>0).
tolerance
Tolerance value for filtering projections (will be used with ""numprojs"").
order
0 = ordered by closest 
1 = ordered through a line
output
Parameter to obtain desired output (specific projection data).
projFlag
Parameter used for projecting to COMPS (current value is zero).
projFlag2
Parameter used for non-normal projections (normal = 0, non-normal = 1).

","Example
*createmark points 1 ""displayed"";
*createmark components 1 ""displayed"";
set num_projs 2;
To get the projection data for displayed points on displayed components as a list of
        list:
set  proj_data_list [ hm_ce_getprojectiondata points 1 comps 1 $num_projs 0.0 0 0 0 0];
This function is optimized for the case where the projection data is required for a number
        of different connectors, points, or nodes, and the components that they need to be projected
        onto are unknown. It is especially useful for close quarter welding scenarios. 
A proj_list consists of 0 or more projections in a list, with each projection having some
        or all of the following information:
{ {comp_id} {elem_id} {x y z} {u v} } 
Note  The ""output"" option determines what is returned for a given projection: 
0 = ALL (data shown above) 
1 = comp_id and elem_id 
2 = comp_id, elem_id, and x y z 
3 = comp_id, elem_id, face and x y z 
4 = comp_id, elem_id, face, x y z and u v 

The ""face"" value will be a non-negative number when valid external face for solid
        element is found during projection. If a valid face cannot be determined or if projection
        finds a shell element then the ""face"" value will be -1. 
The number of projections can be found from using ""llength"" on the proj_list (which is
            especially easy to do when the ::CE::GetProjectionData function is used). 
The ""order"" parameter returns the projection data in the requested ordering based on
            the closest distance to the projected connector/point/node (0) or ordered as a line (1). 
The ""projFlag2"" parameter (value of 1) is used for obtaining non-normal projections
            useful for MIG-Welds. By default, it has a value of 0, which will return normal
            projections.


","Errors
None.
"
410,hm_ce_getprojfesize,"Description
Returns the number of welds created in a layer. This includes weld and rigids.
","Inputs

index
The index of interest in the projection data array.

","Example
To get the number of welds created at index 2:
set num_of_projs [hm_ce_getnumoffeprojinfo ];
foreach index $num_of_projs {
       if { $index == 2 } {
           set num_welds [ hm_ce_getprojfesize $index ];
           break;
       }
}
This function should only be called from within a connector-registered property script
        (which is executed during connector FE realization). The projection data this function
        relies upon is removed immediately after connector FE realization. 
If at a given location (say between comp 1 and comp 2) spring is created with plot elements
        then the number of welds will be 3. 
","Errors
None.
"
411,hm_ce_getresolvedlinkentities,"Description
Returns the link information for the resolved entities organized per link-index. The output
        will contain the entity ID if the link-entity is present in current model else it will be
        0.
","
Inputs



ce_id

The ID of the connector to query.

link_entity_type

The link entity type to query.

","Examples
For connector ID 7 with link 1 as component_1, link 2 as component_2, and both components
        exist in the model:
hm_ce_getresolvedlinkentities 7 comps;
output: 1 2
hm_ce_getresolvedlinkentities 7 parts;
output: 0 0
For connector ID 7 with link 1 as component_1, link 2 as component_2, and only component_1
        exists in the model:
hm_ce_getresolvedlinkentities 7 comps;
output: 1 0
hm_ce_getresolvedlinkentities 7 parts;
output: 0 0
For connector ID 7 with link 1 as {component_1 component_2}, link 2 as component_3, and
        only component_1 and component_3 exist in the model:
hm_ce_getresolvedlinkentities 7 comps;
output: {1 0} 2
hm_ce_getresolvedlinkentities 7 parts;
output: {0 0} 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
412,hm_ce_gettestpoints,"Description
Gets the test point(s) from the connector.
","Inputs

ce_id
The ID of the connector.

","Example
To get the test point(s) location from the connector:
set ce_id [ hm_entitymaxid CONNECTORS];
set pt_cords [ hm_ce_gettestpoints $ce_id];
If the connector is created at a node/point, the coordinate of the node/point is returned.
        If the connector is created using a line, all the points along the line are returned. The
        number of points will depend on the offset, spacing, and density values defined.
","Errors
None.
"
413,hm_ce_getunsyncdata,"Description
Returns data which are not synchronized from the connectorcontrol assigned to a
        connector.
","
Inputs


id
The ID of the connector to query.
option
0 - Returns common data
1 - Returns unique data on connector
2 - Returns unique data on connectorcontrol

","Examples
To get unique data from the connector with ID 101:
set unique_data [hm_ce_getunsyncdata 101 1]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
414,hm_ce_globalget,"Description
Get global variables related to connector display.
","Inputs

global_type
double or int
global_name
one of the following: 
g_ce_colorby 
g_ce_realizedvis 
g_ce_unrealizedvis 
g_ce_failedvis 
g_ce_lt2tvis 
g_ce_2tvis 
g_ce_3tvis 
g_ce_gt3tvis 
g_ce_spotvis 
g_ce_seamvis 
g_ce_areavis 
g_ce_boltvis 
g_ce_applymassvis 
g_ce_size 

","Example
hm_ce_globalget int g_ce_failedvis

","Errors
None.
"
415,hm_ce_info,"Description
Returns the requested information from a specified connector entity.
If the request is not found, an empty string is returned. If the request is not supported,
        an error string is returned.
","Inputs

id
The ID of the connector to query.
option
The name of the option to query.
allowadjacent
The allow adjacent projection flag value.
appliedmass
The applied mass value.
appliedmassdis
The applied mass options value.
areathicknesstype
The option to position hexas between shells.
areastacksize
The number of hexa coatings.
area_maint_gaps
The gap value between hexa faces and shells.
bodylen
The bolt body length value.
boltmaxdiameter
The maximum diameter for bolt hole recognition.
boltmindiameter
The minimum diameter for bolt hole recognition.
boltthread
The bolt thread length metadata value.
coarse_mesh
The flag that indicates the chosen center.
collectorid
The ID of the parent component.
collectorname
The name of the parent component.
comp
The ID of the parent component.
configname
The FE configuration name of the realized connector.
configval
The FE configuration value of the realized connector.
connectivity
The connectivity between realization and links is mesh dependent or
                  independent.
connectivitynum
The connectivity between realization and links is mesh dependent or
                  independent.
cords
The x, y, z coordinates of the connector.
density
The density value for a line connector.
dia_factor
The cylinder bolt diameter factor value.
diameter
The diameter value.
dir_assign
The value for the CE_FE_DIR_PROP_ASSIGN flag.
dircfindnode
The CE_FE_DIRC_FIND_NODE flag value.
dircords
The x, y, z coordinates of the direction node.
fe_vector
The flag that indicates if a vector is created during realization.
fesolver
The FE solver name.
fetype
FE type value for a realized connector as defined in the
                    feconfig.cfg file.
fetypename
FE type name for a realized connector as defined in the
                    feconfig.cfg file.
fevectorreverse
The flag that indicates whether direction reversal is allowed during
                  realization.
forcecollinear
The FE force collinear flag value.
group
The specified connector and other connectors if grouped.
half_spacing
The half-spacing offset flag for seams or lines.
ijk
The vector definition used for realization.
l1
The cylinder bolt length for the L1 direction.
l1d1
The metadata stored for cylinder bolt diameter for L1 direction.
l2
The cylinder bolt length for the L2 direction.
l2d2
The metadata stored for cylinder bolt diameter for L2 direction.
layers
The number of thickness layers (2T/3T) for the connector.
location
The coordinates for point and line connectors.
meshimprint
The CE_FE_MESH_IMPRINT flag value.
nonnormal
The value that indicates whether non-normal projection is allowed during
                  realization.
numlinks
The number of link entities for the connector.
offset
The offset value for a line connector.
positionstring
The connector position with ID.
projfindnode
The CE_FE_PROJ_FIND_NODE flag value.
prop_opt
The property assignment options.
propertyid
The property ID value.
propertyscript
The post-realization property creation options.
realizeto
The option for organizing the realization results.
remesh
Returns 1 for mesh dependent, 0 otherwise.
size
The display size.
snaptonode
The FE snap to node flag value.
spacing
The spacing value for a line connector.
state
The state of the connector entity.
style
The style of the connector entity.
systems
The systems creation requirement.
tolerance
The tolerance specified during realization.
trimsurfeachside
The trim surf each side flag for area connectors.
type
The connector entity type during its creation.
usercontrol
The user control flag (0 or 1).



","Example
To get the state and number of links for connector 15:
set ce_state  [hm_ce_info 15 ""state""]
set num_links [hm_ce_info 15 ""numlinks""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
416,hm_ce_mesh_imprint_option_get,"Description
Returns a mesh imprint option value.
","Inputs

name
Valid names are: 
avoid_imprint 
avoid_int_snapping 
keep_snap 
skip_imprint 
skip_overlap_check 
strict_imprint

","Example
To get the value of avoid_imprint:
hm_ce_mesh_imprint_option_get avoid_imprint
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
417,hm_ce_numlinkentities,"Description
Returns the number of link entities for the connector.
","Inputs

id
The ID of the connector to query.

","Example
To get link information for connector ID 1 for all links:
set ce_id 1
set num_ents [hm_ce_numlinkentities $ce_id]
for {set count 0} {$count <= $num_ents} {incr count} {
  foreach {type info state rule} [hm_ce_getlinkinfo $ce_id $count] {  
    lappend linkArray($type) $info  
  }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
418,hm_ce_projecthexaface,"Description
This option applies to the connector ACM realization in order to control the creation of
        hexa elements that are tied to the surrounding shells using RBE3s. Turning the option on
        will result in the following: 
ACM hexa faces are created such that the face edges are orthogonal (this is especially
        necessary when the surrounding shell mesh has tria elements or quads that are non-rectangle
        in shape). 
The nodes that define the ACM hexa face are projected to surrounding shells for shell gap
        option (useful in cases where the connecting shell mesh defines curved parts). 
This command only needs to be run once for each HyperWorks Desktop session.
","Inputs

state
Flag indicating whether to disable (0) or enable (1) the option.

","Example
To enable the option:
hm_ce_projecthexaface 1
","Errors
None.
"
419,hm_ce_setfeorientaxis,"Description
Set the axis aligned with the welds for the coordinates systems created during realization
        process.
","Inputs

axis
The axis that needs to be oriented along the weld: 
0 x axis 
1 y axis 
2 z axis

","Example
To set y axis aligned with the welds:
hm_ce_setfeorientaxis 1
","Errors
None.
"
420,hm_ce_tooclosetoedgecheck,"Description
Checks if connectors are too close to an edge.
It returns an array of data with {connector_id {comp_id {location} {element_id distance}}}.
        The array is empty if all connectors are ok.
","Inputs

entity_type1
Must be set to connectors.
mark_id1
The ID of the mark containing the connectors to check. Valid values are 1 and 2.
entity_type2
Must be set to comps.
mark_id2
The ID of the mark containing the components to check. Valid values are 1 and 2.
distance
The minimum distance to the edge.
feature_angle
The feature angle to consider.
edge_option
0 - Free edges
1 - Both edges
2 - Feature edges
auto-fix
0 - Do not auto fix bad connectors
1 - Auto fix bad connectors

","Example
To check all connectors against comps 2 and 3, using a distance of 3.0:
*createmark connectors 1 all
*createmark comps 2 2 3
hm_ce_tooclosetoedgecheck connectors 1 comps 2 3.0 0.3 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
421,hm_ce_xmlstringget,"Description
Returns connector information in XML format. 
","Inputs

id
The ID of the connector to query.

","Example
To get the XML formatted information for connector 100:
hm_ce_xmlstringget 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
422,hm_checkproximity,"Description
Checks proximity between input entities and returns list of entities within the specified
        proximity. The output depends on the mode argument as defined below.
","Inputs

entity_type
The type of entity to check. Valid values are elems and comps (only elems in comps are
            considered).
mark_id
The ID of the mark containing the entities to check. Valid values are 1 and 2.
max_proximity

The maximum distance beyond which an entity is not considered.

mode
1 - Global proximity (default) 
2 - Proximity between components (entity_type must be comps) 
3 - Self proximity within components (entity_type must be comps) 
When set to 1, returns two lists of element IDs. The first list contains the elements
            for which a proximity is found. The second list contains the paired elements for the
            elements in the first list. 


E.g. {1, 2, 3, 4}{6, 6, 1, 1}


When set to 2 or 3, returns one list per input component. The first item in each list
            is the component ID. The first sub-list contains elements for which proximity is found.
            The second sub-list contains the paired elements. 
When set to 2: 


E.g. {compid1, {elements within proximity} {paired elements from other
                components}} {compid2, {elements within proximity} {paired elements from other
                components}} etc. 


When set to 3: 


E.g. {compid1, {elements within proximity} {paired elements from same component}}
                {compid2, {elements within proximity} {paired elements from same component}}
                etc.


check_side
1 - Check both sides of elements 
2 - Check only the element normal side 
3 - Check 'outward volume' side (default) 
4 - Check 'inward volume' side
proximity_scheme
0 - Checks basic proximity along a ray from the element center along the normal
            direction.
1 - Checks comprehensive proximity.  Reports any proximity within an imaginary
            offsetted volume of the element (default behaviour if not specified).
proximity_by_edge
0 - Ignores proximity for nearby edges (default behaviour if not specified).
1 - Considers proximity for nearby edges.
min_angle_limit
If the angle between the proximate element pairs is less than this value, such pairs
            are not reported.
max_angle_limit
If the angle between the proximate element pairs is greater than this value, such
            pairs are not reported.

","Example
To find proximity between all components using a max distance of 2.5:
*createmark comps 1 all 
hm_checkproximity comps 1 2.5
{{201 200 199 198 197 196 195 194 225 224 223 222 221 220 219 218} {221 219 220 218 225 223 224 222 197 195 196 194 201 199 200 198}}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
423,hm_collisionend,"Description
Clears memory and ends the collision detection module. This must be preceded by any calls
          to hm_collisioninit, hm_collisionentitycreate and
          hm_collisioncheck.
Note that this does not include the core collision entity.  These commands do not operate
        on those entities, only on temporary memory.
","Examples
To find intersecting surfaces from IDs 1-10:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0
hm_collisionend
hm_getmark surfs 1
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0
hm_collisionend
hm_getmark surfs 1
To find both penetrating and intersecting surfaces from IDs 1-10, using the thickness
        assigned to the surface components:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 2 0 0 0
hm_collisionend
hm_getmark surfs 1
hm_getmark surfs 2
","Errors
None.
",
424,hm_collisiongetcomponententitypair,"Description
Returns the entity details for an entity collision pair. This must be preceded by a call to
        relevant hm_collision* commands to generate the collision data. In
        addition, the pair_results flag to hm_collisioncheck
        must be set to 1. 
For intersections, this returns a list of values that contains: 
entity_type1 entity_id1 face_index1 entity_type2 entity_id2 face_index2


For penetrations, this returns a list of values that contains: 
entity_type1 entity_id1 face_index1 entity_type2 entity_id2 face_index2 depth
            direction_x direction_y directon_z


For each collision type there is a list of pairs of colliding components. For each
        colliding component pair, there is a list of colliding entity pairs. Thus, there is a
        hierarchy of data with the tree looking like this: 
collision type -> component pairs -> entity pairs


The data is therefore accessed as: 
Get the number of colliding component pairs 
Get the component IDs for each component pair 
Get the number of intersected entities for each component pair 
Get the entity types, IDs, and faces (for intersections) or the entity types, IDs,
            faces, depths and directions (for penetrations) for each intersected entity pair.


","Inputs

collision_type
The type of collision to query: 
0 - intersections 
1 - penetrations
component_index
The index of the component pair to query, starting from 0. The total number of
            component pairs for a specific collision_type can be found using
              hm_collisongetcomponentpaircount.
entity_index
The index of the entity pair to query, starting from 0. The total number of entity
            pairs for a specific component_index can be found using
              hm_collisongetcomponententitypaircount.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Examples
To find intersecting surfaces from IDs 1-10, and to get the detailed list of entities for
        each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 0]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 0 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 0 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 0 $i $j]
                lassign $entity_pairs($i,$j) type id1 dd1 type2 id2 dd2
            }
        }
    }
}
hm_collisionend
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components, and to get the detailed list of entities for each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 1]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 1 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 1 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 1 $i $j]
                lassign $entity_pairs($i,$j) type id1 dd1 type2 id2 dd2 depth x y z
            }
        }
    }
}
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
425,hm_collisiongetcomponentlinesegment,"Description
Returns the line segment coordinates for a component collision pair.
Once the call to the relevant hm_collision* commands to generate the
        collision data is made, this command can follow.  In addition, the
          pair_results flag to hm_collisioncheck must be set
        to 1.
This returns a list of values that contains six coordinates: x_coordinate_start
        y_coordinate_start z_coordinate_start x_coordinate_end y_coordinate_end z_coordinate_end
For each intersecting type of collision, there is a list of pairs of intersecting
        components. For each intersecting component pair, there is a list of intersection line
        segments.
To execute this command, the below sequence of data collection is required:
Get the number of colliding component pairs 
Get the component IDs for each component pair 
Get the number of intersected entities for each component pair 


","
Inputs



component_index

The index of the component pair to query, starting from 0. The total number of
            component pairs for a specific collision_type can be found using
              hm_collisiongetcomponentpaircount.

linesegment_index

The index of the the line segment to query, starting from 0. The total number of
            entity pairs for a specific component_index can be found using
              hm_collisiongetcomponentlinesegmentcount.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Examples
To create nodes at the centerr of intersection line segments for intersecting comps with ID
        1 and 2:
set compList1 1;
set compList2 2;
set entityType1 elems;
set entityType2 elems;

hm_collisioninit 0 1e-5 
hm_createmark $entityType1 1 ""by comp id"" $compList1;
hm_createmark $entityType2 2 ""by comp id"" $compList2;
hm_collisionentitycreate $entityType1 1 0 0 0.0 0 0 0 0 0;
hm_collisionentitycreate $entityType2 2 0 0 0.0 0 0 0 0 0;
hm_collisioncheck 0 0 1 0 0 0 0 90.0 1 0 0 1;
set component_pair_count [ hm_collisiongetcomponentpaircount 0 0 ];
if {$component_pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set linesegmentcount [hm_collisiongetcomponentlinesegmentcount $i]
        if {$linesegmentcount != 0} {
            for {set j 0} {$j < $linesegmentcount} {incr j} {
                set linesegments [hm_collisiongetcomponentlinesegment $i $j]
                set x_0 [lindex $linesegments 0]
                set y_0 [lindex $linesegments 1]
                set z_0 [lindex $linesegments 2]
                set x_1 [lindex $linesegments 3]
                set y_1 [lindex $linesegments 4]
                set z_1 [lindex $linesegments 5]
                set curr_x [expr { ($x_0 + $x_1)/2 }]
                set curr_y [expr { ($y_0 + $y_1)/2 }]
                set curr_z [expr { ($z_0 + $z_1)/2 }]
                *createnode $curr_x $curr_y $curr_z
            }
        }
    }
}
hm_collisionend;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
426,hm_collisiongetcomponentpair,"Description
Returns the component IDs of a collision pair. This must be preceded by a call to
          relevant hm_collision* commands to generate the collision data. In
        addition, the pair_results flag to hm_collisioncheck
        must be set to 1. 
For each collision type there is a list of pairs of colliding components. For each
        colliding component pair, there is a list of colliding entity pairs. Thus, their is a
        hierarchy of data with the tree looking like this: 
collision type -> component pairs -> entity pairs 
The data is therefore accessed as: 
Get the number of colliding component pairs. 
Get the component IDs for each component pair. 
Get the number of intersected entities for each component pair. 
Get the entity types, IDs, and faces (for intersections) or the entity types, IDs,
            faces, depths and directions (for penetrations) for each intersected entity pair.


","Inputs

collision_type
The type of collision to query: 
0 - intersections 
1 - penetrations
component_index
The index of the component pair to query, starting from 0. The total number of
            component pairs for a specific collision_type can be found using
              hm_collisongetcomponentpaircount.
include_ignored (optional)
Specifies if results ignored when the allowable_depth value is
            specified via hm_collisioninit should be reported or not: 
0 - Do not include ignored results (default). 
1 - Include ignored results.

","Example
To find intersecting surfaces from IDs 1-10, and to get the detailed list of entities for
        each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 0]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 0 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 0 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 0 $i $j]
            }
        }
    }
}
hm_collisionend
To find penetrating surfaces from IDs 1-10, using the thickness assigned to the surface
        components, and to get the detailed list of entities for each intersection:
*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 0 1 0 0 0 90.0 0 0 0.0 1
set component_pair_count [hm_collisiongetcomponentpaircount 1]
if {$pair_count > 0} {
    for {set i 0} {$i < $component_pair_count} {incr i} {
        set component_pairs($i) [hm_collisiongetcomponentpair 1 $i]
        set entity_pair_count [hm_collisiongetcomponententitypaircount 1 $i]
        if {$pair_count != 0} {
            for {set j 0} {$j < $entity_pair_count} {incr j} {
                set entity_pairs($i,$j) [hm_collisiongetcomponententitypair 1 $i $j]
            }
        }
    }
}
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
427,hm_collisiongetconfig,"Description
Converts keywords into a numerical value for the configuration of the collision detection
        module. The returned value is used for the config argument to
          hm_collisioninit or *collisioncheck2_temp.
One or more keywords can be provided. Valid keywords are:
","InputsThe following inputs are applicable to
        hm_collisioninit and *collisioncheck2_temp:
intersect_planar
If listed, consider coplanar facets which are partially/fully overlapping, within a
            given tolerance defined by hm_collisoininit, as intersected. 
If not listed, do not consider these planar intersections (default for opcode engine).
            This is ignored by the collirad engine.
penetrat_min_overlap
If listed, consider only penetrations between two facets if they have an overlap
            greater than a given tolerance defined by hm_collisioninit (not
            compatible with the collirad engine). 
If not listed, such penetrations are even reported if a node of one of the facets
            penetrates exactly onto the edge of the other facet (default). 
This is ignored if any of the options edge_penetration,
              midside_nodes or split_quads are used in
              hm_collisionentitycreate.

The following inputs are applicable to hm_collisioninit only:
collirad
If listed, switches to the collirad collision detection engine, which is mainly based
            on Radioss algorithms, and provides an automatic fix.
If not listed, the default opcode collision detection engine is used, which supports
            some additional options, but does not support an automatic fix.

The following inputs are applicable to *collisioncheck2_temp only:
constant_gap
If listed, the thickness argument of *collisioncheck2_temp is used
            as a constant/uniform thickness.  This is equivalent to passing
              thickness_type 0 to
            hm_collisionentitycreate.
If not listed, the thickness argument of *collisioncheck2_temp is
            used as a multiplier for the element thickness when using the collirad engine, or
            ignored when using the opcode engine
edge2edge
If listed, edge-to-edge penetrations are considered.  This is equivalent to the
              edge_penetration flag in
              hm_collisionentitycreate.
If not listed, only node-to-surface penetrations are considered.
intersections
If listed, intersections are checked.
neighborhood
If listed, configures the collirad penetration check to ignore penetrations of
            neighboring elements due to thicknesses being greater than element sizes.  This
            corresponds to using the Iremgap 2 option in Radioss contact
            interfaces.
This is also equivalent to adding 100 to thickness_type for
              hm_collisionentitycreate.
If not listed, such undesired penetrations may be reported, but the check is
            faster.
This is ignored for the opcode engine.
penetrations
If listed, penetrations are checked.
self
If listed, include self checks in *collisioncheck2_temp.  This is
            equivalent to the self_check flag in
              hm_collisioncheck.
If not listed, self checks are not included (not compatible with the colirad
            engine).
thick_reduction
If listed, configures the collirad penetration check to restrict the thicknesses of
            the elements to 40% of their size each.  This also avoids undesired penetrations of
            neighboring elements due to thicknesses being greater than element sizes.  This
            corresponds to the behavior of some Radioss contacts.
This is equivalent to adding 200 to the thickness_type argument for
              hm_collisionentitycreate.
Ignored for the opcode engine.

","Example
To configure the collision detection for planar intersections:
set config [hm_collisiongetconfig intersect_planar]
hm_collisioninit $config
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
428,hm_collisionvisualizebymark,"Description
Enables the visualization of collision entities using one of various supported
        visualization modes.
","
Inputs



mark_id

The ID of the markcontaining the collision entities to be visualized. Valid values are
            1 and 2.

node_mark_id

The ID of the mark containing the slave nodes from the collision entities on
              mark_id. Only these nodes will be visualized. Valid values are 1
            and 2.
If 0 is specified, all colliding nodes/elements will be visualized.

review_type

A flag that indicates the type of visualization.  Valid values are:
1 - Highlight failed elements
2 - Review failed elements
3 - Contour penetration depths
4 - Penetration vectors and intersection lines
5 - Contour relative penetrations

fit_view

0 - Do not fit view
1 - Fit view

display_type

A flag that indicates which elements to display.  Valid values are:
1 - Display all elements
2 - Display components with failed elements
3 - Display only failed elements

","Examples
To highlight intersecting elements of comps 1001 and 1002 with auto-fit and display of the
        components with failed elements:
set config [hm_collisiongetconfig collirad intersections];
*clearmark comps 1 all;
eval *createmark comps 1 1001 1002;
*collisioncheck2_temp comps 1 $config 0.0 0.0 0.0 0.0;
*createmark collisions 1 all;
hm_collisionvisualizebymark 1 0 1 1 2;
To generate a contour plot of penetration depths of comps 1001 and 1002 without auto-fit
        and display only failed elements:
set config [hm_collisiongetconfig collirad penetrations];
*clearmark comps 1 all;
eval *createmark comps 1 1001 1002;
*collisioncheck2_temp comps 1 $config 0.0 0.0 0.0 0.0;
*createmark collisions 1 all;
hm_collisionvisualizebymark 1 0 3 0 3;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
429,hm_compareend,"Description
Clears memory and comparison graphics, and ends the comparison module. This must be
        preceded by any calls to hm_compareinit and other
          hm_compare* APIs. 
""Major"" database changes made while inside of the compare module will invalidate and delete
        any comparison results.
","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the same side comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
None.
",
430,hm_compareentitiesposition,"Description
Generates comparison results for entities positioned at a specific location. This must be
        preceded by a call to hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs or elems.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs or elems.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
n1_source
The node ID for the source entity base (N1).
n2_source
The node ID for the source entity x-direction (N2).
n3_source
The node ID for the source entity xy-plane (N3).
n1_target
The node ID for the target entity base (N1).
n2_target
The node ID for the target entity x-direction (N2).
n3_target
The node ID for the target entity xy-plane (N3).
result_type


 
SURFS to SURFS
SURFS to ELEMS ELEMS to SURFS
ELEMS to ELEMS



0 - Basic

Matched (paired) 
Unmatched


Matched (paired) 
Unmatched


Matched 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired)
 Unmatched


Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched 
Overlapped
Intersected 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the comparison of surfs 1-20 and 101-120 with source N1/N2/N3 nodes 100/101/102 and
        target N1/N2/N3 nodes 200/201/202:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesposition surfs 1 surfs 2 0.1 100 101 102 200 201 202 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
None.
"
431,hm_compareentitiesrotate,"Description
Generates comparison results for entities rotated about an axis. This may find multiple
        matches, depending on the requested options. This must be preceded by a call to
          hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs or elems.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs or elems.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
vec_x
X-coordinate of a location along rotation vector.
vec_y
Y-coordinate of a location along rotation vector.
vec_z
Z-coordinate of a location along rotation vector.
base_x
X-coordinate of rotation vector base.
base_y
Y-coordinate of rotation vector base.
base_z
Z-coordinate of rotation vector base.
angle
The rotation angle to use for searching for matches.
steps
The number of steps to consider. This dictates how many increments of
              angle are searched for matches. For example, if
              angle is 45 and steps is 3, the angles 45, 90
            and 135 will be searched. Must be >= 1.
result_type


 
SURFS to SURFS
SURFS to ELEMS ELEMS to SURFS
ELEMS to ELEMS



0 - Basic

Matched (paired) 
Unmatched


Matched (paired) 
Unmatched


Matched 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched 
Overlapped
Intersected 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt for the rotational
        comparison using an angle of 45 and 6 steps, of surfs 1-20 and 101-120 about the y-axis at
        0,0,0:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrotate surfs 1 surfs 2 0.1 0 1 0 0 0 0 45 6 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
432,hm_compareentitiessymmetry,"Description
Generates comparison results for entities positioned symmetrically about a plane. This must
        be preceded by a call to hm_compareinit. 
These results can then be queried using hm_compareget* APIs, or written
        to a file using hm_comparewrite* APIs.
","Inputs

source_entity_type
The type of source entity. Valid values are surfs or elems.
source_mark_id
The ID of the mark containing the source entities. Valid values are 1 and 2.
target_entity_type
The type of target entity. Valid values are surfs or elems.
target_mark_id
The ID of the mark containing the target entities. Valid values are 1 and 2.
tolerance
The tolerance value to use for the comparison.
normal_x
X-coordinate of symmetry plane normal direction.
normal_y
Y-coordinate of symmetry plane normal direction.
normal_z
Z-coordinate of symmetry plane normal direction.
base_x
X-coordinate of symmetry plane base location.
base_y
Y-coordinate of symmetry plane base location.
base_z
Z-coordinate of symmetry plane base location.
result_type


 
SURFS to SURFS
SURFS to ELEMS ELEMS to SURFS
ELEMS to ELEMS



0 - Basic

Matched (paired) 
Unmatched


Matched (paired) 
Unmatched


Matched 
Unmatched



1 - Full (default)

Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched (paired) 
Overlapped 
Intersected 
Unmatched


Matched 
Overlapped 
Intersected 
Unmatched



2 - Detailed

Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched (paired) 
Overlapped (paired) 
Intersected (paired) 
Unmatched


Matched 
Overlapped
Intersected 
Unmatched






review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To write the detailed comparison results file to C:/temp/my_compare.txt
        for the symmetrical comparison of surfs 1-20 and 101-120 about the xz-plane with base
        0,50,0:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessymmetry surfs 1 surfs 2 0.1 0 1 0 0 50 0 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
433,hm_comparefinddistances,"Description
Calculates the distance between all source and target entities. This must be preceded by a
        call to a relevant hm_compareentities* command. Only the distances for
        the target entities are calculated. The results can be contoured or queried.
","Inputs

max_distance
The maximum distance to use in the calculation. A smaller value results in faster
            computation time.
review_results
0 - Do not automatically show the graphical comparison results after execution. 
1 - Automatically show the graphical comparison results after execution (default).
            This is cleared upon a call to hm_compareend.

","Example
To generate a contour of the distance results for a same side comparison of elems 1-20 and
        101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
hm_comparesetreview 2
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
434,hm_comparegetcomparea,"Description
Calculates the area values for a specific component. This must be preceded by a call to a
        relevant hm_compareentities* command.
          hm_comparesetflags should also be set to 1.
","
Inputs


match_type
The type of match to query for the area. Valid values are: 
0 - Unmatched 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched
match_location
The location of the entities to query for the area. Valid values are: 
1 - Source entities 
2 - Target entities
component_id
The ID of the component to query.  If not specified, or given as 0, then the area for
            the entire source or target is calculated (same behavior as
              hm_comparegetarea).  Ensure that the specified ID matches with the
            requested match_location.
transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.

","Examples
Compare assembly 1 to assembly 2 and query the area of component
        10:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparegetcomparea 4 1 10
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
435,hm_comparegetdistancecount,"Description
Returns the number of distances found. This must be preceded by a call to a relevant
          hm_compareentities* command and
          hm_comparefinddistances.
","Example
To find the number of transformations for the recursive comparison of surfs 1-20 and
        101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
set num_distances [hm_comparegetdistancecount]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
436,hm_comparegetdistanceentitytype,"Description
Returns the entity type for a specific distance index. This must be preceded by a call to a
        relevant hm_compareentities* command and
          hm_comparefinddistances. 
Possible return values are: 
2 - Elems 
5 - Surfs
","Inputs

distance_index
The index of the distance to query, starting with 0. The number of distances can be
            found using hm_comparegetdistancecount.

","Example
To find the entity type for distance index 0 for the recursive comparison of surfs 1-20 and
        101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
set entity_type [hm_comparegetdistanceentitytype 0]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
437,hm_comparegettransformationcount,"Description
Returns the number of transformations found. This must be preceded by a call to a relevant
          hm_compareentities* command. 
Multiple transformations can be found by
          hm_compareentitiesrecursive,
          hm_compareentitiesrotate and hm_compareentitiestranslate.
        Other hm_compareentities* commands only find a single transformation
        between source and target entities.
","Example
To find the number of transformations for the recursive comparison of surfs 1-20 and
        101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set num_transformations [hm_comparegettransformationcount]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
438,hm_comparegettransformationmatchentities,"Description
Returns the entity IDs associated with a specific transformation and match. This must be
        preceded by a call to a relevant hm_compareentities* command.
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.
match_index
The index of the match corresponding to the transformation_index to
            query, starting with 0. The number of matches can be found using
              hm_comparegettransformationmatchcount.
match_location
The location of the match to query. Valid values are: 
1 - Source entities 
2 - Target entities

","Example
To find the source entity IDs for transformation 0 and match 5 for the recursive comparison
        of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set source_entities [hm_comparegettransformationmatchentities 0 5 1]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
439,hm_comparegettransformationmatchentitytype,"Description
Returns the type of entities associated with a specific transformation and match. This must
        be preceded by a call to a relevant hm_compareentities* command. 
Possible return values are: 
2 - Elems 
5 - Surfs
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.
match_index
The index of the match corresponding to the transformation_index to
            query, starting with 0. The number of matches can be found using
              hm_comparegettransformationmatchcount.
match_location
The location of the match to query. Valid values are: 
1 - Source entities 
2 - Target entities

","Example
To find the type of source entities for transformation 0 and match 5 for the recursive
        comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set source_entities_type [hm_comparegettransformationmatchentitytype 0 5 1]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
440,hm_comparegettransformationmatchtype,"Description
Returns the type of a specific transformation and match. This must be preceded by a call to
        a relevant hm_compareentities* command. Possible return values are: 
0 - Unmatches 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched
","Inputs

transformation_index
The index of the transformation to query, starting with 0. The number of
            transformations can be found using
            hm_comparegettransformationcount.
match_index
The index of the match corresponding to the transformation_index to
            query, starting with 0. The number of matches can be found using
              hm_comparegettransformationmatchcount.

","Example
To find the type of transformation 0 and match 5 for the recursive comparison of surfs 1-20
        and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiesrecursive surfs 1 surfs 2 0.1 2 0
set match_type [hm_comparegettransformationmatchtype 0 5]
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
441,hm_compareinit,"Description
Initializes the comparison module. This must precede any calls to other
          hm_compare* APIs, and must be followed by a call to
          hm_compareend. 
Any database changes made while inside of the compare module will invalidate and delete any
        comparison results.
","Example
To write the detailed comparison results file to
          C:/temp/my_compare.txt for the same side comparison of surfs 1-20 and
        101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
","Errors
None.
",
442,hm_comparereturnresults,"Description
longDescription
The output is a list of lists.


Consolidated compare data of all sources (Matched Overlapped Intersected
            Unmatched)
Consolidated compare data of all targets (Matched Overlapped Intersected
            Unmatched)
Consolidated matched/overlapped/intersected/unmatched data of one source or target
            (0|1 CompID CompareType MatchPercentage)
0 indicates source, 1 indicates target


Fragmented matched/overlapped/intersected/unmatched data of one source with one target
            (0|1 SourceCompID TargetCompID CompareType MatchPercentage)
0 indicates the next list has target entities, 1 indicates the next list has
                source entities


Information on component ID and type Entities of source or target and match type as
            determined in the list 4 ( SourrceCompID SourceType TargetCompID TargetType)
Entities of source or target and match type as determined in list 4 (EntityIDs)


The data repeats from list 3 to list 6.
","
Inputs


source_component_id
If ignored, or set to 0, all the compared data corresponding to all source components
            will be generated. If a valid source ID is given, the compared data for the
            corresponding source component is generated.
target_component_id
If ignored, or set to 0, all the compared data corresponding to all target components
            will be generated. If a valid target ID is given, the compared data for the
            corresponding target component is generated.

","Examples
Compare assembly 1 to assembly 2 and get results for source component 12 and target
        component
        14:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparereturnresults 12 14
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
443,hm_comparesetelemsurfmode,"Description
Specifies whether to consider element centroids for element-to-surface comparisons. This
        must precede any calls to hm_compareentities* commands. This is useful
        particularly when comparing coarse meshes and highly curved surfaces. 
When this option is enabled, a comparison operation will associate an element with a
        surface if the element has all its nodes on that surface, or at least one node and the
        element centroid projects normally to the surface and that projected point lies within
        roughly one quarter of the average side length of the centroid. Note that for elements that
        are partially off the edge of a surface, if the centroid is not on the surface but part of
        the element is (more than just a node or edge), the element will be marked as unmatched
        instead of intersected.
","Inputs

mode
0 - Do not consider element centroids (default) 
1 - Consider element centroids

","Example
To generate a same side comparison of surfs 1-20 and elems 101-120, including element
        centroids:
*createmark surfs 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_comparesetelemsurfmode 1
hm_compareentitiessameside surfs 1 elems 2 0.1 2 0
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
444,hm_comparesetignoreholes,"Description
Specifies whether to ignore holes and/or slots when performing 3D shell element-to-surface
        comparisons. This must precede any calls to hm_compareentities* commands
        and must be used with hm_comparesetanalysismode > 0. 
When non-zero, the analysis will compare 2D shell elements to three dimensional surface
        data using the shell thickness and offset information to infer a 3D shell, while also
        considering holes and slots. When > 0, holes and/or slots less than the specified
          diameter/length are ignored.
","Inputs

mode
0 - Normal (default) 
1 - Ignore holes < diameter

2 - Ignore slots < diameter and < length

3 - Ignore both holes < diameter and slots <
              diameter and < length
diameter
If mode is > 0, this is the diameter of the holes and/or slots to
            ignore.
length
If mode is > 1, this is the length of the slots to ignore.

","Example
To generate a same side comparison of surfs 1-20 and elems 101-120, using the 2D shell
        thickness and offset, ignoring fillets and all holes < 8.0 in diameter:
*createmark surfs 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_comparesetanalysismode 1
hm_comparesetignoreholes 1 8.0 0.0
hm_compareentitiessameside surfs 1 elems 2 0.1 2 0
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
445,hm_comparesetreview,"Description
Sets the graphical review type for comparison results. This must be preceded by a call to a
        relevant hm_compareentities* command. For distance review, a call must
        also be made to hm_comparefinddistances. This is cleared upon a call to
          hm_compareend.
","Inputs

type
0 - Off 
1 - Comparisons 
2 - Distance
min_legend (optional)
Value that indicates the minimum value to use for the legend when
              type is 2. If not specified, the default is 0.0.
max_legend (optional)
Value that indicates the maximum value to use for the legend when
              type is 2. If not specified, the default is the maximum
            distance.

","Example
To generate a contour of the distance results for a same side comparison of elems 1-20 and
        101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparefinddistances 1.0 1
hm_comparesetreview 2
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
446,hm_comparesetreviewcolordefault,"Description
Sets the graphical review color for comparison results back to the defaults. This must be
        followed by a call to hm_comparesetreview to refresh the graphics. 
The default colors are: 
Inactive - 1 
Unmatched source - 11 
Unmatched target - 14 
Topology source - 26 
Topology target - 46 
Intersected source - 42 
Intersected target - 38 
Overlapped source - 62 
Overlapped target - 30 
Matched source - 54 
Matched target - 22
","Example
To reset the review colors to the default values for a same side comparison of elems 1-20
        and 101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0:
hm_comparesetreviewcolordefault
hm_comparesetreview 1
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
447,hm_comparesetreviewtypes,"Description
Sets the graphical review types to show for comparison results. This must be followed by a
        call to hm_comparesetreview to refresh the graphics.
","Inputs

match_types
The type of matches to enable. Multiple values can be specified. Any value not
            specified is turned off for review. 
0 - Unmatched 
1 - Topological 
2 - Intersected 
3 - Overlapped 
4 - Matched

","Example
To set the review types to matched and overlapped only for a same side comparison of elems
        1-20 and 101-120:
*createmark elems 1 1-20
*createmark elems 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0:
hm_comparesetreviewtypes 4 3
hm_comparesetreview 1
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
448,hm_comparewritefile,"Description
Writes the current comparison data (transformations, match types, match entities, etc.) to
        a file. This must be preceded by a call to a relevant hm_compareentities*
        command. 
This file can be reloaded using hm_comparereadfile to repopulate the
        results in a different HyperMesh session.
","Inputs

filename
The full name and path of the file to write the data to.

","Example
To write the comparison data file to C:/temp/my_compare.txt for the
        same side comparison of surfs 1-20 and 101-120:
*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewritefile C:/temp/my_compare.txt
hm_compareend
To read the comparison data file from C:/temp/my_compare.txt and review
        the distances:
hm_compareinit
hm_comparereadfile C:/temp/my_compare.txt 1
hm_comparefinddistances 1.0 1
hm_comparesetreview 2
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
449,hm_comparewriteresults,"Description
Writes the current comparison results to a file. This must be preceded by a call to a
          relevanthm_compareentities* command.
If hm_comparesetflags is set to 1, the pairwise data can be seen in the
        output file, otherwise the legacy output will be generated.  The optional arguments are only
        valid when hm_comparesetflags is set to 1.
","Inputs

filename
The full name and path of the file to write the results to.
source_component_id
If ignored, or set to 0, all the compared data corresponding to all source components
            will be generated. If a valid source ID is given, the compared data for the
            corresponding source component is generated.
target_component_id
If ignored, or set to 0, all the compared data corresponding to all target components
            will be generated. If a valid target ID is given, the compared data for the
            corresponding target component is generated.

","Example
To write the detailed comparison results file to
          C:/temp/my_compare.txt for the same side comparison of surfs 1-20 and
        101-120:*createmark surfs 1 1-20
*createmark surfs 2 101-120
hm_compareinit
hm_compareentitiessameside surfs 1 surfs 2 0.1 2 0
hm_comparewriteresults C:/temp/my_compare.txt
hm_compareend
Compare assembly 1 to assembly 2 and write the pairwise results to
          C:/temp/pairwise_compare.txt:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparewriteresults C:/test/pairwise_compare.txt
hm_compareend
Compare assembly 1 to assembly 2 and write the pairwise results for source component 10 and
        target component 20 to
        C:/temp/pairwise_compare.txt:*createmark elems 1 ""by assems"" 1 
*createmark elems 2 ""by assems"" 2
hm_compareinit
hm_comparesetflags 1
hm_compareentitiessameside elems 1 elems 2 1.0 2 0
hm_comparewriteresults C:/test/pairwise_compare.txt 10 20
hm_compareend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
450,hm_convertFromOutFileToDatFile,"Description
Generates a DAT file from an OUT file.
The OUT file will be read and flutter summary data is collected, and the DAT file is
        generated in the same directory.
","Inputs

file_name
The name and path of the OUT file.

","Example
To convert the file C:/temp/flutter.out:
hm_convertFromOutFileToDatFile ""C:/temp/flutter.out""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
451,hm_count,"Description
Counts the entities in the database. 
","Inputs

entity_type
The type of entity to be counted. This parameter may be set to any of the entities in
            the database.
selection_flag all or displayed.
Indicates which entities are to be counted.
config_num
The configuration number of the entities to be counted. This parameter is used only if
              <entity type> is set to elements or loads. If set to zero, the
            entities are counted regardless of their configuration.
type_num
The type number of the entities to be counted. This parameter is used only if
              <entity type> is set to elements. If set to zero, all of the
            entities are counted regardless of their type.

","Example
In the template function @count(), if the displayed
        option is selected (active) on the export data panel, the value returned by
          @count() includes only those entities that are currently displayed. In
        the Tcl/Tk function hm_count(), this has to be
        indicated explicitly using the argument selection_flag.
","Errors
None.
"
452,hm_defaultstatus,"Description
Returns the default status of an attribute.
","Inputs

entity_type
The type of the queried entity.
entity_name_or_id
The name or ID of the queried entity.
attribute_name
The name of the attribute.
searchType
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname:  search only by name 
-byid:   search only by ID

","Example
If the attribute is set to the default value (grayed out in the card previewer), the
        function returns 1; otherwise, it returns 0.
","Errors
None.
"
453,hm_detectmeshpatterns,"Description
This command evaluates mesh patterns and connectivities on an input quad/mixed mesh, and
        output problem elements onto a mark. Problem areas include singularities, triangle clusters,
        triangles on edges, unsmooth local connections etc...
The evaluation can be controlled by the listed <name>=<value> options. If no options
        are explicitly specified, all of them will be turned on by default. If any options are
        explicitly turned on, only those specific options will be considered.  If any options are
        explicitly turned off, the other options will still be on. The options may be given in any
        order.
","
Inputs



input_mark_id

The ID of the mark of input elements.  Valid values are 1 and 2.

output_mark_id

The ID of the mark of output elements.  Valid values are 1 and 2.

define_topology_by_1d=<mode>

1 - Use 1D elements as topology for defining faces (default)
0 - Treat input elements as a single face

detect_singularity=<mode>

1 - Detect singularities in terms of mesh flow, including surrounding elements
            (default)
0 - Do not detect singularities in terms of mesh flow

smoothness=<mode>

1 - Calculate smoothness between connected elements (default)
0 - Do not consider smoothness between elements

threshold_index=<value>

The threshold value of the quality index used to find problem elements. Must be
            between 0.0 and 1.0, default 0.5. This helps to capture local flow perturbation caused
            by bad smoothness.

tria_cluster=<mode>

1 - Consider tria clusters (those with multiple trias patched together) 
0 - Do not consider tria clusters

tria_on_edge=<mode>

1 - Consider trias on boundary edges (default)
0 - Do not consider trias on boundary edges

","Examples
Find all elements with bad connections (singularities, triangle clusters etc) except
        triangles on edges:
*createmark elems 1 all
hm_detectmeshpatterns 1 2 tria_on_edge=0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
454,hm_elemlist,"Description
Get a list of element IDs or types for the passed component. 
","Inputs

listType
Type of list to generate (ID or type).
compName
The name of the component containing the elements.

","Example
To generate a list of elements IDs of type elemType for a named component.
set elemIds   [ hm_elemlist id $compName ];
set elemTypes [ hm_elemlist type $compName ];
set numIds [ llength $elemIds ];
set elemList {};
for { set i 0 } { $i < $numIds } { incr i } {
set curType [ lindex $elemTypes $i ];
if { $curType == $elemType } {
lappend elemList [ lindex $elemIds $i ];
}
}

return $elemList;
This command returns an empty list, if the component is empty or if the component does not
        exist. 
","Errors
None.
"
455,hm_entitiesassociatedbygroupsmark,"Description
Selects entities associated to each other through groups.
","Inputs

entity_type
The type of entity to query. Valid values are nodes, elements and components (only
            elements in components are considered).
input_mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
output_mark_id
The ID of the mark containing the isolated output entities which contains only nodes,
            elements and components. Valid values are 1 and 2.
group_mark_id
The ID of the mark containing the groups to consider for association. Valid values are
            0 (default, meaning all groups), 1 and 2.
level
0 - No level down 
Comps 
Elems 
Nodes


1 - One level done 
Comps -> Elems 
Elems -> Nodes 
Nodes 


2 - Two levels down 
Comps -> Elems -> Nodes 
Elems -> Nodes 
Nodes


The reverse is performed on the output.

","Example
To find nodes, elems and comps associated to comps 1-5 by all groups:
*createmark comps 1 1-5
hm_entitiesassociatedbygroupsmark comps 1 2 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
456,hm_entitycanselectby,"Description
This command returns true (1) if entity_type can be selected with the
        specified option, else it returns false (0). The valid values for option
        are the same as those in hm_appendmark, hm_createmark,
          *appendmark and *createmark.
","Example
To determine if elements can be selected using the ""by name only"" option:
hm_entitycanselectby ""by name only"" elems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
 If entity_type is invalid, you will get the following error:
hm_entitycanselectby: invalid entity type specified.

",
457,hm_entityincollector,"Description
Returns the number of entities in a collector. 
","Inputs

collector_type
The type of the queried collector.
collector_name_or_id
The name or ID of the queried collector.
entity_type
The type of the entity to be counted.
config_num
The configuration number of the entities to be counted. If set to zero, the entities
            are counted regardless of their configuration.
type_num
The type number of the entities to be counted. If set to zero, all of the entities are
            counted regardless of their type.
searchType
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname:  search only by name 
-byid:  search only by ID

","Errors
None.
",
458,hm_entitylist,"Description
Returns a list of names or IDs of all entities of the requested type.
","Inputs

entity_type
The type of entity to query.
name_or_id
The type of list to generate. Valid values are: 
name - Return the list of names. Only named entity types support this option.
id - Return the list of IDs. All entity types support this option.
mode
An optional argument that specifies which entity types are returned:
active - Return only the active entities.  This is the default if not specified.
all - Return both active and inactive entities.
inactive - Return only the inactive entities.

","Example
To get the list of node IDs:
hm_entitylist nodes id
To get the list of component names:
hm_entitylist comps name
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
459,hm_entitymaxsolverid,"Description
Returns the maximum solver ID in use for an entity type.
","Inputs

entity_type
The type of entity to query.
id_pool_name
An optional argument, indicating whether the maximum internal ID should be considered
            over all ID pools or a specific ID pool only.

","Example
To get the maximum solver ID for properties:
hm_entitymaxsolverid props
To get the maximum solver ID for properties in the two_idpool property
        ID pool:
hm_entitymaxsolverid props two_idpool
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
460,hm_entityminsolverid,"Description
Returns the minimum solver ID in use for an entity type.
","Inputs

entity_type
The type of entity to query.
id_pool_name (optional)
Indicates whether the minimum internal ID should be considered over all ID pools or a
            specific ID pool only.

","Examples
To get the minimum solver ID for properties:
hm_entityminsolverid props
To get the minimum solver ID for properties in the two_idpool property
        ID pool:
hm_entityminsolverid props two_idpool
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
461,hm_estimategeomthicknesslimits,"Description
Returns the minimum and maximum thickness limits for thin solid geometry.
","Inputs

entity_type
The type of entity to query. Valid values are surfaces and solids.
mark_id
The ID of the mark containing the input entities.
elem_size (optional)
The element size to be used for internal meshing.

","Example
To find the thickness limits for solid ID 100:
*createmark solids 1 100
foreach {min max} [hm_estimategeomthicknesslimits solids 1] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
462,hm_excludebeyond,"Description
This API removes entities from the base mark which are beyond the given distance (in model
        units) or the given number of element rows from the entities on the target mark. If the base
        mark is empty, it will be filled with every entity in the model that is not a part of the
        target mark before the entities are excluded.
The exclusion distance can be measured in either model units or in element rows. If
          dist_or_rows_flag is set to dist, the base entities will be excluded
        based on the absolute distance away from the target entities measured in model units. If
          dist_or_rows_flag is set to rows, the base entities will be excluded
        based on the number of rows of elements they are away from the target entities. Note that
        for the rows option, the elements used to count the rows must be connected
        to the target entities and all base entities not attached to the rows of elements will be
        excluded.
This is very useful for creating morph constraints for boundary layers. It allows you to
        first select all the nodes in the fluid layer and then use this API to exclude all the
        elements which lie a certain distance or number of element rows away from the cavity,
        leaving you with only the nodes inside your boundary layer envelope.
","Inputs

entity_type_base
The base entity type. Must be set to nodes.
mark_id_base
The ID of the mark containing the base entities. Valid values are 1 and 2.
entity_type_target
The target entity type. Valid values are nodes and elems.
mark_id_target
The ID of the mark containing the target entities. Valid values are 1 and 2.
dist_or_rows_flag
dist - Exclude based on the absolute distance measured in model units
rows - Exclude based on the number of rows away from the target entities
dist_or_rows_value
The number of model units or elements rows, depending on
              dist_or_rows_flag.

","Examples
To exclude all nodes from mark 1 which are beyond 500.0 model units away from the elements
        on mark 1:
*createmark nodes 1 ""by comp id"" 89
*createmark elems 1 ""by comp id"" 25
hm_excludebeyond nodes 1 elems 1 dist 500.0
To exclude all nodes from mark 1 which are beyond 5 element rows away from the nodes on
        mark
        2:*createmark nodes 1 ""by comp id"" 89
*createmark nodes 2 ""by comp id"" 25
hm_excludebeyond nodes 1 nodes 2 rows 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
463,hm_exportoptimizationcards,"Description
Exports a Radioss optimization file.
","
Inputs



type

The type of file to write:
1 - Export optimization file only

filename

The full path and filename of the output optimization file (*.radopt). Paths with
            spaces must be enclosed in quotes.
This can also be the starter file name, or the engine file name. The optimization file
            name is derived from this name.

export_template

The full path and filename of the optimization export template. Paths with spaces must
            be enclosed in quotes.

","Examples
To export the optimization file, deriving the name from the model file
        C:/my_files/model_0000.rad:
hm_exportoptimizationcards 1 ""C:/my_files/model_0000.rad"" ""[hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/radioss/optientities.blk""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
464,hm_fe_getconfigfile,"Description
Returns the FE config file set for user-defined weld creation. 
","Example
To get the global file set internally in HyperMesh:
set feconfigfile [ hm_fe_getconfigfile ];
","Errors
This returns the .cfg file specified through the panel or through the
        command. This is specified only for user-defined FE creation.
",
465,hm_fe_getdvstfile,"Description
The diameter vs. thickness is the global file set internally from the panel or through the
        commands.
","Example
To get the diameter vs. thickness file:
set dtfile [ hm_fe_getdvstfile ];
","Errors
None.
",
466,hm_fe_setconfigfile,"Description
Set the FE configuration file for user-defined welds.
","Inputs

configfile
The name of the configuration file.

","Example
To set the global file name for the FE config file:
set configfile ""d:\my_config_file.cfg""
hm_fe_setconfigfile $configfile;
This is stored globally and is applicable to all the connectors realized using user-defined
        weld option.
","Errors
None.
"
467,hm_fe_setWvsTfile,"Description
Sets the width vs thickness file for seam welds.
","
Inputs


file
The name and path of the width vs thickness file.

","Examples
To set the file:
set wvstfile [file join [hm_info -appinfo HMBIN_DIR] WidthMappingTable.txt]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
468,hm_findcirclefromthreepoints,"Description
This command returns the center and the radius of a circle that lies on three 2D points:
          (u1,v1), (u2,v2), (u3,v3). The
        return value will be a list of three parameters: the u coordinate of circle center
          (uc), the v coordinate of circle center (vc) and the
        circle radius (rc).
","Example
To get the center and the radius of a circle that lies on the points (3,5), (5,3) and (7,5)
        :
hm_findcirclefromthreepoints  3 5 5 3 7 5
The result will be ""5 5 2"". The center circle is (5,5) and the radius is 2.
","Errors
Incorrect usage of hm_findcirclefromthreepoints results in a Tcl error. The function returns an error if it isn’t possible to define a
        circle using the given points.
set err [catch { hm_findcirclefromthreepoints $u1 $v1 $u2 $v2 $u3 $v3 } circle]
if {$err} {
#Handle error here //I can't find the new circle.
} 
If err is 0 ""circle"" contains the uc,vc,rc.
",
469,hm_findclosestpointonsurface,"Description
For a given point on a surface, returns the closest other point on that same surface: 
xs ys zs dist 
where xs, ys and zs are the coordinates of the point on the surface closest to input point,
        and dist is the distance between the original and projected points.
","Inputs

x y z
The coordinates of the known point.
surf_id
ID of the surface.

","Example
To find the point closest to a point with coordinates (2676, -737, 605) and located on
        surface 7:
hm_findclosestpointonsurface 2676 -737 605 7
2.6777E+003 -7.3989E+002 6.0481E+002 3.3889E+000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
470,hm_findnarrowsurfaces,"Description
Returns the list of narrow surfaces, including large surfaces with narrow tails or local
        narrow neck regions.
The output is a list of the narrow surface IDs.
If output_surfs_flag is set to 1, the output is grouped into two lists.
        The first list is the narrow surface IDs. The second list contains flags indicating
        information about the type of narrow surface, in the same order as the narrow surface IDs.
        Each flag represents a bit-wise flags mask:
1 - Sliver surface
2 - Surface containing a narrow neck region
4 - Surface containing a narrow tail region
The value for each surface can be either 1, 2, 4 or 6 (the surface contains both a neck and
        a tail).
","Inputs

entity_type
The type of entity to query. Valid values are surfs, solids and comps.
mark_id
The ID of the mark containing the entities. Valid values are 0, 1 and 2. If set to 0,
            all corresponding entities are considered.
width_threshold
Positive value defining the maximal width of a narrow surface, or maximal gap for a
            surface narrow tail or neck region.
output_surfs_flag (optional)
Parameter defining the type of output.
0 - Output contains only list of surfaces IDs (default)
1 - Output contains an additional list of flags for narrow surfaces
sharp_angle_threshold (optional)
An angle, in degrees, that represents a corner angle above which the area nearby a
            surface corner is not considered as a narrow region. Default value is 10 degrees.
reserved
Reserved for future use. Must be set to 0.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid options are:
0 - Use the previous panel
1 - Use the current panel (default).

","Examples
To find narrow surfaces with width below 0.2 mm for component ""main_body"" :
*createmark comps 1 main_body
hm_findnarrowsurfaces comps 1 0.2
718 621 594 589 569 516 232 230 222 220 212 177 36 29
If the surfaces types are
        needed:*createmark comps 1 main_body
hm_findnarrowsurfaces comps 1 0.2 1
{718 621 594 589 569 516 232 230 222 220 212 177 36 29} {4 1 4 4 4 2 4 4 1 4 4 6 4 2}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
471,hm_findtangentpointoncircle,"Description
From a point, find the corresponding two tangent points on a circle.
","Inputs

px, py, pz
Defines a point.
cx, cy, cz
Defines a circle center.
cnx, cny, cnz
Defines a circle normal.
r0
Defines circle radius.

","Example
Returns two tangent points on the circle. 
hm_findtangentpointoncircle  2.0 0.0 0.0  0.0 0.0 0.0   0.0 0.0 1.0   1.0
0.5, 0.732 0.0   and  0.5 -0.732  0.0
","Errors
None.
"
472,hm_flangedetectionfindflanges,"Description
Runs the flange detection functions for finding flanges based on input entities and
        parameters. This must be preceded by calls to hm_flangedetectioninit, and
          hm_flangedetectionsetparams.
","Inputs

find
Bit value defining the types of flanges to find (Bit0 + 2*Bit1):
Bit0
0 - Do not find 2D flanges 
1 - Find 2D flanges
Bit1
0 - Do not find 3D flanges 
1 - Find 3D flanges



","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
473,hm_flangedetectiongetflangedetails,"Description
Returns details about a specific flange. This must be preceded by a call to
          hm_flangedetectionfindflanges.
The details are output
        as:entity_type dimension detection_type {entities list elements/surfaces} {ordered free boundary nodes/lines} {ordered connected boundary nodes/lines} min_width max_width length has_holes is_infinite
entity_type
0 - FE
1 - Geometry
dimension
0 - 2D
1 - 3D
detection_type
0 - By shape
1 - By proximity
has_holes
0 - Does not have holes
1 - Has holes
is_infinite
0 - Is not infinite
1 - Is infinite (no feature at connected side)
","
Inputs


index
The index of the flange to get details for, starting from 0.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
474,hm_flangedetectiongetflangemidline,"Description
Returns offset boundary points for a given flange. This must be preceded by a call to
          hm_flangedetectionfindflanges.
The midline points are returned as a list of triples.  These coordinates can then be used
        to construct the mideline.
","
Inputs



index

The index of the flange to query, starting from 0.

offset_distance=<value>

The offset distance from the free boundary.

max_chordal_deviation=<value>

The chordal deviation used to coarsen the output.  Default value 0.1.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
475,hm_flangedetectiongetmatinggroupdetails,"Description
Returns the members of a mating group. This must be preceded by a call to
          hm_flangedetectionfindmates.
The details are output
        as:{member_type member_contents} {member_type member_contents} ...
member_type
0 - Shape flanges
1 - Proximity patches
member_contents
Flange index if member_type is 0.
Surface/element IDs if member_type is 1.
","
Inputs



index

The index of the mating group to query, starting from 0.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
476,hm_flangedetectiongetnumberofmatinggroups,"Description
Returns the number of found flange mating 'groups'. This must be preceded by a call to
          hm_flangedetectionfindmates.
","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
477,hm_flangedetectionsetparams,"Description
Defines parameters for finding flanges in both geometry and FE. Multiple calls to this
        command can be made to override or redefine the parameters. Settings are cleared on any call
        to hm_flangedetectioninit/hm_flangedetectionend. 
This must be preceded by a call to hm_flangedetectioninit. 
Only max_width is mandatory. All other parameters are optional and have
        default values. Parameters can be specified in any order.
","
Inputs



max_width=<width>

The maximum width of flanges to be detected.

min_width=<width>

The minimum width of flanges to be detected.  Default is 0.0 if not specified.

feature_angle=<width>

The expected deviation at inner boundaries of flanges, in degrees.  Default is the
            global meshing feature angle if not specified.

","Examples
To find 2D flanges from elements in all components, using a min width of 2, a max width of
        20 and a feature angle of 20, and write out all flange details to a file named
          C:/temp/flanges.txt:
set flangesfile [open ""C:/temp/flanges.txt"" ""w""]
*createmark comps 1 all
hm_flangedetectioninit comps 1
hm_flangedetectionsetparams min_width=2.0 max_width=20 feature_angle=20
hm_flangedetectionfindflanges 1
set n [hm_flangedetectiongetnumberofflanges]
if { $n > 0 } {
    puts $flangesfile ""Number of flanges = $n""
    puts $flangesfile ""Flanges details""
    for {set i 0} {$i < $n} {incr i} {
        puts $flangesfile ""$i details = [hm_flangedetectiongetflangedetails $i]""
        puts $flangesfile ""$i midline = [hm_flangedetectiongetflangemidline $i offset_dist=0]""
    }
    hm_flangedetectionfindmates min_search_dist=0 max_search_dist=10
    set m [hm_flangedetectiongetnumberofmatinggroups]
    if { $m > 0 } {
        for {set i 0} {$i < $m} {incr i} {
            puts $flangesfile ""$i = [hm_flangedetectiongetmatinggroupdetails $i]""
        }
    } else {
        puts $flangesfile ""Flange mates not detected.""
    }
} else {
    puts $flangesfile ""Flanges not detected.""
}
hm_flangedetectionend
close $flangesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
478,hm_geomfindsymmetry,"Description
Finds and returns the symmetry transformation matrix and matched / unmatched surfaces
        between two selections. 
The return consists of six lists: 
A list of 16 float values defining the transformation matrix (either computed
            automatically or supplied by the user). 
A list of pairs of matched entities. 
A list of unmatched entities from first selection. 
A list of unmatched entities from second selection.
The maximum deviation between source and target.
A list of two coordinate lists (first on source, and second on target) where the
            maximum deviation occurs.


","Inputs

entity_type
The type of entity to find symmetry for. Surfaces and lines are currently
            supported.
mark_id1
The ID of the mark containing the first input set of entities. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the second input set of entities. Valid values are 1 and 2.
options
Optional arguments as follows: 
tolerance tol
This argument should be followed by a float value, tol, to be
                  used as the tolerance for comparison. If not supplied, the default geometry
                  cleanup tolerance will be used. If the tolerance and transformation are not
                  supplied, the best possible transformation is reported along with the calculated
                  deviation.


transformation a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 a41 a42
                    a43 a44
This argument should be followed by 16 float values, a11-a44, which are the
                  components of the 4x4 transformation matrix that maps the first selection of
                  entities to the second. This argument is optional for surfaces. If not supplied,
                  the transformation will be computed automatically if possible.



","Examples
To find the symmetry between the surfaces in comps named ""a"" and ""b"", using automatic
        calculations. The return values are indented in the line below the command:
*createmark surfs 1 ""by comp"" a
*createmark surfs 2 ""by comp"" b
hm_geomfindsymmetry surfs 1 2
{1 0 0 0 0 1 0 0 0 0 1 0 0 -4.44089209850E-016 7 1} {{2 30} {3 31} {5 33} {6 34} {7 35} {8 36} {10 38} {11 39} {12 40} {13 41} {15 43} {16 44} {17 45} {19 47} {20 48} {21 49} {22 50} {23 51} {24 52} {27 55} {28 56}} {18 1 9 14 57 4 26 25} {46 29 32 58 59} 1.8453535353e-06 { {-12.537342065573 -5 -2.4626579344272} {-12. 537342065573 -5 4.537112141223}}
To find the symmetry between the surfaces in comps named ""a"" and ""b"", using a tolerance of
        1e-5 and automatic transformation calculations. The return values are indented in the line
        below the command:
*createmark surfs 1 ""by comp"" a
*createmark surfs 2 ""by comp"" b
hm_geomfindsymmetry surfs 1 2 tolerance 1e-5
{1 0 0 0 0 1 0 0 0 0 1 0 0 -4.44089209850E-016 7 1} {{2 30} {6 34} {8 36} {10 38} {11 39} {12 40} {13 41} {15 43} {16 44} {17 45} {19 47} {20 48} {21 49} {22 50} {23 51} {24 52} {28 56}} {18 1 3 7 9 5 14 57 4 26 25 27} {46 29 31 32 35 58 59 33 55} 1.8453535353e-06 { {-12.537342065573 -5 -2.4626579344272} {-12. 537342065573 -5 4.537112141223}}
To find the symmetry between the surfaces in comps named ""a"" and ""b"", using a tolerance of
        1e-5, and specifying the transformation manually. The return values are indented in the line
        below the command:
*createmark surfs 1 ""by comp"" a
*createmark surfs 2 ""by comp"" b
hm_geomfindsymmetry surfs 1 2 transformation 1 0 0 0 0 1 0 0 0 0 1 0 0 0 7 1 tolerance 1e-5
{1 0 0 0 0 1 0 0 0 0 1 0 0 0 7 1} {{2 30} {6 34} {8 36} {10 38} {11 39} {12 40} {13 41} {15 43} {16 44} {17 45} {19 47} {20 48} {21 49} {22 50} {23 51} {24 52} {28 56}} {18 1 3 7 9 5 14 57 4 26 25 27} {46 29 31 32 35 58 59 33 55} 1.8453535353e-06 { {-12.537342065573 -5 -2.4626579344272} {-12. 537342065573 -5 4.537112141223}}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
479,hm_getabsoluterotationvector,"Description
Returns a list {x y z} which describes the given entity’s absolute rotation. If HyperMesh is unable to locate the associated systems, the list will
        contain three empty members.
","Inputs

entityType
The type of entity. Only components are currently supported. 
name_or_id
The name or ID of the entity. 
If the numeric name of any entity is identical to the ID of any other entity, allowing
            either may cause a problem. In the event of a conflict, HyperMesh will assume that the value is a name. Problems can be
            avoided by inserting a space or plus sign before an ID. For example: ""+1"" or ""1"" instead
            of 1.
searchType
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname:  search only by name 
-byid:  search only by ID

","Errors
None.
",
480,hm_getadjfacesfromface,"Description
Returns the faces adjacent to the specified face.
","Inputs

face_id
The ID of the face to query.

","Example
To get the adjacent faces for face 100:
hm_getadjfacesfromface 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
481,hm_getadvancedselectiontypes,"Description
Returns a list of valid advanced selection strings for the specified entity type and mode. 
","
Inputs



entity_type

The entity type to query.

mode

Specifies whether to return only the advanced options exposed in the GUI (0, default),
            or all options including those currently only exposed via Tcl (1).

","Examples
To get the list of all advanced selection strings valid for comps:
hm_getadvancedselectiontypes comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
482,hm_getalltiedentities,"Description
This command identifies group of connected parts and free parts, including tied and
        non-tied to the entities, within selected components. The output is a string with the
        connectivity information if any is found, or 0 otherwise. The output is of the form:
G- {IDg1, IDg2,…IDgN} F- {IDf1, IDf2, ..., IDfN}
Where G represents a group of connected parts, and F represents free parts.
You can select the types of components (like RBE3, welds) to be excluded or included while
        grouping attached entities. Mass elements are excluded when checking for connectivity.
Currently enabled for LS-DYNA only.
","Inputs

entity_type
The type of entity to query. Must be set to comps.
mark_id
The ID of the mark containing the entities to query. Valid values are 1 and 2.
<option>=<value>
Additional options are available to further control the behavior. These are optional
            and can be specified in any order after the first two mandatory arguments. All options
            support yes/no, 1/0 and true/false values.
connectors=<value>
Include connectors while checking connectivity. The default value is
                  false/no/0.
constrainedextranodes=<value>
Include constrained extra nodes while checking connectivity. The default value
                  is true/yes/1.
constrainedgroups=<value>
Include constrained extra groups while checking connectivity. The default value
                  is true/yes/1.
constrainedrigidbodies=<value>
Include constrained rigid bodies while checking connectivity. The default value
                  is true/yes/1.
contactgroups=<value>
Include contact groups while checking connectivity. The default value is
                  true/yes/1.
joints=<value>
Include joints while checking connectivity. The default value is
                  true/yes/1.
physicalconnectivity=<value>
Include node-to-node connections while checking connectivity. The default value
                  is true/yes/1.
projection=<value>
0 - Do not compute the projection while getting the tied entities
Compute the projection while getting the tied entities.  The default value is
                  true/yes/1.
rbe3=<value>
Include RBE3 elements while checking connectivity. The default value is
                  true/yes/1.
rigidlinks=<value>
Include rigidlinks while checking connectivity. The default value is
                  true/yes/1.
slipringretractors=<value>
Include slip ring retractors while checking connectivity. The default value is
                  true/yes/1.
welds=<value>
Include weld elements while checking connectivity. The default value is
                  true/yes/1.



","Examples
To include all kinds of connectivity:
*createmark comps 1 displayed
hm_getalltiedentities comps 1 connectors=true
or
hm_getalltiedentities comps 1 connectors=1
or
hm_getalltiedentities comps 1 connectors=yes

To exclude node to node
        connectivity:*createmark comps 1 displayed
hm_getalltiedentities comps 1 physicalconnectivity=false
orhm_getalltiedentities comps 1 physicalconnectivity=0
orhm_getalltiedentities comps 1 physicalconnectivity=no
To exclude connectivity by rigid links and
        joints:*createmark comps 1 displayed
hm_getalltiedentities comps 1 rigidlinks=false joints=false
orhm_getalltiedentities comps 1 rigidlinks=0 joints=0
orhm_getalltiedentities comps 1 rigidlinks=no joints=no
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
483,hm_getareaofsurface,"Description
Returns the area of a surface.
","Inputs

entity_type
The type of entity to query. Only surfaces are valid.
entity_id
The ID of the entity to query.

","Example
To get the area for surface 100:
hm_getareaofsurface surfs 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
484,hm_getaverageelemsize,"Description
Returns the average element size for shell elements. This command calculates the average
        element size using the following formula: 
quad elements: average size of one element = sqrt(1/2 * (longest diagonal) * (sum of
            the parallel altitudes)) 
tria elements: average size of one element = sqrt(area) 


The total average size is then calculated by summing each average size and dividing by the
        number of elements considered.
","Inputs

mark_id
The ID of the mark containing the shell elements.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid options are: 
0 - Use the previous panel. 
1 - Use the current panel (default).
round_to
0 - Round up to 3 significant digits (default). 
1 - Do not round.

","Example
To get the average element size for elements 1-100:
*createmark elems 1 1-100
hm_getaverageelemsize 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
485,hm_getbatchparams,"Description
Query the values of global mesh parameters.
","
Inputs


param
The name of the parameter to query. Valid values can be found in
              *batchparams_update.
There are also a few special considerations:


solid_holes_table = {row_id=<value}
row_id is the index of the row (record) to query inside the
                  table. If not specified, the entire table is returned.
surface_fillets_table = {row_id=<value}
row_id is the index of the row (record) to query inside the
                  table. If not specified, the entire table is returned.
surface_holes_table = {table_id=<value>
                  row_id=<value}
table_id is the index of the table to query.  If set to -1,
                  the default surface hole table is used. For coordinates tables, the index starts
                  with 0.
row_id is the index of the row (record) to query inside
                    table_id. If not specified, the entire table with the
                  specified table_id is returned.



","Examples
To query the 3rd row of the first coordinate hole table:
hm_getbatchparams surface_holes_table = {table_id = 0 row_id = 2}
To query the entire default 2D holes table:
hm_getbatchparams surface_holes_table = {table_id = -1}
To query the 2nd row of the fillet table:
hm_getbatchparams surface_fillets_table = {row_id = 1}
To query the element size and element type:
hm_getbatchparams element_size element_type
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
486,hm_getbinderid,"Description
Returns the IDs of the binder surfaces.
","Example
To get the IDs of the binder surfaces:
hm_getbinderid
","Errors
None.
",
487,hm_getboundingbox_predefined,"Description
This command returns the six values defining the bounding box for a mark of elements for a
        predefined box trim cut. 
x_min y_min z_min x_max y_max z_max 
The box values are determined depending on the following options.
","Inputs

mark_id
The ID of the mark containing the elements. Valid values are 1 and 2.
predefined_cut
The name of a predefined cut. Valid values are: 
front 
rear 
right 
left 
frontright 
frontleft 
rearright 
rearleft


limit
The x value of the box for predefined cuts front, rear, frontright, frontleft,
            rearright and rearleft.

","Example
To get the bounding box for the displayed elements using a front cut with a limit of
        0.1:
*createmark elems 1 displayed
hm_getboundingbox_predefined 1 ""front"" 0.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
488,hm_getcardmark,"Description
This command returns the IDs (from the CARDINPUTLIST) for the entity type specified.
","Inputs

entitytypename
The name of the entity type for which you want to find the IDs.
?PanelSensitive?
0 The mark mask ignores the HyperMesh panel level. 
1 The mark mask is sensitive to the HyperMesh panel
            level.

","Errors
None.
",
489,hm_getcleanupglobalflags,"Description
This command takes as input a mask of flags used for controlling some of the default modes
        for geometry autocleanup, element cleanup and element QI smoothing. It returns a word
        representing the current status of the specified flags. 
The commands which can be affected by resetting the global cleanup default flags using
          *setcleanupglobalflags are as follows:
*autotopocleanup
*hm_auto_elem_cleanup_new
*hm_batchmesh
*hm_failed_elements_cleanup
*optimsmooth
*qismoothfixfailed
*qismoothconstrained
","Inputs

flags
Flags bit value that indicate the global settings to query. To query multiple flags at
            once, sum the bit values of the requested flags. The default value is 0 which returns
            the full current bit value of all flags. 
1 - Ignore component boundaries flag. 
2 - Do not allow preservation of special transversal surfaces on lines generated
            during geometry autocleanup and batchmeshing flag. 
4 - Fixed vertices created by geometry autocleanup do not remain fixed after
            completion flag.

","Example
Assign the current word of all flags to the variable prv_flgs. Setup the
        flags to ignore component boundaries and to not create auxiliary surfaces. Then element QI
        smoothing is performed. Finally, all flags are restored to their original state:
set prv_flags [hm_getcleanupglobalflags 0]
*setcleanupglobalflags 3 1

*createmark elements 1 ""all""
*createmark nodes 1 """"
*optimsmooth 1 1 ""C:/Altair/hw10.0/hm/batchmesh/8mm.criteria"" 30.0 0.20 5 0 

*setcleanupglobalflags $prv_flags 2 
To get the status of the fixed vertices creation:
set flag_4_status [hm_getcleanupglobalflags 4]
To get the status of the component boundaries (1) and the fixed vertices creation (4):
set flag_5_status [hm_setcleanupglobalflags 5]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
490,hm_getclosestnode,"Description
Returns the ID of the closest node to the point (x,y,z). Zero is returned if there are no
        nodes in the database.
","Inputs

x
The X coordinate of the input point.
y
The Y coordinate of the input point.
z
The Z coordinate of the input point.
?elem_mark?
If ?elem_mark? is given, only search nodes attached to elements (in
            components) on the mark. If ?elem_mark? is zero, it is ignored.
?node_mark?
If ?node_mark? is given, ignore nodes on this mark when
            searching.

","Example
To find the closest node to (0,0,0) on a quad4 element:
hm_createmark elems 1 ""by config"" quad4
set id [hm_getclosestnode 0 0 0 1];
To find the closest node to (0,0,0) on all visible elements:
hm_createmark elems 1 advanced displayed
set id [hm_getclosestnode 0 0 0 1];
If ?elem_mark? is zero (or not given), all nodes (including temp nodes)
        will be searched. To ignore temp nodes that are not on your model, use:
hm_createmark elems 1 advanced all
set id [hm_getclosestnode 0 0 0 1];
","Errors
None.
"
491,hm_getclosestpointsbetweentwolines,"Description
Find the shortest distance between two lines and return line points corresponding to this
        distance.
","Inputs

lineID1
ID of the first line.
lineID2
ID of the second line.

","Example
The result is returned as a list: { x1 y1 z1 x2 y2 z2}

Where ""x1"", ""y1"", ""z1"" are coordinates of the closest point on the first line and ""x2"",
        ""y2"", ""z2"" are coordinates of the closest point on the second line.
To find closest points between lines with id 1 and 2:
hm_getclosestpointsbetweentwolines 1 2
2.682E+003 -7.365E+002 6.050E+002 2.685E+003 -7.350E+002 6.040E+002
","Errors
None.
"
492,hm_getcollectorname,"Description
Returns the name of a collector.
","Inputs

entity_type
The type of entity to query. Currently supported for all collector entity types.
id
The ID of the collector.

","Example
To get the name of the component with ID 100:
hm_getcollectorname comps 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
493,hm_getconfigtypecountincol,"Description
This command returns as a list the unique config, type anc count (number) combinations for
        the entities inside a collector. The list returns a list containing alternating config, type
        and count values for the entities of entity_type contained in the
        collector. The values are returned sorted by increasing config and increasing type within
        each config. For example, for a component collector containing 50 tria3 elements (config
        103) of type 1, 25 tria3 elements of type 2, and 10 quad4 elements (config 104) of type 3,
        the values returned would be: 
103 1 50 103 2 25 104 3 15
","Inputs

collector_type
The type of collector to query. Valid values are comps, groups and loadcols.
entity_type
The type of entities in the collector_type to return the config,
            type and count values for. The valid value for collector_type comps and groups is elems.
            The valid values for collector_type loadcols are equations and
            loads.
name_or_id
The name or ID of the queried collector_type.
?search_type?
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. The two options are: 
-byname: search only by name 
-byid: search only by ID

","Example
To get the config, type and count of all elements in the component collector named my_comp: 
set var [hm_getconfigtypecountincol comps elems my_comp -byname]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
494,hm_getconnected2delems,"Description
Returns lists of 2D shell elements and nodes that form t-connections or share edges at
        component boundaries. Advanced options are available to categorize the connected entities
        (T-connected, L-connected, Butt-connected or Overlap connected), as well as to specify the
        format of the return values. 
Elements that have t-connected edges and have a feature larger than the specified feature
        angle are considered t-connected, with the remainder being overlap-connected. 
Similarly, elements that have shared edges and have a feature larger than the specified
        feature angle are considered l-connected, with the remainder being butt-connected. 
The return from this command are lists of 2D elements and/or nodes. Each list is a unique
        continuous connection, based on the specified options. A unique connection is defined as one
        that is of a single type and spans only a single boundary. 
For example, if element output only is requested: 
{type1 elems elems1_1 elems1_2 … elems1_N} {type2 elems elems2_1 elems2_2 … elems2_N} … 
For example, if node list output only is requested: 
{type1 nodes nodes1_1 nodes1_2 … nodes1_M} {type2 nodes nodes2_1 nodes2_2 … nodes2_M} … 
For example, if node list and element output is requested: 
{type1 elems elems1_1 elems1_2 … elems1_N} {type2 elems elems2_1 elems2_2 … elems2_N}
        {type1 nodes nodes1_1 nodes1_2 … nodes1_M} {type2 nodes nodes2_1 nodes2_2 … nodes2_M} …
","Inputs

entity_type
The type of entity to query. Valid values are comps and elems. Only 2D shell elements
            are considered from the input.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input options. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. Each argument must be space separated. 
Each string is required and is introduced as follows: 
""find: t o l b"" 
t
0 - Do not find and include T-connected elements
1 - Find and include T-connected elements


o
0 - Do not find and include overlap-connected elements
1 - Find and include overlap-connected elements 


l
0 - Do not find and include L-connected elements
1 - Find and include L-connected elements 


b
0 - Do not find and include butt-connected elements
1 - Find and include butt-connected elements 


""features: overlap_angle l_angle boundary_type"" 
overlap_angle 
The maximum angle allowed between two components when categorizing as an overlap
                  connection. The angle measured is the smallest angle between the two components.
                


l_angle 
The maximum angle allowed between two components when categorizing as an
                  l-connection. Must be > overlap_angle and less than 180. The angle measured is the
                  smallest angle between the two components. 


boundary_type
comp - Consider component boundaries when finding and categorizing
                  connections


""output: single_node_elems elems nodes"" 
single_node_elems 
0 - Do not return elements that have only a single node along the connection 
1 - Return elements that have only a single node along the connection 


elems
0 - Do not return element lists
1 - Return flat list of uncategorized elements 
2 - Return lists of categorized elements 
3 - Return lists of categorized and grouped elements


nodes 
0 - Do not return node lists
1 - Return flat list of uncategorized nodes
2 - Return lists of categorized nodes 
3 - Return lists of categorized and grouped nodes



","Example
To find and output categorized and grouped t-connected and butt-connected elements, with an
        overlap angle of 5 degrees, an L angle of 185, and using component boundaries, from the
        displayed components:
*createmark comps 1 displayed
*createstringarray 3 ""find: 1 0 0 1"" ""features: 5.0 185.0 comp"" ""output: 0 3 0""
set elem_lists [hm_getconnected2delems comps 1 1 3]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
495,hm_getcoordinatesofpointsonline,"Description
Gets the coordinates of the points for which normalized parameters are specified, along
        with the ID of the line on which they are located, as arguments to the command.
","Inputs

lineID
The ID of the line on which the points are located.
param list
List of line parameters normalized to the range 0…1.0.

","Example
The function returns a list with a number of components equal to number of specified
        parameters in the parameter list. Each component itself is a list consisting of three
        elements representing x, y and z coordinates of calculated point. 
To calculate coordinates of endpoints for the line with ID 13:
set two_points [hm_getcoordinatesofpointsonline 13 [list 0.0 1.0]]
      {2.7E+03 -7.3E+02 6.1E+02} {2.6E+03 -7.3E+02 5.8E+02}
set start_point [lindex $two_points 0]
      2.7E+03 -7.3E+02 6.1E+02
set end_point [lindex $ two_points 1]
      2.6E+03 -7.3E+02 5.8E+02
set x1 [lindex $start_point 0]
      2.7E+03
set y1 [lindex $start_point 1]
      -7.3E+02
set z1 [lindex $start_point 2]
      6.1E+02
set x2 [lindex $end_point 0]
      2.6E+03
set y2 [lindex $end_point 1]
      -7.3E+02
set z2 [lindex $end_point 2]
      5.8E+02
","Errors
None.
"
496,hm_getcrossreferencedentities,"Description
Finds entities that reference the specified entity. This includes collected references,
        data name references and attribute entity references. Each type of entity that references
        the specified input entity is returned in a list, and the found entities are then placed on
        the specified mark for those entity types. See the list of supported entities for this
        command.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
reference_flag
The type of cross-reference entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2). 
Bit0
0 - Do not consider collected entity cross-references. 
1 - Consider collected entity cross-references. If the specified entity is not a
                  collected entity, nothing will be returned for this bit.


Bit1
0 - Do not consider data name entity cross-references. 
1 - Consider data name entity cross-references. If the specified entity is not
                  referenced by any data names, nothing will be returned for this bit. 


Bit2
0 - Do not consider attribute entity cross-references. 
1 - Consider attribute entity cross-references. If the specified entity is not
                  referenced by any entity attributes, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found cross-referenced entities on. Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.
exclude_regions
0 - Include region entities in the search (default).
1 - Exclude region entities in the search.

","Examples
To get all entities that cross-reference component with ID 100 on mark 1 and highlight them
        on the screen:
foreach entity_type [hm_getcrossreferencedentities comps 100 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity cross-references for component with ID 100 on mark 2:
hm_getcrossreferencedentities comps 100 1 2 0 0 -byid
To get only data name entity cross-references for component with ID 100 on mark 1:
hm_getcrossreferencedentities comps 100 2 1 0 0 -byid
To get only attribute entity cross-references for component with ID 100 on mark 1:
hm_getcrossreferencedentities comps 100 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
497,hm_getcurrentmodel,"Description
Returns the name of the current model.
","
Inputs
None.","Examples
Get the name of the current model:
hm_getcurrentmodel
",ErrorsNone.
498,hm_getdeleteassociatedentitiesbycompmark,"Description
Returns the unique associated entities for the components on a mark. The associated
        entities are returned for each selected component, as well as added to the output mark. 
The return value is a ""list of lists"". Each list contains the following: 
{component ID {entity type {entity IDs...}}} 
For example:
{2 {comps 2}} {2 {loads {1 2 3 4 5 6 7 8 9 10}}} {2 {sets {1 2 3 4}}} {2 {props 1}} {2 {mats 2}} {3 {comps 3}} {3 {loads {1 2 3 4}}} {3 {sets {1 2 3 4}}} {3 {props 2}} {3 {mats 2}}
","Inputs

input_mark_id
The ID of the mark containing the input components. Valid values are 1 and 2.
output_mark_id
The ID of the mark containing the output entities. Valid values are 1 and 2.

","Example
To get the associated entities for component 4 on mark 1:
*createmark comps 1 4
hm_getdeleteassociatedentitiesbycompmark 1 2
{4 {comps 4}} {4 {loads {325 326}}} {4 {loadcols 2}}
hm_getmarkall 2
{nodes 7 8 9 10 11} {comps 4} {loads 325 326} {loadcols 2}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
499,hm_getdiedisplayattribute,"Description
Returns the die display attribute. Return values are: 
0 - Wireframe Elements/Wireframe Elements Skin Only 
1 - Shaded Elements 
2 - Shaded Elements and Mesh Lines 
3 - Shaded Elements and Feature Lines 
4 - Transparent Elements


","Example
To get the die display attribute:
hm_getdiedisplayattribute
","Errors
None.
",
500,hm_getdiepartshape,"Description
Returns the shape ID of the die part. If a half model is loaded (that needs a reflection to
        be completed) the shape is 0. If a full model is loaded, the shape is 1.
","Example
To get the IDs of the die part surfaces:
hm_getdiepartshape
","Errors
None.
",
501,hm_getdistancefromnearestline,"Description
Gets the distance of the given point from the nearest line with IDs specified as
        arguments.
","Inputs

point_xyz
The list of x, y, z coordinates of the point.
line_id_list
List of line IDs.

","Examples
The function returns a list consisting of two values. The first value is the distance to
        the closest line. The second value is ID of the closest line.
To get closest to the point with coordinates (10, 20, 30) point on the line with ID 13:
hm_getdistancefromnearestline [list 10 20 30] 13
To get closest line from the set with IDs 13 14 15:
hm_getdistancefromnearestline [list 10 20 30] [list 13 14 15]
To get closest to the point with ID 2 point on the line with ID 13:
hm_getdistancefromnearestline [hm_getvalue points id=2 dataname=coordinates] 13
","Errors
None.
"
502,hm_getdrawbarid,"Description
Returns the IDs of the draw bar surfaces.
","Example
To get the IDs of the draw bar surfaces:
hm_getdrawbarid
","Errors
None.
",
503,hm_getdrawbeadid,"Description
Returns the IDs of the draw bead surfaces.
","Example
To get the IDs of the draw bead surfaces:
hm_getdrawbeadid
","Errors
None.
",
504,hm_getedgeloops,"Description
Returns surface and element free and non-manifold edge loop entities. The return is a ""list
        of loops"". Each loop is an ordered list of either surface edge or element node IDs that
        define each loop. The first value in each loop list is the loop type. The remaining values
        are the ordered node/surface edge IDs defining the loop. If the loop is closed, the first
        and last ID are the same. 
For example: 
{2 1 29 35 34 33 32 31 25 5 4 3 2 1 } {2 6 7 8 9 10 22 23 24 21 18 15 12 30 11 6 }
          {2 16 19 20 17 16 } {4 26 27 28 } {1 26 39 40 41 28 }
","Inputs

entity_type
The type of entity to query. Valid values are surfaces and elements.
markid=<mark_id>
The ID of the mark containing the entities to query. Valid values are 1 and 2.
looptype=<loop_type>
The type of loop types to find. Bit values are used and the value is calculated as
            (1*Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6 + 128*Bit7). If not
            specified, all loop types are returned. 
Bit0
0 - Do not consider open free edge loops
1 - Consider open free edge loops


Bit1
0 - Do not consider closed free edge loops
1 - Consider closed free edge loops


Bit2
0 - Do not consider open t-connections
1 - Consider open t-connections


Bit3
0 - Do not consider closed t-connections
1 - Consider closed t-connections


Bit4
0 - Do not consider open x-connections
1 - Consider open x-connections


Bit5
0 - Do not consider closed x-connections
1 - Consider closed x-connections


Bit6
0 - Do not consider open feature edge loops
1 - Consider open feature edge loops


Bit7
0 - Do not consider closed feature edge loops
1 - Consider closed feature edge loops


featureangle=<angle>
This  is relevant to finding feature edges only.  When an edge is shared by two
            surfaces, and the average angle along the edge between these two surfaces is greater
            than featureangle=<angle>, then it is considered a feature edge.
            The angle is measured in degrees. The default value is the model’s default feature angle
            preference.
refmarkid=<mark_id>
A mark containing a set of reference surfaces used in identifying feature edge loops
            in ambiguous cases. For example, if a feature edge in a loop ends at a vertex at which
            two other feature edges connected, it is not clear which of the two will be the
            continuation of this feature edge. In such cases, the one that is shared with a
            reference surface, or with a surface that is connected to reference surfaces via
            non-feature edges, is taken as the continuation of the feature edge loop. If reference
            surfaces are not given, the feature edge loops are terminated when they come to such
            junctions.
restricttoinput=<value>
0 - Loops are completed naturally for the whole model, which might result in including
            edges that are not in the input specified by mark_id.
1 - The loop output is restricted to the set of edges that are given by the input
            only.

","Examples
To get all edge loops for the displayed surfaces:
*createmark surfs 1 displayed
hm_getedgeloops surfs markid=1
To get all open t-connection (Bit2) and closed t-connection (Bit3) edge loops for the
        displayed surfaces:
*createmark surfs 1 displayed
hm_getedgeloops surfs markid=1 looptype=12
To get all closed free (Bit1) edge loops for the displayed elements:
*createmark elems 1 displayed
hm_getedgeloops elems markid=1 looptype=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
505,hm_getedgesfromvertex,"Description
This command returns all surface edges connected to a specified vertex point.
","Inputs

point_id
The ID of the vertex point.

","Example
To get the edges attached to vertex point with ID 2:
hm_getedgesfromvertex 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
506,hm_getelemcheckelems,"Description
This command returns the elements that match the specified element check criteria. Only the
        elements on mark_id and of the specified dimension are considered when
        determining which elements match the specified criteria.
","Inputs

mark_id
The ID of the mark containing the elements. Valid values are 1 and 2.
dimension
The dimension of the elements on mark_id to consider. Valid values
            are: 
1 - 1D elements 
2 - 2D elements 
3 - 3D elements 
If no elements of the specified dimension are on mark_id, an error
            is returned.
check_type
The type of element check to return the bounds from. The allowable values depend on
            the dimension specified:
dimension = 1: 
length 
timestep


dimension = 2: 
addedmass 
aspect 
cellsquish 
chordaldev 
equiskew 
jacobian 
length
maxinterangle
maxlength
mininterangle
minlength
skew 
taper 
timestep 
volumeareaskew 
warpage 


dimension = 3: 
addedmass 
altitudeaspect 
aspect 
cellsquish 
equiskew 
jacobian 
length 
maxinterangle
maxlength
mininterangle
minlength
ortho_3d
size_ratio_3d
skew 
tetracollapse 
timestep 
volumeareaskew 
volumetricskew 
warpage


check_mode
The type of element check to perform. Valid values are: 
above - return the entity IDs that are above the specified threshold value of the
              check_type from the elements on mark_id of the
            specified dimension. 
below - return the entity IDs that are below the specified threshold value of the
              check_type from the elements on mark_id of the
            specified dimension. 
exact - return the entity IDs that have the specified threshold value (within
            tolerance) of the check_type from the elements on
              mark_id of the specified dimension. 
max - return the entity ID(s) that have the maximum value of the
              check_type from the elements on mark_id of the
            specified dimension. 
min - return the entity ID(s) that have the minimum value of the
              check_type from the elements on mark_id of the
            specified dimension.
threshold
The threshold value to use when check_mode is set to above, below
            or exact. This is ignored and not required when check_mode is set to
            max or min
tolerance
 The tolerance value to use when check_mode is set exact. This is
            ignored and not required when check_mode is set to max, min, above or
            below.
?time_failure?
The value to use as a threshold beyond which the input elements should be considered
            to have failed the test. This is required only when check_type is set
            to addedmass.

","Examples
To get the 1D elements that have the minimum length from the elements in comp1:
*createmark elems 1 ""by collector name"" comp1
set elems [hm_getelemcheckelems 1 1 length min]
To get the 2D elements that have the maximum warpage from the displayed elements:
*createmark elems 1 displayed
set elems [hm_getelemcheckelems 1 2 warpage max]
To get the 2D elements that have a warpage above 5.0 from the displayed elements:
*createmark elems 1 displayed
set elems [hm_getelemcheckelems 1 2 warpage above 5.0]
To get the 3D elements that have a tetracollapse below 0.1 from all elements:
*createmark elems 1 all
set elems [hm_getelemcheckelems 1 3 tetracollapse below 0.1]
To get the 3D elements that have a jacobian of exactly 1.0 from all elements, with a
        tolerance of 0.01:
*createmark elems 1 all
set elems [hm_getelemcheckelems 1 3 jacobian exact 1.0 0.01]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
507,hm_getelemcheckvalues,"Description
This command returns a single list containing alternating values of element IDs and the
        corresponding check value for that element. Only the elements on mark_id
        and of the specified dimension are considered when determining which elements and values are
        returned.
","Inputs

mark_id
The ID of the mark containing the elements. Valid values are 1 and 2.
dimension
The dimension of the elements on mark_id to consider. Valid values
            are: 
1 - 1D elements 
2 - 2D elements 
3 - 3D elements 
If no elements of the specified dimension are on mark_id, an error
            is returned.
check_type
The type of element check to return the bounds from. The allowable values depend on
            the dimension specified:
dimension = 1: 
length 
timestep


dimension = 2: 
addedmass 
aspect 
cellsquish 
chordaldev 
equiskew 
jacobian 
length 
maxinterangle
maxlength
mininterangle
minlength
skew 
taper 
timestep 
volumeareaskew 
warpage 


dimension = 3: 
addedmass 
altitudeaspect 
aspect 
cellsquish 
equiskew 
jacobian 
length 
maxinterangle
maxlength
mininterangle
minlength
ortho_3d
size_ratio_3d
skew 
tetracollapse 
timestep 
volumeareaskew 
volumetricskew 
warpage


?time_failure?
The value to use as a threshold beyond which the input elements should be considered
            to have failed the test. This is required only when check_type is set
            to addedmass.

","Examples
To get the length value for all 1D elements in comp1:
*createmark elems 1 ""by collector name"" comp1
set elemvals [hm_getelemcheckvalues 1 1 length]
To get the warpage value for all displayed 2D elements:
*createmark elems 1 displayed
set elemvals [hm_getelemcheckvalues 1 2 warpage]
To get the jacobian of all 3D elements:
*createmark elems 1 all
set elemvals [hm_getelemcheckvalues 1 3 jacobian]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
508,hm_getelementchecksettings,"Description
This command returns the methods used to calculate each of element quality checks. The
        methods generally represent those used by an FE solver. The command returns a list of 15
        integer values. Each value identifies the method used for a corresponding element quality
        check. The methods’ IDs are returned in the following order: 
solver jacobian_2d jacobian_3d min_len_2d min_len_3d aspect_2d aspect_3d skew_2d
            skew_3d angle warpage taper chord_dev tetra_collapse time_step cell_squish_2d
            cell_squish_3d equi_skew_2d skew_3d 

For element quality check parameters, their meanings and allowable values, see the
          *elementchecksettings command. 
The first returned parameter (solver) has a special meaning. The methods' IDs for most of
        the element quality checks (aspect_2d, aspect_3d, skew_2d, skew_3d, angle, warpage, taper,
        chord, tetcollapse, timestep) are just the IDs of the FE solver methods. A value returned
        for solver that represents a valid FE solver ID means that this FE solver's methods are
        currently being used for all the above mentioned element quality checks. If the global FE
        solver does not have some element quality check, then the HyperMesh method is being used for the check. A return value of -1 for
        solver indicates that the current methods used for the above mentioned element quality
        checks can be found from the output list by the check position. 
It is possible that for some specific element quality check the command returns an FE
        solver ID that does not match the list of permissible IDs for this parameter. This means
        that HyperMesh method (ID = 0 ) is being applied for computation
        of this element quality parameter.
","Example
To retrieve the method (solver) currently being used for calculation of aspect ratio for 2D
        elements:
set all_settings [hm_getelementchecksettings]
set solver [lindex  $all_settings 0]
set aspect2d $solver
if { $solver == -1} {set aspect2d [lindex $all_settings 5]}
","Errors
None.
",
509,hm_getelementsqualityinfo,"Description
 Computes quality parameters for the specified selection of elements. 
","Inputs

elementmask
The markmask of the input element (1 or 2).
criteria_use_mode
1 The quality criteria must be explicitly set beforehand. If the parameter is not
            given, 1 is used as the default value. 
0 The default quality criteria adjusted to the selected averaged element size are
            automatically created if the criteria do not exist.
failed_mask
The markmask of the failed element (0, 1, or 2). If not specified, 0 is used. Must be
            different from elementmask.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid options are: 
0 - Use the previous panel. 
1 - Use the current panel (default).

","Example
Output values are organized in the following list: 
total number of elements on the markmask 
number of failed elements 
quality index 
% of failed elements 
% of trias
","Errors
None.
"
510,hm_getentitiesinboxes,"Description
Finds the entities queried for in the specified boxes, places them on
          output_mark_id.
","Inputs

entity_type
The type of an entity to be found in the boxes. Valid values are nodes, elems, loads,
            systems, equations, vectors, points, line, surf, solids and connectors.
input_mark_id
The ID of the mark containing the boxes. Valid values are 1 and 2.
output_mark_id
The ID of the mark where all the entities within the box will be output. Valid values are 1 and 2.

","Example
To find nodes within the box with ID 1 and put them on mark 2:
*createmark boxes 1 1
hm_getentitiesinboxes nodes 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
511,hm_getentitybasename,"Description
This command returns the fully qualified HyperMesh entity name
        for the partial or short name.
","Inputs

entity_type
Any HyperMesh entity name or partial name.

","Example
To get the full name of comps:
hm_getentitybasename comps
","Errors
None.
"
512,hm_getentitycardimagedictionary,"Description
Certain entity card images have organizational types defined in the templates which are
        used by the panels and the browsers to filter and organize the available entity card images
        (dictionaries). This command returns a list of card images defined in the current template
        that are of the specified type for the specified entity_type.
","Inputs

entity_type
Currently supported for controlvols, mats, props, sensors, sets and tables.
type
The organizational type of the entity to return the card image list for. Also valid
            for ALL and NOTYPE.

","Example
To return the list of card images for props of type 1D defined for the OptiStruct template:
hm_getentitycardimagedictionary props 1D
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
513,hm_getentityinfo,"Description
This command returns definition information for an entity, either corresponding to the data
        name specified or all data names for that entity.
","Inputs

entity_type
The entity type to query.
definition
The definition to query. If dataname is not specified, values for all data names of
            the specified entity_type are returned. Return values for all
            definitions are in the same order so they are easily matched together. If data_name is
            specified, only the definition value for that data name is returned. 
Valid definition types are: 
arraydimension - Returns 0 for data names that are single values, 1 for arrays. 
datatype - Returns the data type name (string, integer, double, etc...). 
displayname - Returns the  default display name. 
editable - Returns the  editable state EDITABLE or
            NONEDITABLE. 
namedidentifier - Returns the data name string name. 
visible - Returns the  visibility state VISIBLE or
            INVISIBLE.
option=<value>
The option to be used to modify the command return value. Only one option can be used
            at a time: 
config=<config>

The return values will only be those associated with the specific entity type
                config. This is not valid for entities without a config, nor for legacy entities
                that do have a config (such as elems, loads, groups, beamsects, laminates, tables,
                bags). 


dataname=<data name> 
The return value will only be for the specified data name.



","Examples
To get all of the data names for elements:
hm_getentityinfo elems namedidentifier
To get all the array dimension of the component data name 'elements':
hm_getentityinfo comps arraydimension dataname=elements
To get all the data names associated with region config 1:
hm_getentityinfo regions namedidentifier config=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
514,hm_getentityroot,"Description
Returns the ID of the root entity for a given modular entity type. 
","
Inputs


entity_type
The modular entity type.  Currently only supported for subsystems.

","Example
To query the root for subsystems:
hm_getentityroot subsystems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
515,hm_getentitytypealiasname,"Description
Returns the alias name for a specified entity type in the current user profile.
","
Inputs



entity_type

The entity type to query.

","Examples
To get the alias name for comps:
hm_getentitytypealiasname comps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
516,hm_getentitytypedisplayname,"Description
This command returns the display name for the specified entity type.
","Inputs

entity_type
The entity type to query.
singular
0 - Returns the plural display name 
1 - Returns the singular display name (default)

","Examples
To get the singular display name for elements:
hm_getentitytypedisplayname elems
or
hm_getentitytypedisplayname elems 1
To get the plural display name for elements:
hm_getentitytypedisplayname elems 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
517,hm_getexistingentitytypes,"Description
Returns the list of entity types that exist in the current database.
","Example
To get the list of existing entity types:
hm_getexistingentitytypes
","Errors
None.
",
518,hm_getfacesbyedgelength,"Description
Gets the faces that have an edge with a length smaller or equal to the specified value.
","Inputs

double
Length of an edge that you specify.

","Example
hm_getfacesbyedgelength 20
","Errors
None.
"
519,hm_getfacesfromsurface,"Description
Gets faces contained in the surface whose ID is supplied as the argument. 
","Inputs

surface_id
ID of the surface.

","Example
The function returns a list containing IDs of the faces from which the surface is composed. 
To get faces that compose the surface with ID 2:
hm_getfacesfromsurface 2

","Errors
None.
"
520,hm_getfilletfaces,"Description
Returns the faces containing fillets with a radius inside a range.
","Inputs

radius_min
The minimum radius value.
radius_max
The maximum radius value.

","Example
To get the faces with fillets with a radius between 5 and 15:
hm_getfilletfaces 5 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
521,hm_getfilletfacesfrommark,"Description
Returns the faces containing fillets with a radius inside a range, only considering
        specific faces.
","Inputs

entity_type
The type of entity to consider. Currently supported values are: 
assems - finds fillet faces only from the surfaces based on the assembly structure of
            the specified assems. 
comps - finds fillet faces only from the surfaces in the specified comps. 
surfs - finds fillet faces only from the specified surfs.
mark_id
The ID of the mark containing the entities to consider. Valid values are 1 and 2.
radius_min
The minimum radius value.
radius_max
The maximum radius value.

","Example
To get the faces with fillets with a radius between 5 and 15 only for surfaces in the
        assembly assem1:
*createmark assems 1 assem1
hm_getfilletfacesfrommark assems 1 5 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
522,hm_getgeometricthinsolidinfo ,"Description
Identify and return information on thin solid surface groups. 
The output is a list of lists, which includes the below information. 
Basic output mode:
Estimated thickness value. 
Solid ID (for solids input) or first surface ID (for surfaces input).
To get all surfaces within the connected section, take this surface ID and select
                all attached surfaces.




The basic output format looks like:
{thickness1 id1} {thickness2 id2} ... {thicknessN idN}
","Inputs

entity_type
The type of entity to query. Valid values are surfs and solids.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
<option>=<value>
The advanced options that control the behavior. Multiple options can be
                  specified, in any order.
feature_angle=<angle>
The maximum angle for separating solid features. The default is the
                        geometry feature angle.
max_thickness=<thickness>
The maximum thickness to be considered as a thin solid. Default is 0,
                        meaning unlimited.
mode=<mode>
The output mode, either simple (default) or advanced. The advanced output
                        includes the master, slave and thickness surface group details.
thinsolid_ratio=<ratio>
The ratio between the minimum (thickness) and middle (approximate width)
                        dimensions. Default is 0.5.





","Examples
Query thin solid info on solids 1-3 using defaults:
*createmark solids 1 1-3
hm_isgeometrythinsolid solids 1
{1.25 1} {2.5 3}
Query thin solid info on surfaces 1-10 using simple mode:
*createmark surfs 1 1-10
hm_isgeometrythinsolid surfs 1 mode=simple
{1.25 5}
Query thin solid info on solids 1-3 using advanced mode:
*createmark solids 1 1-3
hm_isgeometrythinsolid solids 1 mode=advanced
{1.25 1 {1 2 3 4 5 6} {7 8 9 10 11 12} {13 14 15 16}} {2.5 3 {101 102 103 104} {105 106 107 108} {109 110 111 112}}
Query thin solid info on surfaces 1-20 using advanced mode:
*createmark surfs 1-20
hm_getgeometricthinsolidinfo surfs 1 mode=advanced
{0.5 0 {1} {7} {13 14 15}} {1 0 {2 10 11 12 16} {3 4 5 6} {8 9 17 18}}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
523,hm_getgeomtopologytype ,"Description
Returns the topology type of a geometric entity.  Return types include:


points - none, vertex, fixed
lines - none, free, shared, nonmanifold, suppressed
surfs - free, bounding, partition, fin
solids - 1dmappable, 3dmappable, unmappable, ignoredmappable


","Inputs

entity_type
The type of entity to query.  Valid values are points, lines, surfs and solids.
id
The ID of the entity to query.

","Example
To query the topology of surface 100:
hm_getgeomtopologytype surfs 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
524,hm_getguientityname,"Description
This command returns the fully qualified and properly captialized HyperMesh entity name for the specified
          entity_type_id. Each entity type in HyperMesh is assigned a unique ID. This ID is converted to the entity type name
        using this command. 
If entity_type_id is not valid, undefined will be returned. 
This is the inverse of the hm_getentitytype command. 
","Inputs

entity_type_id
The unique entity type ID.

","Examples
To get the name of entity type 1 (Nodes):
hm_getguientityname 1
To get the name of entity type 11 (Properties):
hm_getguientityname 11
","Errors
None.
"
525,hm_gethistorymemorylimit,"Description
Returns the maximum amount of memory allowed to be used for recording history.
","Example
To get the maximum amount of memory allowed to be used for recording history:
hm_gethistorymemorylimit
","Errors
None.
",
526,hm_gethmfileuserprofile ,"Description
Returns the user profile information saved in the specified HyperMesh database. The string is comprised of 3 parts, application,
        profile and subprofile. For example: HyperMesh RadiossBlock
        Block140
","Inputs

filename
The full path and filename of the database file. Paths with spaces must be enclosed in
            quotes.

","Example
To get the user profile for C:\temp\test.hm:
hm_gethmfileuserprofile  C:/temp/test.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
527,hm_getidpoolnumber ,"Description
Returns the ID pool number for a given solver and ID pool name.
","Inputs

solver_id
The solver template ID. If set to 0 the current template is used.
pool_name
The solver pool name to query.

","Example
To get pool number of LS-DYNA element ID pool
        ELEMENT_SOLID_IDPOOL:
hm_getidpoolnumber 9  ELEMENT_SOLID_IDPOOL 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
528,hm_getidpoolsforidrange ,"Description
This command returns a list of pool names for the specified entity_type
        and solver_id_range. The solver_id_range
        must be specified using solver ID values. The range must be specified using a dash - to
        define the range. Only one continuous range may be specified.
If a entity of entity_type exists with the same solver ID in multiple
        pools, all pools containing that solver ID will be returned.
This command is only applicable to templates that support ID pools.
","Example
To get the list of pool names for elements with solver IDs 100-300:
hm_getidpoolsforidrange elems 100-300
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
529,hm_getincludeisolationentitiesmark,"Description
Returns the entities referenced/cross-referenced by the selected components, for include
        file organization purposes.
","Inputs

input_mark_id
The ID of the input mark containing the components. Valid values are 1 and 2.
output_mark_id
The ID of the output mark that should contain the related entities. Valid values are 1 and 2.
isolate_special
A flag indicating whether to force isolation of individual mass, rigid or joint
            elements containing only isolated nodes.
reserved
Reserved for future use. Should be set to 0.

","Example
To put the entities related to components 1 and 2 onto mark 2:
*createmark comps 1 1 2
 hm_getincludeisolationentitiesmark 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
530,hm_getincludes_modified_since_last_export,"Description
Returns the include file IDs marked as dirty since the last export.
","
Inputs

None.
","Examples
None.
","Errors
None.
"
531,hm_getincrementalname,"Description
This command returns a unique incremental name from a specified base name and one or more
        entity types (for example, name1, name2, etc.). Multiple entity types might require the same
        name (generate comp/mat/prop with same name), so the returned name is unique across the
        specified entity types.
","Inputs

entity_type_list
A quoted list of entity types to consider for generating the name. A unique
            incremental name is found considering all of the specified types. Only named entity
            types are valid.
base_name
The base name to use for generating the incremental name. A blank string can be
            specified to just use the incremental ID as the name. Names with spaces must be enclosed
            in quotes.
start_num
An argument that specifies the starting number for generating the incremental name.
            Unless specified as 0, the increment counter always starts at 1. Valid values are: 
Non-negative integer - Find the first available incremental name starting from this
            value.
-1 - Use the highest available incremental name (the generated name never falls inside
            of existing names). This is the default.
-2 - Use the lowest available incremental name (the generated name could fall inside
            of existing names).
num_digits
An argument that specifies the number of digits to use for generating the incremental
            number. If 0, use the minimum number of required digits (default). If the generated
            incremental number does not fit within the specified value, an error is returned.
separator
An argument that specifies the separator (delimeter) that will be appended between the
            base name and the number.  Only valid when start_num is -1.

","Examples
Assume a model has entities with the following names:
Components:
1
2
4
5
my_name1
my_name2
my_name4
my_name5
my_names001
my_names008


Materials:
my_names001
my_names002


Properties:
my_names001
my_names009


The generated names for the examples are shown below the command.
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the highest available incremental name:
hm_getincrementalname ""comps"" """"
or
hm_getincrementalname ""comps"" """" -1
6
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the lowest available incremental name:
hm_getincrementalname""comps"" """" -2
 3
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the lowest available incremental name starting from 0:
hm_getincrementalname ""comps"" """" 0
0
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the lowest available incremental name starting from 1:
hm_getincrementalname ""comps"" """" 1
3
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the lowest available incremental name starting from 4:
hm_getincrementalname ""comps"" """" 4
6
To generate a name based off of components in the form N, where N is the incremental ID of
        any length, using the lowest available incremental name starting from 50:
hm_getincrementalname ""comps"" """" 50
50
To generate a name based off of components in the form my_nameN, where N is the incremental
        ID of any length, using the highest available incremental name:
hm_getincrementalname ""comps""
            my_name
or
hm_getincrementalname ""comps"" my_name -1
my_name6
To generate a name based off of components in the form my_namesNNN, where NNN is the fixed
        incremental ID length, using the highest available incremental name:
hm_getincrementalname ""comps"" my_names -1 3
my_names009
To generate a name based off of components, properties and materials, in the form
        my_namesNNN, where NNN is the fixed incremental ID length, using the highest available
        incremental name:
hm_getincrementalname ""comps props mats"" my_names -1 3
my_names010
To generate a name based off of components, properties and materials, in the form
        my_namesNNN, where NNN is the fixed incremental ID length, using the lowest available
        incremental name:
hm_getincrementalname ""comps props mats"" my_names -2 3
my_names003
To generate a name based off of components and materials, in the form my_nameNNN, where NNN
        is the fixed incremental ID length, using the highest available incremental name:
hm_getincrementalname ""comps mats"" my_names -1 3
my_names009
To generate a name based off of components and materials, in the form my_nameNNN, where NNN
        is the fixed incremental ID length, using the highest available incremental name:
hm_getincrementalname ""comps mats"" my_names -2 3
my_names003
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
532,hm_getinternalid ,"Description
This command returns the internal HyperMesh ID for a solver ID
        and solver ID pool. This command is only applicable to templates and entity types that have
        ID pools.
","Inputs

id_pool
The pool ID or name. By default, the value is assumed to be the pool ID. This is
            controlled by the optional search_type argument.
solver_id
The solver ID to query.
search_type
Defines whether id_pool is specified as a pool name or a pool ID.
            Valid values are -bypoolid and -bypoolname. If not specified, it defaults to
            -bypoolid.

","Examples
To get the internal HM ID of pool ID 1 and solver ID 2:
hm_getinternalid 1 2
or
hm_getinternalid 1 2 -bypoolid
To get the internal HM ID of pool PROP_IDPOOL and solver ID 17:
hm_getinternalid PROP_IDPOOL 17 -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
533,hm_getlinearclenpoint ,"Description
This command finds and returns the coordinates of the point of the line
          line_id, whose arc-length distance from the point P with coordinates
          (x_coord, y_coord, z_coord) is arc_distace. If point
        P is not on the line then an error is returned. Otherwise, the result is returned in a list
        that contains 4 entries. The first 3 are the coordinates of the point and the last one is a
        flag. Possible flag values are 0, -1 and -2. Flag value 0 means that the result point is
        found to be on the line. If the result point happens to be off the line because the given
          arc_distace is too large, then flag gets values -1 or -2 depending on
        whether the result is off the start point or off the end point of the line, respectively. In
        this case, the returned point is the start or the end point of the line depending on the
        case.
","Example
To get the coordinates of the point of line 2751, that is at an arc-length distance of 8.5
        from the point (10.2, 32.5, 2) that lies on the line:
getlinearclenpoint 2751 8.5 10.2  32.5  2 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
e.
",
534,hm_getlinelineangle ,"Description
Returns the angle between two lines at one of their intersection points. If the specified
        point is found to be on both lines, then it calculates the angle between the lines at this
        point and returns its value in degrees. Otherwise, an error is returned.
","Inputs

line_id1
The ID of the first line.
line_id2
The ID of the second line.
x y z
The coordinates of the intersection point.

","Example
To find the angle between line 43 and line 58 at point (4.7, 6.88, 9.4): 
hm_getlinelineangle 43 58 4.7 6.88 9.4 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
535,hm_getlinestartpoint ,"Description
Returns the components of the line start point. If the line is a closed loop, the start and
        end points will return the same value.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the start of the line with ID 341:
set list [hm_getlinestartpoint 341]
set x [lindex $list 0]
set y [lindex $list 1]
set z [lindex $list 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
536,hm_getlinetgendpoint ,"Description
Returns the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the line end point. The first 3 return values are the tangent vector
        components, and the 4th return value is the angle.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the end of the line with ID 341:
foreach {tg_x tg_y tg_z ang} [hm_getlinetgendpoint 341] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
537,hm_getlinetype ,"Description
Returns the line type. Return values are:
0 - Free line
1 - Free surface edge
2 - Shared surface edge
3 - Non-manifold surface edge
4 - Suppressed surface edge


","Inputs

line_id
The ID of the line.

","Example
To get the type of the line with ID 341:
hm_getlinetype 341
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
538,hm_getllsid ,"Description
Returns the IDs of the latitude lines.
","Example
To get the IDs of the latitude lines:
hm_getllsid
","Errors
None.
",
539,hm_getmark ,"Description
Returns the entity IDs of the passed entity type on the specified mark.
","Inputs

entity_type
The type of entity to query.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid options are:0 - Use the previous panel (default).
1 -
              Use the current panel.

model_name
The optional model to get the mark for. If not specified, the current model is
            used.

","Examples
To return the components on mark 1:hm_getmark comps 1
To return the components on mark 1 for model
        model-2:hm_getmark comps 1 0 model-2
A mark of loads is created in the Delete panel. The Mask panel has been pushed using the
        command ""hm_pushpanel mask"". A mark of loads is created in the Mask
        panel. To get the list of loads on mark 1 created from the Mask
        panel:hm_getmark loads 1 1
To get the list of loads on mark 1 created from the Delete
        panel:hm_getmark loads 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
540,hm_getmarkentitytypes ,"Description
Returns a list of entity types that have entities populated on the specified mark.
","Inputs

mark_id
The mark ID of interest. Valid values are 1 and 2.

","Example
To get the list of entity types that have entities populated on mark 1:
hm_getmarkentitytypes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
541,hm_getmass ,"Description
This command returns the mass, volume and area of the selected elements or components.
","Inputs

entity_type
The type of entities to consider. Valid values are elems and comps.
mark_id
The ID of the mark. Valid values are 1 and 2.
mass_type
The type of mass to output.
0 - All mass values
2 - structural mass
3 - non-structural mass
4 - rigid mass
5 - lumped mass
6 - transferred mass
7 - engineering mass
8 - distributed mass

","Example
To get the mass for elements 1-100: 
*createmark elems 1 1-100
set temp [hm_getmass elems 1]
set mass [lindex $temp 0]
set vol [lindex $temp 1]
set area [lindex $temp 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
542,hm_getmatrixdifference,"Description
Given 4x4 transformation matrices, representing the orientation and positions of two
        geometric shapes A and B, return the transformation matrix that brings the A to B. This can
        be used in conjunction with hm_getorientation that returns the
        transformation matrices for various entity types.
The ouput is a list of 16 values representing the 4x4 matrix M1-1M2.
","
Inputs


matrix_1
The first matrix, passed in as a list of 16 values.
matrix_2
The second matrix, passed in as a list of 16 values.

","Examples
Find the difference between the orientation of two selections of surfaces:
*createmark surfs 1 23-44
set x [hm_getorientation surfs 1]
*createmark surfs 1 56-60
set y [hm_getorientation surfs 1]
hm_getmatrixdifference $x $y
Find the difference between the orientation of two components:
*createmark comps 1 44 45
set x [hm_getorientation comps 1 comparetype=1]
hm_getmatrixdifference [list [lindex $x 0]] [list [lindex $x 1]]

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
543,hm_getmemoryinfo ,"Description
This command returns a list of system memory information. This is available on Windows and
          Linux platforms only.
","Example
To get the system memory information:
hm_getmemoryinfo
","Errors
None.
",
544,hm_getmeshfaceparams ,"Description
This command returns all of the relevant automesh settings applied to a surface face by
          *set_meshfaceparams. If no automesh settings are applied, no values are
        returned. The returned values are (in order):
shape_type
elem_type
alg_type
elem_size
smooth_method
smooth_tol
size_control
skew_control


","Inputs

face_id
The global face ID of the surface face to query.

","Example
To get the automesh parameters assigned to face with ID 15:
hm_getmeshfaceparams 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
545,hm_getmethodinfo,"Description
Returns method information from the stress tool .
","Inputs

type
The type of information to return.  Valid values are categories, filenames, names and
            types.

","Example
To get the list of method types:
hm_getmethodinfo types
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
546,hm_getmidsurfcomp ,"Description
Returns the name of the component in the model that contains middle surfaces and no other
        surfaces.  If such a component does not exist, or if there are more than one such
        components, the command returns ""Middle Surface"".
","Example
To get the middle surface component:
hm_getmidsurfcomp
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
547,hm_getmodelcheckcheckname,"Description
Returns the function name for a given check.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

","Examples
To get the function name for the ""Unused materials"" check:
hm_getmodelcheckcheckname ""Unused materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
548,hm_getmodelcheckcheckstatus,"Description
Returns the status for a given check.
0 - Check is not run
1 - Check is run and there are failed entities
2 - Check is run but there are no failed entities 
3 - Relevant entities to run the check are not present in the model


","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

","Examples
To get the status for the ""Unused materials"" check:
hm_getmodelcheckcheckstatus ""Unused Materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
549,hm_getmodelcheckcorrectionname,"Description
Returns the function for a given correction.
","
Inputs



correction_display_name

The GUI display name of the correction. This is case sensitive.

","Examples
To get the function for the ""Delete unused materials"" correction:
hm_getmodelcheckcorrectionname ""Delete unused materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
550,hm_getmodelcheckdefaultconfigfile,"Description
Returns the default model check config file for a profile.
If a user specified config file is not present, then it gives the default config file
        provided in the installation.
","
Inputs



profile

The name of a specific profile to query.  If not specified, then the default config
            file for the current profile is returned.

","Examples
To return the default config file for ""LsDyna"":
hm_getmodelcheckdefaultconfigfile ""LsDyna""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
551,hm_getmodelcheckenttype,"Description
This command returns the entity type for the specified Model Check check display name.
","Inputs

display_name
The check display name.

","Example
To get the entity type for the check named ""Unused Materials"":
set enttype [hm_getmodelcheckenttype ""Unused Materials""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
552,hm_getmodelcheckresultentids ,"Description
Returns the entity IDs for the specified Model Check check display name.
","Inputs

display_name
The check display name.

","Example
To get the entity IDs for the check named ""Unused Materials"":
set ids [hm_getmodelcheckresultentids ""Unused Materials""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
553,hm_getmodelchkvaluelevellimitcriteriaattribute ,"Description
This command returns model check values for level, limit, criteria and attributes for the
        specified check display name.
","Inputs

display_name
The display name of the check to query.

","Example
To get the attribute values for check ""Material E is not defined"":
hm_getmodelchkvaluelevellimitcriteriaattribute ""Material E is not
          defined""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
554,hm_getmoiofsolid,"Description
This command will return 6 values defining the moment and product of inertia values from
        the specified solid entity:
Ixx Iyy Izz Ixy Iyz Izx 
These values will be calculated relative to the center of gravity/center of mass of the
        solid (obtained using hm_getcentroid) and the global coordinate system
        ""translated"" to the COG. The user will specify the density value to use for the
        calculations.
If a density is not given, then the returned values are the ""mass normalized"" values, where
        the MOI values are reported normalized by value of volume*1.0. The volume can be calculated
        using hm_getvolumeofsolid.
","Inputs

solid_id
The ID of the solid.
density (optional)
Density value of the solid. If specified, must be > 0.

","Examples
To get the ""true"" MOI for a solid with ID 10 and a density of 1e-9:
hm_getmoiofsolid 10
            0.000000009
To get the ""mass normalized"" MOI for the solid with ID 10:
hm_getmoiofsolid 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
555,hm_getnearbyentities,"Description
Finds entities nearby entities on an input mark.
The options may be provided in any order.
","
Inputs


inputentitytype=<input_entity_type>
The input entity type to find nearby entities to.  Valid values are comps, elems,
            equations, loads, nodes, systems and vectors.
inputentitymark=<mark_id>
The ID of the mark of input entities.  Valid values are 1 and 2.
outputentitytype={<output_entity_type1> ?<output_entity_type2> ...
              <output_entity_typeN>?}
The list of output entity types to find.  Valid values are comps, elems, equations,
            loads, systems and vectors.
outputentitymark=<mark_id>
The ID of the mark of output entities.  Valid values are 1 and 2.
radius=<value>
The nearby search radius/size.
nearby_search_method=<method>
The optional search method, either box or sphere (default).

","Examples
To query loads and elements nearby comps 301 and 302 using a sphere of size
        100:*createmark comps 1 ""by id only"" 301 302
hm_getnearbyentities inputentitytype=comps inputentitymark=1 outputentitytypes={loads elems} outputentitymark=2 radius=100 nearby_search_method=sphere
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
556,hm_getnodegeometry ,"Description
Get the simplest geometry entity associated with the node.
","Inputs

nodeID
The ID of the node.

List containing two values. The first value is a type of geometry. It can have a value of
        none, point, line, or surface. The second value is an ID of the entity.
","Example
hm_getnodegeometry 1
returns:
none 0
If the node is associated with more than one geometric entity, only the simplest one is
        returned by this command. For example, using this command for a node located on the edge of
        a surface would return ""line"" and the line’s ID, because the line is simpler (fewer
        dimensions) than the surface. (A corner node would return a point because the corner is a
        vertex.)
","Errors
None.
"
557,hm_getoccupiedentitiesinrange ,"Description
Returns the list of occupied IDs in a specific range. The values are returned as a
        compacted list using ranges and commas where applicable.
","Inputs

entity_type
The type of entity to query.
pool_id
The ID of the entity pool to query.
range
The ID range within the specified pool to query. This should be encapsulated in
            quotes.

","Example
To get the element IDs in use in pool 2 for the range 100-200:
hm_getoccupiedentitiesinrange elems 2 ""100-200""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
558,hm_getoffsetZ0 ,"Description
This command returns the offset Z0 value of the specified element.
","Inputs

elem_id
The ID of the element to query.

","Example
hm_getoffsetZ0 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
559,hm_getorientation,"Description
Returns a 4x4 matrix (16 values) corresponding to the moment directions of the input.
","
Inputs


entity_type
The type of entity to query.  Valid values are elems, solids, surfs, nodes, comps and
            parts.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
comparetype=<value>
The type of comparison when entity_type is comps or parts:
0 - Consider both FE (elements) and CAD (surfs/solids).  Default if not
            specified.
1 - Prefer CAD.  Use FE when there is no CAD.
2 - Only CAD
3 - Prefer FE.  Use CAD when there is no FE.
4 - Only FE

","Examples
Find the difference between the orientation of two selections of surfaces:
*createmark surfs 1 23-44
set x [hm_getorientation surfs 1]
*createmark surfs 1 56-60
set y [hm_getorientation surfs 1]
hm_getmatrixdifference $x $y
Find the difference between the orientation of two components:
*createmark comps 1 44 45
set x [hm_getorientation comps 1 comparetype=1]
hm_getmatrixdifference [list [lindex $x 0]] [list [lindex $x 1]]

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
560,hm_getplaneintercepts ,"Description
Given a mark of entities, a plane definition, and a vector, returns the maximum and minimum
        coordinates on the cross-section defined by the virtual intersection of the entities with
        the plane, in the vector direction.
","Inputs

entity_type
The type of entities to consider. Valid values are elems, surfs and comps (elems take
            priority over surfs).
mark_id
The ID of the mark containing the input entities.
normal_x 
normal_y 
normal_z
Defines the normal direction of the input plane
base_x 
base_y 
base_z
 Defines the base location of the input plane and vector.
vec_x 
vec_y 
vec_z
Defines the vector direction.

","Example
To get the plane intercept coordinates for the plane defined by normal (1,0,0) base (0,0,0)
        and along the direction (0,1,0) for all displayed elements:
*createmark elems 1 displayed
hm_getplaneintercepts elems 1 1 0 0 0 0 0 0 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
561,hm_getpoolaliasname,"Description
Returns the alias name for a specified pool ID in current user profile.
","
Inputs



pool_id

The ID of the solver pool to query.

","Examples
To get the alias name for ID pool 20 for LS-DYNA:
hm_getpoolaliasname 20
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
562,hm_getprincipalaxes ,"Description
Returns the principal axes direction cosine values for the selected entities. The values
        are always returned relative to the global axes. The values are returned as 1st_direction_x
        1st_direction_y 1st_direction_z 2nd_direction_x 2nd_direction_y 2nd_direction_z
        3rd_direction_x 3rd_direction_y 3rd_direction_z.
","Inputs

entity_type
The type of entity to query. Currently supported for comps and elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
location_flag
Optional. Specifies the location about which the principal axes are calculated. Valid
            values are: 
0 - Global (0,0,0). Default. 
1 - COG location. 

","Example
To get the principal axes for components 1-5:
*createmark comps 1 1-5
hm_getprincipalaxes comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
563,hm_getqephtimestep ,"Description
This command returns the time step calculated from QEPH elements in a component.
","Inputs

name
The name of the component

","Example
To get the time step from component named ""Flange"":
hm_getqephtimestep ""Flange""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
564,hm_getqualitycriteriastatus,"Description
Checks the status of the quality criteria.
","Inputs

elementsize
Checks to see if it matches the existing quality criteria. If 0 is specified, the
            mismatch is not evaluated.

","Example
The output uses the following values: 
0 - Good criteria - criteria exist and match with the specified element size (if it
            is being checked). 
1 - Criteria do not exist.
2 - Bad (inconsistent) quality criteria. 
3 - Mismatch of the specified element size and the criteria.


","Errors
None.
"
565,hm_getreferencedentities ,"Description
Finds entities that are referenced by the specified entity. This includes collected
        references, data name references and attribute entity references. Each type of entity that
        is referenced by the specified input entity is returned in a list, and the found entities
        are placed on the specified mark for those entity types. See the list of supported entities
        for this command.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
reference_flag
The type of referenced entities to find. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2). 
Bit0
0 - Do not consider collected entity references. 
1 - Consider collected entity references. If the specified entity is not a
                  collector or is empty, nothing will be returned for this bit.
Bit1
0 - Do not consider data name entity references. 
1 - Consider data name entity references. If the specified entity does not have
                  any data name references, nothing will be returned for this bit.
Bit2
0 - Do not consider attribute entity references. 
1 - Consider attribute entity references. If the specified entity does not have
                  any attribute entity references, nothing will be returned for this bit. Only
                  entities for the currently loaded template are considered.


output_mark_id
The ID of the mark to place the found referenced entities on.Valid values are 1 and 2.
string_array
Reserved for future use. Must be set to 0.
number_of_strings
Reserved for future use. Must be set to 0.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are:
-byname - Search only by name. 
-byid - Search only by ID.



","Examples
To get all entities referenced by component with ID 100 on mark 1 and highlight them on the
        screen:
foreach entity_type [hm_getreferencedentities comps 100 7 1 0 0 -byid] {
    hm_highlightmark $entity_type 1 h
}
To get only collected entity references for component with ID 100 on mark 2:
hm_getreferencedentities comps 100 1 2 0 0 -byid
To get only data name entity references for component with ID 100 on mark 1:
hm_getreferencedentities comps 100 2 1 0 0 -byid
To get only attribute entity references for component with ID 100 on mark 1:
hm_getreferencedentities comps 100 4 1 0 0 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
566,hm_getreplacecomponentpairing,"Description
Returns the component pairing for part replacement.
","Inputs

existing_component_mark
The ID of the mark containing the existing/old components.
incoming_component_mark
The ID of the mark containing the incoming/new components.
pairing_mode
Option to define how pairing should be done:0 - Consider bounding box and collision
              approach.
 1 - Consider matching name of components first and then bounding box
              and collision approach.


","Example
To find the pairing of source comps 301 302 and target comps 503 505:
*createmark comps 1 301 302
*createmark comps 2 503 505
hm_getreplacecomponentpairing 1 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
567,hm_getresults,"Description
Returns results data.
<option>=<value> options can be provided in any order.
","Inputs

id=<value>
The ID of the result entity to query.
contour=<value>
0 - Do not contour
1 - Contour
dataname=<value>
The query data type.  Valid values are:
avgmethod
binding
complex_filter
corners
datacomps
datatypes
deriveddatacomps
derivedlayers
envEqns
fields
format
isderived
isvalidmodel
layers
loadcases
lspEqns
subcasetype
systems
dataset=<value>
The data type scalar, tensor or vector.
derived_subcase_id=<value>
The subcase ID for derived subcases of type envelope or lsp.
fileid=<value>
The file ID corresponding to the unique ID of the result file from the result
            entity.
fileid_subcase=<value>
The unique combinations for considering multiple subcases, separated by colons.  For
            example 1:1,2:1,3:1,4:2
resultcomponent=<value>
The component when dataset is tensor or vector.
step=<value>
The step index for a given subcase.
subcase=<value>
The subcase ID within the result file.
type=<value>
The derived loadcase type, either envelope or lsp (linear superposition).
xml=<value>
The complete file path of the XML file that holds the inputs for results query.

","Example
Generate a vonMises Stress contour for subcase 1 and step 0 for file 1 in result ID
        1:hm_getresults id=1 dataset=""Stress"" resultcomponent=""VonMises"" fileid=""1"" subcase=1 step=0 contour=1
Get the envelope derived subcase data for result ID
        1:hm_getresults id=1 type=envelope dataname=UniqueDerivedSubcase
Get the complex filter options for file ID 3 and subcase 5 for result ID
        1:hm_getresults id=1 fileid=3 subcase=5 dataname=complex_filter
Get the complex filter options for multiple file IDs and subcases for result ID
        1:hm_getresults id=1 fileid_subcase=1:1,2:1,3:1,4:2 dataname=complex_filter
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
568,hm_getsolidboundsforsurface,"Description
Returns a list of bounding surface IDs, one list for each set of bounding surfaces found,
        or nothing if there is not a valid closed bounds found.
","
Inputs



mark=<mark_id>

The ID of the mark containing the input surfaces.  Valid values are 1 and 2.

exclude_solids=<mark_id>

An optional Boolean 0|1 that indicates whether to consider surfaces that already bound
            solids. Default is 1 if not specified.

find_baffles=<mark_id>

An optional Boolean 0|1 that indicates whether to consider baffle/fin surfaces.
            Default is 0 if not specified.

","Examples
To find the solid bounds for surface 100:
*createmark surfs 1 100
hm_getsolidboundsforsurface mark=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
569,hm_getsolidsfromsurface ,"Description
Returns the list of solid IDs associated with a specified surface ID.
","Inputs

surfaceID
The ID of any surface in the model

","Example
To get a list of solids associated with surface of ID 1:
hm_getsolidsfromsurface 1
This command returns information necessary for running other commands related to surface
        and solid creation.
","Errors
None.
"
570,hm_getsolvercards ,"Description
This command returns a list of solver cards (template tags) for either the specified
          entity_type or id_pool. The syntax is different
        depending on the method chosen.
 If entity_type is specified, this command returns a list of all solver
        cards related to the specified entity_type. The specified
          entity_type must be the fully qualified HyperMesh entity name (see hm_getentitybasename) In
        this method the -byentitytype flag must be specified otherwise the
        command will treat entity_type as id_pool. 
If id_pool is specified, this command returns a list of all solver cards
        related to the specified id_pool. The optional
          search_type argument determines whether id_pool is
        specified as a pool name or a pool ID. Valid values for search_type are
          -bypoolid and -bypoolname. If
          search_type is not specified, it defaults to
          -bypoolid. This method is only applicable to templates that support ID
        pools.
","Examples
To get the solver cards for properties:
hm_getsolvercards properties -byentitytype
To get the solver cards for the ID pool with ID 1:
hm_getsolvercards 1
or
hm_getsolvercards 1 -byid
To get the solver cards for the ID pool with name one_idpool:
hm_getsolvercards one_idpool -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
571,hm_getsolverid ,"Description
Returns the solver ID and pool name for the specified HyperMesh
        internal ID. If there is no solver ID and pool for the specified entity, an error is
        returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The internal ID or name of the entity to query.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the solver ID and pool name for property with internal ID 4:
hm_getsolverid props 4
or
hm_getsolverid props 4 -byid
To get the solver ID and pool name for a material with name 1:
hm_getsolverid mats 1
or
hm_getsolverid mats 1 -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
572,hm_getsolverids ,"Description
Returns the solver ID and pool names for the specified HyperMesh internal ID. If there is no solver ID and pool for the specified entity, the internal ID
        and a blank ID pool are returned.
","Inputs

entity_type
The type of entities to query.
entity_ids
The list of internal IDs to query. The return values will be in the same order as the
            input list.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.
groupbypoolname
By default, the command returns the entity IDs in the order of the list, with a list
            item containing two sub-lists for each input ID (the sublists contain the solver ID and
            the pool name). If the string groupbypoolname is passed, the return
            values are grouped together by pool name, with two items returned for each pool found,
            the first being the pool name, and the second being the list of solver IDs found for
            that pool.

","Examples
To get the solver IDs and pool names for property with internal IDs 4 and 5:
hm_getsolverids props ""4 5""
or
hm_getsolverids props ""4 5"" -byid
To get the solver IDs and pool names for material with names 1 and 2:
hm_getsolverid mats ""1 2""
or
hm_getsolverid mats ""1 2"" -byname
To get the solver IDs and pool names for material with names 1 and 2 and group by pool
        name:
hm_getsolverid mats ""1 2"" groupbyname
or
hm_getsolverid mats ""1 2"" -byname groupbyname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
573,hm_getsourcecompsgroupsusingprefixbasenamesuffix,"Description
Returns a list of matching component IDs which have the same prefix-base-suffix name in the
        original model and an incoming model.
","
Inputs

None
","Examples
For components that are matching as shown below (ID in brackets):
abc-comp1-123.1234 (1) abc-comp1-123-4.5678 (4)
xyz-comp2-345.123 (2) xyz-comp2-345.789 (3)
hm_getsourcecompsgroupsusingprefixbasenamesuffix
  {1 4 2 3}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
574,hm_getsurfaceedges ,"Description
Get a list of edges associated with a specified ID.
","Inputs

surfID
 The ID of the surface for which edges are returned. Lists of surface edge IDs grouped
            by surface loops.

","Example
hm_getsurfaceedges 13
returns:
{1 3 5} {2 8}
meaning that the surface has two loops, the first one consisting of edges 1, 3, and 5, and
        the second consisting of edges 2 and 8.
","Errors
None.
"
575,hm_getsurfacenormal ,"Description
Gets the normals of the surfaces connected to the node or point whose ID is given as the
        argument.
","Inputs

entityType
The type of entity. Only nodes or points are supported.
entityID
ID of the entity.

","Examples
The result is returned as a list: { nsurfs x1 y1 z1 surf_id1 x2 y2 z2 surf_id2 …
          }

Where nsurfs is the number of surfaces attached to the point, xn yn zn are direction
        cosines of the normal of the surface having ID surf_idn. If no surfaces are attached, the
        list consists of the single number 0.
Suppose that node with ID 100 is located on a shared edge between surfaces having IDs 10 an
        11. To retrieve the normals at attached surfaces:
set node_norms [ hm_getsurfacenormal nodes 100 ]
   2 1.697E-001 7.988E-001 5.771E-001 10 1.699E-001 7.969E-001 5.796E-001 11
To get x cosine of the normal to surface 10 at this node:
lindex $node_norms 0
   1.697E-001

This function queries all surfaces connected to a given node to obtain the normal on each
        surface at a given node or point location. 
","Errors
None.
"
576,hm_getsurfacesbyarea,"Description
Gets the surfaces with an area smaller or equal to the specified value.
","Inputs

double
Maximum area that the user specifies.

","Example
hm_getsurfacesbyarea 40
","Errors
None.
"
577,hm_getsurfacesfromedge ,"Description
Gets all surfaces connected to the edge whose ID is supplied as the argument.
","Inputs

line_id 
ID of the edge.

","Example
To get surfaces connected to the edge with ID 2:
hm_getsurfacesfromedge 2
","Errors
None.
"
578,hm_getsurfacesfromvertex ,"Description
Gets all surfaces connected to the point whose ID is supplied as the argument.
","Inputs

point_id
Point ID. 

","Example
The function returns a list containing IDs of surfaces connected to the vertex points. 
To get surfaces connected to the vertex with ID 2:
hm_getsurfacesfromvertex 2
","Errors
None.
"
579,hm_getsurfacethicknessvalues ,"Description
This command returns the midsurface thickness and offset values for nodes, points, or
        elements. 
An error is returned if a non-topological point or node or an element not associated to any
        surface, is given as input.
","Inputs

entity_type
The type of entity to query. Valid values are nodes, points and elems.
entity_id
The ID of the entity to query. 
For nodes and points, the return result is a list with the number of list values equal
            to the number of surfaces connected to the entity. Each value is a list itself with
            three sub-values. The first value is the ID of associated surface, the second value is
            the thickness of the surface at the node or point location (-1 if not defined), and the
            third value is the thickness offset. 
For elements, only a single list value is returned, also with three sub-values
            indicating the surface ID, the thickness at the element centroid, and the offset at the
            element centroid.
mark_id
The ID of the mark containing the entities to query. Valid values are 1 and 2.

For nodes and points, the return result is a list with the number of list values equal
            to the total number of surfaces connected to each entity. Each value is a list itself
            with four sub-values. The first value is the ID of the or node, the second value is the
            ID of the associated surface, the third value is the thickness of the surface at the
            node or point location (-1 if not defined), and the fourth value is the thickness
            offset. 
For elements, the return result is a list with the number of list values equal to the
            total number of elements. For element_method 0-3, four sub-values
            indicating the element ID, the surface ID, the thickness of the element (-1 if not
            defined), and the offset of the element are returned. For
              element_method 4, the element ID is returned as the first
            sub-value. For each node of the element, a sub-list is returned containing the node ID,
            the thickness at the node and the offset at the node for the element. For example:
            {elem_id1 {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}} {elem_id2 {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}} … {elem_idn {node_id1 thickness_1 offset_1} {node_id2 thickness_2 offset_2} … {node_n thickness_n offset_n}}.
element_method
Only allowed for element mark_id based usage. This determines how the thickness and
            offset values are measured for elements (ignored when the mark only contains nodes or
            points). Valid values are: 
0 - Thickness and offset are measured at the element centroid. 
1 - Thickness and offset are measured as a weighted average of the element’s nodes. If
            an element spans multiple surfaces, -1 is returned for the surface ID, thickness and
            offset. 
2 - Thickness is measured at the element's nodes and the minimum value is used. The
            offset value from this node is also reported. If an element spans multiple surfaces, -1
            is returned for the surface ID, thickness and offset. 
3 - Thickness is measured at the element's nodes and the maximum value is used. The
            offset value from this node is also reported. If an element spans multiple surfaces, -1
            is returned for the surface ID, thickness and offset. 
4 - The thickness of each element node is returned. For elements that don't span
            surfaces but have nodes on shared/non-manifold edges or shared vertices, the reported
            values should all come from the same ""common surface"" of the element. For elements that
            do span surfaces, values for nodes on an edge/vertex between the shared surfaces, the
              ambiguous_values argument is used. For surfaces that don't have
            thickness, -1 is returned for the thickness and offset of any nodes associated with that
            surface.
ambiguous_values
Defines what to do when an element that spans multiple surfaces and a node of that
            element is on an edge/vertex between the shared surfaces. This option is only used for
              element_method=4 when a ""common surface"" or a ""most common surface""
            cannot be determined. Surfaces that don't have a thickness are ignored and not
            considered in the calculations. If all surfaces have no thickness, -1 is returned for
            all nodes. 
1 - Report the average value at nodes from spanned surfaces. 
2 - Report the minimum value at nodes from spanned surfaces. 
3 - Report the maximum of value at nodes from spanned surfaces.

","Examples
Suppose that the node with ID 100 is located on a shared edge between surfaces having IDs
        10 and 11. To retrieve the list of surfaces, thicknesses and offsets:
set node_thick [ hm_getsurfacethicknessvalues nodes 100 ]
To get the surface, thickness and offset at the centroid for element 50:
set elem_thick [ hm_getsurfacethicknessvalues elems 50 ]
 To get the surface, thickness and offset as the weighted node average for element 50:
*createmark elems 1 50
set elem_thick [ hm_getsurfacethicknessvalues elems 1 1 ]
To get the surface, thickness and offset for all displayed nodes:
*createmark nodes 1 displayed
set node_thick [ hm_getsurfacethicknessvalues nodes 1 0 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
580,hm_gettgofpointsonline,"Description
This command returns the line coordinates and tangents at each of the given line u
        parameters. For each u parameter, a list of six values is returned: 
The x component of the tangent. 
The y component of the tangent. 
The z component of the tangent. 
The x component of the point.
 The y component of the point. 
The z component of the point.


","Inputs

line_id
The ID of the line to query.
u_parameter_list
The list of u parameter values to query.

","Example
To get the tangent value to line 2619 at parameters 0, 0.3, 0.6 and 1:
hm_gettgofpointsonline 2619 ""0 0.3 0.6 1""
The result will be:
{6.99262682991E-001 7.14009158681E-001 -3.49660048614E-002 1.30423642953E+002 -1.27525626452E+002 -8.36964589224E+001} {8.61157286718E-001 5.07521178145E-001 -2.88163368057E-002 8.65818866056E+001 -1.61178431282E+002 -8.15929252958E+001} {9.71575894632E-001 2.36065122496E-001 -1.77070299994E-002 4.33332186353E+001 -1.78459163875E+002 -8.04130928544E+001} {9.88553405126E-001 -1.50402051914E-001 1.18906683276E-002 -2.96276296290E+001 -1.81248468873E+002 -8.00744589224E+001}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
581,hm_gettiedentities,"Description
 Finds elements or components tied to nodes, elements, components or contactsurfs.
","Inputs

input_entity_type
The type of the input entities. Valid values are nodes, elements, components or
            contactsurfs.
output_entity_type
The type of the entity to find/output. Valid values are elements and components.
input_mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
output_mark_id
The ID of the mark containing the output entities. Valid values are 1 and 2.
projection
0 - Do not compute the projection while getting the tied entities
1 - Compute the projection while getting the tied entities (default)

","Examples
To find and show elements tied to the displayed elements:
*createmark elems 1 displayed
hm_gettiedentities elems elems 1 2
*showentitybymark 2
To find and show elements tied to component 1:
*createmark comps 1 1
hm_gettiedentities comps elems 1 2
*showentitybymark 2
 To find and show components tied to component 3:
*createmark comps 1 3
hm_gettiedentities comps comps 1 2
*showentitybymark 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
582,hm_gettracksid,"Description
Returns the ID of the tracks.
","Example
To get the IDs of the tracks.
hm_gettracksid
","Errors
None.
",
583,hm_gettypefromidpoolnumber,"Description
Returns the type for a specified pool ID in the current user profile.
","
Inputs



pool_id

The ID of the solver pool to query.

","Examples
To get the type for ID pool 20 for LS-DYNA:
hm_gettypefromidpoolnumber 20
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
584,hm_getundoactions ,"Description
Returns the history actions on the undo list.
","Example
To get the history actions on the undo list:
hm_getundoactions
","Errors
None.
",
585,hm_getunoffsetablenodes ,"Description
Saves to the user list the unoffsetable nodes. Useful for CFD BL meshing. 
Consider a node and all its surrounding elements. The visibility angle of an element is the
        signed angle between the node normal and the element normal after subtracting 90 degrees.
        The visibility angle of the node is the minimum of the element visibility angle for all
        surrounding elements. The best visibility angle of the node is the maximum of the node
        visibility angle for all choices on the node normal. A node having zero or negative best
        visibility angle is considered absolutely unoffsetable. A node having its best visibility
        angle less than angle_threshold is considered unoffsetable.
","Inputs

entity_type
The type of entity to query. Valid values are comps and elems.
mark_id
The ID of the mark containing the entities to query. Valid values are 1 and 2.
angle_threshold
 A value >=0.0 and < 45.0 that defines the threshold visibility angle in degrees
            for determining a node is unoffsetable.

","Example
To find all unoffsetable nodes in comp1 using an angle threshold of 2.5:
*createmark comps 1 comp1
hm_getunoffsetablenodes comps 1 2.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
586,hm_getunresolvedids ,"Description
Returns the unresolved IDs for a specific entity type and optional ID pool. The values are
        returned as a list per ID pool:
{id_pool_id1 solver_ids1...} {id_pool_id2 solver_ids2...} ... {id_pool_idN solver_idsN...}
If there is no ID pool for the specified entity type, """" will be returned for
        id_pool_id.
","Inputs

entity_type
The type of entity to query.
?id_pool_id?
The ID of the ID pool to query. If empty, all ID pools are considered.

","Examples
To get the list of entity types with unresolved IDs, and to query the IDs:
foreach entity_type [hm_getunresolvedidcrossreferences] {
set ids($entity_type) [hm_getunresolvedids $entity_type]
}
To get the list of entity types with unresolved IDs, and to query the IDs for pool 1
        only:
foreach entity_type [hm_getunresolvedidcrossreferences] {
set ids($entity_type) [hm_getunresolvedids $entity_type 1]
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
587,hm_getusermark,"Description
This command returns the list IDs of entity_type that exist on the user
        mark. Only one user mark exists for each entity_type. 
The user mark is created either through the command hm_saveusermark or
        through panel input collectors via the ""save"" extended entity selection option.
","Examples
To get the user mark of properties:
hm_getusermark props
To create a mark of elements 1-3, save it to the element user mark and retrieve it
        later:
hm_createmark elems 1 ""1 2 3""
hm_saveusermark elems
hm_markclear elems 1
…
hm_getusermark elems

","Errors
This command does not return any errors.
",
588,hm_getuvcoordinates ,"Description
Returns the parametric uv coordinates at a node location on the referenced surface. The u
        and v values are returned as a list containing two values. The first value in the list is
        the value of u, and the second value is the value of v. 
This command is only valid for single surfaces or surfaces generated by trimming one
        original surface and suppressing edges. It is not valid for the generic case of surfaces
        composed from different parametric patches by suppressing edges only (for example, two
        separate surfaces stitched together, then edges suppressed).
","Inputs

surf_id
The ID of the surface.
node_id
The ID of the node. The node must be associated to the surface.
scaled
Optional argument used when the referenced surface is a trimmed surface. If the value
            is set to 0 (default), the uv coordinates returned will be in reference to the
            parametric space of original untrimmed surface. If the scale value is set to 1, the uv
            coordinates returned will be in reference to the parametric space of the trimmed
            surface.

","Example
To get the uv coordinates of node 5 of surface 1:
hm_getuvcoordinates 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
589,hm_getvalue ,"Description
Queries data names, attributes, and metadata on entities. It will return the value of any
        type of data name, attribute, or metadata of an entity. In addition, this command will also
        return the value at a specific index for array type of data names, attributes, and
        metadata.
","Inputs

entity_type
The type of entity to query.
<select_type>=<selection>
The entity or entities that are to be queried. There are several ways to provide the
            entities to be queried. Only one option can be used at a time:
id=<id>
The ID of the single entity to query.
name=<name>
The name of the single entity to query.
mark=<mark_id>
The ID of the mark containing the entities to query.
list=<list_id>
The ID of the list containing the entities to query.
user_ids={<id1> <id2> ... <idN>}
The IDs of one or more entities to query.
user_names={<name1> <name2> ... <nameN>}
The names of one or more entities to query.


dataname=<data name or attribute name/ID>
The dataname=value data name and/or attribute pair that defines the relevant data to
            query. For attributes, this can be either the attribute name or ID.  If not specified,
            one of the metadata_value... options must be used.
column=<column_index>
This is the optional column index for a 2D array. Used together with row_index, it
            returns the value at the specified row_index and column_index.
locationunit={<entity_id>, <face_index>}
Valid only for engineering loads.  This is required if a non-uniform load is being
            queried.  If the load is applied on a regular set, only
              <entity_id> is needed.  If the load is applied on solid element
            faces, then <face_index> is also required.


entity_id
The ID of the entity to query.
face_index
The index of the solid element face.


metadata_value=<metadata_name>
This is to query the metadata value for a specified metadata name. This is valid for
            all types of metadata.
metadata_value_count=<metadata_name>
This is to query the metadata count for a specified metadata name. This is valid for
            all types of metadata.
metadata_value_ids=<metadata_name>
This is to query the metadata entity IDs for a specified metadata name. This is valid
            for entity and entity array metadata.
metadata_value_type=<metadata_name>
This is to query the metadata entity type for a specified metadata name. This is valid
            for entity and entity array metadata.
modelname=<name_of_model>
This is the optional model name to query when there are multiple models in the
            database.  If not specified, the current model is used.
row=<row_index>
This is the optional row index for a 1D or 2D array. For 1D array, it returns the
            single value at the specified index. For a 2D array, it will return the entire row.

","Examples
 Get the node IDs in a set named
        node_set:hm_getvalue sets name=node_set dataname=ids
 Get the name of entity set with ID
        1:hm_getvalue sets id=1 dataname=name
Get the attribute Rho of material ID
        1:hm_getvalue mats id=1 dataname=Rho
Get the attribute 183 of material ID
        1:hm_getvalue mats id=1 dataname=183
Get materialid for components on mark
        1:hm_getvalue comps mark=1 dataname=materialid
Get node1 for elements 1 and 2 on list
        1:hm_getvalue elems list=1 dataname=node1
Get materialid for components with names ""mid"" and
        ""center"":hm_getvalue comps user_names={mid center} dataname=materialid
Get submodel types for include file
        10:hm_getvalue includes id=10 dataname=typesundersubmodel
Get the attribute Rho of material ID 1 for model
        model-2:hm_getvalue mats id=1 dataname=Rho modelname=model-2
Get a magnitude value for non-uniform distributed load 5 on node
        15:hm_getvalue loads id=5 dataname=magnitude locationunit={15}
Get a magnitude value for non-uniform distributed load 5 on element 25 face
        2:hm_getvalue loads id=5 dataname=magnitude locationunit={25,2}
Get the metadata value for an integer metadata with the name mymeta_int on a
        component:hm_getvalue comps id=1 metadata_value=mymeta_int
Get the metadata value for an entity metadata with the name mymeta_entity on a
        component:hm_getvalue comps id=1 metadata_value=mymeta_entity 
Get the metadata value entity count for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_count=mymeta_entityarray
Get the metadata value entity IDs for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_ids=mymeta_entityarray
Get the metadata value entity types for an entity array metadata with the name
        mymeta_entityarray on a
        component:hm_getvalue comps id=1 metadata_value_type=mymeta_entityarray
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
590,hm_getvolumeofsolid,"Description
This command finds the volume of the solid solid_id. The
          solid argument is actually the entity type, but because this command is
        specifically for solid volumes, ""solids"" is the only valid entity type.
","Example
To find the volume of solid 3:
hm_getvolumeofsolid solids 3
","Errors
Incorrect usage of hm_getvolumeofsolid results in a Tcl error. The function returns an error if the current model does not contain
        a solid with the given solid_id. 

If { [ catch {hm_getvolumeofsolid solids $solid_id } ] } { 
# Handle error here - $solid_id is not a valid solid ID. 
}

",
591,hm_getwrappoints ,"Description
Given a mark of entities, a plane definition, and a vector, returns the maximum and minimum
        coordinates on the cross-section defined by the virtual intersection of the entities with
        the plane, in the vector direction.
","Inputs

entity_type
The type of entities to consider. Valid values are elems, surfs and comps (elems take
            priority over surfs).
mark_id
The ID of the mark containing the input entities.
x1 
y1 
z1
Defines the normal coordinates of the first input point.
x2 
y2 
z2
Defines the normal coordinates of the second input point.
x3 
y3 
z3
Defines the normal coordinates of the third input point.

","Example
To get the wrap points for all displayed elements using input points (0,0,0) (10,0,0)
        (10,10,0):
*createmark elems 1 displayed
hm_getwrappoints elems 1 0 0 0 10 0 0 10 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
592,hm_historyscriptunsupportedtofile,"Description
Writes out to files a summary of the unsupported commands contained inside
          .tcl script files. An individual file or an entire directory
        (including its children) can be specified. 
The output files have the same name as the input .tcl files but with a
          .txt extension, and are written with the same directory structure as
        the input files.
","Inputs

input_file
The full name and path of the input .tcl file, or input
            directory.
output_dir
The full path of the directory where the output files will be written.

","Examples
To write out the list of unsupported commands for test.tcl in C:\temp to
          C:\output:
hm_historyscriptunsupportedtofile C:/temp/test.tcl C:/output
To write out the list of unsupported commands for all .tcl files in C:\temp to
          C:\output:
hm_historyscriptunsupportedtofile C:/temp C:/output
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
593,hm_holedetectionend ,"Description
Clears memory and ends the hole detection module. This must be preceded by any calls to
          hm_holedetectioninit and other hm_holedetection*
        APIs. 
""Major"" database changes made while inside of the hole detection module will invalidate and
        delete any results.
","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
To write out all geometric shell hole details to a file named C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
594,hm_holedetectionfindmates,"Description
Runs the hole detection mating functions for finding holes and tubes mating 'groups'. This
        must be preceded by a call to hm_holedetectionfindholes. 
All other parameters are optional and have default values. Parameters can be specified in
        any order.
","Inputs

max_angle
The maximum angle between the center line of holes/tubes. Default value 1.0.
max_distance
The maximum normal distance between the center of holes/tubes. Default value
            10.0.
max_lateral_distance
The maximum lateral distance to allow. Default value 1.0.
max_lateral_factor
The maximum lateral distance to allow, defined by scaling the diameter of the current
            hole using this factor. This is not used by default and must be explicitly defined. This
            is ignored if max_lateral_distance is also defined.
allow_hole_to_tube
0 - Do not allow mates to be found between holes and tubes (default) 
1 - Allow mates to be found between holes and tubes
allow_mismatched_shapes
0 - Do not allow mates to be found between different shapes (default) 
1 - Allow mates to be found between different shapes
allow_self
0 - Do not allow mates to be found within the same component (default) 
1 - Allow mates to be found within the same component

","Example
To write out all geometric shell mate details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
hm_holedetectionfindmates
set n [hm_holedetectiongetnumberofmates]
if { $n > 0 } {
puts $holesfile ""Number of mates = $n""
puts $holesfile ""Mate details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetmatedetails $i]""
}
} else {
puts $holesfile ""Holes mates not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
595,hm_holedetectiongetholedetailsdata,"Description
Returns details about a specific query for a hole/tube.
","
Inputs


index
The index of the hole/tube to get details for, starting from 0.
query_key
The keyword to be used for a specific shape type. Valid values are:


axis
The x/y/z coordinates of the axis.  Valid for all holes.
axis_bottom
The x/y/z coordinates of the bottom axis.  Valid for all tubes.
axis_top
The x/y/z coordinates of the top axis.  Valid for all tubes.
capped_flag
Returns true if there is a capped hole.  Valid for all tubes.
center
The x/y/z coordinates of the center.  Valid for all holes.
center_bottom
The x/y/z coordinates of the bottom center.  Valid for all tubes.
center_top
The x/y/z coordinates of the top center.  Valid for all tubes.
depth
The tube depth.  Valid for all tubes.
entities_list
The list of ordered nodes or lines.  Valid for all holes.
has_washer
Returns true if there is a washer.  Valid for all 2D mesh holes.
length
The side length.  Valid for square/rectangular holes.
length_bottom
The bottom side length.  Valid for square/rectangular tubes.
length_top
The top side length.  Valid for square/rectangular tubes.
radius
The circular radius.  Valid for circular holes.
radius_bottom
The bottom circular radius.  Valid for circular tubes.
rim_entities_bottom
The bottom list of ordered nodes or lines.  Valid for all tubes.
rim_entities_top
The top list of ordered nodes or lines.  Valid for all tubes.
radius_top
The top circular radius.  Valid for circular tubes only.
shape_type
The shape type.  Valid for all holes/tubes.
tube_barrel_info
The number of barrels, barrel types, and entity IDs in the format
                  {number_of_barrels {barrel_type {surface/element/face IDs}}}.  Valid for all
                  tubes.
tube_entities_list
The list of tube surfaces, shells, or solids and face indices.  Valid for all
                  tubes.
width
The side width.  Valid for rectangular holes.
width_bottom
The bottom side width.  Valid for rectangular tubes.
width_top
The top side width.  Valid for rectangular tubes.



","Examples
To write out geometric shell hole queried information details to C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""queried data details of hole""
puts $holesfile ""shape-type = [hm_holedetectiongetholedetailsdata 0 shape_type]""
puts $holesfile ""center = [hm_holedetectiongetholedetailsdata 0 center]""
puts $holesfile ""radius = [hm_holedetectiongetholedetails 0 radius]""
puts $holesfile ""entities list = [hm_holedetectiongetholedetails 0 entities_list]""
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
596,hm_holedetectiongetnumberofholes ,"Description
Returns the number of found holes/tubes. This must be preceded by a call to 
          hm_holedetectionfindholes.
","Example
 To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
597,hm_getholedetectionwasherelementslist,"Description
Returns the ID of washer elements layer-wise. This must be preceded by a call to
          hm_holedetectionfindholes.
The output is in the format:
{Number of layers {layer 1 elem IDs…} {layer 2 elem IDs…} {layer 3 elem IDs…} etc...}
For example:
{2 { 430 429 428 427 426 425 424 423 422 419}{ 418 417 416 415 414 413 412 411 410
        409}}
","
Inputs


index
The index of the node/line to get the associated hole index.

","Examples
To output the the washer elements layer-wise for each detected hole that has washer
        elements to the command window:
hm_holedetectioninit
*createmark elems 1 all
hm_holedetectionsetentities elems 1
hm_holedetectionsetholeparams hole_shape=1
set find_type 1
hm_holedetectionfindholes $find_type
puts ""---------------------------------------------------------------------""
set num_holes [hm_holedetectiongetnumberofholes]
puts "" Number of Shell Holes:: $num_holes""

for {set i 0} {$i < $num_holes } {incr i } {
	set holedetailslist [hm_holedetectiongetwasherelementslist $i]
    puts ""hole index:$i $holedetailslist""
}
puts ""---------------------------------------------------------------------""
hm_holedetectionend

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
598,hm_holedetectioninit ,"Description
Initializes the hole/tube detection module. This must precede any calls to other
          hm_holedetection* APIs, and must be followed by a call to
          hm_holedetectionend. 
""Major"" database changes made while inside of the hole detection module will invalidate and
        delete any results.
","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
599,hm_holedetectionsetholeparams ,"Description
Defines parameters for finding 2D holes in both geometry and FE. Multiple calls to this
        command can be made to override or redefine the parameters for each hole shape. Settings are
        cleared on any call to hm_holedetectioninit/hm_holedetectionend. 
This must be preceded by a call to hm_holedetectioninit. 
Only hole_shape is mandatory. All other parameters are optional and have
        default values. Parameters can be specified in any order.
","Inputs

hole_shape=
The shape of hole the parameters are being defined for. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Do not consider general holes 
1 - Consider general holes
Bit1
0 - Do not consider circular holes 
1 - Consider circular holes
Circular holes: The distance from any of its nodes to the calculated center must
                  not differ from the calculated radius by more than
                    max_geom_dev_percent and max_geom_dev_abs
                  (if enabled). Also, no edge must make an angle greater than
                    max_smooth_edge_angle with either adjoining edge.
Bit2
0 - Do not consider rounded holes. 
1 - Consider rounded holes.
Rounded holes: The distance from any of the nodes on the rounded ends to the
                  respective calculated centers must not differ from the calculated radii by more
                  than max_geom_dev_percent and
                    max_geom_dev_abs (if enabled). The radii must be within
                    max_geom_dev_percent of each other. Also, no edge must make
                  an angle greater than max_smooth_edge_angle with either
                  adjoining edge. Opposite straight sides must have lengths within
                    max_geom_dev_percent of each other.
Bit3
0 - Do not consider square holes. 
1 - Consider square holes.
Square holes: At every node except four, no edge must make an angle greater than
                    max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent and
                    max_geom_angle_dev_abs (if enabled) of 90 degrees. And, all
                  four sides must have lengths within max_geom_dev_percent and
                    max_geom_dev_abs (if enabled) of their average. The sides
                  must have a relative deviation from straight lines of not more than
                    max_straightness_dev_percent.
Bit4
0 - Do not consider rectangular holes.
1 - Consider rectangular holes.
Rectangular holes: At every node except four, no edge must make an angle greater
                  than max_smooth_edge_angle. At those four nodes, the measured
                  angle is within max_geom_dev_percent and
                    max_geom_angle_dev_abs (if enabled) of 90 degrees. Opposite
                  pairs of sides must have lengths within max_geom_dev_percent
                    and max_geom_dev_abs (if enabled) of each other. The sides
                  must have a relative deviation from straight lines of not more than
                    max_straightness_dev_percent.


?hole_type=<>?
The hole type to consider. If 0 (default), the holes type check is skipped. Bit values
            are used and the value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3).
Bit0
0 - Do not consider surface holes. 
1 - Consider surface holes.
Surface holes: Holes with small angle deviation of axis of adjacent surface
                  normals.
Bit1
0 - Do not consider flanged surface holes 
1 - Consider flanged surface holes
Flanged surface holes: Holes with bent edges (stiffness ring rib).
Bit2
0 - Do not consider cylindrical holes. 
1 - Consider cylindrical holes.
Cylindrical holes: Free edge loops of cylinders.
Bit3
0 - Do not consider conical holes. 
1 - Consider conical holes.
Conical holes: Free edge loops of cones.


?max_avg_adj_surf_angle=<>?
Maximal average angle deviation of holes axial direction of adjacent surfaces normals.
            Acceptable values are [0.0, 90.0]. If less than 0.0, this check is skipped. Default
            value 45 degrees.
?max_big_planar_dim=<>?
This threshold applies to the rounded (elongated) and rectangular holes. The maximum
            planar dimension of the hole cannot exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.
?max_geom_angle_dev_abs=<>?
Sets the absolute angle threshold for deviation of corner angles of rectangular holes
            from right angle, see holes shape. Acceptable values are [0.0, 90.0], otherwise the
            closer extreme is used. If less than 0.0, this check is skipped. Default value -1.
?max_geom_dev_abs=<>?
Sets the absolute threshold for linear hole shape deviation, see hole_shape. If less
            than 0.0, this check is skipped. Default value -1.
?max_geom_dev_percent=<>?
Sets the relative threshold for hole linear and angle shape deviation, see hole_shape.
            Acceptable values are [0.0, 100.0], otherwise the closer extreme is used. If less than
            0.0, this check is skipped. Default value -1.
?max_offset_plane_dev=<>?
No node on the perimeter of a hole must exceed this distance from the mean plane. If
            less than or equal to 0.0, this check is skipped. Default value 0.0.
?max_planar_dim=<>?
The maximum width of the hole cannot exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.
?max_smooth_edge_angle=<>?
See hole_shape. Acceptable values are [0.0, 90.0], otherwise the closer extreme is
            used. If less than 0.0, this check is skipped. Default value -1.
?max_straightness_dev_percent=<>?
Sets the relative threshold for the chordal deviation of the sides of rectangular
            holes of straight lines, see hole shape. Acceptable values are [0.0, 100.0], otherwise
            the closer extreme is used. If less than 0.0, this check is skipped. Default value
            -1.
?min_planar_dim=<>?
The minimum width of the hole must exceed this value. If less than or equal to 0.0,
            this check is skipped. Default value 0.0.

","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
600,hm_idconvertmode,"Inputs

flag
1 or 0 
0 = strings containing trailing alpha characters (e.g., 001PART) are converted to an
            ID by *createmark and *appendmark. The default is
            0. 
1 = the string must not contain alpha characters to be converted to an ID

","Example
To put a component with ID 1 on the mark if it exists and 001FRONT does not.
hm_idconvertmode 0
*createmark comps 1 001FRONT
To put a component with name 001FRONT on the mark if it exists.  Otherwise, the mark is empty.
hm_idconvertmode 1
*createmark comps 1 001FRONT
","Errors
None.
",
601,hm_intersectlineline ,"Description
s1x0 s1y0 s1z0 
s1x1 s1y1 s1z1 
s2x0 s2y0 s2z0 
s2x1 s2y1 s2z1
The four 3D points, which are the start and end points of two segments. 
Return value: x y z
","Example
hm_intersectlineline   0.0 0.0 0.0  2.0 0.0 0.0  -1.0 0.0  0.0 1.0 0.0 0.0 
Result: 1.0 0.0 0.0 
","Errors
None.
",
602,hm_isentitydatanameparameterized ,"Description
Determines if a specific data name or attribute is parameterized. A return value of 0 means
        it is not parameterized. A return value of 1 means it is parameterized.
","Inputs

entity_type
The type of entity to query.
id
The ID of the entity to query.
data_name_or_attribute
The data name or template attribute name/ID to query.
row_index (optional)
Row index for a 1D or 2D array. For a 1D array, it checks the parameterization at the
            specified row index. For a 2D array, it will check for the entire row. 
This should be blank for non-array data names/attributes.
column_index (optional)
Column index for a 2D array. Used together with row_index, it
            checks the parameterization at the specified row_index and
              column_index. 
This should be blank for non-array data names/attributes.

","Example
To check the parameterization of attribute with name LSD_DA1 for entity set 5:
hm_isentitydatanameparameterized sets 5 LSD_DA1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
603,hm_ishistorysupported ,"Description
Returns the history support level for the specified command. The return values are as
        follows: 
-1 - Command does not modify the database and therefore does not affect history 
0 - Command is not supported for history 
1 - Command is supported for history


","Inputs

command
The name of the HyperMesh Tcl Modify Command command to query.

","Example
To query the support level of *displaynone:
hm_ishistorysupported *displaynone
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
604,hm_ispointinsidesolidelem ,"Description
This command returns 1 if the point is found to be inside the solid element and 0
        otherwise.
","Inputs

x , y , z
The (x,y,z) coordinates of the point.
elem_id
The ID of the solid element.

","Example
To check whether the point with coordinates 10, 20, 30 is inside the solid element with ID
        1:
hm_ispointinsidesolid 10 20 30 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
605,hm_istextcard,"Description
This command returns 1, for control cards if it is a string array card, else it returns
        0.
","Inputs

entityId
The ID of an entity whose control card you wish to evaluate.

","Example
0 for non-text cards, or 1 for text string array cards.
A card is a string array card if: 
It has exactly three attributes.
Attributes 1 (template tag) and 2 (array size) are integers.
Attribute 3 is an array of strings.
",
606,hm_jobs_authenticateServer,"Description
Authenticates a server. No authentication is required for a local server.
","Inputs

name
The name of the server to authenticate.
username
The username to use to authenticate.
password
The password to use to authenticate.

","Example
To authenticate the server named HWUL:
hm_jobs_authenticateServer HWUL myuser abc123
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
607,hm_jobs_editServer,"Description
Edits an already existing server.
Note that the ""local"" server is not editable.
","Inputs

name
The name of the server to edit.
new_name
The new name of the server.
new_host
The new host/IP of the server.
new_port
The new port number on which the server will communicate.

","Example
To edit the server HWUL:
hm_jobs_editServer HWUL hwul 172.1.3.4 17084
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
608,hm_jobs_getServerDetails,"Description
Returns the name, IP and port of a server. If the server does not exist, nothing is
        returned.
","Inputs

name
The name of the server to query.

","Example
To query the server named HWUL:
hm_jobs_getServerDetails HWUL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
609,hm_jobs_getServerListFromServices,"Description
Returns the list of servers added by all applications.
Note that the ""local"" server is always available by default in the servers list and can
        neither be deleted nor edited.
","Example
To get the list of added servers:
hm_jobs_getServerListFromServices
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
610,hm_jobs_setCurrentServer,"Description
Set a server as current, and server actions correspondingly happen on the current
        server.
","Inputs


name
The name of the server to set as current.


","Example
To set server HWUL as current:
hm_jobs_setCurrentServer HWUL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
611,hm_jobs_startService,"Description
This command is used to explicitly start the PBS-sensor services. Any of the actions
        related to server go through PBS-sensor services. By default, PBS-sensor is started
        implicitly when any job related API is being used. In special cases this can be used to
        invoke the PBS-sensor services.
","Examples
To invoke PBS-sensor services explicitly:
hm_jobs_startService
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
612,hm_jobs_submitHSTJob,"Description
Submits a HyperStudy job to the server.
Returns the job ID upon successful submission, or null on failure.
Always set the current server on which the job needs to be submitted by using
          hm_jobs_setCurrentServer before submitting a job. To run jobs locally
        using PBS-sensor, set the current server as ""local"". Jobs submitted using the local server
        will run in sequential order. For local job submission, the
          additional_files and zip_flag arguments can be
        passed as null strings, and the master file should hold all the information related to the
        additional files.
","Inputs


app_id
The application name to which the job has to be submitted to (for example,
              HST_batch).
version
The HyperStudy version to use (for example, 2021).
job_name
The name of the job to submit.
solver
The solver to be used (for example, OptiStruct).
input_file
The full name and path of the input file.
output_path
The full path where the output should go.
additional_files
A string containing any required additional files that need to be uploaded.
zip_flag
Must be set as ""true"" if any .zip file is passed, ""false""
              otherwise.
args
Any additional HyperStudy command line arguments.


","Examples
To submit a HyperStudy job on the server:
hm_jobs_submitHSTJob HST_batch 14.0 ""new_job"" OptiStruct ""C:/temp/input/MASTER.hstx"" ""C:/temp/output"" ""{C:/temp/input/slave1.dat} {C:/temp/input/slave2.dat}"" false """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
613,hm_jobs_terminateJob,"Description
Kills a running job.
","Inputs


server_job_id
The server job ID returned after submitting a job that should be terminated.


","Examples
To kill job ID 122366.admin:
hm_jobs_terminateJob 122366.admin
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
614,hm_linegetorderelems,"Description
This command returns a list of lists for the input free edges. The first element of each
        list is the ID of the free edge and subsequent elements of that list are the IDs of the
        associated 1D elements.
For example, the output for two orphan edges of IDs 115822 and 115823 with associated 1D
        elements 8 and 9 is { 115822 8} { 115823 9}
","
Inputs



mark_id

The ID of the mark of lines.  Valid values are 1 and 2.
Only free lines are considered.

tolerance

The tolerance to compare association of 1D elements with respect to a free line. In
            the absence of this argument, best associated 1D elements will be returned.

","Examples
Find elements for all free lines using a tolerance of 0.5:
*createmark lines 1 all
hm_linegetorderelems 1 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
615,hm_linelength,"Description
Returns the sum of lengths of the lines whose IDs are given as arguments.
","Inputs

lineX_id
The ID number of a line.

","Example
If the total length is not an integer, it will be returned as a double precision floating
        point number whose number of significant digits is determined by the global variable,
        g_ConversionPrecision. The length of every line will only be computed once, even if it is
        listed several times. Zero will be returned if no IDs are given.
","Errors
None.
"
616,hm_markbyfeature ,"Description
Put entities on the specified output mark based on entities on the input mark selection and
        specified feature parameters.
","Inputs

input_mark_id
The ID of the input mark. Valid values are 1 and 2.
output_mark_id
The ID of the output mark to put the entities selected by feature. Valid values are 1 and 2.
param_string
This string contain keyword/value pairs, separated by whitespace. Valid keywords are:
feature_mode
This is mandatory input parameter. Valid values are: 
1 - Put on output mark lines representing circles.  Input mark entity type
                      is lines.
2 - Put on output mark lines representing circles.  Input mark entity type
                      is surfaces.
3 - Put on output mark surfaces representing cylinders.  Input mark entity
                      type is surfaces.
4 - Put on output mark surfaces representing fillets.  Input mark entity
                      type is surfaces.
5 - Put on output mark surfaces representing valve seats.  Input mark
                      entity type is surfaces.
6 - Put on output mark surfaces that contain internal discontinuities and
                      high curvature areas.  Input mark entity type is surfaces.


min_radius (optional)
This parameter filters output lines or surfaces by minimal curvature radius.
                  Valid values are any value > 0.0, or a value < 0.0 to specify any radius.
max_radius (optional)
This parameter filters output lines or surfaces by maximal curvature radius.
                  Valid values are any value > 0.0, or a value < 0.0 to specify any radius.
internal_only (optional)
Used only for feature_mode 1 or 2. If set to 1, all outer
                  circles on surfaces will be excluded from the output.
closed_cylinder (optional)
Used only for feature_mode 3. If set to 1, all non closed
                  cylinder surfaces will be excluded from the output.
valve_output (optional)
Used only for feature_mode 5. If set to 1, all surfaces
                  representing the cylinder part of a valve seat will be excluded from the output.
                



","Examples
To put on mark 2 all lines representing circles with radius between 1.0 and 15.0:
*createmark lines 1 all
hm_markbyfeature 1 2 ""feature_mode 1 min_radius 1.0 max_radius 15.0""
To put on mark 2 all surfaces representing closed cylinders with any radius:
*createmark surfaces 1 all
hm_markbyfeature 1 2 ""feature_mode 3 closed_cylinder 1 min_radius -1.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
617,hm_markclearall ,"Description
 This command clears all entity IDs for all entity types from the specified mark.
","Inputs

mark_id
The ID of the mark. Valid values are 1 and 2.
model_name
The optional model to clear all marks from. If not specified, the current model is
            used.

","Example
To clear the contents of mark 2 for all entity
        types:hm_markclearall 2
To clear the contents of mark 2 for all entity types for model
        model-2:hm_markclearall 2 model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
618,hm_markremove ,"Description
This command removes entities from the specified mark. Only entity IDs are allowed, and
        there are no advanced removal methods.
","Inputs

entity_type
The type of entity mark to remove.
mark_id
The ID of the mark. Valid values are 1 and 2.
list
The entity IDs to remove. When specifying the list using a Tcl
            variable, the eval Tcl command must precede the
              hm_markremove command (see example below). This expands (substitutes) the
              Tcl list before executing the command.

","Example
To remove the components with IDs 1 and 5 from mark 2:
hm_markremove comps 2 1 5
or, using a list:
set comps ""1 5""
eval hm_markremove comps 2 $comps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
619,hm_marktotable,"Description
Creates a named mark table and populates it with the entities on a mark. 
Tables are not stored within a HyperMesh file. When the current
        model is deleted or a new model is loaded, all tables are cleared. If a table contains an
        entity that is subsequently deleted, the entity is removed from the table.
","Inputs

entity_type
The type of entity mark to create the table for.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
table_name
 The name of the table to create. If a table with this name already exists, it will be
            replaced with the new table.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the list has been created from a panel entity selector under the
            above conditions. Valid options are: 
0 - Use the previous panel (default). 
1 - Use the current panel.
force
0 - Do not create the table if the mark is empty (default). 
1 - Create the table if the mark is empty.

","Example
To find all displayed elements that contain free edges and split them:
*createmark comps 1 ""displayed""
*findedges comps 1 0
*createmarklast elems 1
hm_marktotable elems 1 plot_table
*findmark elems 1 1 0 nodes 0 1
*findmark nodes 1 1 0 elems 0 1
foreach elem_id [hm_getmark elems $elem_mark] {
if {[hm_tablelookup plot_table $elem_id] == 0} {
*appendmark elems 2 $elem_id
}
}
*splitelements 4 2
hm_markclear elems 1
hm_markclear nodes 1
hm_tableclearall
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
620,hm_me_entitiesall,"Description
Returns all of the entity types and IDs contained in a module. The return is a list of
        lists, with the first value in each sublist being the entity type, and the remaining values
        being the entity IDs. For example:
{props 1 2} {mats 5} {elems 100 101 102} {nodes 100 101 102 103 104 105}
","Inputs


id
The ID of the module to query.


","Example
To get the entities contained in module 10:hm_me_entitiesall 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
621,hm_me_moduleget,"Description
Returns the module ID an entity belongs to.
","Inputs


entity_id
The type of entity to query.
entity_type
The type of entity to query.


","Example
To get the module ID that property 10 belongs
        to:hm_me_moduleget props 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
622,hm_me_parentsget,"Description
Returns the recursive list of parent module IDs.
","Inputs

id
The ID of the module to query.

","Example
To get the recursive parents of module 10:hm_me_parentsget 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
623,hm_measureshortestdistance,"Description
This command measures the shortest distance between two entity selections. The return is a
        list of values: 
d dx dy dz id1 x1 y1 z1 id2 x2 y2 z2
d - The value of the shortest distance 
dx - The x value of the shortest distance, measured relative to the specified local
            system 
dy - The y value of the shortest distance, measured relative to the specified local
            system 
dz - The z value of the shortest distance, measured relative to the specified local
            system 
id1 - ID of the closest entity from mark 1 
x1 y1 z1 - Coordinates of the closest location on entity id1 
id2 - ID of the closest entity from mark 2 
x2 y2 z2 - Coordinates of the closest location on entity id2


","Inputs

entity_type1
The type of entity on the first mark. Valid values are nodes, elements, points, lines,
            surfaces and solids.
mark_id1
The ID of the first mark. Valid values are 1 and 2.
reserved1
Reserved for future use. Must be set to 0.
entity_type2
The type of entity on the second mark. Valid values are nodes, elements, points,
            lines, surfaces and solids.
mark_id2
The ID of the second mark. Valid values are 1 and 2.
reserved2
Reserved for future use. Must be set to 0.
system_id
The ID of a local coordinate system to use for reporting the coordinate values dx, dy,
            dz, x1, y1, z1, x2, y2 and z2. If the value is specified as 0, the global coordinate
            system is used (default).

","Examples
To get the shortest distance between nodes 100-200 and nodes 300-400:
*createmark nodes 1 100-200
*createmark nodes 2 300-400
hm_measureshortestdistance nodes 1 0 nodes 2 0 0
To get the shortest distance between surface 100 and lines 1-10, with the distance output
        relative to system ID 5:
*createmark surfs 1 100
*createmark lines 1 1-10
hm_measureshortestdistance surfs 1 0 lines 1 0 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
624,hm_metadata ,"Description
This command returns metadata, based off of query parameters.
","Inputs

findbyname name ?entity_type?
Returns all metadata with the specified name. If entity_type is
            specified, all metadata with the specified name and attached to that entity type is
            returned.
findbytype entity_type
 Returns all metadata attached to entities of the specified entity type.
findbymark entity_type mark_id
Returns all metadata attached to the entities on the mark. 
findall
Returns all metadata.

","Examples
 To find all metadata named .ALTAIR.HW.CATIA.TAG:
hm_metadata findbyname .ALTAIR.HW.CATIA.TAG
To find all metadata named .ALTAIR.HW.CATIA.TAG attached to
        surfaces:
To find all metadata named .ALTAIR.HW.CATIA.TAG attached to surfaces:
hm_metadata findbyname .ALTAIR.HW.CATIA.TAG surfs
To find all metadata attached to solids:
hm_metadata findbytype solids
To find all metadata attached to the displayed surfaces:
*createmark surfs 1 ""displayed""
hm_metadata findbymark surfs 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
625,hm_modelchecksavetoxml,"Description
Saves the config data (checks and corrections) for the current profile to an XML file.
","
Inputs



filename

The full name and path of the XML file to save.

","Examples
To save the current profile checks and corrections to C:\temp\my_config.xml:
hm_modelchecksavetoxml C:/temp/my_config.xml
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
626,hm_modent_getconstraintruleoptions,"Description
Returns a list of options that control the behavior of add/move/remove operations for a
        modular entity.  Valid entity combinations are:
Table 1. 

Independent Entity Types
Dependent Entity Types




beamsectcols
beamsects


components
elements


components
materials


components
nodes


components
properties


loadcols
loads


materials
curves


properties
materials


systcols
systems


vectorcols
vectors




The return string is of the format:
<independent_type> { dependent_type1 {add_move_remove add_move_remove_shared}?
        dependent_type2 {add_move_remove add_move_remove_shared}? ... ?dependent_typeN
        {add_move_remove add_move_remove_shared}?}
add_move_remove has values 0 (false) and 1 (true)
add_move_remove_shared has values 0 (forbid whole action), 1 (do not move shared), or 2
        (move shared)
","
Inputs

None.
","Examples

hm_modent_getconstraintruleoptions
comps { nodes {1 2} elems {1 3} props {0 2} mats {0 2}}
loadcols { loads {0 3}}
systcols { systs {1 3}}
props { mats {1 2}}
mats { curves {1 2}}
vectorcols { vectors {1 3}}
beamsectcols {beamsects {1 3}}

","Errors
None.
"
627,hm_modent_getcontentsbymark,"Description
longDescription
","
Inputs


entity_type
The modular entity type.  Currently supported for subsystemconfigurations, subsystems
            and subsystemsets.
entity_id
The ID of the modular entity.
content_entity_type
The content entity type.
mark_id
The ID of the mark to return the content entities.  Valid values are 1 and 2.

","Examples
To get the components for subsystem 2 on mark 1:
hm_modent_getcontentsbymark subsystems 2 comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
628,hm_modent_getincludes,"Description
Returns the list of includes that are managed by a subsystem.
","
Inputs


entity_type
The modular entity type. Currently supported for subsystems.
entity_id
The ID of the modular entity.
recursive
0 - Do not return children includes
1 - Return children includes
sorted
0 - Do not sort
1 - Sort

Comment.
","Examples
To get the list of include files managed by subsystem with ID 3. Children includes will be
        listed; the list is not sorted:
hm_modent_getincludes subsystems 3 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
629,hm_modent_getrepresentationdefinitions,"Description
Returns the number of modular entity representations available, and those realized.
They are returned by their representation keys (identifier).  For example:
Crash5 { avaialble 2 realized 1 }
Crash10 { available 1 realized 0 }
","
Inputs


entity_type
The modular entity type.  Currently only supported for subsystems.
mark_id
The ID of the mark containing the modular entities.  Valid values are 1 and 2.
ignore_transient
0 - Return all representations
1 - Return only representations saved as files

","Examples
To get the saved representations that are available, and those realized, for subsystems on
        mark 1:
*createmark subsystems ""by id only"" 4 6 8
hm_modent_getrepresentationdefinitions subsystems 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
630,hm_morph_getdomainarcangle ,"Description
Returns the arc angle of a specified edge domain. Optional arguments allow the arc angle to
        be calculated using a line, node, or base point and axis to find the center of
        curvature.
","Inputs

domainID
The ID of an edge domain.
?BaseAndAxis?
x, y, z - Base point is x, y, z. 
dx, dy, dz - Axis is along dx, dy, dz.
?(Line) entityId?
line entity Id - Specify 'line' and the line ID.
?(Node) entityId?
node entity Id - Specify 'node' and the node ID.
?<blank>?
<none> - Default approximates the center of the edge domain.

","Examples
To get the arc angle of a domain with ID 2:
hm_morph_getdomainarcangle 2
To get the arc angle a domain with ID 2 and measured at 2.0, 5.0, 0.0 and normal to a
        vector that runs 1.0 in the x direction, 0.5 in the y direction, and 0.0 in the z
        direction:
hm_morph_getdomainarcangle 2 2.0 5.0 0.0 1.0 0.5 0.0
To get the arc angle of a domain with ID 2 and measured using node ID 12 as the center
        node:
hm_morph_getdomainarcangle 2 node 12
To get the arc angle of a domain with ID 2 and measured using line ID 3 as the center
        line:
hm_morph_getdomainarcangle 2 line 3
","Errors
None.
"
631,hm_morph_getdomainradius,"Description
Returns the radius of a specified edge domain. Optional arguments allow the radius to be
        calculated using a line, node, or base point and axis to find the center of curvature.
","Inputs

domainId
The ID of an edge domain.
?BaseAndAxis?
The ID of an edge domain. 
x, y, z              Base point is x, y, z 
dx, dy, dz        Axis is along dx, dy, dz
?(Line) entityId?
line entity Id - Specify 'line' and the line ID
?(Node) entityId?
node entity Id - Specify 'node' and the node ID
?<blank>?
<none> - Default approximates the center of the edge domain.

","Examples
To get the radius of a domain with ID 2:
hm_morph_getdomainradius 2
To get the radius of a domain with ID 2 and measured at 2.0, 5.0, 0.0 and normal to a
        vector that runs 1.0 in the x direction, 0.5 in the y direction, and 0.0 in the z
        direction:
hm_morph_getdomainradius 2 2.0 5.0 0.0 1.0 0.5 0.0
To get the radius of a domain with ID 2 and measured using node ID 12 as the center
        node:
hm_morph_getdomainradius 2 node 12
To get the radius of a domain with ID 2 and measured using line ID 3 as the center
        line:
hm_morph_getdomainradius 2 line 3
If the radius of the edge domain is not constant, an average is returned.
","Errors
None.
"
632,hm_morph_gethandlenode,"Description
Returns the node ID for the specified handle.
","Inputs

handle_id
The ID of the handle to query.

","Example
To get the node ID for a handle with ID 2:
hm_morph_gethandlenode 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
633,hm_morph_getmvoledge,"Description
 Returns the morph volume edge ID for the specified nodes along the edge.
","Inputs

node_1_id
The ID of the first node on the edge.
node_2_id
The ID of the second node on the edge.

","Example
To find the edge running through nodes with IDs 5 and 8:
hm_morph_getmvoledge 5 8
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
634,hm_morph_getmvolface,"Description
Returns the morph volume face ID for the specified morph volume and nodes along the edges
        of that face.
","Inputs

mvol_id
The ID of the morph volume.
node_1_id
The ID of the first node on the edge.
node_2_id
The ID of the second node on the edge.
node_3_id
The ID of the third node on the edge.

","Example
To find the face of morph volume with ID 2 using nodes 5, 8 and 12:
hm_morph_getmvolface 2 5 8 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
635,hm_morphupdatecheck ,"Description
This command maintains the database with respect to HyperMorph
        entities. It checks for changes in the database on which HyperMorph entities depend, and if it finds any it calls commands that
        update those entities to account for the changes. For instance, if elements are deleted for
        a domain, this command will update all dependent domains, potentially add or remove handles,
        and recalculate the influences for all the affected domains. 
This command needs to be called before any morphing commands are called and after any
        commands are called which affect HyperMorph entities or the
        entities on which they depend. When HyperMesh is run
        interactively this command is called when you enter and leave any HyperMorph panel, the delete panel, or the
          shape panel. If HyperMesh is being run through
        an interface, this command can be called when any model is loaded into HyperMesh, before and after every HyperMorph command (the ones with ""morph"" in them), and after anything is deleted to ensure proper
        functioning.
","Example
To calculate and perform any necessary HyperMorph updates:
hm_morphupdatecheck
","Errors
None.
",
636,hm_projectpointonsegment,"Description
Returns the closest point to a specific point on a finite segment.
","
Inputs


px, py, pz
Defines a point with three coordinate values.
sx1, sy1, sz1
The segment start point.
sx2, sy2, sz2
The segment end point.

","Examples
Example:
hm_projectpointtosegment 0.0 0.0 0.0 -1.0 2.0 0.0 1.0 2.0 0.0
Result: 0.0 2.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
637,hm_projectpointtosegmentwithangle,"Description
Finds the projection point to a specific point on a segment along a specific direction. The
        result is returned as the point on the straight line that runs from point (px, py,
          pz)  in the calculated direction, and is the point closest to the straight line
        that runs through points (sx, sy, sz) and (ex, ey,
        ez).
","Inputs

px, py, pz
The point.
sx, sy, sz
Beginning of the segment.
ex, ey, ez
End of the segment.
angle
The angle, in degrees, that defines the direction vector in the x-y plane.  0
            corresponds to the x-direction and 90 corresponds to the y-direction.
unused1
Unused, but must be specified.
unused2
Unused, but must be specified.

","Example
Find the projection of (0.0, 0.0, 0.0) to the segment defined by points (1.0, -1.0, 0.0)
        and (1.0, 1.0, 0.0) using an angle of 0 (x-direction):
hm_projectpointtosegmentwithangle 0.0 0.0 0.0 1.0 -1.0 0.0 1.0 1.0 0.0 0.0 0.0 0.0
  1.0 0.0 0.0
","Errors
None.
"
638,hm_proximitygetcomponentelementpair,"Description
Returns a specific proximity element pair for a specific component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.
element_pair_index
The index of the element pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentelementpaircount for the
            specified component_pair_index.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
639,hm_proximitygetcomponentpair ,"Description
Returns a specific proximity component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
640,hm_proximitygetelementdistance,"Description
Returns the proximity distance for a given element.
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","
Inputs



element_id

The ID of the element to query.

","Examples
Output the proximity distance at each input element:
*createmark comps 1 all 
hm_proximityinit comps 1 2.5
hm_proximitymarksourceproximityelements 1
set elems [hm_getmark elems 1]
foreach elem $elems {
   puts ""Distance for element $elem is [hm_proximitygetelementdistance $elem]""
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
641,hm_proximityinitwithtarget,"Description
Checks the proximity between elements or components, allowing the user to specify the
        target, and stores the results internally. Other APIs can be used to query the results.
This must precede any calls to other hm_proximityget*/hm_proximitymark*
        APIs, and must be followed by a call to hm_proximityend.
","
Inputs



source_entity_type

The type of source entity to query. Valid values are elements and components.

source_mark_id

The ID of the mark containing the source input entities. Valid values are 1 and 2.

target_entity_type

The type of target entity to query. Valid values are elements and components.

target_mark_id

The ID of the mark containing the target input entities. Valid values are 1 and 2.
check_side
1 - Check both sides of the elements 
2 - Check the element normal side only 
3 - Check 'outward volume' side (default behavior if not specified) 
4 - check 'inward volume' side
proximity_scheme
0 - Checks basic proximity along a ray from the element center along the normal
            direction.
1 - Checks comprehensive proximity. Reports any proximity within an imaginary
            offsetted volume of the element (default behaviour if not specified).
proximity_by_edge
0 - Ignores proximity for nearby edges (default behaviour if not specified).
1 - Considers proximity for nearby edges.
min_angle_limit
If the angle between the proximate element pairs is less than this value, such pairs
            are not reported.
max_angle_limit
If the angle between the proximate element pairs is greater than this value, such
            pairs are not reported.

","Examples
To find elements in proximity between the ""source"" and ""target"" components, and highlight
        the found entities:
*createmark comps 1 ""source""
*createmark comps 2 ""target""
hm_proximityinitwithtarget comps 1 comps 2 2.5
hm_proximitymarksourceproximityelements 1
hm_proximitymarktargetproximityelements 2
hm_highlightmark elems 1 h
hm_highlightmark elems 2 l
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
642,hm_proximitymarksourceproximityelements,"Description
Marks all the source elements within proximity to the given mark.
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","
Inputs



mark_id

The ID of the mark to which the elements will be placed.  Valid values are 1 and
            2.

","Examples
To output the source proximity elements to mark 1 and highlight them:
*createmark comps 1 all 
hm_proximityinit comps 1 2.5
hm_proximitymarksourceproximityelements 1
hm_highlightmark elems 1 h
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
643,hm_removedieattribute ,"Description
Removes the die attribute from an entity.
","Inputs

die_attribute
Valid values are: 
addendum 
binder 
fl 
tl
entity_id
The ID of the entity.

","Example
To remove the die attribute from the binder with ID 100:
hm_removedieattribute binder 100
","Errors
None.
"
644,hm_saveusermark ,"Description
This command stores the IDs of entity_type that exist on
          mark_id on the user mark. Valid mark_ids are 1 and
        2. Only one user mark exists for each entity_type. 
The ?panel_sensitive? option can be used when multiple panel levels have
        been pushed, either using the shortcut function keys, or the hm_pushpanel
        command. This option determines whether to use the current panel or the previous panel for
        the operation. This option is relevant only when the mark has been created from a panel
        entity selector under the above conditions. Valid panel_sensitive options
        are: 
0 - Use the previous panel (default). 
1 - Use the current panel. 
The user mark is accessed either through the command hm_getusermark or
        through panel input collectors, hm_createmark and
          hm_appendmark via the ""retrieve"" option.
","Example
To save the user mark of properties 1,3 and 5:
m_createmark props 1 ""by id only"" ""1 3 5""
hm_saveusermark props 1
To create a mark of elements 1-3, save it to the element user mark and retrieve it
        later:
hm_createmark elems 1 ""1 2 3""
hm_saveusermark elems
hm_markclear elems 1
…
hm_getusermark elems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If mark_id is invalid, you will get the following error:
hm_saveusermark: invalid markmask specified
",
645,hm_setmodelcheckcheckstatus,"Description
Sets the run status for the specified Model Check check display name.
","Inputs

display_name
The check display name.
status


0 - Not run
1- Run and found failed entities
2 -Run and found no failed entities
3 - No relevant entities found in the model



","Example
To set the run status for the check named ""Unused Materials"" to run (1):
hm_setmodelcheckcheckstatus ""Unused Materials"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
646,hm_setmodelcheckresultentids,"Description
This command sets the entity IDs for the specified Model Check check display name.
","Inputs

display_name
The check display name.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To set the entity IDs for the check named ""Unused Materials"" and to the entities stored on
        mark 1:
hm_setmodelcheckresultentids ""Unused Materials"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
647,hm_solverconvert ,"Description
This command converts a model from one solver to another. 
Supported solvers are:


Solver Name
Solver ID
Solver Type


Nastran
1
 


OptiStruct
1
 


Abaqus
2
Standard2D, Standard3D


ANSYS
8
 


LS-DYNA
9
Keyword971, Keyword970


PAM-CRASH
18
Pamcrash2G2008, Pamcrash2G2007, Pamcrash2G2006 Pamcrash2G2005,
                Pamcrash2G2004


Radioss
20
Block110, Block100, Block90, Block51, Block44




Supported conversions are:


Source Solver Name
Destination Solver Name


Abaqus
Nastran/OptiStruct


ANSYS
Nastran/OptiStruct


LS-DYNA
Nastran/OptiStruct


Radioss
PAM-CRASH


PAM-CRASH
Radioss


Nastran/OptiStruct
Abaqus


Nastran/OptiStruct
Ansys


Nastran/OptiStruct
LS-DYNA


Nastran/OptiStruct
Radioss


ANSYS
Abaqus




","Inputs

source_solver
The source solver name or ID.
destination_solver
The destination solver name or ID.
source_type
The source solver template type.
destination_type
The destination solver template type.
batch
Flag that indicates if the conversion should be run in batch mode. 
0 - no batch mode 
1 - batch mode

","Examples
Convert Abaqus Standard3D model to OptiStruct in batch mode:
hm_solverconvert Abaqus OptiStruct Standard3D """" 1
or
hm_solverconvert 2 1 Standard3D """" 1
Convert Radioss Block90 model to PAM-CRASH Pamcrash2G2007 without batch mode:
hm_solverconvert RadiossBlock Pamcrash Block90 Pamcrash2G2007 0
or
hm_solverconvert 20 18 Block90 Pamcrash2G2007 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
648,hm_tableclear ,"Description
Clear a table (all memory is freed).
","Inputs

tableName
The name of the table to clear. 

","Example
When the current model is deleted, or a new model is loaded, all tables are cleared. 
","Errors
None.
"
649,hm_tablecopy,"Description
Makes a copy of the HyperMesh table. Overwrites destination
        table.
","Inputs

table1
Source table
table2
Destination table 
TCL_OK(0) if successful. TCL_ERROR(1) otherwise

","Example
# Creating 2 tables
*createmark comp 1 1 2 
hm_marktotable comp 1 t12
*createmark comp 1 2 3
hm_marktotable comp 1 t23
# Copying table
hm_tablecopy t12 tcom;
hm_tableintersection tcom t23; 
# tcom contains comp 2 now
","Errors
None.
"
650,hm_tableintersection ,"Description
 Finds subset of entities common to two HyperMesh tables of the
        same entity type and places it into the first table.
","Inputs

table1
First table.
table2
Second table. 
TCL_OK(0) if successful. 
TCL_ERROR(1) otherwise 

","Example
This command can be used to find entities common for two HyperMesh tables.
# Creating 2 tables
*createmark comp 1 1 2 
hm_marktotable comp 1 t12
*createmark comp 1 2 3
hm_marktotable comp 1 t23
# Copying table
hm_tablecopy t12 tcom;
hm_tableintersection tcom t23; 
# tcom contains comp 2 now

","Errors
None.
"
651,hm_tablelookup ,"Description
 Search a table for an entity ID. The constant 1 is returned if the ID is found. Otherwise,
        0 is returned. 
","Inputs

tableName
The name of the table.
id
The ID to search for. 

","Example
When the current model is deleted, or a new model is loaded, all tables are cleared. See
          hm_marktotable for a sample use of hm_tablelookup. 
","Errors
None.
"
652,hm_triplecos ,"Description
Get the cosine angle of two vectors.
","Inputs

X0 y0 z0 
x1 y1 z1 
Definition of two vectors. 
A double value of cosine angle between these two vectors.

","Example
hm_triplecos  0.0  0.0 1.0  1.0 0.0 0.0 
result: 0.0   
","Errors
None.
"
653,hm_updatemodelcheckresultvalues,"Description
Updates the failed values for the model check entity.
","Inputs

display_name
The check display name.

","Example
To update the model check entity with ID 2 and name check_volume:
*createstringarray 3 0.5 1 1.5
*attributeupdatestringarray modelcheckchecks 2 100230 1 2 0 1 3
hm_updatemodelcheckresultvalues ""check_volume""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
654,hm_wadlinesend,"Description
Clears memory and ends the WAD lines module. This must be preceded by any calls to
          hm_wadlinesinit and other hm_wadlines* APIs. Any
        database changes made while inside of the WAD lines module will invalidate and delete any
        WAD results.
","Example
 To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
None.
",
655,hm_wadlinesgetchildtestzone,"Description
Returns the coordinates of the child test zone boundary.
This must be run after hm_wadlinesinit and setting all necessary options
        with hm_wadlinessetparameters.
","
Inputs

None.
","Examples
To setup and extract the child test zone:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
set zone_vertices [hm_wadlinesgetchildtestzone]
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
656,hm_wadlinesgetgridpoints,"Description
Returns coordinate data defining WAD grid points. The data will be returned as a list of
        one string, two integers, and three doubles. The string defines whether the point is child,
        middle or adult. The two integers are the row and column indices of the grid point. The
        three doubles are the X, Y, and Z coordinates of the grid point. For
        example:Child -6 3 1.45816988887E+003 -600 8.59794186814E+002 Middle -1 6 1.75816988887E+003 -100 9.73484336137E+002 Adult -5 9 2.05816988887E+003 -500 1.03367256770E+003
","Inputs

wad_child_min
The WAD line where child impact points begin.
wad_child_max
The WAD line where child impact points end.
wad_adult_min
The WAD line where adult impact points begin.
wad_adult_max
The WAD line where adult impact points end.
side_tolerance
GTR - No impact points are found within this distance of the side reference
            lines.
EuroNCAP, CNCAP - Impact points found within this distance will be deactivated.
protocol_method
The method to use for measuring the side_tolerance distance. 
0 - Euro NCAP (default if not specified) 
1 - Homologation 
2 - ECER
3 - UN-R127 for corners, Euro NCAP elsewhere
4 - CNCAP
protocol_version
Used for Euro NCAP protocol, 7.0 (default if not specified), 8.0 or 8.2. 
grid_spacing
The spacing between the impact points, default 100.0.
EuroNCAP, CNCAP - The grid spacing between the two nearest impact points in the same
            row or column.
GTR - The spacing between headform points on a wadline.
vertical_spacing
For GTR, it is the spacing between 2 wadlines on which impact points need to be
            created, default 100.0.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
657,hm_wadlinesgetinternalbumperline,"Description
Returns the averaged points for the internal bumper line as a series of x, y, and z values.
        It will use the front entities set using hm_wadlinessetentities and the
          corner_angle set with hm_wadlinessetparameters to
        determine the ""Corner of Bumper"" for both sides of the vehicle. If
          hm_wadlinessetbumper has been used, the outermost ends of those entities will be
        determined. All points for the internal bumper reference line will fit laterally between
        either the ""Corner of Bumper"" or the outermost ends of the bumper entities, whichever is
        larger. This is the ""Edge of Bumper Test Zone.""
","Inputs

spacing
The lateral distance, starting from the center line, at which the points will be
            placed.
max_depth
The maximum rearward distance a point can be from the first point of contact with the
            bumper entities and still be used to find the height of the bumper entities. If the
            bumper entities have not been set, the front entities are used instead.
max_height
The maximum height allowed for the averaged points as measured from the origin (set
            using hm_wadlinessetaxes).

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 82.5 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 182.0 -1.0 0.0 0.0 0.0 -1.0 0.0
hm_createmark components 1 ""by id"" ""100000199 100000200 290000007 410000016 411000016 420000004 420000005 420000006 420000007 420000008 420000009 420000010 420000011 420000012 420000013 420000014 420000015 420000016 420000019 420000020""
hm_createmark components 2 ""by id"" ""100000003 100000010 100000022 100000113""
hm_wadlinessetentities comps 1 comps 2
hm_createmark components 1 ""by id"" ""407000001 407000002""
hm_wadlinessetbumper comps 1
hm_wadlinesgetinternalbumperline 10.0 50.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
658,hm_wadlinesgetreferenceline,"Description
Returns coordinate data defining WAD reference lines.
","Inputs

line_location
The location of the line to query (0=front, 1=rear, 2=left, 3=right, 4=upper bumper,
            5=lower bumper, 6=left corner, 7=right corner). The data will be returned as a list of
            doubles. Every three doubles are the X, Y, and Z coordinates of a point along the line.
            The lines all run from front to back and from left to right.
offset (optional)
Argument that defines an offset to apply when querying the rear, left and right
            reference lines. A positive value offsets the line toward the center of the bonnet by
            the specified value. Negative values are supported, but should not be necessary.
method
The method to use for measuring the offset distance. 
0 - Euro NCAP (default if not specified) 
1 - Homologation 
2 - ECER

","Example
 To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
659,hm_wadlinesgetwadline ,"Description
Returns coordinate data defining a WAD line.
","Inputs

distance
The distance from ground level for the WAD line, as measured along the vehicle. The
            data will be returned as a list of doubles. Every three doubles are the X, Y, and Z
            coordinates of a point along the line. The lines run from left to right.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
660,hm_wadlinesinit,"Description
Initializes the WAD lines module. This must precede any calls to other
          hm_wadlines* APIs, and must be followed by a call to
          hm_wadlinesend. Any database changes made while inside of the WAD lines
        module will invalidate and delete any WAD results.
","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
None.
",
661,hm_wadlinessetbumper,"Description
Sets the entities for the internal bumper components used for the internal bumper reference
        line and upper/lower leg grid point generation. Unlike the
          hm_wadlinessetentities and hm_wadlinessetwipers
        APIs, using wadlinessetbumper will not reset any stored entities or
        generated reference lines. This allows you to set the bumper entities at any time during
        WADLines analysis and be able to extract any data which has already been calculated. This
        will allow you to reuse these marks if needed.
","Inputs

entity_type
The entity type denoting the internal bumper. Valid values are elems, surfs and comps
            (elems take priority over surfs).
mark_id
The ID of the mark containing the internal bumper entities. Valid values are 1 and 2.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 82.5 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 182.0 -1.0 0.0 0.0 0.0 -1.0 0.0
hm_createmark components 1 ""by id"" ""100000199 100000200 290000007 410000016 411000016 420000004 420000005 420000006 420000007 420000008 420000009 420000010 420000011 420000012 420000013 420000014 420000015 420000016 420000019 420000020""
hm_createmark components 2 ""by id"" ""100000003 100000010 100000022 100000113""
hm_wadlinessetentities comps 1 comps 2
hm_createmark components 1 ""by id"" ""407000001 407000002""
hm_wadlinessetbumper comps 1
hm_wadlinesgetgridpointsleg 0 100.0 7.0
hm_wadlinesgetgridpointsleg 1 100.0 7.0
hm_wadlinesgetgridpointsleg 0 100.0 8.0
hm_wadlinesgetgridpointsleg 1 100.0 8.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
662,hm_wadlinessetentities,"Description
Sets the entities used for a WAD lines analysis.
","Inputs

entity_type_front
The entity type denoting the front of the vehicle (bumper, bonnet, fenders). Valid
            values are elems, surfs and comps (elems take priority over surfs).
mark_id_front
The ID of the mark containing the front entities. Valid values are 1 and 2.
mode_or_entity_type_rear
One of the following:
- The entity type denoting the rear of the vehicle (windshield, a-pillars). Valid
            values are elems, surfs and comps (elems take priority over surfs).
- The string all_in_one to denote all entities are given in
              mark_id_front, or front_only to run only a front
            bumper analysis.
mark_id_rear
The ID of the mark containing the rear entities if
              mode_or_entity_type_rear is a specific entity type, or blank if one
            of the strings is used. Valid values are 1 and 2.

","Examples
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
The above example can be modified instead to put all entities on the first mark:
...
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR"" ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 all_in_one
...
The example can be modified instead to only run a bumper analysis:
...
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
hm_wadlinessetentities comps 1 front_only
...
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
663,hm_wadlinessetoptions,"Description
Sets various WAD lines module options. Accepts a series of name value pairs, and any number
        of pairs may be given. This API may be called any number of times, such as once per option,
        or just once with all the options. The API can be called at any time during the analysis,
        thus allowing options to change between calls. Changes do not retroactively update any
        previous calculated results. It is recommended that this API be called before any results
        are requested.
If an option is not given it will be assigned a default value. If the options
          protocol_method and protocol_version are set using this
        API, and not set in other APIs which accept them, those APIs will default to the values set
        by this API.
The following are the options which can be set using this API:
","Inputs

blerl_height
The height from the ground to start the straight edge for creating the bonnet leading
            edge reference line.  Default 600.0.
blerl_offset
The offset distance used to create the bonnet leading edge reference line.  Default
            82.5.
blerl_selen
The length of the straight edge used to create the bonnet leading edge reference line.
            Default 1000.0.
brrl_offset
The offset distance used to create the bonnet rear reference offset line.  Default
            82.5.
corner_gauge_height
The total height of the corner gauge (UN-R127). Default 236.0.
corner_height_max
The maximum value for the height of the center of the corner gauge (UN-R127). Default
            1003.0.
corner_height_min
The minimum value for the height of the center of the corner gauge (UN-R127). Default
            75.0.
cycling_impact_angle
The impact angle of cyclist headform impact points. Default 60.
cycling_zone_max
The WAD line where cycling impact zone ends. Used in regulation CNCAP 2021 and
            EuroNCAP 2022/2023. Default 0.
cycling_zone_min
The WAD line where cycling impact zone starts. Used in regulation CNCAP 2021 and
            EuroNCAP 2022/2023. Default 0.
groundz_cord
The height of the ground plane for which marking is done, stored as a
            structuralproperty.  Default 0.0.
headform_adult_impact_angle
The impact angle used for adult headform points.  Default 65.0.
headform_child_impact_angle
The impact angle used for child headform points.  Default 50.0.
headform_forward_impact_angle
The impact angle used for horizontally projected headform points.  Default 20.0.
horiz_proj_min_angle
The minimum angle used to determine if points should be horizontally projected (Euro
            NCAP 8.2). Default 60.0.
horiz_proj_min_dist
The minimum distance allowed between horizontally projected grid points and other grid
            points (Euro NCAP 8.2). Default 50.0.
impactor_mass
The mass of the impactor used to test upper legform impact point.  Default 10.5.
impactor_mass_nominal
The nominal mass of the impactor used to test upper legform impact point.  Default
            7.4.
init_velocity
The initial velocity of the impactor.  Default 11.11.
leg_offset
The offset distance from the corner bounds where legform points are not created.
            Default for GTR 42.0.
protocol_method
0 - Euro NCAP (default)
1 - Homologation
2 - ECER
3 - UN-R127 for corners, Euro NCAP elsewhere
4 - CNCAP
protocol_version
Used for Euro NCAP protocol, 8.4 (default if not specified), 7.0, 8.0 or 8.2.
side_ref_wad_dist
The WAD distance used for extending reference lines forward (Euro NCAP 8.2). Default
            1000.
srl_left_offset
The offset distance used to create the left bonnet side reference offset line.
            Default 82.5.
srl_right_offset
The offset distance used to create the right bonnet side reference offset line.
            Default 82.5.
upper_legform_max_energy
The upper limit for energy of the upper leg impactor.  Default 457.0.
upper_legform_min_energy
The lower limit for energy of the upper leg impactor.  Default 160.0.
upperlegbumper_lowerlimit
The lower limit used to create lower legform points.  Default 425.0.
upperlegbumper_upperlimit
The upper limit used to create lower legform points.  Default 500.0.
wad_method
0 - Measures along the surface of the vehicle, not direct from bonnet to
            windshield
1 - Measures along tangent (default)
zheight
The z height parameter for impact points created through the
              hm_wadlinesgetgridpoints command.

","Example
To setup and extract WAD lines data, specifying Euro NCAP version 8.0:
hm_wadlinesinit
hm_wadlinessetoptions prototol_version 8.0
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
664,hm_wadlinessetaxes,"Description
Sets the origin and coordinate axes for a WAD lines analysis.
","Inputs

origin_x origin_y origin_z
Defines the X, Y and Z coordinates of the origin. Must be at the vehicle centerline
            (default 0,0,0).
forward_x forward_y forward_z
Defines the vector pointing toward the front of the vehicle (default 1,0,0).
left_x left_y left_z
Defines the vector pointing toward the left side of the vehicle (default 0,1,0).

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
None.
"
665,hm_wadlinessetwipers,"Description
Sets the wiper entities used for a WAD lines analysis.
","Inputs

entity_type
The entity type denoting the wipers. Valid values are elems, surfs and comps (elems
            take priority over surfs).
mark_id
The ID of the mark containing the wiper entities. Valid values are 1 and 2.
use_for_reference_line 
0 - Off 
1 - On
 use_for_wad_line
0 - Off 
1 - On

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
None.
"
666,hm_writeviewcommands,"Description
Sets the state of writing certain view commands to the command file. The following commands
        are affected:

*rotateabout
*view
*view_restoreprevious
*viewset
*window

","Inputs

mode
0 - Do not write these commands to the command file 
1 - Write these commands to the command file

","Example
To disable writing the view commands to the command file:
hm_writeviewcommands 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
667,hm_xformvectoratpointtoglobal,"Description
This command returns the three global components of a locally defined vector.
This command can be used in conjunction with
          hm_xformvectoratpointtolocal to convert a vector from one coordinate
        system to another.
","Inputs

x y z
The x, y, and z values should be given relative to the local coordinate system
              syst_id.
syst_id
The x, y, and z values should be given relative to the local coordinate system
              syst_id. If syst_id is a cylindrical system, r,
            t, and z must be used for x, y, and z. If syst_id is a spherical
            system, r, t, and p must be used for x, y, and z.
node_id
The base of the vector is specified by node_id which must be a node
            in the current model.

","Example
To convert the vector (1,0,0) at base node 10 defined in rectangular system ID 5 to the
        cylindrical system ID 8:
set g_xyz [hm_xformvectoratpointtoglobal 1 0 0 5 10]
set g_x [lindex $g_xyz 0]
set g_y [lindex $g_xyz 1]
set g_z [lindex $g_xyz 2]
set l_rtz [hm_xformvectoratpointtolocal $g_x $g_y $g_z 8 10]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If syst_id does not exist, you will get the following error:
        System syst_id could not be found. 
If node_id does not exist, you will get the following
        error:Node node_id could not be found.
"
668,hm_xpointlocal,"Inputs

system_id
The ID of the system into which the point should be transformed.
x y z
The coordinates of the point to be transformed in the global system.

","Errors
None.
",,
669,hm_ypointlocal,"Description
Transforms a coordinate into a local system and returns the y value of the transformed
        point.
","Inputs

system_id
The ID of the system into which the point should be transformed.
x y z
The coordinates of the point to be transformed in the global system.

","Errors
None.
",
670,hm_zpointlocal,"Description
Transforms a coordinate into a local system and returns the z value of the transformed
        point. 
","Inputs

system_id
The ID of the system into which the point should be transformed.
x y z
The coordinates of the point to be transformed in the global system.

","Errors
None.
",
671,hwct_getinfofromlibrary,"Description
Query information from a currently connected library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
mark_id
The ID of the mark of entities. Valid values are 1 and 2.
attribute_list
The list of attributes, separated by semi-colons (e.g. {attribute1; attribute2; ...;
            attributeN}).
childgroupname=<value>
The group name of the children on which the attribute information is needed.
childkey=<value>
The returned information is gropued by this key attribute on the child.
filter=<value>
all - Process all children of the given childgroupname for the
            input entities
retrieved - Process only those children retreived from the library

","Examples
Query the library for subsystem 2 and list it as per the childkey (hwrepalis). The child
        here is crash for subsystem 2:
{ 2 { crash { smd_cid : 6932c5faac1cc748a333bf0c49fb2f61 } } }
*createmark subsystems 1 2
set library_info [hwct_getinfofromlibrary subsystems 1 id childgroupname=representations childkey=hwrepalias filter=retrieved]

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
672,hf_getdrawbeadforce,"Description
This command returns the locking condition, restraint force, closure force and final
        force.
","Inputs

material_name
Name for the material
thickness
Blank thickness
height
Draw bead height
radius
Draw bead radius
shoulder_radius
Shoulder radius
friction
Friction
type
Shape type: 
1 - round 
2 - step 
3 - square

","Example
set returnValue [hf_getdrawbeadforce ""CRDQ"" 1.0 1.0 6.25 6.25 0.125 1]
set locking [ lindex $ returnValue 0 ]
set restraint [ lindex $ returnValue 1 ]
set closure [ lindex $ returnValue 2 ]
set final [ lindex $ returnValue 3 ]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
673,hm_answernext,"Inputs

answer
Valid values are yes, no, all (for 'yes to all') and nall (for 'no to all').

","Example
To answer yes to deleting the current model, which has not been saved:
hm_answernext yes
*deletemodel
","Errors
None.
",
674,hm_attributebehavior,"Description
Returns the behavior flag of an attribute on an entity for the current template. If the
        attribute does not exist on the entity, or is not an attribute from the current template, an
        error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute behavior of the attribute named Rho on material 6 for the LS-DYNA template:
hm_attributebehavior material 6 Rho -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
675,hm_attributeidentifier,"Description
Returns the identifier flag of an attribute on an entity for the current template. If the
        attribute does not exist on the entity, or is not an attribute from the current template, an
        error is returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. -
byid - Search only by ID.

","Examples
To get the attribute identifier of the attribute named Rho on material 6 for the LS-DYNA template:
hm_attributeidentifier material 6 Rho -byid
To get the attribute behavior of attribute ID 118 on material 6 for the LS-DYNA template:
hm_attributeidentifier material 6 118 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
676,hm_attributeindexstatus,"Description
Returns the status flag of an indexed attribute on an entity.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The name or ID of the entity.
attribute_index
The index of the attribute owned by the queried entity (starting at 1).
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Example
To get the attribute status of the attribute with index 3 on material 6:
hm_attributeindexstatus material 6 3 -byid
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
677,hm_attributenamefromid,"Description
Returns an attribute name from the attribute ID for the current template. If the attribute
        does not exist in the current template, an error is returned.
","Inputs

attribute_id
The ID of the attribute to query.

","Example
To get the attribute name of the attribute ID 100:
hm_attributenamefromid 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
678,hm_attributetype,"Description
Returns the attribute type number of an attribute for the current template. If the
        attribute is not an attribute from the current template, an error is returned. The values
        returned have the following meanings: 
1 - integer 
2 - double
3 - string 
4 - 1D integer array
5 - 1D double array 
6 - entity 
7 - (not supported) 
8 - (not supported) 
9 - 2D integer array 
10 - 2D double array 
11 - string array 
12 - 1D entity array 
13 - 2D entity array


","Inputs

attribute_name_or_id
The name or ID of the attribute to query. The attribute must be in the current
            template.

","Examples
To get the attribute type number of the attribute named LSD_PID for the LS-DYNA template:
hm_attributetype LSD_PID
To get the attribute type number of the attribute ID 149 for the LS-DYNA template:
hm_attributetype 149
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
679,hm_ce_errorreport,"Description
Returns the specific reason for the failed realization of a connector.
","Inputs

ce_id
The ID of the connector entity.
reportFlag
0 returns one of the failure criteria. 
1 returns all the causes for failed realization.

","Examples
To obtain a simple report for failed realization for a connector with ID 10:
set ce_id 10;
set single_err_report [ hm_ce_errorrepot $ce_id 0 ];
To get a detailed report returned as list of lists for connector with ID 10:
set ce_id 10;
	set detail_err_report [ hm_ce_errorrepot $ce_id 1 ];
This function returns a report only for the failed connectors. The state of the connector
        can be looked up using the connection information table. All failed connectors are marked
        red.
","Errors
None.
"
680,hm_formnodelistsfrommark,"Description
Forms ordered node lists from a mark of nodes. 
The return consists of a list-of-lists, with each sub-list being an ordered node list.
","Inputs

entity_type
Must be set to nodes.
mark_id
 The ID of the mark containing the input nodes. Valid values are 1 and 2.
?error_mark_id?
The ID of the mark to use for storing any nodes which cannot be formed into a list.
            Valid values are 0 (default, do not store), 1 and 2.
?use_edge_topo?
0 - Do not use the edge selection from the last call to
              *createmarkpanel for nodes. 
1 - Use the edge selection from the last call to *createmarkpanel
            for nodes (default).

","Example
To form node lists from nodes selected by the user via
        *createmarkpanel:
*createmarkpanel nodes 1 ""Select nodes to form lists""
hm_formnodelistsfrommark nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
681,hm_getgeometricthinsolidinfo,"Description
Identify and return information on thin solid surface groups. 
The output is a list of lists, which includes the below information. 
Basic output mode:
Estimated thickness value. 
Solid ID (for solids input) or first surface ID (for surfaces input).
To get all surfaces within the connected section, take this surface ID and select
                all attached surfaces.




The basic output format looks like:
{thickness1 id1} {thickness2 id2} ... {thicknessN idN}
","Inputs

entity_type
The type of entity to query. Valid values are surfs and solids.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
<option>=<value>
The advanced options that control the behavior. Multiple options can be
                  specified, in any order.
feature_angle=<angle>
The maximum angle for separating solid features. The default is the
                        geometry feature angle.
max_thickness=<thickness>
The maximum thickness to be considered as a thin solid. Default is 0,
                        meaning unlimited.
mode=<mode>
The output mode, either simple (default) or advanced. The advanced output
                        includes the master, slave and thickness surface group details.
thinsolid_ratio=<ratio>
The ratio between the minimum (thickness) and middle (approximate width)
                        dimensions. Default is 0.5.





","Examples
Query thin solid info on solids 1-3 using defaults:
*createmark solids 1 1-3
hm_isgeometrythinsolid solids 1
{1.25 1} {2.5 3}
Query thin solid info on surfaces 1-10 using simple mode:
*createmark surfs 1 1-10
hm_isgeometrythinsolid surfs 1 mode=simple
{1.25 5}
Query thin solid info on solids 1-3 using advanced mode:
*createmark solids 1 1-3
hm_isgeometrythinsolid solids 1 mode=advanced
{1.25 1 {1 2 3 4 5 6} {7 8 9 10 11 12} {13 14 15 16}} {2.5 3 {101 102 103 104} {105 106 107 108} {109 110 111 112}}
Query thin solid info on surfaces 1-20 using advanced mode:
*createmark surfs 1-20
hm_getgeometricthinsolidinfo surfs 1 mode=advanced
{0.5 0 {1} {7} {13 14 15}} {1 0 {2 10 11 12 16} {3 4 5 6} {8 9 17 18}}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
682,hm_gethistorymemoryusage,"Description
Returns the current amount of memory used for recording history.
","Example
To get the current amount of memory used for recording history:
hm_gethistorymemoryusage
","Errors
None.
",
683,hm_gethmfileversion,"Description
Returns the binary file version string for a specified HyperMesh database. The string is comprised of 2 parts, major-minor, where:
major is the major file version. It is itself comprised of two parts,
            release.binary.
minor is the minor file version.

For example:  13.02-110
","Inputs

filename
The full path and filename of the database file. Paths with spaces must be enclosed in
            quotes.

","Example
To get the file version for C:\temp\test.hm:
hm_gethmfileversion  C:/temp/test.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
684,hm_getidpoolsforidrange,"Description
This command returns a list of pool names for the specified entity_type
        and solver_id_range. The solver_id_range
        must be specified using solver ID values. The range must be specified using a dash - to
        define the range. Only one continuous range may be specified.
If a entity of entity_type exists with the same solver ID in multiple
        pools, all pools containing that solver ID will be returned.
This command is only applicable to templates that support ID pools.
","Example
To get the list of pool names for elements with solver IDs 100-300:
hm_getidpoolsforidrange elems 100-300
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
685,hm_getincludes,"Description
Returns a list of include IDs or names. Only one argument may be specified at a time. If no
        argument is specified, the IDs are returned.
The IDs and names are returned in the same order.
","Inputs

byshortname
Returns the list of includes by their short names.
byfullname
Returns the list of includes by their full path names.
byshortnameexportpair
Returns the list of includes by their short names, along with the export flag for
            each.
byshortnamesolverflagpair
Returns the list of includes by their short names, along with the solver flag for
            each.
byshortnamealwaysmergeflagpair
Returns the list of includes by their short names, along with the always merge flag
            for each.

","Example
To get the list of include IDs:
hm_getincludes
To get the list of include short names:
hm_getincludes -byshortname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
686,hm_getinternalidlist,"Description
This command returns the internal HyperMesh IDs for a list of
        solver IDs and a solver ID pool. This command is only applicable to templates and entity
        types that have ID pools.
","Inputs

id_pool
The pool ID or name. By default, the value is assumed to be the pool ID. This is
            controlled by the optional search_type argument.
solver_id_list
The list of solver IDs to query. All IDs must belong to the specified pool.
search_type
Defines whether id_pool is specified as a pool name or a pool ID.
            Valid values are -bypoolid and -bypoolname. If not specified, it defaults to
            -bypoolid.

","Examples
To get the internal HM IDs of pool ID 1 and solver IDs 2, 3 and 4:
hm_getinternalidlist 1 ""2 3 4""
or
hm_getinternalidlist 1 ""2 3 4"" -bypoolid
To get the internal HM IDs of pool PROP_IDPOOL and solver IDs 17 and 20:
hm_getinternalidlist PROP_IDPOOL ""17 20"" -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
687,hm_getlineendpoint,"Description
Returns the components of the line end point. If the line is a closed loop, the start and
        end points will return the same value.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the end of the line with ID 341:
set list [hm_getlineendpoint 341]
set x [lindex $list 0]
set y [lindex $list 1]
set z [lindex $list 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
688,hm_getlinestartpoint,"Description
Returns the components of the line start point. If the line is a closed loop, the start and
        end points will return the same value.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the start of the line with ID 341:
set list [hm_getlinestartpoint 341]
set x [lindex $list 0]
set y [lindex $list 1]
set z [lindex $list 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
689,hm_getlinetgendpoint,"Description
Returns the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the line end point. The first 3 return values are the tangent vector
        components, and the 4th return value is the angle.
","Inputs

line_id
The ID of the line.

","Example
To get the components of the tangent vector and the angle between the tangent vector and
        the z-axis at the end of the line with ID 341:
foreach {tg_x tg_y tg_z ang} [hm_getlinetgendpoint 341] {}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
690,hm_getlinetype,"Description
Returns the line type. Return values are:
0 - Free line
1 - Free surface edge
2 - Shared surface edge
3 - Non-manifold surface edge
4 - Suppressed surface edge


","Inputs

line_id
The ID of the line.

","Example
To get the type of the line with ID 341:
hm_getlinetype 341
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
691,hm_getllsid,"Description
Returns the IDs of the latitude lines.
","Example
To get the IDs of the latitude lines:
hm_getllsid
","Errors
None.
",
692,hm_getmark,"Description
Returns the entity IDs of the passed entity type on the specified mark.
","Inputs

entity_type
The type of entity to query.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
panel_sensitive
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid options are:0 - Use the previous panel (default).
1 -
              Use the current panel.

model_name
The optional model to get the mark for. If not specified, the current model is
            used.

","Examples
To return the components on mark 1:hm_getmark comps 1
To return the components on mark 1 for model
        model-2:hm_getmark comps 1 0 model-2
A mark of loads is created in the Delete panel. The Mask panel has been pushed using the
        command ""hm_pushpanel mask"". A mark of loads is created in the Mask
        panel. To get the list of loads on mark 1 created from the Mask
        panel:hm_getmark loads 1 1
To get the list of loads on mark 1 created from the Delete
        panel:hm_getmark loads 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
693,hm_getmarkentitytypes,"Description
Returns a list of entity types that have entities populated on the specified mark.
","Inputs

mark_id
The mark ID of interest. Valid values are 1 and 2.

","Example
To get the list of entity types that have entities populated on mark 1:
hm_getmarkentitytypes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
694,hm_getmass,"Description
This command returns the mass, volume and area of the selected elements or components.
","Inputs

entity_type
The type of entities to consider. Valid values are elems and comps.
mark_id
The ID of the mark. Valid values are 1 and 2.
mass_type
The type of mass to output.
0 - All mass values
2 - structural mass
3 - non-structural mass
4 - rigid mass
5 - lumped mass
6 - transferred mass
7 - engineering mass
8 - distributed mass

","Example
To get the mass for elements 1-100: 
*createmark elems 1 1-100
set temp [hm_getmass elems 1]
set mass [lindex $temp 0]
set vol [lindex $temp 1]
set area [lindex $temp 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
695,hm_getmeshedgeparams,"Description
This command returns all of the relevant automesh settings applied to a surface edge by
          *set_meshedgeparams. If no automesh settings are applied, no values are
        returned. The returned values are (in order):

elem_density
alg_type
bias_style
bias
min_size
max_size
chordal_dev
max_angle

","Inputs

edge_id
The global edge ID of the surface edge to query.

","Example
To get the automesh parameters assigned to edge with ID 15:
hm_getmeshedgeparams 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
696,hm_getmeshvolumesinfo,"Description
This command returns the number of volumes and multiple lists containing the element IDs
        and volume indices for each input element.
","Inputs

mark_id
The mark of elements to find volumes for. Valid values are 1 and 2.
mode
0: internal voids considered as ""voids"" and do not make a new volume
1: internal voids considered as new volumes

The output from this command is in the following format:
{n} {elem_id1 volume_i1 volume_j1} {elem_id2 volume_i2 volume_j2} ...
{n} - The number of identified volumes.
{elem_id volume_i volume_j} - List containing the ID of the shell element and a pair of
        volumes of corresponding element sides. The first volume (i) corresponds to the volume on
        the shell element side with normal pointing out. A volume of 0 represents free space (no
        volume).
If 0 volumes are detected, only {n} is returned.
","Example
To orient all shell elements so that the normal points toward the inside of the volume with
        the smallest ID (or inside if there is only one volume):
*createmark elements 1 displayed
set volumes_list [hm_getmeshvolumesinfo 1 0]
set num_volumes [lindex $volumes_list 0]
set volumes_list [lreplace $volumes_list 0 0]
set reverse_list""""
foreach elem $volumes_list{
    set elemid [lindex $elem 0] 
    set vol1 [lindex $elem 1]
    set vol2 [lindex $elem 2]
    if {$vol1 > $vol2} {
        lappend reverse_list $elemid
    }
}
if { [llength $reverse_list ] } {
    *clearmark elements 2
    eval *createmark elements 2 $reverse_list
    eval *normalsreverse elements 2 1.e-10
    *clearmark elements 2
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
697,hm_getmodelcheckconcernentityidresultentityid,"Description
Finds the concerned non projecting untied nodes for a given contact group/interface. Untied
        node IDs are placed on mark 2.
","Inputs

display_name
The display name of the check to query. Currently supported values are:
? ""Un-Tied nodes in Contact Tied"" for LS-DYNA
? ""Un-Tied nodes in interface type2"" for Radioss


contact_id
ID of the contact for which untied nodes are to be found. This must be one of the
            contact IDs listed in the Model Checker browser after a Model Checker run.

","Examples
To find untied nodes for contact with ID 123:
For LS-DYNA:
hm_getmodelcheckconcernentityidresultentityid ""Un-Tied nodes in Contact Tied"" 123
For Radioss:
hm_getmodelcheckconcernentityidresultentityid ""Un-Tied nodes in interface type2"" 123
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
698,hm_getmodelcheckresultentids,"Description
Returns the entity IDs for the specified Model Check check display name.
","Inputs

display_name
The check display name.

","Example
To get the entity IDs for the check named ""Unused Materials"":
set ids [hm_getmodelcheckresultentids ""Unused Materials""]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
699,hm_getmoi,"Description
Returns the tensorial moment-of-inertia Ixx, Iyy, Izz, Ixy, Ixz, Iyz values for the
        selected entities.
","Inputs

entity_type
The type of entity to query. Currently supported for comps and elems.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
location_flag (optional)
Specifies the location about which the MOI is calculated. Valid values are:
0 - Global (0,0,0). Default.
1 - COG location.
2 - Node specified by node_id argument.


node_id (optional)
Specifies the node location about which the MOI is calculated if location_flag=2.
            Ignored otherwise.
axes_flag (optional)
Specifies the axes to report the MOI values relative to. Valid values are:
0 - Global axes. Default.
1 - Principal axes
2 - System specified by system_id argument.


system_id (optional)
Specifies the system ID to report the MOI values relative to if axes_flag=2. Ignored
            otherwise.
reserved_1
Reserved for future use. Must be set to 0.
reserved_2
Reserved for future use. Must be set to 0.

","Example
To get the MOI for components 1-5:
*createmark comps 1 1-5
hm_getmoi comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
700,hm_getnodalthickness,"Description
Gets the thickness of the node whose ID is given as the argument. 
","Inputs

entityType
The type of the entity. Only nodes are currently supported.
nodeID
ID of the node. 

","Example
This function queries the surface definition to obtain the thickness at a given node
        location. To obtain the thickness value using this function, the node should be associated
        with a geometric surface that was created using midsurface extraction tools in HyperMesh. The function returns ""-1"" if the thickness at that location
        could not be obtained.
hm_getnodalthickness node 73
","Errors
None.
"
701,hm_getnodessharedbyothercomps,"Description
This command returns the nodes on the input components that are shared by other
        components.
","Inputs

comp_mark_id
The ID of the mark containing the components with the nodes of interest. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the components with the nodes of interest. Valid values are 1 and 2.
exclude

0 - Do not exclude any nodes.
1 - Exclude nodes on mass, rigid and joint elements.


","Example
To find the nodes from component 100 shared by other components:
*createmark comps 1 100
hm_getnodessharedbyothercomps 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
702,hm_getoffset,"Description
This command returns the offset value of the specified element.
","Inputs

elem_id
The ID of the element to query.

","Example
To get the offset for element 100:
hm_getoffset 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
703,hm_getplanarfaces,"Description
Returns a list of planar face IDs.  These faces can be converted to surfaces using hm_getsurfacefromface.
","Example
To get the list of all planar face IDs:
set pfaces [hm_getplanarfaces];
","Errors
None.
",
704,hm_getPOLid,"Description
Returns the IDs of the POL lines.
","Example
To get the IDs of the POL lines:
hm_getPOLid
","Errors
None.
",
705,hm_getprojceid,"Description
Returns the ID of the connector from the FE weld data array for a given index. This command
        should only be used from within a connector-registered property script (which is executed
        during connector FE realization). The projection data this function relies upon is removed
        immediately after connector FE realization.
","Inputs

index
The index of the weld in the FE weld data array.

","Example
To get the connector ID for the 10th index in the weld data array:
set ce_id [hm_getprojceid 10]; 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
706,hm_getredoactions,"Description
Returns the history actions on the redo list.
","Example
To get the history actions on the redo list:
hm_getredoactions
","Errors
None.
",
707,hm_getreplacequerryonentities,"Description
This command can be used to query information about a part replace preview operation. This
        must always be used in conjunction with the *replacentitywithentity
        command.
","Inputs

option
1 - Get the replace status of all replaced entities. The status are 1 (not OK), 2 (OK)
            and 3 (partial OK). 
2 - Get the replace entity list. 
3 - Get the replace pass/fail status for common nodes shared between the replace
            component and other components.

","Examples
To get the replace status for all entities:
hm_getreplacequerryonentities 1
{loadcols {3 7 } {2 2 } {{1 of 1nodes replaced} {4 of 4 loads replaced} }} {groups { 2 1 } {2 2 } {{Master - 1 of 1 comps replaced} {Master - on all10 of 10 nodes 
replaced( Set - slave_set(grp1))} }} {outputblocks { 1 2 } {2 2 } {{4 of 4 nodes replaced} {4 elements replaced by69 elements} }}
To get the replace entity list:
hm_getreplacequerryonentities  2
{loadcols 3 7 } {systcols 1 } {groups 2 1 } {outputblocks 1 2 } {elements 7614 7615 7624 7616 7617 7618 7619 7620 7621 7622 7623 } {components 135 } {sets 1 7 2 9 13 4 15 16 18 20 } {contactsurfs 1 11 12 }
To get the pass/fail status:
hm_getreplacequerryonentities  3
{PASS 162473 162476 162497 162509 162516 162528 162530 162533 162535 162536 162538 162593 162650 162658 162676 162704 162707 162728 253082 } {FAIL }
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
708,hm_getsolidsfromsurface,"Description
Returns the list of solid IDs associated with a specified surface ID.
","Inputs

surfaceID
The ID of any surface in the model

","Example
To get a list of solids associated with surface of ID 1:
hm_getsolidsfromsurface 1
This command returns information necessary for running other commands related to surface
        and solid creation.
","Errors
None.
"
709,hm_getsolvercards,"Description
This command returns a list of solver cards (template tags) for either the specified
          entity_type or id_pool. The syntax is different
        depending on the method chosen.
 If entity_type is specified, this command returns a list of all solver
        cards related to the specified entity_type. The specified
          entity_type must be the fully qualified HyperMesh entity name (see hm_getentitybasename) In
        this method the -byentitytype flag must be specified otherwise the
        command will treat entity_type as id_pool. 
If id_pool is specified, this command returns a list of all solver cards
        related to the specified id_pool. The optional
          search_type argument determines whether id_pool is
        specified as a pool name or a pool ID. Valid values for search_type are
          -bypoolid and -bypoolname. If
          search_type is not specified, it defaults to
          -bypoolid. This method is only applicable to templates that support ID
        pools.
","Examples
To get the solver cards for properties:
hm_getsolvercards properties -byentitytype
To get the solver cards for the ID pool with ID 1:
hm_getsolvercards 1
or
hm_getsolvercards 1 -byid
To get the solver cards for the ID pool with name one_idpool:
hm_getsolvercards one_idpool -bypoolname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
710,hm_getsolverid2,"Description
Returns the solver ID and pool name for the specified HyperMesh
        internal ID. If there is no solver ID and pool for the specified entity, the internal ID and
        a blank ID pool are returned.
","Inputs

entity_type
The type of entity to query.
entity_name_or_id
The internal ID or name of the entity to query.
search_type
By default, HyperMesh searches for entities by name, and
            if the name is not found, it then searches by ID. This option allows you to specify how
            the search for an entity should be conducted. Valid values are: 
-byname - Search only by name. 
-byid - Search only by ID.

","Examples
To get the solver ID and pool name for property with internal ID 4:
hm_getsolverid2 props 4
or
hm_getsolverid2 props 4 -byid
To get the solver ID and pool name for a material with name 1:
hm_getsolverid2 mats 1
or
hm_getsolverid2 mats 1 -byname
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
711,hm_getsurfaceedges,"Description
Get a list of edges associated with a specified ID.
","Inputs

surfID
 The ID of the surface for which edges are returned. Lists of surface edge IDs grouped
            by surface loops.

","Example
hm_getsurfaceedges 13
returns:
{1 3 5} {2 8}
meaning that the surface has two loops, the first one consisting of edges 1, 3, and 5, and
        the second consisting of edges 2 and 8.
","Errors
None.
"
712,hm_getsurfacenormal,"Description
Gets the normals of the surfaces connected to the node or point whose ID is given as the
        argument.
","Inputs

entityType
The type of entity. Only nodes or points are supported.
entityID
ID of the entity.

","Examples
The result is returned as a list: { nsurfs x1 y1 z1 surf_id1 x2 y2 z2 surf_id2 …
          }

Where nsurfs is the number of surfaces attached to the point, xn yn zn are direction
        cosines of the normal of the surface having ID surf_idn. If no surfaces are attached, the
        list consists of the single number 0.
Suppose that node with ID 100 is located on a shared edge between surfaces having IDs 10 an
        11. To retrieve the normals at attached surfaces:
set node_norms [ hm_getsurfacenormal nodes 100 ]
   2 1.697E-001 7.988E-001 5.771E-001 10 1.699E-001 7.969E-001 5.796E-001 11
To get x cosine of the normal to surface 10 at this node:
lindex $node_norms 0
   1.697E-001

This function queries all surfaces connected to a given node to obtain the normal on each
        surface at a given node or point location. 
","Errors
None.
"
713,hm_getsurfacesfromedge,"Description
Gets all surfaces connected to the edge whose ID is supplied as the argument.
","Inputs

line_id 
ID of the edge.

","Example
To get surfaces connected to the edge with ID 2:
hm_getsurfacesfromedge 2
","Errors
None.
"
714,hm_getsurfacesfromvertex,"Description
Gets all surfaces connected to the point whose ID is supplied as the argument.
","Inputs

point_id
Point ID. 

","Example
The function returns a list containing IDs of surfaces connected to the vertex points. 
To get surfaces connected to the vertex with ID 2:
hm_getsurfacesfromvertex 2
","Errors
None.
"
715,hm_getthickness,"Description
This command returns the thickness value for an entity.
","Inputs

entity_type
The type of entity to query. Valid values are comps, elems and props. 
For an entity_type of components the following applies: 
If the component has a property directly assigned, the thickness of the property is
            returned. 
If no property is assigned to the component, nothing is returned. 
For an entity_type of elements the following applies: 
If the element has a property assigned, the thickness of the property is returned. 
If no property is assigned directly to the element, use the component rules as
            above.
entity_id
The ID of the entity to query.
ply_id
Optional argument that allows for additional control for querying the thickness of
            individual plies of composites. 
Used as follows for metallic properties:If not specified, returns the thickness. 
If specified as 1, returns the thickness as (a). 
Any other value will return an error. 
Used as follows for composite properties: 
If not specified, returns the total thickness (sum of all ply thicknesses). 
If a valid ply is specified, returns the thickness of that ply. 
Any other value will return an error.

","Examples
Get the thickness value of component 11 which has a PSHELL property with thickness of
        0.25:
hm_getthickness comps 11
	0.25

hm_getthickness comps 11 1
	0.25

hm_getthickness comps 11 2
	2 is not a valid ply ID.
Get the thickness value of component 15 which has a PCOMP property with 4 plys (thickness
        values of 0.1, 0.25, 0.25, 0.1, total of 0.7):
hm_getthickness comps 15
	0.7

hm_getthickness comps 15 1
	0.1

hm_getthickness comps 15 2
	0.25

hm_getthickness comps 15 3
	0.25

hm_getthickness comps 15 4
	0.1

hm_getthickness comps 15 5
	5 is not a valid ply ID.
Get the thickness value of element 20 which has a PSHELL property with thickness of
        0.25:
hm_getthickness elems 20
	0.25

Get the thickness value of element 20 which does not have a property assigned but belongs
        to a component that has a PSHELL property with thickness of 0.25:
hm_getthickness elems 20
	0.25
Get the thickness value of element 20 which does not have a property assigned and belongs
        to a component that does not have a property assigned:
hm_getthickness elems 20
	""""

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
716,hm_gettrimmedbinderid,"Description
Returns the IDs of the trimmed binder surfaces.
","Example
To get the IDs of the trimmed binder surfaces:
hm_gettrimmedbinderid
","Errors
None.
",
717,hm_getundoactions,"Description
Returns the history actions on the undo list.
","Example
To get the history actions on the undo list:
hm_getundoactions
","Errors
None.
",
718,hm_getunresolvedidcrossreferences,"Description
Returns entities that are referring to an unresolved ID. The return value is a list of 3
        values for each cross-referenced entity: 
{entity_type id_pool_name ids} 
For entities with ID pools the IDs returned are the solver IDs. Otherwise, the IDs are the
        internal IDs. If there is no ID pool for the specified entity type, """" will be returned for
          id_pool_id.
","Inputs

entity_type
The type of entity to query.
entity_id
The ID of the entity to query.
?id_pool_id?
The ID of the ID pool to query. If specified, entity_id is taken as
            a solver ID. If not specified, entity_id is taken as an internal
            ID.

","Example
To get the list of entity types cross-referencing material unresolved ID 100:
hm_getunresolvedidcrossreferences materials 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
719,hm_getunusedoremptyentities,"Description
Returns empty or unused entities, and places them on a mark. The return value is a list of
        lists. Each sub-list contains the empty or unused entity type as its first value, and the
        found entity IDs as the remainder of the sub-list. For example:
{sets 1 2} {comps 3} {mats 3 4}
","Inputs

mode=<mode>
The query mode. Valid values are empty and unused.
outputmark=<mark_id>
The ID of the mark to use for the output entities.
<select_type>=<selection>
The entity or entities that are to be queried. There are several ways to provide the
            entities to be queried. Only one option can be used at a time:
id=<id>
The ID of the single entity to query.
name=<name>
The name of the single entity to query.
mark=<mark_id>
The ID of the mark containing the entities to query. If specified, this must be
                  different from outputmark.


type=<entity_type>
The type of entity to query. If not specified, all entities in the database are
            queried.

","Examples
To get the empty sets out of sets ids 1 2 3:
*createmark sets 1 1 2 3
hm_getunusedoremptyentities mode=empty type=sets inputmark=1 outputmark=2 
To query all unused entities in database:
hm_getunusedoremptyentities mode=unused outputmark=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
720,hm_getuvcoordinates,"Description
Returns the parametric uv coordinates at a node location on the referenced surface. The u
        and v values are returned as a list containing two values. The first value in the list is
        the value of u, and the second value is the value of v. 
This command is only valid for single surfaces or surfaces generated by trimming one
        original surface and suppressing edges. It is not valid for the generic case of surfaces
        composed from different parametric patches by suppressing edges only (for example, two
        separate surfaces stitched together, then edges suppressed).
","Inputs

surf_id
The ID of the surface.
node_id
The ID of the node. The node must be associated to the surface.
scaled
Optional argument used when the referenced surface is a trimmed surface. If the value
            is set to 0 (default), the uv coordinates returned will be in reference to the
            parametric space of original untrimmed surface. If the scale value is set to 1, the uv
            coordinates returned will be in reference to the parametric space of the trimmed
            surface.

","Example
To get the uv coordinates of node 5 of surface 1:
hm_getuvcoordinates 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
721,hm_getverticesfromedge,"Description
Get surface edge endpoints.
","Inputs

edgeID
The ID of the surface edge.

","Example
List containing two IDs of edge endpoints.
hm_getverticesfromedge 12
For a closed edge that starts and ends at the same point, the returned list still contains
        two entries, both equal to the same point ID. 
The points order in the returned list reflects the parametric direction of the edge; the
        first point corresponds to the smallest parameter value. 
","Errors
None.
"
722,hm_getwrappoints,"Description
Given a mark of entities, a plane definition, and a vector, returns the maximum and minimum
        coordinates on the cross-section defined by the virtual intersection of the entities with
        the plane, in the vector direction.
","Inputs

entity_type
The type of entities to consider. Valid values are elems, surfs and comps (elems take
            priority over surfs).
mark_id
The ID of the mark containing the input entities.
x1 
y1 
z1
Defines the normal coordinates of the first input point.
x2 
y2 
z2
Defines the normal coordinates of the second input point.
x3 
y3 
z3
Defines the normal coordinates of the third input point.

","Example
To get the wrap points for all displayed elements using input points (0,0,0) (10,0,0)
        (10,10,0):
*createmark elems 1 displayed
hm_getwrappoints elems 1 0 0 0 10 0 0 10 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
723,hm_holedetectionend,"Description
Clears memory and ends the hole detection module. This must be preceded by any calls to
          hm_holedetectioninit and other hm_holedetection*
        APIs. 
""Major"" database changes made while inside of the hole detection module will invalidate and
        delete any results.
","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
To write out all geometric shell hole details to a file named C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
724,hm_holedetectiongetnumberofholes,"Description
Returns the number of found holes/tubes. This must be preceded by a call to 
          hm_holedetectionfindholes.
","Example
 To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
725,hm_holedetectioninit,"Description
Initializes the hole/tube detection module. This must precede any calls to other
          hm_holedetection* APIs, and must be followed by a call to
          hm_holedetectionend. 
""Major"" database changes made while inside of the hole detection module will invalidate and
        delete any results.
","Example
To write out all geometric shell hole details to a file named
          C:/temp/holes.txt:
set holesfile [open ""C:/temp/holes.txt"" ""w""]
hm_holedetectioninit
*createmark surfs 1 all
hm_holedetectionsetentities surfs 1
hm_holedetectionsetholeparams hole_shape=31 
hm_holedetectionfindholes 1
set n [hm_holedetectiongetnumberofholes]
if { $n > 0 } {
puts $holesfile ""Number of holes = $n""
puts $holesfile ""Holes details""
for {set i 0} {$i < $n} {incr i} {
puts $holesfile ""i = $i [hm_holedetectiongetholedetails $i]""
}
} else {
puts $holesfile ""Holes not detected.""
}
hm_holedetectionend
close $holesfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
726,hm_intersectlineline,"Description
s1x0 s1y0 s1z0 
s1x1 s1y1 s1z1 
s2x0 s2y0 s2z0 
s2x1 s2y1 s2z1
The four 3D points, which are the start and end points of two segments. 
Return value: x y z
","Example
hm_intersectlineline   0.0 0.0 0.0  2.0 0.0 0.0  -1.0 0.0  0.0 1.0 0.0 0.0 
Result: 1.0 0.0 0.0 
","Errors
None.
",
727,hm_isentitysupportedforaction,"Description
Determines if a particular entity type is supported for a certain action. A return value of
        0 means it is not supported. A return value of 1 means it is supported.
","Inputs

entity_type
The type of entity to query.
action
The action to query. Currently supported actions are REVIEW, SHIIR and CARDEDIT.

","Examples
To query if nodes are supported for SHIIR:
hm_isentitysupportedforaction nodes SHIIR
To query if components are supported for CARDEDIT:
hm_isentitysupportedforaction comps CARDEDIT
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
728,hm_ispointinsidesolidelem,"Description
This command returns 1 if the point is found to be inside the solid element and 0
        otherwise.
","Inputs

x , y , z
The (x,y,z) coordinates of the point.
elem_id
The ID of the solid element.

","Example
To check whether the point with coordinates 10, 20, 30 is inside the solid element with ID
        1:
hm_ispointinsidesolid 10 20 30 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
729,hm_mapelementstoplane,"Description
This command performs fast unfolding of a given set of connected shell elements onto a
        plane, while minimizing deformation for each element. The result is returned as a list with
        a number of entries equal to the number of nodes in the set of selected elements: { { id1 x1
        y1 } { id2 x2 y2} ... }. Each entry in the list consists of the node ID and mapped node u-v
        coordinates onto the plane.
","Inputs

mark_id
The ID of the mark containing the shell elements to map. Valid values are 1 and 2.
panel_sensitive (optional)
Can be used when multiple panel levels have been pushed, either using the shortcut
            function keys, or the hm_pushpanel command. This option determines
            whether to use the current panel or the previous panel for the operation. This option is
            relevant only when the mark has been created from a panel entity selector under the
            above conditions. Valid values are: 
0 - Use the previous panel (default). 
1 - Use the current panel.

","Example
To get the mapping for all elements to a plane, and to translate the nodes to that
        plane:
*createmark elems 1 all
set node_map2d [ hm_mapelementstoplane 1 ]

# Move each node to its 2D position (flatten the mesh)
foreach node $node_map2d {
# Node id, and calculated u, v on a plane
set node_id [ lindex $node 0 ]
set node_u  [ lindex $node 1 ]
set node_v  [ lindex $node 2 ]

# Current coordinates
set node_x  [ hm_getvalue nodes id=$node_id dataname=globalx]
set node_y  [ hm_getvalue nodes id=$node_id dataname=globaly]
set node_z  [ hm_getvalue nodes id=$node_id dataname=globalz]

# u will be new node's x, v will be new node's y, new z will be 0
set vector_x [ expr $node_u - $node_x ]
set vector_y [ expr $node_v - $node_y ]
set vector_z [ expr - $node_z ]
*createvector 1 $vector_x $vector_y $vector_z

# Calculate translation distance used by 'translatemark' (vector magnitude is ignored there)
set dist [expr sqrt( $vector_x * $vector_x + $vector_y * $vector_y + $vector_z * $vector_z )]

# Select and translate the node
*createmark nodes 1 $node_id
*translatemark nodes 1 1 $dist
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
730,hm_markclearall,"Description
 This command clears all entity IDs for all entity types from the specified mark.
","Inputs

mark_id
The ID of the mark. Valid values are 1 and 2.
model_name
The optional model to clear all marks from. If not specified, the current model is
            used.

","Example
To clear the contents of mark 2 for all entity
        types:hm_markclearall 2
To clear the contents of mark 2 for all entity types for model
        model-2:hm_markclearall 2 model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
731,hm_marksearchmode,"Description
For entities that have both a name and ID, they can be searched by name first then ID or by
        ID first then name. mode determines this search order for
          *appendmark and *createmark commands.
Valid modes are
0 - Search for names first, then ID (HM default). 
1 - Search for ID first, then name.


This command does not affect hm_appendmark or
          hm_createmark.
","Examples
If the database contains the following components:
name = ""1"", id = 100
name = ""100"", id = 1
The following commands will mark the first component (name =""1""):
hm_marksearchmode 0
*createmark comps 1 1
The following commands will mark the second component (name = ""100""):
hm_marksearchmode 1
*createmark comps 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If mode is invalid, you will get the following error:
hm_marksearchmode: valid values are 0 and 1.
",
732,hm_me_rootget,"Description
Returns the session-level root module ID.
","Example
To get the session-level root module ID:
hm_me_rootget
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
733,hm_morph_getdomainangle,"Description
 Returns the angle between two specified edge domains. Optional argument allows the user to
        input a normal vector to be used to measure the angle.
","Inputs

domainId1
The ID of one edge domain.
domainId2
The ID of a different edge domain.
x y z(optional)
Normal vector which will be used to calculate the angle between the domains. Default
            vector is normal to the end points of the two domains.

","Examples
To find the angle between domains with ID 2 and 3:
hm_morph_getdomainangle 2 3
To find the angle between two domains with ID 2 and 3 and measured normal to a vector that
        runs 1.0 in the x direction, 0.5 in the y direction, and 0.0 in the z direction:
hm_morph_getdomainangle 2 3 1.0 0.5 0.0
Only the angle from one end to the other end, using the connecting node as the vertex, is
        measured. Curvature is ignored.
","Errors
None.
"
734,hm_morph_gethandledomains,"Description
Returns the domain IDs for the specified handle.
","Inputs

handle_id
The ID of the handle to query.

","Example
To get the domain IDs for a handle with ID 2:
hm_morph_gethandledomains 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
735,hm_morph_getnodehandle,"Description
Returns the handle ID for the specified node if a handle exists at that node.
","Inputs

node_id
The ID of the node to query.

","Example
To get the handle ID for a node with ID 2:
hm_morph_getnodehandle 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
736,hm_proximitygetcomponentelementpaircount,"Description
Returns the number of element pairs for a specific component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
737,hm_proximitygetcomponentpaircount,"Description
Returns the number of proximity component pairs. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
738,hm_proximitymarkcomponentallelementpairs,"Description
Marks the element pairs for a specific component pair. 
This must be preceded by a call to hm_proximityinit and followed by a
        call to hm_proximityend.
","Inputs

component_pair_index
The index of the component pair. This starts from 0 and must be less that the value
            returned by hm_proximitygetcomponentpaircount.
mark_id1
The output mark on which the elements for the first component are placed.
mark_id2
 The output mark on which the elements for the second component are placed. 

","Example
To calculate the proximity between all comps using a max distance of 2.5 and to query the
        component pairs:
*createmark comps 1 all
hm_proximityinit comps 1 2.5
set comp_pair_count [hm_proximitygetcomponentpaircount]
for {set i 0} {$i < $comp_pair_count} {incr i} {
    set comp_pair [hm_proximitygetcomponentpair $i]
    puts ""Component pair $i: $comp_pair""
    set elem_pair_count [hm_proximitygetcomponentelementpaircount $i]
    for {set j 0} {$j < $elem_pair_count} {incr j} {
        set elem_pair [hm_proximitygetcomponentpair $i $j]
        puts ""    Element pair $j: $elem_pair""
    }
}
hm_proximityend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
739,hm_runcommandfile,"Description
This command can be used to execute a HyperMesh command file
          (*.cmf) from within aTcl script. In the case
        there is an error in one of the lines of the command file, the command execution continues
        without prompting if the user wants to continue.
","Inputs

filename
The full path and filename of the command file. Note that forward slashes (/) are
            required in the path and filename, the name must be wrapped in curly braces {}, or the
            backwards slash (\) must be escaped. Paths with spaces must be enclosed in quotes or
            curly braces. These are Tclrequirements.
prompt (optional)
Argument specifying whether to ignore the *answer command in the
            command file (default, 0) or to honor the *answer command when
            present (1).

","Examples
To run the command file command1.cmf in folder
          C:/solidedit:
hm_runcommandfile C:/solidedit/command1.cmf
or
hm_runcommandfile {C:\solidedit\command1.cmf}
or
hm_runcommandfile C:\\solidedit\\command1.
To run the command file command1.cmf in folder ""C:/solid
          edit:""
hm_runcommandfile ""C:/solid edit/command1.cmf""
or
hm_runcommandfile {C:/solid edit/command1.cmf}
","Errors
None.
"
740,hm_setdieattribute,"Description
Sets the die attribute for an entity. 
","Inputs

die_attribute
Valid values are: 
drawbead 
drawbar
entity_id
The ID of the entity.

","Example
To set the die attribute for the drawbar with ID 100:
hm_setdieattribute drawbar 100
","Errors
None.
"
741,hm_solverconvert,"Description
This command converts a model from one solver to another. 
Supported solvers are:


Solver Name
Solver ID
Solver Type


Nastran
1
 


OptiStruct
1
 


Abaqus
2
Standard2D, Standard3D


ANSYS
8
 


LS-DYNA
9
Keyword971, Keyword970


PAM-CRASH
18
Pamcrash2G2008, Pamcrash2G2007, Pamcrash2G2006 Pamcrash2G2005,
                Pamcrash2G2004


Radioss
20
Block110, Block100, Block90, Block51, Block44




Supported conversions are:


Source Solver Name
Destination Solver Name


Abaqus
Nastran/OptiStruct


ANSYS
Nastran/OptiStruct


LS-DYNA
Nastran/OptiStruct


Radioss
PAM-CRASH


PAM-CRASH
Radioss


Nastran/OptiStruct
Abaqus


Nastran/OptiStruct
Ansys


Nastran/OptiStruct
LS-DYNA


Nastran/OptiStruct
Radioss


ANSYS
Abaqus




","Inputs

source_solver
The source solver name or ID.
destination_solver
The destination solver name or ID.
source_type
The source solver template type.
destination_type
The destination solver template type.
batch
Flag that indicates if the conversion should be run in batch mode. 
0 - no batch mode 
1 - batch mode

","Examples
Convert Abaqus Standard3D model to OptiStruct in batch mode:
hm_solverconvert Abaqus OptiStruct Standard3D """" 1
or
hm_solverconvert 2 1 Standard3D """" 1
Convert Radioss Block90 model to PAM-CRASH Pamcrash2G2007 without batch mode:
hm_solverconvert RadiossBlock Pamcrash Block90 Pamcrash2G2007 0
or
hm_solverconvert 20 18 Block90 Pamcrash2G2007 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
742,hm_tableclear,"Description
Clear a table (all memory is freed).
","Inputs

tableName
The name of the table to clear. 

","Example
When the current model is deleted, or a new model is loaded, all tables are cleared. 
","Errors
None.
"
743,hm_tabledifference,"Description
Finds the difference of two HyperMesh tables of the same entity
        type (subtracts the contents of the second table from the first table) and places the result
        in the first table.
","Inputs

table1
First table.
table2
Second table. 
TCL_OK(0) if successful. TCL_ERROR(1) otherwise

","Example
This command can be used to find entities unique for a table: 
# Creating 2 tables
*createmark comp 1 1 2
hm_marktotable comp 1 t12
*createmark comp 1 2
hm_marktotable comp 1 t2
hm_tabledifference t12 t2;  
# T12 contains only comp 1 now

","Errors
None.
"
744,hm_tablelist,"Description
Use hm_tableclear or hm_tableclearall to remove the
        table from the list. When the current model is deleted, or a new model is loaded, all tables
        are cleared. 
","Errors
None.
",,
745,hm_tabletomark,"Description
This command appends the entity IDs stored in table_name to mark
          mark_id. Valid mark_ids are 1 and 2. 
The ?panel_sensitive? option can be used when multiple panel levels have
        been pushed, either using the shortcut function keys, or the hm_pushpanel
        command. This option determines whether to use the current panel or the previous panel for
        the operation. This option is relevant only when the mark has been created from a panel
        entity selector under the above conditions. Valid panel_sensitive options
        are: 
0 - Use the previous panel (default). 
1 - Use the current panel. 
Tables are not stored within a HyperMesh database
          (.hm file). When the current model is deleted or a new model is
        loaded, all tables are cleared. 
If a table contains an entity that is subsequently deleted, the entity is removed from the
        table. Renumbering does not modify the entity IDs stored in the table.
","Example
To put the elements from table elem_table on element mark 1:
hm_tabletomark elem_table 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
If table_name does not exist, you will get the following error:
hm_marktotable: the table <table_name> was not found.
If mark_id is invalid, you will get the following error:
hm_marktotable: invalid mark mask <mark_id> specified, must be either 1 or 2.
If mark_id is empty, and ?force? is not specified or
        is specified as 0:
hm_marktotable: no entities were found on the mark.

",
746,hm_wadlinescheckentities,"Description
Checks front and rear entities for validity. This must be preceded by a call to
          hm_wadlinessetentities. 
If entities are valid, 0 is returned. If any front entities are in the rear group, or vice
        versa, non-zero is returned.
","Example
To setup and check WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
if {[hm_wadlinescheckentities] == 0} {
  puts ""Entities are valid.""
}
hm_wadlinesend
","Errors
None.
",
747,hm_wadlinesgetwadline,"Description
Returns coordinate data defining a WAD line.
","Inputs

distance
The distance from ground level for the WAD line, as measured along the vehicle. The
            data will be returned as a list of doubles. Every three doubles are the X, Y, and Z
            coordinates of a point along the line. The lines run from left to right.

","Example
To setup and extract WAD lines data:
hm_wadlinesinit
hm_wadlinessetparameters 45.0 50.0 100.0 100.0 50.0 20.0 25.0 60.0
hm_wadlinessetaxes 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0
*createmark comps 1 ""bonnet"" ""bumper"" ""fenderL"" ""fenderR""
*createmark comps 2 ""windshield"" ""a-pillars""
hm_wadlinessetentities comps 1 comps 2
*createmark elems 1 ""by collector"" wipers
hm_wadlinessetwipers elems 1 0 1
hm_wadlinesgetreferenceline 0
hm_wadlinesgetreferenceline 1
hm_wadlinesgetreferenceline 2
hm_wadlinesgetreferenceline 3
hm_wadlinesgetreferenceline 4
hm_wadlinesgetreferenceline 5
hm_wadlinesgetreferenceline 6
hm_wadlinesgetreferenceline 7
hm_wadlinesgetwadline 1000.0
hm_wadlinesgetwadline 1500.0
hm_wadlinesgetwadline 1700.0
hm_wadlinesgetwadline 2100.0
hm_wadlinesgetgridpoints 1000.0 1500.0 1700.0 2100.0 50.0
hm_wadlinesend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
