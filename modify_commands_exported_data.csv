,api_name,api_description,input,example,error
0,*absoluterotatedummyjoint,"Description
Rotate the dummy’s joint to an absolute position. Rotation occurs first about the X, then
        Y, then Z.
","Inputs

entities
The entity type. Currently, only components is supported.
xRot
The rotation in degrees about the child’s X axis.
yRot
The rotation in degrees about the child’s Y axis.
zRot
The rotation in degrees about the child’s Z axis.
parentChild
0 - Child rotates about its own axis (after being reset back to parent). 
1 - Parent rotates about the child’s axis.

When parentChild is 0, xRot, yRot,
        and zRot define the rotational differences between the parent and child
        systems. That is, the child will be reset back to the parent, and then it will be rotated
        about the X, Y, and Z (in that order).
When parentChild is 1, xRot, yRot,
        and zRot define the rotations in the X, Y, and Z directions that will
        occur from the current parent’s position.
","Examples
For a rotational difference of 20 degrees about the X axis between the child and
        parent:
*absoluterotatedummyjoint(components, 1, 20, 0, 0, 0)
",
1,*absorbentities,"Description
Absorb entities using the tabular segregation interface.
","
Inputs


entity_type
The type of entity to absorb.  Currently only supported for loads.
mark_id
The ID of the mark containing the entities to absorb.  Valid values are 1 and 2.
value_rule
Specifies whether value-based segregation is desired and, if so, the type of tolerance
            provided:
0 - Do not segregate by value
1 - Segregate by value, tolerance is a ratio
2 - Segregate by value, tolerance is a percentage
3 - Segregate by value, tolerance is an absolute
tolerance
The tolerance value when value_rule is non-zero.
location_unit_rule
Specifies whether location unit-based segregation is desired and, if so, the type of
            entities considered:
0 - Do not segregate by location unit
1 - Segregate by location unit, all cases considered
2 - Segregate by location unit, consider only 2D shells
4 - Segregate by location unit, consider only 2D edges
6 - Segregate by location unit, consider 2D shells and 2D edges
8 - Segregate by location unit, consider only 3D faces
10 - Segregate by location unit, consider 2D shells and 3D faces
12 - Segregate by location unit, consider 2D edges and 3D faces
14 - Segregate by location unit, consider 2D shells, 2D edges and 3D faces
topology_rule
Specifies whether topology-based segregation is desired and, if so, the type of
            topologies considered:
0 - Do not segregate by topology
1 - Segregate by topology, all cases considered
2 - Segregate by topology, consider only non-adjoining mesh
4 - Segregate by topology, consider only component boundary
6 - Segregate by topology, consider non-adjoining mesh and component boundary
8 - Segregate by topology, consider only mesh edge
10 - Segregate by topology, consider non-adjoining mesh and mesh edge
12 - Segregate by topology, consider component boundary and mesh edge
14 - Segregate by topology, consider non-adjoining mesh, component boundary and mesh
            edge
face_angle
The face angle value when topology_rule specifies the mesh edge
            option.
edge_angle
The edge angle value when topology_rule specifies the mesh edge
            option.
preseve_parameters
0 - Do not preserve
1 - Preserve
max_cluster_count
The maximim number of clusters allowed per entity instance.

","Examples
Absorb all displayed loads without any
        segregation:*createmark loads 1 displayed
*absorbentities loads 1 0 0 0 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2,*accepteditedsurface_with_user_tolerance ,"Description
Moves surfaces from the midsurface to edit component into the middle surface component and
        stitches surfaces according to a specified tolerance.
","Inputs

auto_stitch
= 0 - Auto-stitch is disabled.
≠ 0 - Auto-stitch combines surfaces using the specified
            tolerance.
tolerance
Surfaces within this decimal-value tolerance are stitched together if
              auto_stitch is enabled.
If auto_stitch is enabled but tolerance is less
            than zero, then the result is stitched with a tolerance of 1/5 the midsurface
            thickness.

","Example
To move midsurfaces from midsurface to edit into middle surface with a stitching tolerance
        equal to ¼ of the midsurface thickness:
*accepteditedsurface_with_user_tolerance(1,0.25)
",
3,*acousticmeshcreate,"Description
Options are available for creating the mesh using specified type and quality parameters, to
        create face elements, to input fixed nodes within the cavities and optionally to only create
        a mesh for particular AC_Structural.N components. The AC_Structural.N naming convention is
        used to separate each cavity by placing them in components of different names, where N
        ranges from 1 to the number of structural cavities found. 
This command can be run multiple times after running *acousticmeshinit a
        single time. Each time *acousticmeshcreate is run, it automatically
        deletes any existing AC_Structural.N and AC_Seat.M components. Note that a similar naming
        convention is used for seat cavities, AC_Seat.M. In order to avoid memory leaks, the
          *acousticmeshend command should be called when the acoustic cavity mesh
        process is complete.
","Inputs

fixed_nodes_mark_id
The mark ID containing any internal fixed nodes. Valid values are 1 and 2. An empty mark can be specified or 0 can be used, if there are no
            fixed nodes specified.
mesh_type
0 - Preview mesh 
13 - For all-tetrahedral 
14 - For hexa-tetrahedral, non-conforming
max_structural_cavities
A flag used to denote the number of cavities for which to output elements: 
0 - All
> 0 -  The number of largest cavities found. 
< 0 - Those above this (positive) percent of largest cavities found.
min_jacobian
The minimum Jacobian for any hexa elements created. It is measured at the corner nodes
            of the elements.
min_tet_collapse
The minimum tet-collapse for any tetrahedral elements created.
create_comp_mark
If 1 or 2, only output cavities for components are placed on this mark. These
            components are those with the AC_Structural.N naming convention. 
Use 0, if not required.
create_cavity_faces
Create faces for any solid-meshed cavities. These elements are placed in the
            ^cavity_faces component.
reserved1
Reserved for future use. Must be specified as 0.
reserved2
Reserved for future use. Must be specified as 0.

","Examples
To produce an acoustic cavity mesh preview of the 10 largest cavities:
*acousticmeshcreate 0 0 10 0.0 0.0 0 0 0 0
To produce an acoustic cavity mesh hexa-tetrahedral mesh of the 10 largest cavities. There
        are fixed nodes and cavities to output. Also, the output of cavity faces is enabled. There
        are also minimum acceptable Jacobian and tet-collapse values specified (0.2 and 0.1,
        respectively).*acousticmeshcreate 1 14 10 0.2 0.1 1 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
4,*acousticmeshinit,"Description
Used to initialize an acoustic cavity mesh. This command must be run before
          *acousticmeshcreate, which actually generates the preview and solid
        acoustic cavity meshes.
","Inputs

structural_mark_id
The mark ID containing any input structural comps. Valid values are 1 and 2.
seats_mark_id
The mark ID containing any seat comps. Valid values are 1 and 2.
cell_size
The element size of the solid elements.
seat_coupling
A flag used to denote: 
0 - Node-to-node re-mesh.
1 - Seats are considered as master MPC.
2 - Seats are considered as slave MPC.
topo_patch_size
The input (topological) hole patch size.
semantic_patch_size
The input (semantic) hole patch size.
create_hole_elements
A value of 1 indicates to create patch elems to topo holes. These elements are places
            in the ^patches_holes component.
flag
Reserved for future use. Must be specified as 0.
reserved
Reserved for future use. Must be specified as 0.

","Examples
To initialize an acoustic cavity mesh with an element size of 40.0, patching holes and gaps
        of 200.0 and 100.0 respectively, and creating the hole patch elements:
*acousticmeshinit 1 2 40.0 0 200.0 100.0 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
5,*acousticmeshinterface_2,"Description
Used to query the results of an acoustic cavity mesh operation. This command must be run
        after *acousticmeshcreate. It specifically utilizes a bounding box
        defined by the acmodl_normal, acmodl_intol, and
          acmodl_dskneps input parameters to identify:
The wetted nodes on the body: nodes on elements on the interface with the fluid that
            satisfy the bounding box criteria. 
The interface nodes of the fluid: the nodes on the fluid faces that are on faces that
            have at least one body node within their bounding box. 
The wetted element faces of the body: the elements on the body that contain at least
            one node within a bounding box. 
The interface faces of the fluid: the fluid faces that have at least one body node
            within their bounding box. 
The wetted body components: the components that contain at least one element on the
            body that has a node on the wetted interface.


It should be noted that the body is composed of the structural and the seat components.
","Inputs

mark_id_cavity
The ID of the mark containing the 3D cavity components. Valid values are 1 and 2.
mark_id_structural
The ID of the mark containing the  2D structural components. Valid values are 1 and 2.
wetted_node_output_mark_id
The ID of the mark containing the found wetted body nodes. Valid values are 1 and 2.
If set to 0, the values are not returned.
interface_node_output_mark_id
The ID of the mark containing the found fluid interface nodes. Valid values are 1 and 2.
If set to 0, the values are not returned.
wetted_element_output_mark_id
The ID of the mark containing the found wetted body element faces. Valid values are 1 and 2.
If set to 0, the values are not returned.
interface_element_output_mark_id
The ID of the mark containing the found fluid interface element faces. Valid values
            are 1 and 2, if the create_cavity_faces option was enabled for
              *acousticmeshcreate. 
If set to 0, the values are not returned.
wetted_component_output_mark_id
The ID of the mark containing the found wetted body components. Valid values are 1 and 2.
If set to 0, the values are not returned.
acmodl_normal
Used to define the (positive) height of bounding box for particular fluid faces. This
            height is equal to the largest side of the face multiplied by this value, and is in the
            outward direction.
acmodl_intol
Used to define the (negative) height of the bounding box for particular fluid faces.
            This height is equal to the largest side of the face multiplied by this value, and is in
            the inward direction.
acmodl_dskneps
Used to define the in-plane extension of the bounding box for particular fluid faces.
            This extension is measured relative to the distance from the center of the face to each
            corner. This value is the ratio by which the face is extended at each corner.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Examples
Calculate, and then highlight, the wetted nodes, wetted elements and wetted components for
        two structural and seat cavities:
*createmark comps 1 812
*createmark elems 1 ""by comp id"" 813
*createmark elems 2 ""by comp id"" 816
*acm_create_mpc 1 2 1 50.0 2
*createmark components 1  ""AC_Structural.1"" ""AC_Seat.1"" ""AC_Seat.2"" ""AC_Structural.2""
*createmark components 2 ""input_for_acm""
*acousticmeshinterface_2 1 2 1 0 1 0 2 0.4 0.2 0.2 0 0
hm_highlightmark nodes 1 h
hm_highlightmark nodes 1 n
hm_highlightmark elems 1 h
hm_highlightmark elems 1 n
hm_highlightmark comps 2 h
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
6,*adaptive_triangle_mesh,"Description
Creates an adaptive tria mesh from an STL tria mesh input. This is useful for remeshing
        dirty STL meshes.
","Inputs

entity_type
The type of entity to remesh. Valid values are comps and elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
options
The options to control the new mesh generation. They are all key=value pairs. Pairs
            are separated by either a space or a comma. Valid parameters are:
break_connectivity=<value>
Option to manage the connectivity with the neighboring mesh:
0 – Fix nodes on selection boundary as well as other edges
1 – Break the connectivity at the selection boundary
2 – Keep the connectivity at the selection boundary
3 – Redo connectivity outside the selection, the spread of the transition region
                  is determined automatically till the size meets neighbouring size
dfmin=<value>
The minimum elem size.
feature_angle=<value>
The minimum angle used to define features to keep in the resulting mesh. Default
                  is 35.0 degrees.
growth_ratio=<value>
The growth ratio of the triangles. Default is 1.2.
inside=<value>
The fixed number of layers of elements inside the element selection where the
                  connectivity is redone. This is valid only when
                    break_connectivity=3.
outside=<value>
The fixed number of layers of elements outside the element selection where the
                  connectivity is redone. This is valid only when
                    break_connectivity=3.
ref_size=<value>
The default elem size.
span_angle=<value>
Defines the maximum angle an element can span on a curved section. Default is
                  25.0 degrees.



","Examples
To create a new adaptive mesh of comp ""remesh"" with new mesh size 10, minimum size 1.0,
        growth ratio 1.2, span angle 30 degrees and feature angle 30 degrees:
*createmark comps 1 ""remesh""
*adaptive_triangle_mesh comps 1 ""growth_ratio=1.2 span_angle=30.0 feature_angle=30.0 ref_size=10.0 dfmin=1.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
7,*adaptive_wrapper_end,"Description
Terminates the adaptive wrap mesher and clears the temporary data populated during adaptive
        wrap mesh generation. 
This command must be called after *adaptive_wrapper_init.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
8,*adaptive_wrapper_leak_check,"Description
This command can be used to quickly identify leaks from the base mesh. Volumes are defined
        by selection of seed nodes. Seed nodes should not be part of the base mesh. 
This command must be called after *adaptive_wapper_init.
","Inputs

entity_type
The type of entities used for adaptive wrap mesh leak detection. Currently only
            supported for elems.
elem_mark_id
The ID of mark containing the elements. Valid values are 1 and 2.
node_mark_id
The ID of mark containing the seed nodes. Valid values are 1 and 2.
min_size
The minimum element size considered during leak detection. It also acts as the gap
            patch tolerance to check the closeness of volumes.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0   

#Detect leaks
*createmark elements 1 ""all""
*adaptive_wrapper_leak_check elems 1 1 0.1

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate Mesh 
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0  1 2 

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
9,*adaptive_wrapper_mesh,"Description
This command generates an adaptive wrap mesh.
This command must be called after *adaptive_wrapper_build and must be
        followed by *adaptive_wrapper_end.
","Inputs

mesh_type
0: Quad dominant
string_array
The string array ID that contains the mesh generation parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Each string should be contained in quotes and contain one of the following parameters
            as keywords, followed by the parameters values. Keywords and the corresponding values
            can be separated by a semicolon.
AcousticMeshType: <type>
The type of acoustic cavity mesh. 
1 - Hex-tet mesh 
2 - All tet mesh
AcousticMeshQualityHexJacobian: <value> 
The Jacobian target cut off value used for hex-text cavity meshing.
AcousticMeshQualityTetCollapse: <value> 
The tet-collapse target cut off value used for all tet cavity meshing.  
ConsiderCavityByComps: <mark_id> 
During preview, some new components will be displayed to show the cavity. This
                  is the optional mark ID containing those components to send for meshing. 
DoRemesh: <option> 
0 - Do not remesh the wrap mesh with adaptive tria mesh. 
1 - Remesh the wrap mesh with adaptive tria mesh.
ExcludeVolumeSeedNodeMark: <mark_id>  (optional)
Mark ID containing seed nodes used to specify the volumes to exclude from
                  wrapping. 
IncludeVolumeForLargestCavityIndex: <index>  (optional)
Volume index to wrap. 
IncludeVolumeSeedNodeMark: <mark_id>  (optional)
Mark ID containing seed nodes used to specify the volumes to wrap. 
MaxSmoothIterations: <max>  (optional)
Maximum number of smoothing iterations to perform on the wrap mesh. 
RemeshGrowthRate: <rate> 
If DoRemesh is set to 1, this is the specified growth rate to
                  reuse for remeshing.
SpanAngle: <value> 
If DoRemesh is set to 1, this is the specified span angle to
                  use during remeshing. 
OrganizeWrapElemsByBaseComps: <option> 
If set to 1, organize the wrap mesh according to the base mesh components, by
                  creating new components with the same base comp name with the suffix
                    _Wrap. If DoRemesh is set to 1, the suffix
                  is _Wrap_Remesh instead. New assemblies are also created for
                  these components, named Wrapped_Components and
                    Wrapped_Remeshed_Components. 


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
10,*adaptive_wrapper_mesh_reject,"Description
Rejects the *adaptive_wrapper_mesh operation.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_mesh_reject

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
11,*adaptive_wrapper_preview_clear,"Description
Clears the preview generated by *adaptive_wrapper_preview.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

#Build skeletal octree structure
*adaptive_wrapper_build

#Preview all cavities
*adaptive_wrapper_preview

#Clear the preview
*adaptive_wrapper_preview_clear

#Generate Mesh 
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0  1 2 

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
12,*adaptive_wrapper_proximity_params,"Description
Assigns proximity parameters to the adaptive wrapper mesher. Both local and global
        proximity controls can be assigned. This command also allows an option for checking self
        proximity.
This command must be called after *adaptive_wrapper_init and before
          *adaptive_wrapper_build.
","Inputs

self_proximity_for_all
Global option to check self proximity for all elements. Gaps below this value are
            considered to be closed.
prox_lower_bound
Lower proximity bound for global self proximity check.
string_array
The ID of the string array that contains the proximity control parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each string should be contained in quotes and contain one of the following parameters
            as keywords followed by the parameters values. Keywords and the corresponding values can
            be separated by a semicolon. Each keyword can be used multiple times to define different groups.
WithinGroup: <proximity lower bound> <self proximity flag> <number of
                  comps> <comp IDs>...
Local option to check proximity within specified components. For example, to
                  specify a lower proximity value of 0.5 for comps 11-13: 
""WithinGroup: 0.5 1 3 10 12 13""
AcrossGroups: <proximity lower bound> <number of comps in first set>
                  <comp IDs in first set> <number of comps in second set> <comp IDs in
                  second set>
Local option to check proximity between two sets of components. For example, to
                  specify a lower proximity value of 0.5 between comps 10-12 and 20-24:
""AcrossGroups: 0.5 3 10 11 12 5 20 21 22 23 24""


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
13,*adaptive_wrapper_set_features,"Description
This command assigns/extracts features for the adaptive wrapper mesher.
This command must be called after *adaptive_wrapper_init and before
          *adaptive_wrapper_build.
","Inputs

feature_type
The feature extraction scheme. Valid values are: 
1 - Simple feature extraction 
2 - Connected feature extraction 
3 - User defined features 
4 - Do not use features
mark_id
The mark ID containing user-defined plotel feature elements. Valid values are 1 and 2.
Only used if feature_type is 3.
feature_angle
If feature_type is 1 or 2, this is the feature angle used for
            feature extraction.
clean_features
1 - Cleans features based on feature overlap. This is used to avoid excessive
            refinement.
cleanup_tol
If clean_feature is 1, this is the tolerance used to check for
            feature overlap.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
14,*add_multi_washer_elements,"Description
This command is used to add washer elements to circular holes of shell meshes. Multiple
        holes can be handled at a time.
","Inputs

node_mark_id
The mark of nodes on the circular holes to add washers to. Valid values are 1 and 2.
feature_angle
Defines the mesh feature lines around washer elements. The range should be (0, 180).
            It is usually set to 30.
string_array
The string array ID that contains the washer element information. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
The first string in quotations should contain the following parameters as keywords
            followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
layer_number <layers> 
The number of washer element layers, > 0.
uniform_layers <flag> 
The value is 1 or 0. 1 means that all layer widths are uniform.
hole_density <value> 
The washer element density on the hole.

All other strings define layer width parameter groups. If
                uniform_layers is set to 1, only one layer width parameter group
              is needed. Otherwise, the number of groups should be the same as the layer number.
              Each group contains 2 quoted values:

width_flag <flag> 
1 - The width_value defines the width of the layer, otherwise
                  it is defined as the ratio of the layer width over the hole radius.
width_value <value>
Defines the width of the layer.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
periphery_node_mark_id
The output mark of periphery nodes generated on the hole. Valid values are 0, 1 and 2. 
0 - No periphery nodes are placed on the mark.
background_elem_mark_id
The output mark of background elements to be deleted in order to update the
            connectivity of the newly created elements and their neighbors. Valid values are 0, 1
            and 2. 
0 - Background elements are deleted and element connectivity is updated. Otherwise,
            the background elements are kept and placed on the mark.
rigid_spider
Valid values are 0, 1 and 2. If the value is set to 0, no rigid elements will be
            created inside the hole. 
1 - A single spider will be created inside the hole. 
2 - Individual rigid elements will be created for periphery nodes.
local_cordinate_system
1 - A local coordinate system will be created in the plane of the hole.

","Examples
To add washer elements around the hole containing node 60, using 2 element layers of
        uniform size, a density of 8 and a width of 5.0:
*createmark nodes 1 60
*createstringarray 2 ""layer_number = 2 uniform_layers = 1 hole_density = 8""  ""1 5.0""
*add_multi_washer_elements 1 30 1 2 0 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
15,*add_rib,"Description
This command creates a rib whose position is determined by a profile plane together with
        two points that are located on two given surfaces, respectively. The mid-plane of the rib
        will be always parallel to the profile plane. The rib is allowed to cut into some other ribs
        transversely as it goes from surface1 to surface2,
        hence creating multiple walls in between. They are also allowed to go over some other ribs
        or bumps. 
","Inputs

plane_id
The ID of a plane created using the *createplane command. This
            defines the rib profile plane.
surface_id1
The ID of the first surface on which a rib end is located.
surface_id2
The ID of the second surface on which a rib end is located.
x1, y1, z1
The coordinates of the first rib end point, on surface_id1. This
            point does not have to be on the profile plane but it should be close enough for
            accurate positioning of the rib. The intersection line of surface_id1
            with the profile plane_id is calculated and the closest location on
            this line to the input is used, which would be located both on
              surface_id1 and the profile plane_id at the same
            time.
x2, y2, z2
The coordinates of the second rib end point, on surface_id2. This
            point does not have to be on the profile plane but it should be close enough for
            accurate positioning of the rib. The intersection line of surface_id2
            with the profile plane_id is calculated and the closest location on
            this line to the input is used, which would be located both on
              surface_id2 and the profile plane_id at the same
            time.
width
The distance between the side planes of the rib measured at the top plane of the rib.
            It is the width of the top plane of the rib and its value must always be greater than
            zero.
draft_angle
The tilt angle of the side planes of the rib with respect to the mid-plane of the rib.
            If the draft angle is zero, then the sides of the rib will be parallel to the mid-plane
            of the rib. As the draft angle increases, the side planes open up from the bottom of the
            rib, keeping the locations fixed at the top plane of the rib. Negative draft angles are
            allowed, but if too large, might result in intersection of side planes with each other
            hence the rib might fail to be created.
plane_position
Specifies if the profile plane is going to be coincident with the mid-plane (i.e.,
            value 0), or if it will be on its left or right (i.e., values 1 and 2, respectively) at
            a distance which is equal to half of the width. 
options
0 - Triangular rib 
1 - Quadrilateral rib

","Examples
To create a triangular rib that has a width of 0.8 and a draft angle of 4.0 degrees, using
        the x-y plane with base (0, 0, and 0). The rib will be created on the left of this profile
        plane. The rib will start at surface 9 and end at surface 6. The exact start location is the
        closest point to point (12.0, 35.0, and 22.0) that is at the intersection of surface 9 with
        profile plane and the exact end position is determined similarly by point (10.5, 35.5, and
        17.5) using surface 6 and profile plane.
*createplane 1 0 0 1 0 0 0
*add_rib 1 9 6 12.0 35.0 22.0 10.5 35.5 17.5 0.8 4.0 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
16,*addfacestocontactsurfusingfacenumber,"Description
Adds elements using the face number to a contact surface.
","Inputs

name
The name of the contact surface to update.
mark_id
The mark ID that contains the elements to add. Valid values are 1 and 2.
face_number
The face number of the element (starting from 0).
reverse_normals
0 - Create contact surface along element normal.
1 - Create contact surface opposite element normal.
element_id
The single element ID to use (default is 0).
use_element_id
0 - Use mark_id (default).
1 - Use element_id.

","Examples
To add elements 1 through 100 using face number 2 to contactsurf
        ""test"":
*createmark elems 1 1-100
*addfacestocontactsurfusingfacenumber ""test"" 1 1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
17,*addincludetodisplay,"Description
This command displays/unmasks all of the entities in the specified include file to the
          HyperMesh
modeling window.
","Inputs

id
The ID of the include file. An ID of 0 selects the master file. If not specified,
            should be blank """".
shortname
The shortname of the include file. This value can be blank when id
            is specified. If not specified, should be blank """".

","Examples
To add the entities in the include with ID 3 to the display:
*addincludetodisplay 3 """"
To add the entities in the include with shortname elems.fem to the
        display:*addincludetodisplay """" elems.fem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
18,*addshellstocontactsurf,"Inputs

Name
Name of the contactsurf being created.
Elemmark
Elements to be added to contactsurf.
Reversenormals
Direction of normal for contactsurfs.
0 - Along element normal.
1 - Opposite element normal. Set to 1, if normals need be opposite to element
                normals.



","Example
Add elements on mark 1 to contactsurf ""test"".
*addshellstocontactsurf(""test"", 1, 0)
",,
19,*adjustcontactsurfacenormal,"Description
Adjusts a contact surface normal using an orientation element.
","Inputs

name
The name of the contact surface entity to adjust.
mark_id1
The ID of the mark of elements to adjust, when flag is 1. Valid values are 1 and 2.
elem_flag
Flag for reversing the contact normal of all or individual elements of the contact
            surface.
0 - All elements, mark_id is ignored
1 - Individual elements, mark_id is used.
orientation_element
The ID of the shell element that should be used for shell contact surface normal
            correction on shell face. This element should be part of the selection.
reverse_normal
0 - Correct contact normal along the direction of
              orientation_element normal (default)
1 - Correct contact normal opposite to the direction of
              orientation_element normal

","Examples
To adjust the normal of contactsurf ""test"" for the elements on mark 1 in the normal
        direction of reference element id 23:
*createmark elems 1 12 29 53 23
*adjustcontactsurfacenormal ""test"" 1 1 23 0
To adjust the normal of contactsurf ""test"" for the elements on mark 1 in the reverse normal
        direction of reference element id
        23:*createmark elems 1 12 29 53 23
*adjustcontactsurfacenormal ""test"" 1 1 23 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
20,*adjustmass,"Description
Adjust mass for a selection of components for LS-DYNA.
","
Inputs



entity_type

Must be set to comps.

target_mass

The target mass.

target_cogx

The target COG x location.

target_cogy

The target COG y location.

target_cogz

The target COG z location.

","Examples
To adjust mass for component 100 to 200 with COG at (1000,1000,1000):
*createmark comps 1 200
*adjustmass comps 1 200 1000 1000 1000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
21,*admasconnectivityupdatemultentselectwithvisnod,"Description
Updates mass elements. A visualization node is used when updating and the number of
        selected entities are greater than one. This is because a set is automatically created from
        those entities and attached to the mass element.
","Inputs

mass_elem_id
The ID of the mass element to update.
entity_type
The type of entity containing the nodes which the mass element will be updated with.
            Valid entity types are comps, mats, blocks, assems, props, sets and nodes.
mark_id
The ID of the mark containing the entity_type entities. Valid values are 1 and 2.
additional_node_mark_id
The ID of the mark containing any additional nodes. Valid values are 1 and 2.

For now this option is ignored.
vis_node_id
The ID of the visualization node.

","Examples
To update mass element with ID 100, using components 1-3 and visualization node 50:
*createmark comps 1 1-3
*admasconnectivityupdatemultentselectwithvisnod 100 comps 1 0 50
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
22,*AE_AttachmentAbsorb,"Description
Absorb FE into attachments.
","
Inputs


entity_type
The entity type to absorb.  Valid values are nodes and elements.
integer_array
The ID of the integer array created using *createarray, which
            contains the IDs of the entities to absorb.  Must be set to 1.  If the array is empty,
            all rigidlink, RBE2 and RBE3 elements are considered.
number_of_integers
The number of integers in the array.  If 0, all elements are considered.
option
A flag to specify if the absorption logic should consider selected entities or all
            elements:
0- Consider specific
1 - Consider all rigidlink, RBE2 and RBE3 elements
config
The config for the attachment:
1 - Rigid spider
2 - Rigid patch

","Examples
Absorb an attachment from elements 116 and 227 (RBE2
        types):*createarray 2 116 227
*AE_AttachmentAbsorb elements 1 2 0 1
Absorb an attachment from all the rigidlink, RBE2 and RBE3
        elements:*AE_AttachmentAbsorb elements 1 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
23,*AE_AttachmentControlCreateFromAnother,"Description
Duplicate an attachment control.
","
Inputs


new_name
The name of the new attachment control to create.
old_name
The name of the existing attachment control to duplicate.
reserved
Reserved for future use.  Must be set to 1.

","Examples
To create an attachment control RigidSpider_2 from RigidSpider_1:
*AE_AttachmentControlCreateFromAnother RigidSpider_2 RigidSpider_1 1 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
24,*AE_AttachmentControlDefaultCreate,"Description
Initializes the attachment control defaults.  Must be called before any attachment controls
        can be used or saved.
","
Inputs


reserved1
Reserved for future use, must be set to """".
reserved2
Reserved for future use, must be set to 1.

","Examples
Create an attachment control named ""myattachmentcontrol"", derived from the rigid spider
        default:
*AE_AttachmentControlDefaultCreate """" 1
*AE_AttachmentControlCreateFromDefault ""myattachmentcontrol"" ""rigidspider"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
25,*AE_ConvertBoltLinkToAttachment,"Description
Converts connector bolt comp/part links to attachment links.  New attachments are created
        as needed.
","
Inputs


mark_id
The ID of the mark of connectors to convert.  Valid values are 1 and 2.

","Examples
Convert all bolt connectors to bolt connectors with attachments as links:
*createmark connectors 1 all
*AE_ConvertBoltLinkToAttachment 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
26,*AE_Unrealize,"Description
Unrealize attachments
","
Inputs


mark_id
The ID of the mark of attachments to unrealize.  Vaild values are 1 and 2.

","Examples
Unrealize all attachments in the model:
*createmark attachments 1 all
*AE_Unrealize 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
27,*alignnode,"Description
Aligns a node along the imaginary line between two other nodes.
","Inputs

end_node1
The ID of the first end node.
end_node2
The ID of the second end node.
node
The ID of the node to align.

","Examples
To align node 100 between nodes 200 and 300:
*alignnode 200 300 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
28,*alignnode3,"Description
Aligns multiple nodes along the imaginary line between two other nodes.
","Inputs

end_node1
The ID of the first end node.
end_node2
The ID of the second end node.
mark_id
The ID of the mark of nodes to align. Valid values are 1 and 2.

","Examples
To align nodes 100-110 between nodes 200 and 300:
*createmark nodes 1 100-110
*alignnode2 200 300 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
29,*allsuppressactive,"Description
This command takes an integer state indicating the active/inactive
        status for all supported entities.
","Inputs

state
Indicates to set all supported entities as:
0 - To active and to turn on their display. 
1 - To inactive and remove them from the display. 
2 - To active, but not to re-display them.



","Examples
To set all supported entities to active and re-display:
*allsuppressactive 0
To set all supported entities to inactive:
*allsuppressactive 1
To set all supported entities to active and not re-display:
*allsuppressactive 2
",
30,*alternatefejointcreate,"Description
Creates an FE joint element for use with the OptiStruct FE
        solution sequence.  The elements can correspond to JOINT, MBPTCV, MBCVCV, MBPTDCV or MBPTDSF
        cards.
For type 42, system1 and system2
        must be specified as 0.
For type 43, require system1 to be specified and system2 may be
        specified as zero, And FE joint type 44 requires both system1 and system2 should be
        specified.
","Inputs

type
The type of FE joint element.  Valid values are:
42 - Ball.  system1 and system2 must be
            specified as 0.
43 - Revolute.  system1 is mandatory, but
              system2 may be specified as 0.
44 - Universal.  system1 and system2 must be
            specified.
node1
The ID of the first FE joint node.
node2
The ID of the second FE joint node.
system1
The ID of the first FE joint system.
system2
The ID of the second FE joint system.

","Example
To create a ball FE joint connecting nodes 10 and 25:
*alternatefejointcreate 42 10 25 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
31,*alternatejointcreate,"Description
This command creates a joint element that corresponds to a JOINT, MBPTCV, MBCVCV, MBPTDCV
        or MBPTDSF card.
","Inputs

type
Joint element type. Supported values are:
8 - Ball
9 - Fixed
10 - Revolute
11 - Translational
12 - Cylindrical
13 - Universal
14 - Constant velocity
15 - Planar
16 - Inline
17 - Perpendicular
18 - Parallel axes
19 - Inplane
20 - Orient
21 - Point to Curve
22 - Curve to Curve
23 - Point to Deformable Curve
24 - Point to Deformable Surface


node1
The ID of the first node of the joint element.
node2
The ID of the second node of the joint element.
orient1_node
The ID of the first orientation node of the joint element.
orient2_node
The ID of the second orientation node of the joint element.
orient1_x
x coordinate defining the first orientation vector.
orient1_y
y coordinate defining the first orientation vector. 
orient1_z
z coordinate defining the first orientation vector. 
orient2_x
x coordinate defining the second orientation vector.
orient2_y
y coordinate defining the second orientation vector.
orient2_z
z coordinate defining the second orientation vector.
curve_set1
The ID of the first entity set used to define the MBD curve.
curve_set2
The ID of the second entity set used to define the MBD curve.

All joint elements, except those with type 23 or type 24, require both
          node1 and node2 to be valid, non-zero IDs. For
        joints that are either of those two types, node2 may be specified as
        zero. In addition, for those types, this command will always set node2 to
        be equal to node1.
","Examples
To create a fixed joint connecting nodes 10 and 25:
*alternatejointcreate 9 10 25 0 0 0 0 0 0 0 0 0 0 
The following command creates an inline joint connecting nodes 20 and 100, using node 50 as
        the first orientation node:
*alternatejointcreate 16 20 100 50 0 0 0 0 0 0 0 0 0
To create a point to curve joint element connecting nodes 15 and 16, using a MBD curve
        defined by an entity set of ID 4:
*alternatejointcreate 21 15 16 0 0 0 0 0 0 0 0 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
32,*altgapelement,"Description
Creates a node-to-node gap element (CGAP) for use with the OptiStruct solver.
","Inputs

node1
The ID of the first node of the gap element.
node2
The ID of the second node of the gap element.
propertyname
The name of the property which should be assigned to the gap element.
vectorid
The ID of the orientation vector associated with the gap element.
nodeid
The ID of the orientation node associated with the gap element.
orient_x
X component of the orientation vector.
orient_y
Y component of the orientation vector.
orient_z
Z component of the orientation vector.
comps_flag
Flag to indicate whether individual components are used in defining the orientation of
            the element.
0 - Components are not used.
1 - Components are used.
systemid
Coordinate system ID used to orient the gap element.
Orientation of the gap element may be specified using either a vector, node,
            coordinate system or individual components.

","Examples
To create a gap element between node 10 and node 25 with property gapprop, using node 51 as
        orientation node:
*altgapelement(10,25,""gapprop"",0,51,0,0,0,0,0)
",
33,*ameshclearsurface,"Description
Frees memory temporarily allocated for the automesher.
",,,
34,*analysiscurvecreatecomplex,"Description
Creates a curve pair by extracting complex values from a results file. The results file
        must be loaded before executing this command. The curves must be part of an extended (dual)
        plot and the y-values are assumed to be complex, either real/imaginary or
        phase/magnitude.
","Inputs

entity_type
The type of entities on the mark.
mark_id
The ID of the mark that contains the entities. Valid values are 1 and 2.
x_data_type
The name of the x data type from which to extract data.
y_data_type
The name of the y data type from which to extract data.
x_component
The name of the x component to be extracted from the file if the x data type is
            displacement. Valid values are:
complex
x comp/complex
y comp/complex
z comp/complex


y_component
The name of the y component to be extracted from the file if the y data type is
            displacement. Valid values are:
complex
x comp/complex
y comp/complex
z comp/complex.



","Examples
To create a complex curve from the displacement results for node 12:
*analysisfileset C:/my_results/test.res
*createmark nodes 1 12
*analysiscurvecreatecomplex nodes 1 ""displacements"" ""simulationid"" ""complex"" """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
35,*analysisfilesetwithsolverids,"Description
Loads a results file for use in subsequent operations. All IDs are assumed to be solver IDs
        for the current template.
","Inputs

filename
The full path and name of the results file.

","Examples
To load the result file named C:/my_results/test.res:
*analysisfilesetwithsolverids C:/my_results/test.res
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
36,*animatelegendsetrange,"Description
Sets the animation legend range for transient animation sequences.
","Inputs

mindef
Flag to use minimum value passed in.
Type: integer
minimum
Minimum value used by legend.
Type: double
maxdef
Flag to use maximum value passed in.
Type: integer
maximum
Maximum value used by legend.
Type: double

","Examples
*animatelegendsetrange(1 , 0.001, 1, 100.00)
",
37,*animatemodal,"Description
Creates a modal animation from results data. The results file must be loaded before
        executing this command. The *freesimulation command clears the
        animation.
","Inputs

title
The title to use for the animation.
max_deflection
The maximum deflection in model units, or the scale factor, to which the maximum
            analysis result should be scaled. Use a negative value for model units and a positive
            value for scale factor.
frames
The number of frames to use during the animation sequence. The maximum value is
            machine dependent.
display_mode
The type of display to generate. Valid values are:
0 - Mesh wireframe only.
1 - Rendered with mesh lines.
2 - Feature lines only.
3 - Rendered with feature lines.
4 - Rendered only.


output_type
This argument is no longer supported and is ignored.

","Examples
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements data type, using a 10.0 model unit
        scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*animatecycles 10
*animatemodal """" 10.0 4 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
38,*answer,"Description
Provides an answer to the previous command for .cmf files.
","Inputs

answer
Valid values:
yes - Yes
no - No
all - Yes to all
nall - No to all

","Examples
To answer yes to deleting the current model, which has not been saved:
*deletemodel()
*answer(yes)
",
39,*appendmarksolverdata,"Description
Appends a mark with entities of the given type that match a defined pattern of identifying
        information.
","Inputs

EntityType
The type of entities to add to the mark. See details below for different entities
            supported.
SolverNumber
A unique number for each solver that HyperMesh interfaces with:
70 - ACTRAN 
2 - Abaqus

8 - ANSYS
4 - Autodv 
10 - Deform 
1 - Dytran 
9 - LS-DYNA3D 
11 - HFSolver 
19 - HyperXtrude
17 - Ideas 
1 - OptiStruct
22 - MADYMO3D 
3 - Marc 
8 - ANSYS
16 - Moldflow 
1 - Nastran
6 - PAM-CRASH
18 -  PAM-CRASH
21 - Permas 
20 - Radioss


markID
The mark ID to which the entities found by this command will be appended.
Valid values are 1 and 2.
Arg1, Arg2, … 
Various arguments that vary based on entity type.

For each entity, the attribute # in the solver template and its value need to be defined in
        pair. Refer to the Templates section of the Reference Guide to learn more about
        attributes and their values.
Table 1. Arg Table

Entity Type
arg1
arg2
arg3
arg4
arg5
arg6




NODES
unused
attrib1
value1
...
 
 


ELEMS
config
type
attrib1
value1
...
 


COMPS
Card Image/ Template Tag
attrib1
value1
...
 
 


LINES
unused
attrib1
value1
...
 
 


SURFS
unused
attrib1
value1
...
 
 


LOADS
config
type
entitytype
attrib1
value1
...


SYSTS
unused
0-any definitioncode1-coordinate based
2-node based
(see
                    below)

0-any type1-rectangular
2-cylinder
3-spherical

attrib1
value1
...


LOADCOLS
Card Image/ Template Tag
loadstepid
attrib1
value1
...
 


SYSTCOLS
Card Image/ Template Tag
attrib1
value1
...
 
 


SETS
Card Image/ Template Tag
entitytype1000-justrlink nodesets
1001-omit rlink
                  nodesets

0-any set1-unordered
2- ordered
3-formula

attrib1
value1
...


PROPS
Card Image/ Template Tag
attrib1
3-formulavalue1

...
 
 


Groups
config
type
ttag
loadstepid
attrib1
value1


Groups - rwalls
config=5
type
ttag
loadstepid
geometrytype
motiontype(see below)



Plots
unused
attrib1
value1
...
 
 


Curves
unused
attrib1
value1
...
 
 


Blocks
Card Image/ Template Tag
attrib1
value1
...
 
 


Mats
Card Image/ Template Tag
attrib1
value1
...
 
 


Assems
unused
attrib1
value1
...
 
 


Titles
unused
attrib1
value1
...
 
 


Vectorcols
Card Image/ Template Tag
attrib1
value1
...
 
 


Vectors
unused
attrib1
value1
...
 
 


Equations
unused
config
attrib1
value1
...
 


Cards
Card Image/ Template Tag
attrib1
value1
...
 
 


Outputblocks
unused
loadstepid
entitytype
attrib1
value1
...


Outputblocks (elems)
unused
loadstepid
2
class (see note)
attrib1
value1


Loadsteps
unused
attrib1
value1
...
 
 


HM_points
unused
attrib1
value1
...
 
 


HM_splines
unused
attrib1
value1
...
 
 


Sensors
unused
attrib1
value1
...
 
 


Designvars
config
attrib1
value1
...
 
 


Beamsectcols
Card Image/ Template Tag
attrib1
value1
...
 
 


Beamsects
unused
attrib1
value1
...
 
 


Optitableentrs
unused
attrib1
value1
...
 
 


Optifunctions
unused
attrib1
value1
...
 
 


Optiresponses
unused
attrib1
value1
...
 
 


Dvprels
unused
attrib1
value1
...
 
 


Opticonstraints
unused
attrib1
value1
...
 
 


Desvarlinks
unused
attrib1
value1
...
 
 


Objectives
unused
attrib1
value1
...
 
 


Controlvols
Card Image/ Template Tag
attrib1
value1
...
 
 


Multibodies
Card Image/ Template Tag
attrib1
value1
...
 
 


Ellipsoids
unused
attrib1
value1
...
 
 


Opticontrols
unused
attrib1
value1
...
 
 


Optidscreens
unused
attrib1
value1
...
 
 


HM_tag
unused
attrib1
value1
...
 
 


Mbjoint
unused
attrib1
value1
...
 
 


Mbplane
unused
attrib1
value1
...
 
 


Dobjrefs
unused
attrib1
value1
...
 
 


Contactsurfs
Card Image/ Template Tag
attrib1
value1
...
 
 


Connectors
unused
attrib1
value1
...
 
 


Shapes
unused
attrib1
value1
...
 
 


Handles
unused
attrib1
value1
...
 
 


Domains
unused
attrib1
value1
...
 
 


Symmetrys
unused
attrib1
value1
...
 
 


Solids
unused
attrib1
value1
...
 
 


Morphconstraints
unused
attrib1
value1
...
 
 


Hypercubes
unused
attrib1
value1
...
 
 


Ddvals
unused
attrib1
value1
...
 
 





","Examples
To add all the properties that use the Nastran PBUSH
        card:*createmark props 1
*appendmarksolverdata(props, 1, 1, 857,  All)
Here the Property entities (""props"") that use Nastran (solver
        ""1"") attribute ID 857 (from the ARG. Table) set to any value, are added to the mark.
To add all the LS-DYNASingle_surface_contacts
        to the
        mark:*createmark props 1
*appendmarksolverdata(groups, 9, 1, 3, 1, 2389, 0, 97, 1, 4733, 0)
For example, you can use this command to create a mark containing all the components in the
        model that use the LS-DYNA *PART_INTERTIA card image.
",
40,*applyresults,"Description
Provides a yes/no/yes to all answer to the previous command. This is only useful for
        command files.
","Inputs

entity_type
The entity type to apply the results to. Valid values are nodes, elems and comps.
mark_id
The ID of the mark containing the entities to apply the results to. Valid values are 1 and 2.
scale
The scale factor to use for the displacements.
component
The string that identifies the component to use for the displacements. Valid values
            are:
total disp
x comp
y comp
z comp

","Examples
To apply displacement results from Subcase 1 in the .res file
          model.res using component total disp to all displayed nodes:
*analysisfileset ""model.res""
*inputsimulation ""Subcase 1"" ""displacements""
*createmark nodes 1 displayed
*applyresults nodes 1 1.0 ""total disp""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
41,*assemblyaddmark,"Inputs

assemblyptr
The assembly ID.
If assemblyptr has an ID of zero, then the mark of entities is
            removed from any assembly and placed at the top level. 
entity type
The type of entity contained on the mark. It is limited to assemblies, components, and
            multibodies.
mark
The ID of the mark to be added to the assembly.

","Examples
To add component 14 to assembly 2:
*createmark comps 1 14
*assemblyaddmark 2 comps 1
",,
42,*assemblymodifyhierarchy,"Description
Adds an assembly.
","Inputs

assemblyname
The name of the assembly. 
mark
The ID of the mark containing the components and assemblies that should be in the
            assembly. 
color
The index number of the color in the HyperMesh
            palette.

Assemblies can now contain other assemblies, not only components.
",,
43,*assignedplot,"Description
Creates an assigned plot from results data. The results file must be loaded before
        executing this command. The *freesimulation command clears the plot.
","Inputs

title
The title to use for the plot.
legend_min
Indicates if the minimum value found in the file should be used as the minimum value
            on the legend (0), or if the legend_min_value argument should be used
            instead (1).
legend_min_value
The minimum value to display on the legend. This is only used if
              legend_min is set to 1.
legend_max
Indicates if the maximum value found in the file should be used as the maximum value
            on the legend (0), or if the legend_max_value argument should be used
            instead (1).
legend_max_value
The maximum value to display on the legend. This is only used if
              legend_max is set to 1.
mesh_color
The color used to plot the mesh. Valid values are 1 through 64. A value of -1 uses the
            elements color. A value of 0 uses the background color.
scale_factor
The scale factor used for scaling a deformed plot.
full_size
Determines whether the assigned plot fills the entire screen. Valid values are: 
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return.
reserved
Reserved for future use. Must be set to 0.
vector_comp
Indicates the vector data type component to use. Valid values are:
x comp
y comp
z comp
magnitude
mult
The value used to multiply the results values.
min_max_titles
Indicates if the min/max titles should be displayed. Valid values are: 
0 - Do not display min/max titles. 
1 - Display min/max titles.
plot_info_title
Indicates if the plot information title should be displayed. Valid values are: 
0 - Do not display plot information title. 
1 - Display plot information titles.

","Examples
To load the result file named C:/my_results/test.res and generate an
        assigned plot for Subcase 1 with Displacements data type, using the maximum and minimum
        values defined in the analysis file, a mesh color of black, and normal plot size:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*assignedplot """" 0 0.0 0 0.0 0 0.0 0 0 ""magnitude"" 1.0 0 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
44,*assignsystem_fromcurves,"Description
Assigns a system to an entity type based on lines. The axis of the system is then projected
        on the element/property plane. It also re-orients and visualizes the element (material)
        coordinate system for selected entities. When review is complete, the command
          *vectorsoff must be run. This command is currently supported for
          Abaqus, Nastran and OptiStructsolvers.
","Inputs

entity_type
The type of entity to update. Only elements and properties are supported.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
geom_entity_type
The type of entity from which the system will be referenced. Only nodes and lines are
            supported.
geom_mark_id
The ID of the mark containing the geometry entities. Valid values are 1 and 2.
size
If only_orient is 1, this defines the size of the displayed
            vectors. If 0, size will be determined automatically.
color
The color of the vectors or lines. Valid values are 1 through 64.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid
rebar
This is valid only for Abaqus user profile.
table_id
The ID of the distribution table. For Abaqus, the
            distribution table with this table ID will be updated accordingly. For Nastran and OptiStruct, the only valid
            value is 0 and a distribution table is created and updated internally.
reverse_flag
0 - The line’s direction will not be flipped.
1 - The line’s direction will be flipped.

","Examples
To project the axis of the line 210 on the element plane of all the elements, and display
        the projection as cyan vectors (color 7) with size = 3, without flipping the direction:
*createmark elements 1 all
*createmark lines 2 210
*assignsystem_fromcurves elements 1 lines 2 3 7 1 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
45,*assignsystemfromcurveswithnormals,"Description
Assigns a system to an entity type based on curves with surface normal. The axis of the
        system is then projected on the element/property plane. Reorients and visualizes the element
        (material) coordinate system for selected entities. When review is complete, the command
          *vectorsoff must be run. This command is currently supported for
          Abaqus, Nastran and OptiStruct.
<option>=<value> options can be provided in any order.
","
Inputs



entity_type

The type of entity to update. Only solid elements and solid properties are
            supported.

mark_id

The ID of the mark containing the entity_type entities.  Valid
            values are 1 and 2.

geom_entity_type

The type of entity from which the system will be referenced.  Valid values are lines
            and nodes.

geom_mark_id

The ID of the mark containing the geom_entity_type entities.  Valid
            values are 1 and 2.

color=<value>

The color of the vectors or lines. Valid values are 1-64.

flipnormal=<value>

0 - The line’s direction will not be flipped
1 - The line’s direction will be flipped

normalentityid=<value>

The ID of the entity considered for normal calculations.

normalentitytype=<value>

The type of entity considered for normal calculations. Only surfaces are
            supported.

onlyorient=<value>

0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges.
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.

rebar=<value>

The rebar value for Abaqus.

size=<value>

If set to 0, the size will be determined automatically. Otherwise, this defines the
            size of the displayed vectors.

tableid=<value>

The ID of the distribution table. For Abaqus, the
            distribution table with this ID will be updated accordingly. For Nastran and OptiStruct, the valid value
            will be 0, i.e. a distribution table will be created internally which will be
            updated.

","Examples
To project the axis of the line 100 on the element plane of all the elements and display
        the projection as color 7 with size 3, without flipping the direction, and with surface
        normal from surface 1:
*createmark elements 1 all
*createmark lines 2 100
*assignsystemfromcurveswithnormals elements 1 lines 2 size=3 color= 7 onlyorient=1 rebar=0 tableid=0 flipnormal=0 normalentitytype=SURFS normalsentityid=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
46,*attributeupdate_entityidarray2d_mark,"Description
Updates an attribute, which is a 2D array of entity IDs, on a set of entities. 
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs resides.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
target entity
The type of entity to which the attribute refers. 
data
The 2D array of IDs.
rows
The number of rows in the array.
cols
The number of columns in the array.

","Example
In order to store the 2x2 table shown below in an attribute for loadcols 1 - 7: 
1 2
8 9


Do the
        following:*createmark(loadcols,1) 1 2 3 4 5 6 7
*createarray(4) 1 2 8 9
*attributeupdate_entityidarray2d(loadcols, 1, 1234, 1, 2, 0, materials, 2, 2)
",
47,*attributeupdatedoublearray,"Description
Updates an attribute of type double array.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
data
Double array.
length
Double array length.

","Example
Update attribute 615 of type double array to [1,2,3,4] on the material
        with ID
        7:*createdoublearray 4 1 2 3 4
*attributeupdatedoublearray materials 7 615 2 2 0 1 4
",
48,*attributeupdatedoublearray2delementmark,"Description
Updates one element of an attribute of type 2D double array.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs reside.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute. 
row
The row number the value to be changed resides in (first row is zero).
col
The column number the value to be changed resides in (first column is zero).
value
The new value of the 2D array element. 

","Example
To update the item in a 2D array attribute to 5 (specifically row 3, column 2). The
        attributes are found on materials with IDs of 7 and 8. Do the
        following:*createmark(materials, 1) 7 8
*attributeupdatedoublearray2delementmark(materials, 1, 1234, 1, 2, 0, 2, 1, 5)
",
49,*attributeupdatedoublearrayelementmark,"Description
Updates one element of an attribute of type double array.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
index
Index into the array (first index is zero).
value
The value of the array element.

","Example
Update the first element (index 0) of some double array attributes to 10.5.The attributes
        are found on materials with IDs 7 and
        8.*createmark(materials,1) 7 8
*attributeupdatedoublearrayelementmark(materials,1,615,2,2,0 ,0,10.5)
",
50,*attributeupdatedoublemark,"Description
Updates an attribute of type double on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
value
The value of the attribute.

","Example
Update an attribute of type double to 100.0 on the materials with IDs of 7 and
        8.*createmark(materials,1) 7 8
*attributeupdatedoublemark(materials,1,615,2,2,0,1,1)
",
51,*attributeupdateentityidarray,"Description
Updates an attribute that is an array of entity IDs.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity that owns the attribute.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
targetentity
The type of entity to which the attribute refers.
data
An array of IDs to entities.
length
The length of the data array.

","Example
*createarray(4) 0 0 0 0
*attributeupdateentityidarray(loadcols, 1, 6436, 1, 2, 0, materials, 1, 4)
",
52,*attributeupdateentityidarrayelementmark,"Description
Updates one element of an attribute of type 2D entity ID array.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs resides. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
target entity
The type of entity to which the attribute refers. 
index
Index into the array (first index is zero).
value
The new value of the 2D array element. 

","Examples
Assuming you want to update an element in an entity ID array attribute to point to a
        loadcol with an ID of 5. The attributes are found on materials with ID's of 7 and 8, do the
        following:
*createmark(materials, 1) 7 8
*attributeupdateentityidarrayelementmark(materials, 1, 1234, 1, 2, 0, loadcols, 0, 5)
",
53,*attributeupdateentitymark,"Description
Updates an attribute of type entity on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
targetentity
The type of entity to which the attribute points. 
targetentityid
The ID of the entity to which the attribute points.

","Examples
Update an attribute of type entity (on elements 17 and 18) to point to a
        node with ID
        1.*createmark(elements,1) 17 18
*attributeupdateentitymark(elements,1,1247,6,0,0,nodes,1)
",
54,*attributeupdateintarray,"Description
Updates an attribute of type int array.
","Inputs

entity type
The type of entity that owns the attribute.
id
The entity ID.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The int array.
length
The int array length.

","Examples
Update an attribute of type int array to [1, 2, 3, and 4] on the material with ID 7.
        *createintarray(4) 1 2 3 4 *attributeupdateintarray(materials,7,615,2,2,0,1,1) 
",
55,*attributeupdateintarray2delementmark,"Description
Updates one element of an attribute of type integer array. 
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs resides. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
row
The row number the value to be changed resides in (first row is zero).
col
The column number the value to be changed resides in (first column is zero). 
value
The new value of the 2D array element. 

","Examples
Assuming you want to update an element in a 2D array attribute to 5 (specifically located
        at row 3, column 2). The attributes are found on materials with IDs of 7 and 8, you would do
        the
        following:*createmark(materials, 1) 7 8
*attributeupdateintarray2delementmark(materials, 1, 1234, 1, 2, 0, 2, 1, 5)
",
56,*attributeupdateintarrayelementmark,"Description
Updates one element of an attribute of type int array. 
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
index
Index into the array, starting at zero.
value
The integer value to be placed into the array.

","Examples
*attributeupdateintarrayelementmark(loadcols, 1, 5000, 1, 2, 0, 0, 4)
",
57,*attributeupdateintmark,"Description
Updates an attribute of type int on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
value
The value of the attribute.

","Examples
Update an attribute of type int array to 123 on the materials with IDs 7 and
        8.*createmark(materials,1) 7 8
*attributeupdateintmark(materials,1,615,2,2,0,1,123)
",
58,*attributeupdatestring,"Description
Updates an attribute of type string.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
value
The value of the attribute.

","Examples
Update an attribute of type string to a value of composite on an element with ID,
        100.*attributeupdatestring(elements,100,1241,6,2,0,""composite"")
",
59,*attributeupdatestringarrayelementmark,"Description
Updates one element of an attribute of type string array.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
index
Index into the array (first index is zero).
value
The value of the array element.

","Examples
Update the first element (index 0) of some string array attributes to steel. The attributes
        are found on materials with IDs 7 and
        8.*createmark(materials,1) 7 8
*attributeupdatestringarrayelementmark(materials,1,615,2,2,0,0,""steel"")
",
60,*attributeupdatestringmark,"Description
Updates an attribute of type string on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
value
The value of the attribute.

","Examples
Update an attribute of type string to steel on the materials with ID 7 and
        8.*createmark(materials,1) 7 8
*attributeupdatestringmark(materials,1,615,2,2,0,""steel"")
",
61,*automesh,"Description
Employs a surface-based automeshing algorithm to generate a mesh on a given surface
        face.
","Inputs

face_index
The index of the surface face to mesh.
algorithm
Determines the surface-based mesh generation algorithm to use to create elements for
            the given face. Valid values are: 
1 - Auto decide 
2 - Map as rectangle 
3 - Map as triangle 
4 - Map as pentagon 
5 - Advancing front 
6 - Map as circle


elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values
            are: 
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only



","Examples
To automesh face 0 with mixed elements using advancing
        front:*automesh 0 5 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
62,*automesh_params,"Description
Set 2D meshing parameters on edges and faces.  This must be called before 2D meshing
        commands. After executing the 2D  meshing commands, the parameters defined in this command
        are restored to their default values.
","
Inputs



mapmethod=<value>

Defines the method to map nodes between opposite edges of rectangular shaped
            surfaces:
0 - Auto decide (default)
1 – Force map to use parametric lengths. Generally useful when the number and biasing
            of nodes on opposite edges are similar in order to make more regular mesh flow
            lines.
2 – Force map to use arc lengths. Generally useful for constant size meshing with
            unaligned density and biasing on opposite edges to make more regularly shaped
            elements.

mindensity=<value>

Assign a minimum density on edges. This will ensure a minimum number of nodes even for
            small edges.

mindensitycurvratio=<value>

The ratio of the curved edge length to the length of a straight segment between edge
            ends, where mindensity will be applied. 

mindensityclength=<value>

The threshold for edge length to split only small edges, where
              mindensity will be applied. 

smoothedges=<value>

Defines the smoothing method to be used in the meshing command. Useful prior to
            calling automatic meshing. Valid values are:
0 - None
1 - Auto-decide (default)
2 - Size corrected
3 - Shape corrected
4 - Angle corrected

","Examples
To set several 2D meshing options:
*automesh_params mindensity=2 mindensitylength=0.2 mindensitycurvratio=1.1 mapmethod=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
63,*autoupdate1delems,"Description
This command updates the orientation and offset of 1D elements using the normal and
        thickness of neighboring shells. These shells are identified by the command itself. It works
        only with bar/beam elements.
Options can be provided in any order.
","
Inputs



mark=<mark_id>

The ID of the mark containing the input elements. Valid values are 1 and 2.

adjustoffset=<value>

Flag to adjust offset in vertical (normal) and/or lateral direction. Valid values
            are:
vert - Adjusts vertical offset
lat - Adjusts lateral offset
all - Adjusts both offsets

allshells=<value>

Flag to consider all or displayed neighbouring shells. Valid values are:
0 - Only displayed shells
1 - All shells

angletol=<value>

The angular tolerance in degrees, used for orientation to check whether shell normal
            is within limit.

offsetends=<value>

The flag to offset at both ends of the elements or any one. Valid values are:
start - Offset at start/end a
end - Offset at end/end b
startend - Offset at both ends

offsetlateral=<value>

The offset flag in lateral direction. Valid values are:
neg - Negative
pos - Positive

offsetnormal=<value>

The offset flag in normal direction. Valid values are:
neg - Negative
pos - Positive

orient=<value>

Flag to orient the elements. Valid values are:
0 - False
1 - True

rotate=<angle>

The rotation angle in degrees, for orientation. Elements are rotated along their
            respective X-axis.



thickness=<value>

The mode of thickness to be considered for shell thickness, in case of multiple
            neighboring shells having different thickness values. Valid values are:
avg - Averaged thickness
max - Maximum thickness
min - Minimum thickness

","Examples
Update orientation of selected 1D elements by 180 degrees to shell normal:
*createmark elements 1 1 2 3 4
*autoupdate1delems mark=1 orient=1 rotate=180 allshells=0
Update offset of selected 1D elements at both ends in negative direction of base and
        positive direction of adjacent with respect to neighboring shells (considering its average
        thickness):
*createmark elements 1 1 2 3 4
*autoupdate1delems mark=1 orient=0 allshells=0 thickness=avg offsetnormal=neg offsetlateral=pos adjustoffset=all offsetends=startend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
64,*bar3element,"Description
Creates a bar3 element.
","Inputs

node1
The first node ID (end a).
node2
The second node ID.
node3
The third node ID (end b).
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This argument is only used if
              orientation_node is 0.
orientation_node
The orientation node ID. If set to 0, then vector_id is used. If
            non-zero, then y_dir specifies whether this node defines the local y-
            or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
property_name
The name of the property collector assigned to the bar.

","Examples
To create a bar3 element between nodes 101, 102 and 103 with its local y-axis defined by
        the vector (1, 0, and 0) and assigned property
        prop1:*createvector 1 1.0000 0.0000 0.0000
*bar3element 101 102 103 1 0 0 0 0 ""prop1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
65,*bardirectionupdate,"Description
Updates the direction node for multiple bar and/or bar3 elements.
","Inputs

mark_id
The ID of the mark containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
orientation_node
The orientation node ID. y_dir specifies whether this node defines
            the local y- or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.

","Examples
To update bar element 17 with orientation node 5 as the
        y-axis:*createmark elements 1 17
*bardirectionupdate 1 5 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
66,*barelementcreatewithoffsets,"Description
Creates a bar element with offsets.
","Inputs

node1
The first node ID (end a).
node2
The second node ID (end b).
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This argument is only used if
              orientation_node is 0.
orientation_node
The orientation node ID. If set to 0, then vector_id is used. If
            non-zero, then y_dir specifies whether this node defines the local y-
            or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
property_name
The name of the property collector assigned to the bar.
offset_system_a
The system used to define the offsets at end a. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_a
The offset in the x-direction at end a.
offset_y_a
The offset in the y-direction at end a.
offset_z_a
The offset in the z-direction at end a.
offset_system_b
The system used to define the offsets at end b. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_b
The offset in the x-direction at end b.
offset_y_b
The offset in the y-direction at end b.
offset_z_b
The offset in the z-direction at end b.

","Examples
To create a bar3 element between nodes 101, 102 and 103 with its local y-axis defined by
        the vector (1, 0, and 0) and assigned property prop1. The element has an offset vector at
        end a defined using the global system (0.2, 0.2, and 0.2) and offset vector at end b defined
        using the global system (0.3, 0.3, and
        0.3):*createvector 1 1.0000 0.0000 0.0000
*bar3elementcreatewithoffsets 101 102 103 1 0 0 0 0 ""prop1"" 0 0.2 0.2 0.2 0 0.3 0.3 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
67,*barelementrotatebyangle,"Description
Rotate bar elements along their respective X-axis using an input angle.
","
Inputs



mark_id

The ID of the mark containing the elements to rotate. Valid values are 1 and 2.

angle

The angle to rotate, in degrees.

","Examples
To rotate elements 1-4 by 60 degrees:
*createmark elements 1 1-4
*barelementrotatebyangle 1 60
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
68,*barelementupdatebytable,"Description
This command updates the bar element data names using the data provided in the input table.
        This command is similar to *barelementupdatewithoffsets but differs only
        in its approach to update the elements, whereby each element in the table can be updated
        with a unique value of the data name in one operation whereas the latter  updates a specific
        value to all elements.
<option>=<value> options can be provided in any order.
","
Inputs



table_name

The name of the table to use as input.  This option is mandatory.

id=<id>

The table column that contains the element IDs. This is a mandatory input.
property=<property>
The table column that contains the properties ID. This is optional input. If provided,
            it will assign the properties in this column to respective elements in ID column. The
            column type should be unsignedint.
node=<node>
The table column that contains the node IDs. This is optional input. If provided, it
            will assign the nodes in this column, as orientation node, to respective elements in ID
            column. ydir specifies whether this node defines the local y-axis or
            local z-axis. The column type should be unsignedint.
ydir=<ydir>
The table column that contains the ydir flags. This is optional input. If set to 1,
            then orientation node defines the local y-axis of the bar. Otherwise, orientation node
            defines the local z-axis. The column type should be unsignedint.
vector=<vector>
The table column that contains the vectors. This is optional input. If provided, it
            will update the orientation direction of the respective elements in the ID column. The
            column type should be triple.
vector_option=<vector_option>
The table column that contains the vector options. This is optional input. If
            provided, it will be used for vector calculation. The column type should be
            unsignedint.
0 - Vector is defined by using global coordinate system. 
1 - Vector is defined by using local coordinate system. 
2 - Vector will be calculated by aligning element y-axis parallel to global XY
            plane.
3 - Vector will be calculated by aligning element y-axis parallel to global YZ
            plane.
4 - Vector will be calculated by aligning element y-axis parallel to global ZX plane 
5 - Vector will be calculated by aligning element z-axis parallel to global XY
            plane.
6 - Vector will be calculated by aligning element z-axis parallel to global YZ plane. 
7 - Vector will be calculated by aligning element z-axis parallel to global ZX
            plane.
offset_system_a=<offset_system_a>
The table column that contains the offset systems for end a. This is optional input.
            If provided, it will use the respective system to define the offsets at end a. The
            column type should be unsignedint.
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node 1.
2 - Offsets given in elemental coordinate system.
offseta=<offseta>
The table column that contains the offsets for end a. This is optional input. If
            provided, it will update offset in the x-direction at end a of the respective elements
            in the ID column. The column type should be triple.
offset_system_b=<offset_system_b>
The table column that contains the offset systems for end b. This is optional input.
            If provided, it will use the respective system to define the offsets at end b. The
            column type should be unsignedint.
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node 1.
2 - Offsets given in elemental coordinate system.
offsetb=<offsetb>
The table column that contains the offsets for end b. This is optional input. If
            provided, it will update offset in the x-direction at end b of the respective elements
            in the ID column. The column type should be triple.
pina=<pina>
The table column that contains the pin flags for end a. This is optional input. If
            provided, it will update the pin flags at end a of the respective elements in the ID
            column. A pin flag of 0 passes forces in all degrees of freedom. The column type should
            be int.
pinb=<pinb>
The table column that contains the pin flags for end b. This is optional input. If
            provided, it will update the pin flags at end b of the respective elements in the ID
            column. A pin flag of 0 passes forces in all degrees of freedom. The column type should
            be int.

","Examples
Update the direction of the 1D elements listed in the table with ID and vector columns
        specified:
*tablecreate ""Elems1DReOrient"" 1 1 1 0 0
*createstringarray 3 ""1441"" ""1442"" ""1443""
*tableaddcolumn ""Elems1DReOrient"" ""elements"" ""ElemID"" 1 3
*createstringarray 9 ""-0.000000"" ""1.000000"" ""0.000000"" \
                     ""-0.000000"" ""1.000000"" ""0.000000"" \
                     ""-0.000000"" ""1.000000"" ""0.000000""
*tableaddcolumn ""Elems1DReOrient"" ""triple"" ""Direction"" 1 9
*barelementupdatebytable Elems1DReOrient id=ElemID vector=Direction
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
69,*barelementupdatewithoffsets,"Description
Updates the vector, pin flags, property, direction node and offset for multiple bar and/or
        bar3 elements.
","Inputs

mark_id
The ID of the mark containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
update_vector
If non-zero, vector_id is used to update the local y-axis.
vector_option
0 - Vector is defined by using global coordinate system. 
1 - Vector is defined by using local coordinate system. 
2 - Vector will be calculated by aligning element y-axis parallel to global XY
            plane.
3 - Vector will be calculated by aligning element y-xis parallel to global YZ
            plane.
4 - Vector will be calculated by aligning element y-axis parallel to global ZX plane 
5 - Vector will be calculated by aligning element z-axis parallel to global XY
            plane.
6 - Vector will be calculated by aligning element z-axis parallel to global YZ plane. 
7 - Vector will be calculated by aligning element z-axis parallel to global ZX
            plane.
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. 
update_pins
If non-zero, pin_flags_a and pin_flags_b are
            used to update the pin flags.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
update_property
If non-zero, property_name is used to update the property.
property_name
The name of the property collector assigned to the bar.
update_orientation
If non-zero, the direction node will be updated.
orientation_node
The orientation node ID. y_dir specifies whether this node defines
            the local y- or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.
update_offset_a
If non-zero, the offsets at end a are updated.
update_offset_b
If non-zero, the offsets at end b are updated.
offset_system_a
The system used to define the offsets at end a. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_a
The offset in the x-direction at end a.
offset_y_a
The offset in the y-direction at end a.
offset_z_a
The offset in the z-direction at end a.
offset_system_b
The system used to define the offsets at end b. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_b
The offset in the x-direction at end b.
offset_y_b
The offset in the y-direction at end b.
offset_z_b
The offset in the z-direction at end b.

","Examples
To update the elements on mark 1 with y-axis defined by vector (0.0, 1.0, and
        0.0):*createvector 1 0.0000 1.0000 0.0000
*barelementupdatewithoffsets 1 1 0 1 0 0 0 0 """" 0 0 0 0 0 0.0 0.0 0.0 0 0 0.0 0.0 0.0
To update the elements on mark with y-axis oriented in global XY
        plane:*barelementupdatewithoffsets 1 1 2 1 0 0 0 0 """" 0 0 0 0 0 0.0 0.0 0.0 0 0 0.0 0.0 0.0
To update the elements on mark 1 with orientation node 3 in
        y-direction:*barelementupdatewithoffsets 1 0 0 1 0 0 0 0 """" 1 3 1 0 0 0.0 0.0 0.0 0 0 0.0 0.0 0.0
To update the elements on mark 1 with offsets a defined in global system having offset
        vector (0.2, 0.2, and 0.2) and offsets b defined in global system having offset vector (0.3,
        0.3, and
        0.3):*barelementupdatewithoffsets 1 0 0 1 0 0 0 0 """" 0 0 0 1 0 0 0.2 0.2 0.2 1 0 0.3 0.3 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
70,*baroffsetupdate,"Description
Updates the offsets in the global system for multiple bar and/or bar3 elements.
","Inputs

mark_id
The ID of the mark containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
update_offset_a
If non-zero, the offsets at end a are updated.
update_offset_b
If non-zero, the offsets at end b are updated.
offset_x_a
The offset in the x-direction at end a. This is defined in the global system.
offset_y_a
The offset in the y-direction at end a. This is defined in the global system.
offset_z_a
The offset in the z-direction at end a. This is defined in the global system.
offset_x_b
The offset in the x-direction at end b. This is defined in the global system.
offset_y_b
The offset in the y-direction at end b. This is defined in the global system.
offset_z_b
The offset in the z-direction at end b. This is defined in the global system.

","Examples
To update bar element 23 with offset vector at end a defined as (1.0, 2.0, 3.0) and at end
        b as (4.0, 5.0,
        6.0):*createmark elements 1 23
*baroffsetupdate 1 1 1.0 2.0 3.0 1 4.0 5.0 6.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
71,*barpinsupdate,"Description
Updates pins of bar elements.
","
Inputs



mark_id

The ID of the mark containing the elements to update. Valid values are 1 and 2.

update_pinsa

0 - Do not update pinsa
1 - Update pinsa

pinsa

The pins at end a.  Maximum value is 123456.

update_pinsb

0 - Do not update pinsb
1 - Update pinsb

pinsb

The pins at end b.  Maximum value is 123456.

","Examples
Release pins of elements 1-4, the translational and rotational X-axis at ends a and b
        respectively:
*createmark elements 2 1-4
*barpinsupdate 2 1 1 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
72,*batchmesh_mc,"Description
Meshes geometry using BatchMesh mesh controls. 
","Inputs

mark_id
The ID of the mark containing the mesh controls to use. Valid values are 1 and 2.
entity_type
The entity type for the model control on-the-fly selection. Valid values are surfaces,
            comps and regions. 
This is ignored, if the model control selection is set directly in the model mesh
            control.
entity_mark_id
The ID of the mark containing the model control on-the-fly selection. Valid values are 1 and 2.
This is ignored, if the model control selection is set directly in the model mesh
            control.
options
A flag that indicates the advanced options. Bit values are used and the value is
            calculated as (2*Bit1 + 4*Bit2 + 8*Bit3 + 64*Bit6 + 128*Bit7).
Bit1: Overlapping selection behavior.
0 - Allow overlapping selections. The first mesh control referencing the entity
                  is used and that entity is ignored in subsequent mesh controls. 
1 - Do not allow overlapping selections and return an error.
Bit2: Mesh connectivity.
0 - Keep connectivity with existing mesh. 
1 - Break connectivity with existing mesh.
Bit3: Mesh controls order.
0 - Apply mesh controls by element size. 
1 - Apply mesh controls by increasing ID.
Bit6: Plot elements.
0 - Keep plot elements. 
1 - Delete plot elements before meshing.
Bit7: Delete elements unassociated to geometry.
0 - Keep unassociated elements. 
1 - Delete unassociated elements before meshing.



","Examples
BatchMesh the components 1 and 2, using a first order mixed mesh, keeping any adjacent
        existing elements with criteria file
          C:/batch_criteria/crash_10mm.criteria and parameters file
          C:/batch_criteria/crash_10mm.param:*createentity meshcontrols config=MCBM_CFG_BATCHMESH_GLB name=main_mc
*setvalue meshcontrols name=main_mc MCBM_ENTITY_SEL={comps 1 2} MCBM_MODE_CBX=0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_10mm.criteria"" MCBM_PARAMS_FILE=""C:/batch_criteria/crash_10mm.param""
*createmark meshcontrols 1 $main_mc_name
*batchmesh_mc 1 comps 1 0
BatchMesh the components Main_Body, Medium and Detailed, using a first order mixed mesh,
        keeping any adjacent existing elements. 
Mesh component Main_Body with criteria file
          C:/batch_criteria/crash_10mm.criteria and parameters file
          C:/batch_criteria/crash_10mm.param. 
Mesh component Medium with element size 7.0, scaling the criteria and parameters from
          C:/batch_criteria/crash_5mm.criteria and
          C:/batch_criteria/crash_5mm.param. 
Mesh component Detailed with auto generated criteria and parameters with element size 4.0,
        min element size 2.0 and max element size 6.5. Use defaults for all other auto-generation
        options.#Create a global mesh control for all comps
set main_id [hm_getvalue comps name=Main_Body dataname=id]
set medium_id [hm_getvalue comps name=Medium dataname=id]
set detailed_id [hm_getvalue comps name=Detailed dataname=id]

set main_mc_name ""main_mc""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH_GLB name=$main_mc_name
*setvalue meshcontrols name=$main_mc_name MCBM_ENTITY_SEL={comps $main_id $medium_id $detailed_id} MCBM_MODE_CBX=0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_10mm.criteria"" MCBM_PARAMS_FILE=""C:/batch_criteria/crash_10mm.param""

#Create a local mesh control for Medium
set medium_mc_name ""medium_mc""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH name=$medium_mc_name
*setvalue meshcontrols name=$medium_mc_name MCBM_ENTITY_SEL={comps $medium_id} MCBM_MODE_CBX=1 MCBM_ELEM_SIZE=7.0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_5mm.criteria"" MCBM_PARAMS_FILE=""C:/batch_criteria/crash_5mm.param""

#Create a local mesh control for Detailed
set detailed_mc_name ""detailed_mc""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH name=$detailed_mc_name
*setvalue meshcontrols name=$detailed_mc_name MCBM_ENTITY_SEL={comps $detailed_id} MCBM_MODE_CBX=2 MCBM_ELEM_SIZE=4.0 MCBM_MIN_ELEM_SIZE=2.0 MCBM_MAX_ELEM_SIZE=6.5

#Create the mesh from the 3 mesh controls.  The comps selection is not required since the entity selection is defined already.
*createmark meshcontrols 1 $main_mc_name $medium_mc_name $detailed_mc_name
*batchmesh_mc 1 comps 1 0

BatchMesh all surfaces with criteria and parameters
          C:/batch_criteria/crash_12mm.criteria and
          C:/batch_criteria/crash_12mm.param with the following exceptions: 
Surfaces with IDs 78, 134 and 163 should be meshed with criteria and parameters
              C:/batch_criteria/crash_8mm.criteria and
              C:/batch_criteria/crash_8mm.param

Regions with IDs 2 and 5 should be meshed with criteria and parameters
              C:/batch_criteria/crash_5mm.criteria and
              C:/batch_criteria/crash_5mm.param

#Global mesh control for 12mm mesh
set glob_mc_name ""part_mc""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH_GLB name=$glob_mc_name
*setvalue meshcontrols name=$glob_mc_name MCBM_ENTITY_SEL={comps 0} MCBM_MODE_CBX=0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_12mm.criteria"" MCBM_PARAMS_FILE=""C:/batch_criteria/crash_12mm.param""

#Local mesh control for 8mm mesh
set mc8mm_name ""mc_8mm""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH name=$mc8mm_name
*setvalue meshcontrols name=$mc8mm_name MCBM_ENTITY_SEL={surfs 78 134 163} MCBM_MODE_CBX=0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_8mm.criteria""  MCBM_PARAMS_FILE=""C:/batch_criteria/crash_8mm.param""

#Local mesh control for 8mm mesh
set mc5mm_name ""mc_5mm""
*createentity meshcontrols config=MCBM_CFG_BATCHMESH name=$mc5mm_name
*setvalue meshcontrols name=$mc5mm_name MCBM_ENTITY_SEL={regions 2 5} MCBM_MODE_CBX=0 MCBM_CRITERIA_FILE=""C:/batch_criteria/crash_5mm.criteria""  MCBM_PARAMS_FILE=""C:/batch_criteria/crash_5mm.param""

#Create the mesh from the 3 mesh controls.  The surfs selection is required since the global control entity selection is not defined.
*createmark meshcontrols 1 $glob_mc_name $mc8mm_name $mc5mm_name
*createmark surfs 1 all
*batchmesh_mc 1 surfs 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
73,*batchparams_write,"Description
Write the global mesh quality parameters to a file.
","
Inputs


filename
The full name and path of the file to write.

","Examples
To write the parmeters to C:/temp/5mm.param:
*batchparams_write C:/temp/5mm.param
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
74,*beamsectionautoconnectshell,"Description
If the part or parts of the shell type beam section specified have gaps between them of
        equal to or less than the connection_tolerance, one or more ""weld"" type
        parts of connection_thickness will be created to bridge the gaps. The
        ""weld"" type connections created will span the gap at the closest points between the parts.
        If the parts are already connected, the gap must exceed the
          connection_tolerance and then narrow to be equal to or less than the
          connection_tolerance before an additional connection is created.
        Additional vertices may be created to position the connections at the most central positions
        between the joined parts. Note that the addition of these ""weld"" parts to the section will
        alter the sectional properties such as the area and moments of inertia. 
It is important to note that the shear center and a number of other sectional properties
        are not calculated for shell type beam sections which have unconnected parts, and will
        default to the beam center. This command is intended to be used to automatically connect
        shell beam sections in logical ways so that the true shear center can be found. For example,
        if you create lines from a section cut of a pair of components which are connected with
        rigid elements, the lines will lack similar connections and thus a section created from
        those lines would also be unconnected. This command can be used to reconnect the parts of
        the section and thus give a more accurate representation of the properties of the cut
        section.
","Inputs

beam_section_id
The ID of the shell beam section to connect.
connection_type
The type of connection to create. Valid values are: 
0 - Spot weld 
Other types of connections are currently unsupported (such as seam welds).
connection_tolerance
The maximum distance between the parts to be connected. Must be > 0.
connection_thickness
The thickness of the new part created to connect the existing parts. If set to 0.0,
            the thickness will be equal to the distance between the parts.

","Examples
To automatically connect a shell type beam section with ID 1 such that parts closer then
        2.0 model units apart are joined with a weld type connection of thickness
        1.5:*beamsectionautoconnectshell 1 0 2.0 1.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
75,*beamsectioncalculateresults,"Description
This command invokes the beam solver to calculate the results for selected standard, shell,
        and solid beam sections.
","Inputs

entity_type
Must be set to beamsects.
mark_id
The ID of the mark containing the beam sections. Valid values are 1 and 2.

","Examples
To solve all results for all beam sections in the
        model:*createmark beamsects 1 all
*beamsectioncalculateresults beamsects 1
",
76,*beamsectioncreateshell,"Description
Creates a shell beam section for HyperBeam, using lines or 1D
        elements.
","Inputs

entity_type
The type of entity that defines the cross-section. Valid values are lines and elems.
            For elements, only 1D elements can be used.
mark_id
The mark ID containing the input entities. Valid values are 1 and 2.
plane_id
The plane ID created using the *createplane command. The plane
            defines the plane to project the input entities. This is only used when project is set
            to 2.
vector_id
The vector ID created using the *createvector command. The vector
            defines the direction to project the input entities to the plane. This is only used when
            project is set to 2.
project
Defines how the projection of the input entities occurs: 
2 - Project the entities to the defined cross-section plane. The
              plane_id and vector_id options are required. 
3 - Create a cross-section plane that fits the selected entities. The
              base_node_id option is required.
base_node_id
The ID of the node to use as the base. This is only used when project is set to
            3.
part_generation
Defines how many individual parts are created: 
0 - Automatically sort the lines or elements into their separate sheet metal
            parts.
1 - Force every separate line or element to be a separate sheet metal part with
            individual thickness.

","Examples
To create a shell section from lines 1 through 10, projecting to the xy-plane at 0, 0, and
        0 along the z-direction, and creating individual
        parts:*createmark lines 1 1-10
*createplane 1 0 0 1 0 0 0
*createvector 1 0 0 1
*beamsectioncreateshell lines 1 1 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
77,*beamsectioncreatesolid,"Description
Creates a solid beam section for HyperBeam, using a planar
        collection of elements, lines or surfaces. 
If surfaces are used, HyperMesh meshes the surface with quads
        and trias of the specified order (2nd order recommended), with the meshing parameters such
        as element size calculated in such a way as to produce elements useful to HyperBeam. 
If lines are used, HyperMesh builds a surface through the
        projected lines and meshes the surface with quads and trias as above. 
If elements are used, they must form a single, connected patch with small enough elements
        that there is at least one internal node providing flexibility for each of the thinnest
        portions of the beam cross-section. 
The base_node and vector_id are used to orient the
        beam cross-section calculations. HyperMesh beam cross-sections
        are, by convention, assumed to be in the y-z plane. The centroid and moments of inertia will
        be reported in those coordinates.
","Inputs

entity_type
The type of entity to use to create the section. Valid values are elements, lines, or
            surfaces.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
plane_id
The ID of the plane to use, defined using the *createplane command.
            Currently always 1.
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. Currently always 1.
use_plane
A flag specifying whether or not the plane is reliable; usually this can be inferred
            automatically from the command. 
0 - HyperMesh tries to infer a plane from the data, then
            projects the elements, lines, or surfaces to that plane before using them. 
1 - Used when you also supply a plane ID via the plane_id argument.
              HyperMesh projects the entities to the specified plane
            instead of inferring one.
base_node
The ID of the node specifying the origin of all beam section calculations.
elem_order
The order (1 or 2) of the elements to use.

","Examples
To create a solid section from elements 1-100, using an inferred plane, z-axis as the
        vector, and base node
        100:*createvector 1 0 0 1
*createmark elems 1 1-100
*beamsectioncreatesolid elems 1 1 1 0 100 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
78,*beamsectioncreatesolidfrompoints,"Description
Creates a solid beam section for HyperBeam, using a closed loop
        of point coordinates that form a polygon.
HyperMesh builds a surface through the points and meshes the
        surface with quads and trias of the specified order (2nd order recommended), with the
        meshing parameters such as element size calculated in such a way as to produce elements
        useful to HyperBeam.
","Inputs

double_array
The ID of the double array that contains the point coordinates specified in a
            counter-clockwise direction. The double array is created using the
              *createdoublearray command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
order
The order (1 or 2) of the elements to use.
write_to_file
A flag specifying whether or not the results should be written to a file with name
              stdsolidbeamdata. This is written to the HyperMesh working directory. Valid values are: 
1 - Write to file. 
0 - Do not write to file.
section_type
A flag to indicate the type of section. Valid values are: 
1 - Hollow section. 
0 - Non-hollow section.
base_node
A flag specifying how to calculate the base node. Valid values are: 
0 - Choose the base point as the origin (0,0,0). 
1 - Choose the base point as the average of the minimum and maximum point values.
calc_var
Variable for holding the results of calculation. By default this value is zero.

","Examples
To create a solid section from coordinates (0,0) (1,0) (1,1) and
        (0,1):*createdoublearray 8 0 0 1 0 1 1 0 1
*beamsectioncreatesolidfrompoints 1 8 1 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
79,*beamsectionsetdatageneric,"Description
Updating a generic beam section requires two commands of which this is the second. This
        command will update all data for a generic type beam section. The command
          *beamsectionsetdataroot should precede use of this command. 
Beam section data cannot be updated piecemeal with this command; all data must be known for
        the beam and sent in as arguments.
","Inputs

double_array
The ID of the double array that contains the additional input parameters. The double
            array is created using the *createdoublearray command. This should
            always be set to 1. 
The contents of this array are the results values for the beam section. The values
            should be in the same order as those listed in the string_array. Any
            results not given will be set to zero.
number_of_doubles
Integer indicating the size (number of doubles) of the double array created using
              *createdoublearray.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
The contents of this array are the identifying names of the results types for a beam
            section. The correct syntax is required to recognize the results types. The following is
            a list of all results types. Not all types need to be given, but those that are not will
            be set to zero.


Results Type
Identifier




Area
area
 
 


Centroid location
centroid [0]
centroid [1]
 


Max coord ext - centroidal
coordExt [0]
coordExt[1]
 


Max coord ext - principle
coordExtP[0]
coordExtP[1]
 


Elastic Torsional Modulus
Emt
 
 


Plastic Torsional Modulus
Pmt
 
 


Moment of Inertia - centroidal
ICentroid[0]
ICentroid[1]
ICentroid [2]


Moment of Inertia - principle
IPrinciple[0]
IPrinciple[1]
 


Moment of Inertia - local
IUser[0]
IUser[1]
IUser[2]


Angle
theta
 
 


Torsional Constant
J
 
 


Warping Constant
Gamma
 
 


Radius of Gyration
radiusG
 
 


Elastic Sectional Modulus - centroidal
S[0]
S[1]
 


Elastic Sectional Modulus - principle
SP[0]
SP[1]
 


Shear Center - local
shearCenter[0]
shearCenter[1]
 


Shear Center -principle
shearCenterP[0]
shearCenterP[1]
 


Shear Deformation Coefficient
ShearDeform[0]
ShearDeform[1]
ShearDeform[2]


Shear Factors
shearStiff[0]
shearStiff[1]
shearStiff[2]


Torsion Coefficient
torsionCoeff[0]
torsionCoeff[1]
 


Plastic Section Modulus - centroidal
Z[0]
Z[1]
 


Plastic Section Modulus - principle
ZP[0]
ZP[1]
 


Number of Cells
NumberOfCells
 
 


Cell areas
Cell1
Cell2
Cell3


Cell4
Cell5
Cell6


Cell7
Cell8
Cell9


Cell10
Cell11
Cell12





number_of_strings
Integer indicating the size (number of strings) of the string array created using
              *createstringarray.
beam_sect_id
The ID of the shell or solid beam section to update.

","Examples
To update the parameter data for a shell type section with ID 4. Only the area and
        centroidal moment-of-inertia values are defined, all others are set to 0. Note: This command
          should be used in tandem with *beamsectionsetdataroot as
          follows:
*beamsectionsetdataroot 4 1 0 1 7 1 0 0 0 0 0 0 0
*createdoublearray 56 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
*createstringarray 56 ""area"" ""centroid[0]"" ""centroid[1]"" ""coordExt[0]"" ""coordExt[1]"" ""coordExtP[0]"" ""coordExtP[1]"" ""Emt"" ""Pmt"" ""Icentroid[0]"" ""Icentroid[1]"" ""Icentroid[2]"" ""Iprincipal[0]"" ""Iprincipal[1]"" ""Iuser[0]"" ""Iuser[1]"" ""Iuser[2]"" ""J"" ""gamma"" ""radiusG"" ""S[0]"" ""S[1]"" ""shearCenter[0]"" ""shearCenter[1]"" ""shearCenterP[0]"" ""shearCenterP[1]"" ""ShearDeform[0]"" ""ShearDeform[1]"" ""ShearDeform[2]"" ""PrincipalShear[0]"" ""PrincipalShear[1]"" ""shearStiff[0]"" ""shearStiff[1]"" ""shearStiff[2]"" ""torsionCoeff[0]"" ""torsionCoeff[1]"" ""Z[0]"" ""Z[1]"" ""ZP[0]"" ""ZP[1]"" ""SP[0]"" ""SP[1]"" ""theta"" ""NumberOfCells"" ""Cell1"" ""Cell2"" ""Cell3"" ""Cell4"" ""Cell5"" ""Cell6"" ""Cell7"" ""Cell8"" ""Cell9"" ""Cell10"" ""Cell11"" ""Cell12""
*beamsectionsetdatageneric 1 56 1 56 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
80,*beamsectionsetdatashell,"Description
Updating a shell beam section requires two commands of which this is the second. This
        command will update all data for a shell type beam section. The command
          *beamsectionsetdataroot should precede use of this command. 
Beam section data cannot be updated piecemeal with this command; all data must be known for
        the beam and sent in as arguments. 
Results will be calculated for the beam section automatically after updating.
","Inputs

vertex_array
The ID of the double array that contains the vertices defining the shell section. The
            double array is created using the *createdoublearray command. This
            should always be set to 1. 
The contents of this array are stored in two groups. The first group contains the
            local Y and Z locations for each vertex. These are stored in pairs such that the first
            value is the Y location for the first vertex, the second value is the Z location of the
            first vertex, the third value is the Y location for the second vertex, the fourth value
            is the Z location of the second vertex, and so on. This repeats for all vertices. The
            second group contains the initial, minimum, and maximum thicknesses for each part. These
            are stored in threes such that the first three values are the current thickness, minimum
            thickness, and the maximum thickness for the first part. The second three values are the
            current thickness, minimum thickness, and the maximum thickness for the second part, and
            so on. This repeats for all parts.
vertex_array_length
Integer indicating the size (two times the number of vertices for the section
            (vertex_count) plus three times the number of parts for the section (part_count)) of the
            double array created using *createdoublearray.
connectivity_array
The ID of the integer array that defines the vertex connectivity. The integer array is
            created using the *createarray command. This should always be set to
            1. 
The contents of this array are stored in groups with the first value of each group
            denoting the number of vertices for the part and the following values being the IDs of
            the vertices for the part. This repeats for all parts. 
Thus, if a shell type section has two parts, one going through 4 vertices: 1, 2, 3,
            and 4; and the other going through 3 vertices: 1, 5, and 4; the array should follow this
            pattern and be written as follows:
            *createarray 9 4 1 2 3 4 3 1 5 4
Note that the list of vertices starts with an ID of 1. There is no vertex with an ID
            of 0.
connectivity_array_length
Integer indicating the size (part_count plus the number of vertices contained within
            each part for all parts) of the integer array created using
              *createarray.
part_name_array
The ID of the string array that defines the part names. The string array is created
            using the *createstringarray command. This should always be set to 1. 
The contents of this array are stored as a list of names for each part. The order of
            this array should match the order used for the integer array when defining the
            connectivity.
part_name_array_length
Integer indicating the size (part_count) of the string array created using
              *createarray.
beam_sect_id
The ID of the beam section to update.
part_count
The number of parts in the section.
vertex_count
The number of vertices in the section.

","Examples
To update the parameter data for a shell type section with ID 2. Note that this command
        should be used in tandem with *beamsectionsetdataroot as
        follows:*beamsectionsetdataroot 2 1 0 3 7 1 0 0 0 0 0 0 0
*createdoublearray 15 3 -3 3 2 3 1 -2 1 -2 -3 0 -3 1 0.5 1.5
*createarray 6 5 1 2 3 4 5
*createstringarray 1 ""shellpart.0""
*beamsectionsetdatashell 1 15 1 6 1 1 2 1 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
81,*beamsectionsetdatasolidelems,"Description
Updating a solid beam section requires two commands of which this is the second. This
        command will update all data for a solid type beam section. The command
          *beamsectionsetdataroot should precede use of this command. 
Beam section data cannot be updated piecemeal with this command; all data must be known for
        the beam and sent in as arguments. 
The solid beam section interior elements are explicitly sent in using this command and
        results will be calculated for the beam section automatically after updating. Unlike the
        command *beamsectionsetdatasolid, no internal meshing of the beam will
        occur.
","Inputs

vertices_double_array
The ID of the double array that contains pairs representing a series of local y and z
            locations for the vertices of all the elements defining the section. The double array is
            created using the *createdoublearray command. This should always be
            set to 1. 
As an example, to define a rectangular section consisting of a single quad4 element
            with vertices at points (5,5), (5,0), (0,0), and (0,5), and two tria3 elements, one with
            vertices at points (5,5), (5,0), and (7,2), and one with vertices at points (0,0),
            (0,5), and (-2,2), use the following input to *createdoublearray:
            *createdoublearray 12 5 5 5 0 0 0 0 5 7 2 -2 2 
Note that vertices (5,5), (5,0), (0,0), and (0,5) are each shared by two elements and
            so they do not need to be repeated. Extra spaces were added for clarity.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. 
This should be equal to two times the number of vertices for the section.
elemverts_int_array
The ID of the integer array that contains four groups, with each group containing the
            number of elements in the group followed by the vertex IDs for each element in the group
            listed one after the other. The groups follow a specific order with tria3 coming first,
            quad4 second, tria6 third, and quad8 last. The integer array is created using the
              *createarray command. This should always be set to 1. 
As an example, to define a rectangular section consisting of a single quad4 type
            element at vertices 4, 3, 2, and 1 and two tria3 type elements, one at vertices 1, 2,
            and 5, and the other at vertices 3, 4, and 6, use the following input to
              *createarray:
            *createarray 14 2 1 2 5 3 4 6 1 4 3 2 1 0 0 
Note the four groups (separated by extra spaces for clarity) starting with the two
            tria3s and that a zero must be used to denote that there are no elements of a certain
            type (tria6 and quad8). 
Also note that it is critical to order the vertices in a clockwise direction given
            that the Y axis points upward and the Z axis points to the right. Also, for second order
            elements you must list the corner vertices first and then the mid-side vertices second.
            For the mid-side vertices, start with the mid-side located clockwise after the first
            corner vertex listed.
number_of_ints
Integer indicating the size (number of integers) in the double array created using
              *createarray.
This should be equal to four plus three times the number of tria3 elements, plus four
            times the number of quad4 elements, plus six times the number of tria6 elements, plus
            eight times the number of quad8 elements.
beam_sect_id
The ID of the shell or solid beam section to update.

","Examples
To update the element data for a solid type
        section:*beamsectionsetdataroot 3 1 0 0 7 1 0 1 1 0 0 0 0
*createdoublearray 12 5 5 5 0 0 0 0 5 7 2 -2 2
*createarray 14 2 1 2 5 3 4 6 1 4 3 2 1 0 0
*beamsectionsetdatasolidelems 1 12 1 14 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
82,*beamsectiontranslate,"Description
The beam section specified will be translated by the amounts specified by
          translation_y and translation_z, or be centered at
        the centroid or the shear center of the beam depending on the option specified by
          translation_option. The beam must be of type shell or solid.
","Inputs

beam_sect_id
The ID of the shell or solid beam section to update.
translate_option
0 - The section will be translated by the amounts specified by
              translation_y and translation_z. 
1 - The section will be centered at the location of the centroid. 
2 - The section will be centered at the location of the shear center.
translation_y
Amount of translation in the local y direction of the beam for a
              translation_option of 0.
translation_z
Amount of translation in the local z direction of the beam for a
              translation_option of 0.

","Examples
To translate a beam section with ID 1 to be centered at its shear
        center:*beamsectiontranslate 1 2 0 0
To translate a beam section with ID 1 by 1.0 in the local y direction and 2.1 in the local
        z direction:*beamsectiontranslate 1 0 1.0 2.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
83,*blmesh_2d,"Description
Generates a 2D boundary layer mesh on surfaces/elements.
","Inputs

base_entity_type
The type of entities to use for the base. Valid values are surfs and elems.
base_mark_id
The ID of the mark containing the base entities. Valid values are 1 and 2.
bl_entity_type
The type of entities to use for the boundary layers. Valid values depend on the base
            entity type:
surfs - valid value is lines. 
elems - valid values are elems or nodes. Only plotel elements are allowed.
bl_mark_id
The ID of the mark containing the boundary layer entities. Valid values are 1 and 2.
num_layers
The number of boundary layers to generate.
first_layer_thickness
The thickness value of the first layer.
growth_rate
The growth rate of the boundary layers.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. Valid parameters include: 
element_size: <size> 
element_type: <type>
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create 5 layer boundary mesh with a quad dominated mesh of size 2.0 on surface 10 using
        lines 20, 21, 25, 26, 37 and 38, with the first layer being 0.15 thick and a growth rate of
        1.2:*createstringarray 2 ""element_size: 2.0"" ""element_type: quads""
*createmark surfs 1 10
*createmark lines 1 20 21 25 26 37 38
*blmesh_2d surfs 1 lines 1 5 0.15 1.2 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
84,*blmesh_2d_computeblthickness1,"Description
Used to generate boundary layer thickness on boundary nodes with specified parameters and
        default BL/nonBL type definition. *blmesh_2d_input_bl and
          *blmesh_2d_input_nonbl should be used before calling this command.
","Inputs

base_entity_type
The type of entities to use for the base to generate BL thickness. Only elems are
            valid.
base_mark_id
The ID of the mark containing the base entities. Valid values are 1 and 2.
num_layers
The number of boundary layers to generate.
first_layer_thickness
The thickness value of the first layer.
growth_rate
The growth rate of the boundary layers.
core_to_BL_ratio
Ratio of core mesh to BL thickness, which is used for BL reduction.
corner_factor
A dimensionless value used for corner management. The range is 0.1-1.0 for thinner BL
            thickness, and 1.0-10.0 for thicker BL thickness.
string_array
The ID of the string array that contains additional input parameters. The string array
            is created using the *createstringarray command. This should always
            be set to 1. Valid strings are:
DefaultBLSelection:
Default BL/non-BL selection for all boundary edges. Valid values are: 
With_BL 
Without_BL_fixed 
Without_BL_remesh


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create a 5 layer boundary mesh from elements 10-100, with the first layer being 0.15
        thick and a growth rate of 1.2, a core-to-BL ratio of 2.5, a corner factor of 1.0, using
        boundary layer elements 10 and 11 as fixed and 12 and 13 as float, and non-boundary layer
        elements 1 and 2 as fixed and 5 and 6 as
        float:*createmark elems 1 10 11
*createmark elems 2 12 13
*blmesh_2d_input_bl elems 1 elems 2
*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createstringarray 1 ""DefaultBLSelection: With_BL""
*createmark elems 1 10-100
*blmesh_2d_computeblthickness1 elems 1 5 0.15 1.2 2.5 1.1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
85,*blmesh_2d_input_nonbl,"Description
Specifies non-boundary layer input for *bl_mesh2d2 and
          *bl_mesh2d_computeblthickness. 
If *blmesh_2d_input_nonbl is not called before either command, then all
        edges of the selected region are considered as boundary layer edges.
","Inputs

fixed_entity_type
The type of entities to use for the fixed non-boundary layer. Valid values depend on
            the base_entity_type value specified in
              *bl_mesh2d2. 
If base_entity_type is surfs, then the only valid value is lines. 
If base_entity_type is elems, then the valid values are elems or
            nodes. For elems, only plotel elements are allowed.
fixed_mark_id
The ID of the mark containing the fixed entities. Valid values are 1 and 2.
float_entity_type
The type of entities to use for the float non-boundary layer. Valid values depend on
            the base_entity_type value specified in
              *bl_mesh2d2. 
If base_entity_type is surfs, then the only valid value is lines. 
If base_entity_type is elems, then the valid values are elems or
            nodes. For elems, only plotel elements are allowed.
float_mark_id
The ID of the mark containing the float entities. Valid values are 1 and 2.
float_mode
Option to specify behavior of float non-boundary layer entities. 
0 - Do nothing special.
1 - Use remesh option.

","Examples
To create a 5 layer boundary mesh with a quad dominated mesh of size 2.0 on surface 10,
        with the first layer being 0.15 thick and a growth rate of 1.2, using boundary layer
        elements 10 and 11 as fixed and 12 and 13 as float, and non-boundary layer elements 1 and 2
        as fixed and 5 and 6 as
        float:*createmark elems 1 10 11
*createmark elems 2 12 13
*blmesh_2d_input_bl elems 1 elems 2
*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createstringarray 2 ""element_size: 2.0"" ""element_type: quads""
*createmark surfs 1 10
*blmesh_2d2 surfs 1 5 0.15 1.2 1 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
86,*blockcontrollines,"Description
Controls the lines on a block. 
","Inputs

index
The index to be modified. 
on
Set to 1, to display the block lines.

",,
87,*blocknodeupdate,"Description
Updates the finite difference nodes in a finite difference block. 
","Inputs

name
The name of the block.
function
0 - add nodes to an index.
1 - remove nodes from an index.
2 - remove all nodes from an index.
type
The index. Not used, if function is 2. 
0 - i
1 - j
2 - k
start
The starting position of the nodes to be added or removed. Not used, if
              function is 2. 
end
The ending position of the nodes to be added or removed. Not used, if
              function is 2. 
number
The number of nodes to add. Not used, if function is 1 or 2. 
factor
The expansion factor. Not used, if function is 1 or 2. 

","Examples
To add 50 nodes uniformly in the k direction to an existing block named block1:
        *blocknodeupdate(block1,0,2,-10.0,110.0,50,1.0)
",
88,*blockvisualize,"Description
Creates a fill hide plot of a finite difference block. 
","Inputs

name
The name of the block.
iplane
The i plane to display. 
jplane
The j plane to display. 
kplane
The k plane to display. 
icolor
The color in which to display the i plane. Not used if iplane is 0. 
jcolor
The color in which to display the j plane. Not used if jplane is 0. 
kcolor
The color in which to display the k plane. Not used if kplane is 0. 
usewallcolor
1 - If the colors of the walls are to be used.
0 - If the colors specified by icolor, jcolor,
            and kcolor are to be used.

The color values are not used and the block is visualized using the wall colors, unless the
        planes are nonzero, in which case, the plane is visualized using the color provided. 
","Examples
To display the entire finite difference block named block1:
        *blockvisualize(block1,0,0,0,0,0,0)
",
89,*blockwallcreate,"Description
Creates a wall in a finite difference block. 
","Inputs

blockname
The name of the block. 
wallname
The name of the wall to be created. 
color
The color of the new wall. 

",,
90,*blockwalleditrange,"Description
Adds or deletes a range of cells in a finite difference wall. 
","Inputs

blockname
The name of the block.
wallname
The name of the wall to be edited. 
imin
The minimum value in the i direction, inclusive. 
imax
The maximum value in the i direction, inclusive. 
jmin
The minimum value in the j direction, inclusive. 
jmax
The maximum value in the j direction, inclusive. 
kmin
The minimum value in the k direction, inclusive. 
kmax
The maximum value in the k direction, inclusive. 
del
0 - Adds cells.
1 - Deletes cells. 

",,
91,*blockwallfindintersect,"Description
Intersects one- and two-dimensional finite elements with cells in a finite difference
        block. 
","Inputs

blockname
The name of the block. 
wallname
The name of the wall into which cells are to be inserted. 
entity type
The type of entity in the mark (either elements or components).
mark
The ID of the mark.

",,
92,*blockwallremovecell,"Description
Removes one cell from a finite difference wall. 
","Inputs

wallname
The name of the wall from which the cell is to be removed. 
cellid
The ID of the cell to be removed. 

","Examples
The ID of any cell, knowing the (i,j,k) location, may be found by the formula
          (i*divj*divk)+(j*divk)+k, where divj and divk are the number of divisions
        in the j and k directions, respectively. 
",
93,*blockwallupdate,"Description
Updates the color of a wall in a finite difference block. 
","Inputs

blockname
The name of the block. 
wallname
The name of the wall. 
color
The new color of the new wall. 

",,
94,*body_split_with_morphed_lines,"Description
Splits surfaces or solids using swept lines. 
","Inputs

entity_type
The type of entities to split. Valid values are solids or surfaces.
mark_id
The ID of the mark containing the entities to split. Valid values are 1 and 2..
list_id
The ID of the list containing the lines from which to to generate the swept surface
            used for splitting.
coords
The array of coordinates or offsets used to indicate sweeping direction of line ends.
            The values in the array are given as a sequence of x, y, z values for either the offset,
            or the absolute value of the swept line ends (the particular usage depends on the
              target_type parameter value). The coord_size
            parameter gives the number of values used in the array.
coords_size
The array of coordinates or offsets used to indicate the sweeping direction of the
            line ends. The values in the array are given as a sequence of x, y, z values for either
            offset or absolute value of swept line ends (the particular usage depends on the
              target_type parameter value). The coord_size
            parameter gives the number of values used in the array.
target_type
Controls the way that the values given by coords indicate sweeping direction of line
            ends. Permissible values of this parameter are 0, 1, 2, 3, 4, 5, 6, and 7: 
0 - The first 3 values of coords are used as x, y, z values of
                the offset of the line start point; the next 3 values, if present, are used as the
                offset of the line end point. If the second trio of values is not provided then the
                same offset is used for both start and end points. 
1 - The first 3 values of coords are used as x, y, z values of
                the position of swept line start. The second set of x, y, z values is used as the
                position of swept line end point. If only one point is given on input then the
                position of the endpoint is calculated to give the same offset from original line
                end point as the start point (line translation). 
2 - The same as 0. 
3 - The values in coords are used as positions of swept line
                end points. The choice of points’ order is made automatically to minimize swept
                surface distortion. 
(n+4) - Adding 4 to above values (e.g. using 4-7) results in creating splitting
                lines without surface creation.


options
0 - The swept surface is used as-is. 
1 - The surface is extended to cover trimmed entities.

","Examples
To split solid 1 with the surface swept in x direction from the line formed by combining
        lines 10 and
        11:*createmark solids 1 1
*createdoublearray 3 1.0 0.0 0.0
*creatlist lines 1 10 11
*body_split_with_morphed_lines solids 1 1 1 3 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
95,*body_split_with_swept_lines,"Description
Input lines are used to construct cutting surfaces, which are then used to trim selected
        solids or surfaces.
","Inputs

entity_type
The type of entities to split. Valid values are solids or surfaces.
entity_mark
The ID of the mark containing the entities to split. Valid values are 1 and 2.
line_mark_id
The ID of the mark containing the lines from which to to generate the swept surface
            used for splitting. Valid values are 1 and 2.
vector_id
using the *createvector command. This must be set to 1. 
In the case where a limited sweep is specified (see options), the length of the vector
            defines the position of the back edge of the swept surface relative to the position of
            the corresponding input line. A positive value results in shifting the position of the
            back edge in the direction of the input vector.
back_dist
In the case where a limited sweep is specified (see options), this defines the
            position of the front edge of the cutting surface with respect to the position of
            corresponding input line. For a value of 0 the front edge coincides with input line. A
            positive value results in shifting the position of the front edge in the direction of
            the input vector.
options
The options to use for trimming the selected entities. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2).
Bit0
0 - Limited sweep. The swept surfaces are created and used as defined by vector
                  length and back_dist. 
1 - Unlimited sweep. Cutting surfaces are extended in sweep direction to trim as
                  many input surfaces as possible.


Bit1
0 - Limited lines. Original input lines are used to generate swept
                  surfaces.
1 - Extended lines. Input lines are extended before sweeping them to generate
                  cutting surfaces.


Bit2
0 - Cutting surfaces become part of the model. 
1 - Cutting surfaces are temporary and are only used to generate trimming lines
                  on intersected surfaces.



","Examples
To trim solid 111 by sweeping lines 5 and 6 in the z-direction and extending the cutting
        surfaces in all
        directions:*createmark solids 1 111
*createmark lines 1 5 6
*createvector 1 0 0 1
*body_trim_with_swept_lines solids 1 1 1 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
96,*boolean_merge_solids,"Inputs

entitymarkA
Markmask of solid entities in set A.
entitymarkB
Markmask of solid entities in set B.
opcode
Code of boolean operation to be performed. 
14 - A and B 
8 - A or B 
2 - A minus B
options
Currently used to specify how to process internal shared boundaries in resulted solid
            or solids.
0 - All boundaries shared between sets A and B are removed.
1 - Surfaces that were part of the boundary of solids in the set B are kept in the
            result.
2 - All shared boundaries are kept in the result.
3 - All shared boundaries are removed.

",,,
97,*calculateproximityelements,"Description
This command allows you to find which input elements are within a specified proximity
        distance. There are options to narrow or expand the constraints placed on the search
        algorithm. These constraints include, dimension of elements considered, type of
        interference, whether elements of the same component can interfere, angle between
        interfering element face normals and a threshold depth.
","Inputs

entity_type
The type of entity to check for element proximity: elems or comps.
input_mark_id
Input mark ID containing either components or elements.
output_mark_id
Output mark ID containing elements within proximity distance.
dim_type
The dimensionality of the elements to check: 
0 - Check both 2D and 3D elements.
2 - Only check 2D elements.
3 - Only check 3D elements.
calc_type
Type of interferences considered: 
0 - Intersections only.
1 - Both intersections and penetrations.
2 - Penetrations only.
self_interferenc
Set to 1 to consider self-intersections and penetrations within component, otherwise
            set to 0.
check_method
Used to specify a stricter definition of penetration - one requiring all nodes on
            element to be within proximity distance for the elements to be added to output mark. 
0 - To avoid.
1 - To utilize stricter method. This stricter check is not generally recommended.
proximity_dist
Proximity distance - a float value greater than 0.0.
pair_angle
Only include elements forming interference pair with another element within this angle
            - a float with values ranging from 0.0 to 90.0.
threshold_depth
Results avoid elements penetrating by less than this value - float value greater than
            0.0, and less than the proximity_dist.

","Example
Place on mark 2 the elements contained in component mark 1 that are within 2.0 proximity
        distance. Furthermore, avoid including any elements whose interference element partner’s
        normal differs by more than 45
        degrees.*calculateproximityelements comps 1 2 0 2.0 45.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
98,*carddisable,"Description
Disables an existing control card from being output through the template system. 
","Inputs

name
The name of an existing card to disable.

",,
99,*cardenable,"Description
Enables an existing control card to be output through the template system. 
","Inputs

name
The name of an existing card to enable.

",,
100,*CE_AddLinkEntities,"Description
This command updates connectors with entities.
","Inputs

connector_mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
entity_type
Type of entity to be added to the connectors as links.
entity_mark_id
The ID of the mark containing the entities to use as links. Valid values are 1 and 2.

","Examples
To add comps 1 and 2 as to connectors
        1-3:*createmark connectors 1 1-3
*createmark comps 1 1 2
*CE_AddLinkEntities 1 comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
101,*CE_AddLinkEntitiesWithArrays,"Description
This command updates connectors at the specified locations with arrays.
","Inputs

integer_array
The integer array ID that contains the connector ID and number of layers for that
            connector. The integer array is created using the *createarray
            command. This should always be set to 1.
number_of_integers
Integer indicating the size (number of integers) in the integer array created using
              *createarray.
entity_type
The entity type to be added to the connectors as links.
entity_mark_id
The mark ID the entities to use as links. Valid values are 1 and 2.
entity_state
The state of the link entities. Valid values are: 
0 - Geometry.
1 - Elements.
ce_rules
Flag indicating when to make the links. Valid values are: 
0 - Now. 
1 - At realize.
ce_le_rule
Flag indicating how to make the links. Valid values are: 
0 - None. 
1 - Use ID. 
2 - Use name.
tolerance_flag
Flag indicating whether to use the default tolerance. Valid values are: 
0 - Use default. 
1 - Use specified values.
double_array
The double array ID that contains the add link tolerance values. The double array is
            created using the *createdoublearray command. This should always be
            set to 1. 
The tolerance is used to add entities only within the given value from the specified
            connector. Must be set to 1. Ignored if tolerance_flag is 0.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
keep_existing
Option for deleting existing links first then adding new links, or adding new links
            directly. 
0 - Delete then add.
1 - Add.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Valid strings are: 
ce_spot_extralinknum=1
The number of extra links for spot connectors.
ce_seam_extralinknum=0
The number of extra links for seam connectors.
ce_spot_non_normal=1
The non-normal option for spot connectors.
ce_area_non_normal=0
The non-normal option for area connectors.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To add comps 1 and 2 to connectors 1001, 1002, and 1003 from scratch, the layer numbers for
        these connectors are 2, 3, and 2, the tolerances are 10.0, 11.0, and
        15.0:*createarray 6 1001 2 1002 3 1003 2
*createdoublearray 3 10.0 11.0 15.0;
*createstringarray 4 ""ce_spot_extralinknum=5"" ""ce_seam_extralinknum=7"" ""ce_spot_non_normal=1"" ""ce_area_non_normal=0""
*createmark comps 1 1 2
*CE_AddLinkEntitiesWithArrays 1 6 comps 1 1 1 0 1 1 3 0 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
102,*CE_AddLinkEntitiesWithRules,"Description
This command updates connectors at the specified locations with rules.
","Inputs

connector_mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
entity_type
Type of entity to be added to the connectors as links.
entity_mark_id
The ID of the mark containing the entities to use as links. Valid values are 1 and 2.
entity_state
The state of the link entities. Valid values are: 
0 - Geometry.
1 - Elements.
ce_rules
Flag indicating when to make the links. Valid values are: 
0 - Now. 
1 - At realize.
ce_le_rule
Flag indicating how to make the links. Valid values are: 
0 - None. 
1 - Use ID. 
2 - Use name.
tolerance_flag
Flag indicating whether to use the default tolerance. Valid values are: 
0 - Use default. 
1 - Use specified value.
tolerance
Used to add entities only within the given tolerance from the specified
            connector.
num_ents
Number of entities to add/update connector (connectors thickness (2T, 3T, etc.)
            value).

","Examples
Update connectors 1 and 2 to add the nearest two out of four components specified, using a
        tolerance of 1.0. Components will be linked by
        IDs:*createmark connectors 1 1 2
*createmark comps 1 21 23 24 27
*CE_AddLinkEntitiesWithRules 1 comps 2 1 1 1 1 1.0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
103,*CE_BoltAutoCreateFromAttachments,"Description
Creates bolt connectors from attachments.
","
Inputs


mark_id
Te ID of the mark of attachments to create bolt connectors from.  Valid values are 1
            and 2.
string_array
The ID of the array created using *createstringarray, which
            contains the additional input strings.  Must be set to 1.  Valid strings are:
ce_config_name=<name>
The name of the bolt config.
maxdiameter=<value>
The maximum hole diameter to find (default 25.0).
mindiameter=<value>
The minimum hole diameter to find (default 0.0).
only2layer=<value>
The number of attachments per bolt (default 0).
tolerance=<value>
The tolerance to use for attachment pair searches (default 50).


number_of_strings
The number of strings in string_array.

","Examples
Create a bolt (general) connector from 2 attachments:
*createmark attachments 1 ""attach_200_229"" ""attach_36_51""
*createstringarray 2 ""tolerance=25"" ""ce_config_name=bolt (general)""
*CE_BoltAutoCreateFromAttachments 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
104,*CE_ConnectorAreaCreate,"Description
Create area connector(s) at the specific location(s) by mark with certain rules.
","Inputs

entities
Types that specify location of area connector(s):
Elems
Surfs
entitymark
The mark for elements or surfaces.
linkentity
Type of entity to be added to the area connector as a link: 
Surfs
Comps
linkmark
Mark of surfaces or components to add to the area connector as links.
ent_state
Specifies whether geometry or element gets precedence during realization of connector.
            Currently, only element is supported.
0 - Geometry.
1 - Element.
ce_rules
Rule to specify if and how a link entity is to be added to a connector. 
0 - None.
1 - Now. 
2 - A fe realize.
ce_le_rule
Rule that specifies how an entity is to be remembered by the connector. 
0 - None.
1 - Use ID.
2 - Use name.
tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.
tolerance
Specified to add entities only with in the given tolerance from the specified
            connector.
group
Specified if do group after creation.
0 - Do not group.
1 - Group.
param1
For future use.
param2
For future use.

","Examples
This example creates 2 area connector at elements 1, 2, 3, 6, 7, 8 and add nearest 2 of the
        four components specified within a tolerance of 1.0, remembers the components by their IDs,
        and does not group connectors after
        creation.*createmark(elems, 1) 1, 2, 3, 6, 7, 8
*createmark(components, 2) 21 23 24 27
*CE_ConnectorAreaCreate(elems, 1, components, 2, 1, 1, 1, 1, 1.0, 0, 0, 0.0)
Each created area connector displays as a plane with cylinders located at the corners, and
        only the closest two components are added to it. The total number of layers defined at each
        area connector is 2.
",
105,*CE_ConnectorAreaMapMesh,"Description
Use the projections of components or elements to mesh area connectors.
","Inputs

ce_mark
The mark containing the area connectors..
entitytype
The type of entities to map from.
Comps
Elems
entitymark
The mark containing the comps or elems to map from.
vectorptr
The direction to project.
tolerance
The allowable distance from the comps/elems to the area connectors.
param1
For future use.

","Examples
To mesh area connectors 1, 2, 3 using elements 4, 5, 6, 7, 8, with allowed distance 10.0,
        and projection direction (0.0, 1.0,
        0.0):*createmark(connectors, 1) 1, 2, 3
*createmark(elems, 1)4, 5, 6, 7, 8
*createvector(1, 0.0, 1.0, 0.0)
*CE_ConnectorAreaMapMesh(1, elems, 1, 1, 10.0, 0)
Meshed area connector displays as a plane with virtual elements.
",
106,*CE_ConnectorAreaMeshWithDetails,"Description
Meshes area connectors and updates the width and offset stored on the connector.
","
Inputs


mark_id
The ID of the mark of area connectors. Valid values are 1 and 2.
element_size
The element size.
element_type
The element type for mapped meshing algorithms:
0 - Trias
1 - Quads
2 - Mixed
3 - R-trias
element_type2
The element type for free meshing algorithms:
0 - Trias
1 - Quads
2 - Mixed
3 - R-trias
link_opposite_edges
0 - Do not link
1 - Link
size_control
0 - Off
1 - On
skew_control
0 - Off
1 - On
edge_mesh_algorithm
0 - Standard
1 - Chordal deviation
min_size
The minimum element size when edge_mesh_algorithm is 1.
max_size
The maximum element size when edge_mesh_algorithm is 1.
chordal_deviation
The chordal deviation value when edge_mesh_algorithm is 1.
max_angle
The maximum angle between edges when edge_mesh_algorithm is 1.
area_width
The new width value.
area_offset
The new offset value.

","Examples
To update area connector 10 with width 2.0 and mesh it with a default edge size of 1.0:
*createmark connectors 1 10
* CE_ConnectorAreaMeshWithDetails 1 1.0 1 1 1 0 0 0 0 0 0 0 2.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
107,*CE_ConnectorCombine,"Description
Combines connectors. Locates connectors that are considered subsets of other connectors
        within a given tolerance, makes supersets from the connectors having at least one common
        link entity, and deletes the original subsets.
","Inputs

markMask
The mark mask (1 or 2).
tolerance
The maximum distance between two connectors that are considered to be duplicates.

","Examples
To combine connectors on the mark mask 1 within 0.05
        tolerance:*CE_ConnectorCombine(1, 0.05)
To make a combination possible, connectors must have at least one shared link entity. 
Currently supported for connectors located at geometric points only.
",
108,*CE_ConnectorCreateAndFERealizeForTrimMass,"Description
Create apply mass connectors at the specified location with certain rules, and realize them
        using a specified config type, mass value and distribution type. 
","Inputs

entitytype
The entity type serving as the location of apply mass connector(s). Valid options are
            nodes and points. 
entitymark
Mark of the location points or nodes.
linkentitytype
Link types: 
Nodes
Elems
Comps
hm_tag


linkentitymark
Mark of the entities of links.
ce_rules
Rule to specify how a link entity is to be added to a connector: 
0 - None 
1 - User selected
2 - Use name


ce_le_rule
Rule that specifies how an entity is to be remembered by the connector: 
0 - None
1 - User ID
2 - Use name


tolerance
Add entities as links only with in the given tolerance from the specified
            location.
num_ents
The number of links.
-1 - All entities within tolerance will be added as
                links.


config
Apply mass type: 
1100 - Point mass
1101 - Rigid mass
1102 - Rigidlink mass
1103 - rbe3 mass


mass
Value of the applied mass.
distribution_type
Apply mass distribution type:
0 - Divide mass by nodes.
1 - Apply mass to all nodes.
2 - Divide mass by area.
3 - Unit area.


param1
For future use (must be 0).

","Examples
This example creates 2 apply mass connectors at nodes 1 and 2, using nodes as links, adding
        nodes as links to the connectors using ""proximity"" tolerance = 10.0, and setting the
        remember rule to ""none"". It also realizes connectors using ""point mass"" (1100), ""mass value""
        = 100.0, distributing the mass to the link nodes using the ""divide mass by nodes"" method
        (1).
*createmark(nodes, 1) 1, 2    *CE_ConnectorCreateAndFERealizeForTrimMass(NODES, 1, NODES, 0, 2, 0, 10.0, -1, 1100, 100.0, 1, 0)

",
109,*CE_ConnectorCreateByAutopitchNew,"Description
Create connectors using autopitch points, obtained by flange detection techniques.
The name=value options may be specified in any order, and the entire string must be
        enclosed in quotes.
","
Inputs



entity_type

The entity types to find flanges in, to create connectors. Valid values are
            components.

mark_id

The mark ID containing the entities. Valid values are 1 and 2.

All option=value arguments may be specified in any order.


autopitch_feature_edge_distance=<value>

The distance from the feature edges for autopitch points.



autopitch_interval=<value>

Spacing between autopitch points. Points are not created if set to 0.0.



autopitch_offset=<value>

The initial offset for autopitch point. If set to 0.0,
              autopitch_interval/2 is used.



autopitch_to_edge_distance=<value>

The distance from the free edge for autopitch points.



consider_thin_solids=<value>

0 - Closed shell thin solids are not considered as input. Only standard shell
            midmeshes are considered.
1 - Closed shell thin solids are considered as input, along with standard shell
            midmeshes.



create_points_in_middle=<value>

0 - Autopitch points are created on one of the flanges
1 - Autopitch points are created at the midplane of flanges



feature_angle=<value>

Used to identify each connected sequence of feature edges. Specifically, a feature
            edge is one whose adjoining faces form an angle greater than this value. Acceptable
            values are [0.0, 180], otherwise closer extreme is used.

max_flange_width=<value>

The maximum flange width. Used only if it is greater than 0.0.

max_proximity_distance=<value>

The maximum proximity distance that can be used. Also, used as the tolerance value for
            connector creation.

max_variation_percent=<value>

The maximum percentage variation allowed in inter-flange distances, from the average
            inter-flange distance.

","Examples
To create connectors at the midplane of the components 1 and 2 using a feature angle of 30
        degrees, not considering closed shell thin solids as input, maximum flange width of 20.0,
        maximum proximity distance of 20.0, autopitch interval of 50.0, offset of 10.0, a distance
        from free edge of 10.0, with 0 maximum percentage variation allowed in inter-flange
        distances and a distance from the feature edges of 5.0:
*createmark comps 2 1 2
*CE_ConnectorCreateByAutopitchNew components 2 ""feature_angle=30 consider_thin_solids=0 max_flange_width=20.0 max_proximity_distance=20.0 autopitch_interval=50.0 autopitch_offset=10.0 autopitch_to_edge_distance=10.0 create_points_in_middle=1 max_variation_percent=0 auto_pitch_feature_edge_distance=5.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
110,*CE_ConnectorCreateByListAndRealizeWithDetails,"Description
Creates a certain style of connector at locations specified by a list, with certain rules
        and details, and realize the connectors using specified realization details.
","Inputs

entity_type
The entity type that specifies the location to create connectors. Valid values
            are:
Lines (for seam and area).
Nodes (for spot, bolt, seam and area).
list_id
The ID of the list containing the entities. Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are area, bolt, seam and spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are comps and surfs.
link_mark_id
The ID of the mark containing the link entities. Valid values are 1 and 2.
solver_name
The target solver for realization.
config
The element type used for realization. Valid values are:
2 - plot 
3 - weld 
5 - rigid 
21 - spring 
55 - rigidlink 
60 - bar2 
61 - rod 
70 - gap 
104 - quads 
1001 - custom


fe_type
The type ID for the current solver specified in the feconfig.cfg
            file. Only used for custom config 1001.
tolerance
The maximum distance allowed between the connector and each of its links during
            realization.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid creation parameters include:
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default).
1 - Offset connectors.
line_spacing=<value>
The spacing for spot or seam connectors on lines. Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elements (elems) or geometry (geom). Default
                  elems.
link_rule=<value>
The link rule. Valid values are now, at_fe_realize or none. Default none.
relink_rule=<value>
The relink rule. Valid values are id, name or none. Default none.
seam_area_group=<value>
Group flag for seam or area connector. 
0 - No (default).
1 - Yes.
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
0 - Do not offset tol (default).
1 - Use tol.Valid realization parameters include:

ce_appliedmass=<value>
The value of the applied mass. Default 0.0.
ce_appliedmassdis=<value>
The mass distribution type for apply mass: 
0 - Apply to all nodes (default). 
1 - Divide by nodes. 
2 - Divide by area. 
3 - Unit area.
ce_areaconstantthickness=<value>
The constant thickness when ce_areathicknesstype is 3.
                  Default 0.0.
ce_areathicknesstype=<value>
0 - (T1+T2)/2 (default). 
1 - Shell gap. 
2 - Mid-thickness. 
3 - Constant thickness.
ce_areastacksize=<value>
The density for area connectors. Default 0.
ce_boltmaxdiameter=<value>
The maximum diameter for a hole to be accepted as a bolt hole. Default
                  10.0.
ce_boltmindiameter=<value>
The minimum diameter for a hole to be accepted as a bolt hole. Default 0.0.
ce_configfile=<value>
The path and name of the FE configuration file. Default """".
ce_connectivity=<value>
0 - Mesh independent (default) 
1 - Mesh dependent + remesh 
2 - Mesh dependent + ensure projection 
3 - Mesh dependent + quad transition 
4 - Mesh dependent + projection and find nodes 
5 - Mesh dependent + find nearest nodes
ce_diameter=<value>
The diameter value for custom types (acm, cweld, mat100, and so on). Default
                  0.0.
ce_dvstfile=<value>
The path and name of the diameter vs thickness file. Default """".
ce_fevectorreverse=<value>
0 - Do not reverse the direction for seam connectors (default).
1 - Reverse the direction for seam connectors.
ce_forcecollinear=<value>
0 - Do not force collinear (default).
1 - Force collinear.
ce_nonnormal=<value>
0 - Normal projection (default).
1 - Non-normal projection.
ce_propertyid=<value>
The ID of the property to assign. Default 0.
ce_propertyscript=<value>
The path and name of the property script file. Default """".
ce_systems=<value>
0 - Do not build systems (default).
1 - Build systems.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create a seam connector at the location of node list 66 55 65 to connect components 1
        and 2 using a tolerance of 6.0 for Nastran:*createlist nodes 1 66 55 65
*createmark comps 2 1 2
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.000000""
*CE_ConnectorCreateByListAndRealizeWithDetails nodes 1 seam 2 comps 2 Nastran 2 0 10.0 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
111,*CE_ConnectorCreateByMark,"Description
Creates a certain style of connector at locations specified by a mark, with certain rules
        and details.
","Inputs

entity_type
The entity type that specifies the location to create connectors. Valid values
            are:
elems (for area)
lines (for spot, bolt, seam and area)
nodes (for spot, bolt and apply_mass)
points (for spot, bolt and apply_mass)
surfs (for area).
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are apply mass, area, bolt, seam, and
            spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are:
comps (for spot, bolt, seam, area or apply_mass)
elems (for spot or apply_mass)
nodes (for spot or apply_mass)
surfs (for spot, seam or area) 
tags (for spot or apply_mass)
link_mark_id
The ID of the mark containing the link entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. Valid parameters include:
area_mesh_size=<value>
The mesh size for area connectors when using surfs as the location. Default
                  10.0.
area_mesh_type=<value>
The mesh type for area connectors when using surfs as the location. 
0 - trias 
1 - quads 
2 - mixed 
3 - right trias
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default).
1 - Offset connectors.
line_spacing=<value>
The spacing for spot or seam connectors on lines. Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elements (elems) or geometry (geom). Default
                  elems.
link_rule=<value>
The link rule. Valid values are now, at_fe_realize or none. Default none.
relink_rule=<value>
The relink rule. Valid values are id, name or none. Default none.
seam_area_group=<value>
Group flag for seam or area connector. 
0 - No (default).
1 - Yes.
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
0 - Do not offset tol (default).
1 - Use tol.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create a spot connector at the location of node 10 to connect components 3 and 4 using a
        tolerance of
        6.0:*createmark nodes 1 10
*createmark comps 2 3 4
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.0""
*CE_ConnectorCreateByMark nodes 1 spot 2 comps 2 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
112,*CE_ConnectorCreateByMarkWithCC,"Description
Creates a connector from a mark and assigns a connectorcontrol/connectorcontroldefault.
","
Inputs


entity_type
The entity type that specifies the location to create connectors. Valid values
            are:
elems (for area)
lines (for spot, bolt, seam and area)
nodes (for spot, bolt and apply_mass)
points (for spot, bolt and apply_mass)
surfs (for area).
mark_id
The ID of the mark containing the entities.  Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are apply_mass, area, bolt, seam, and
            spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are:
comps (for spot, bolt, seam, area or apply_mass)
elems (for spot or apply_mass)
nodes (for spot or apply_mass)
surfs (for spot, seam or area)
tags (for spot or apply_mass)
link_mark_id
The ID of the mark of link entities.  Valid values are 1 and 2.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
area_mesh_size=<value>
The mesh size for area connectors when entity_type is surfs.
                  Default 10.0.
area_mesh_type=<value>
The mesh type for area connectors when entity_type is
                  surfs.
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default)
1 - Offset connectors
line_spacing=<value>
The spacing for spot or seam connectors on lines.  Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elems (default) or geom.
link_rule=<value>
Specifies the link rule. Valid values are now, at_fe_realize or none
                  (default).
relink_rule=<value>
Specifies the relink rule. Valid values are id, name or none (default).
seam_area_group=<value>
Flag for seam or area connector grouping:
0 - No (default)
1 - Yes
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
Flag for seam or area connector grouping:
0 - Do not use tol (default)
1 - Use tol


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
cc_type
The type of control to assign.  Valid values are connectorcontrol and
            connectorcontroldefault.
cc_name
The name of the connectorcontrol/connectorcontroldefault to assign.

","Examples
Create a spot connector at the location of node 10 to connect component 3 and 4 using a
        tolerance of 6.0 and assign connectorcontrol
        my_acm:*createmark nodes 1 10
*createmark components 2 3 4
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.000000""
*CE_ConnectorCreateByMarkWithCC nodes 1 ""spot"" 2 comps 2 1 5 connectorcontrol ""my_acm""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
113,*CE_ConnectorGroup,"Description
Group or ungroup seam connectors on mark to behave as a single/multiple seam
        connector(s).
","Inputs

connector_mark
The mark of connectors that needs to be updated.
group
Specifies if the individual connectors on the specified mark must be grouped to behave
            as a single connector.
1 = group
0 = ungroup

","Examples
Group the connectors 1, 2 and 3 on mark.
        *createmark(connectors, 1) 1 2 3
*CE_ConnectorGroup(1, 1)

The individual connectors are grouped only if the distance between their end points is
        within a small tolerance value. A valid case for grouping is when connectors are created
        from continuous line segments. The grouped connectors behave as a single connector (during
        realization the weld nodes are shared among adjacent test points of connectors in group). 
",
114,*CE_ConnectorLineCombine,"Description
Combines multiple line connectors to a single line connector.  In addition, the internal
        lines (within the connectors) are merged into a single internal line.
","
Inputs


mark_id
The ID of the mark of connectors.  Valid values are 1 and 2.
entity_type
The entity type that specifies the location to create connectors. Valid values are
            lines.
entity_mark_id
The ID of the mark containing the entities.  Valid values are 1 and 2.  If specified,
            set entity_list_id as 0.
entity_list_id
The ID of the list containing the entities.  Valid values are 1 and 2.  If specified,
            set entity_mark_id as 0.
ce_style
The style of connectors to create. Valid values are apply_mass, area, bolt, seam, and
            spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are:
comps (for spot, bolt, seam, area or apply_mass)
elems (for spot or apply_mass)
nodes (for spot or apply_mass)
surfs (for spot, seam or area)
tags (for spot or apply_mass)
link_mark_id
The ID of the mark of link entities.  Valid values are 1 and 2.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
area_mesh_size=<value>
The mesh size for area connectors when entity_type is surfs.
                  Default 10.0.
area_mesh_type=<value>
The mesh type for area connectors when entity_type is
                  surfs.
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_combine_option=<value>
The combine option for combining the two or more line
                    connectors:combine_smooth – Combines lines/connector with smooth
                    curve
combine_straight – Combines lines/connectors with straight
                    curve
combine_midline – Combines two lines/connectors as one midline
                    connector

line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default)
1 - Offset connectors
line_spacing=<value>
The spacing for spot or seam connectors on lines.  Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elems (default) or geom.
link_rule=<value>
Specifies the link rule. Valid values are now, at_fe_realize or none
                  (default).
relink_rule=<value>
Specifies the relink rule. Valid values are id, name or none (default).
seam_area_group=<value>
Flag for seam or area connector grouping:
0 - No (default)
1 - Yes
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
Flag for seam or area connector grouping:
0 - Do not use tol (default)
1 - Use tol


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To combine spot line connectors 1 and 2 , lines 3 and 4, and components links 1, 2, 3 and 4
        with combine_smooth
        option:*createmark connectors 1 1 2
*createmark lines 1 3 4
*createmark comps 2 3 4
*createstringarray 9 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=99.0"" ""line_density=0"" ""line_spacing=5.000000"" ""line_offset=0.000000"" ""line_combine_option=combine_smooth""
*CE_ConnectorLineCombine 1 lines 1 1 spot 2 comps 2 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
115,*CE_ConnectorLineCreate,"Description
Creates connector(s) on the lines at the given density or spacing. 
","Inputs

entities
Type to specify connector location.
Lines
markmask
Line mark for the line collector.
density
Integer number to split line into number of points. Spacing between points.
= line_length/density
spacing
Float number to split line into number of points with specified distance between
            points.
= spacing
half_spacing_offset
Create points from an offset (= spacing/2) from the start and end of line.
offset
Create points from an offset (= offset) from the start and end of line.

","Examples
Create a connector on line number 10 on mark 1 with a spacing of 2 and
          half_spacing_offset.*createmark(lines, 1) 10
*CE_ConnectorLineCreate(lines, 1, 0, 2.0, 1, 0)
Only one connector is created for each line at the center of the line and it is displayed
        as a cylinder.
",
116,*CE_ConnectorPartition,"Description
This command can be used to partition seam connectors. Each test point is tested for at
        least two available projections. This happens with respect to the tolerance specified on the
        connector or to the tolerance given in the command. The connectors become partitioned into
        passed and failed seam connector pieces. These connectors can be organized in different
        components and follow certain numbering rules. The original connectors can also be backed
        up.
","Inputs

connector_mark_id
The mark ID containing the connectors to update. Valid values are 1 and 2.
non_normal
0 - Use normal projection (recommended, <5° is considered normal).
1 - Use non-normal projection.
use_tol
Flag indicating the tolerance to use. 
0 - Use original tolerance.
1 - Use tolerance by tol.


tol
The tolerance to use if use_tol is 1.
passed_comp_type
The method to store the passed connectors.
0 - Passed connectors will be organized into the newly created component ""CE
                partition passed"".
1 - Passed connectors will be organized into the current component. 
2 - Passed connectors will be organized into the connectors' original component. 
3 - Passed connectors will be organized into the specified component
                  passed_comp.


passed_comp
The name of the component to use if passed_comp_type is 3.
number_passed_type
Method to renumber passed connectors. 
0 - Passed connectors will be renumbered/created beginning with the connector ID
                defined by passed_start_id. Any IDs already is use are skipped. 
1 - Passed connectors will be renumbered/created beginning with lowest available
                (unused) connector ID.


passed_start_id
Connector ID for renumbering the passed connectors when
              number_passed_type is set to 0.
failed_comp_type
The method to store the failed connectors. 
0 - Failed connectors will be organized into the newly created component ""CE
                partition failed"". 
1 - Failed connectors will be organized into the current component. 
2 - Failed connectors will be organized into the connectors' original component. 
3 - Failed connectors will be organized into the specified component
                  failed_comp.


failed_comp
The name of the component to use if failed_comp_type is 3.
number_failed_type
Method to renumber failed connectors. 
0 - Failed connectors will be renumbered/created beginning with the connector ID
                defined by failed_start_id. Any IDs already is use are
                skipped.
1 - Failed connectors will be renumbered/created beginning with lowest available
                (unused) connector ID.


failed_start_id
Connector ID for renumbering the failed connectors when
              number_failed_type is set to 0.
backup
Flag indicating whether to backup the original connectors before partitioning. 
0 - Do not backup.
1 - Backup.


backup_comp_type
The method to store the backup connectors if backup is 1. 
0 - Backup connectors will be organized into the newly created component ""^CE
                partition backup"". 
1 - Backup connectors will be organized into the specified component
                  backup_comp.


backup_comp
The name of the component to use if backup_comp_type is 1.

","Examples
Partition the connectors 1-100. This is done using a normal projection with a tolerance of
        20. The passed connectors will be moved into the original connector component and their IDs
        will continue. The failed connectors will be moved into the new ""CE partition failed""
        component, and will begin with ID 5000. No backup of the original connectors will be
        made.*createmark connectors 1 1-100
*CE_ConnectorPartition 1 0 1 20.0 2 """" 1 1 0 ""CE partition failed"" 0 5000 0 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
117,*CE_ConnectorSeamCreateUsingLinelist,"Description
Create seam connectors at specified locations by line list with certain rules.
","Inputs

line_list
Line entity selected either by list or path selection (must be a number = 1 or
            2).
density
Integer number to split line into number of points. Spacing between points (=
            line_length/density).
spacing
Float number to split line into number of points with specified distance between
            points (= spacing).
entity
Entity type to be added to the connector as a link.
surfs
comps
entitymark
Mark of entities to add to the connector as links.
ent_state
Link elements or geometry.
0 - geom
1 - elems


ce_rules
Rule to specify if and how a link entity is to be added to a connector.
0 - None
1 -  User select
2 - Proximity




ce_le_rule
Rule that specifies how an entity is to be remembered by the connector.
0 - None
1 - Use ID
2 - Use name


tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.


tolerance
Specified to add entities only with in the given tolerance from the specified
            connector (same as search radius in fe realize panel).
group
Specifies if the individual connectors created from continuous line segments must be
            grouped to behave as a single connector.
0 - Not grouped.
1 - Group.


parm1
For future use; only ""0"" is currently valid.
parm2
For future use; only ""0"" is currently valid.

","Examples
To create 2 seam connectors at the locations of line 1 and 2 to link components 3 and
        4:*createlist(Lines, 1) 1, 2
*createmark(Comps, 2) 3, 4
*CE_ConnectorSeamCreateUsingLinelist(1, 5, 0.0, Comps, 2, 1, 1, 1, 1, 10.0, 1, 0, 0.0)
This command is outdated, and *CE_ConnectorCreateByList() is recommanded
        to be used for creating seam connector. 
A created seam connector is displayed as a line with cylinder like icons at each of the
        test points (at the specified spacing) with the closest components added to it. The total
        number of layers supported by seam connector is two.
",
118,*CE_ConnectorSeamTrim,"Description
Trim/split seam connectors using nodes.
","Inputs

mark_id
The ID of the mark containing the seam connectors to trim. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the trim/split nodes. Valid values are 1 and 2.
tolerance
The tolerance value used to snap the nodes to the point of seam connectors when snap
            is 1.
snap
0 - Do not snap nodes to seam connectors.
1 - Snap nodes to seam connectors.
mode
0 - Split seam connectors.
1 - Trim seam connectors.

","Examples
To split seam connector 101 using node
        1001:*createmark connectors 1 101
*createmark nodes 1 1001
*CE_ConnectorSeamTrim 1 1 0.5 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
119,*CE_ConnectorSetVectorByMark,"Description
Set projection vector for connectors specified by mark. 
","Inputs

markmask
The mark of the connectors.
type
The method to set the vector: 
0 - use i (see next argument). 
1 - use j (see next argument). 
2 - use k (see next argument).
i
1st of 3 float number defining a vector.
j
2nd of 3 float number defining a vector.
k
3rd of 3 float number defining a vector.
vector
HyperMesh Vector entity ID.
node1
1st node ID to define a vector in HyperMesh.
node2
2nd node ID to define a vector in HyperMesh

","Examples
To set a projection vector for connector 1, 2, 3 using vector
        3:*createmark(connectors, 1) 1, 2, 3
*CE_ConnectorSetVectorByMark(1, 1, 0, 0, 0, 3, 0, 0) 
Projection vector for a connector will be used during realization process.
",
120,*CE_ConnectorTrimAdvanced,"Description
longDescription
","
Inputs


style
The style of connectors to edit. Valid values are area, seam and spot.
mark_id
The ID of the mark of connectors. Valid values are 1 and 2.
node_mark_id
The ID of the mark of nodes. Valid values are 1 and 2.
tolerance
The tolerance value used to snap the nodes to the point of spot connectors when
              snap is 1.
snap
0 - Do not snap nodes to spot connectors
1 - Snap nodes to spot connectors
mode1
0 - Split
1 - Trim
mode2
0 - None
1 - Create trim/split connector with location node entities
2 - Create trim/split connectors with location line entities

","Examples
To split spot connector 101 using node
        1001:*createmark connectors 1 101
*createmark nodes 1 1001
*CE_ConnectorTrimAdvanced spot 1 1 0.5 1 0 0
To trim seam connector 102 using node
        1002:*createmark connectors 1 102
*createmark nodes 1 1002
*CE_ConnectorTrimAdvanced seam 1 1 0.5 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
121,*CE_ConvertByMark,"Description
Converts between bolt and spot connectors.
","Inputs

mark_id
The ID of the mark containing the connectors to convert. Valid values are 1 and 2.
source_style
The source connector style.
spot
bolt
target_style
The target connector style.
spot
bolt
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Examples
To convert spot connectors 101 and 102 to bolt
        connectors:*createmark connectors 1 101 102
*CE_ConvertByMark 1 ""spot"" ""bolt"" 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
122,*CE_ConvertLinksByMark,"Description
Converts connector links to a new entity type.
","Inputs

mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
target_entity_type
The entity type to which the link is converted. Valid values are:
comps
props 
parts
link_index
The index of the link to be converted, starting from 0.
-1 - all links are converted
?target_link_rule?
The optional rule to set for the converted link entity. Valid rules are:
0 - Undefined
1 - None
2 - Use ID
3 - Use name
4 - Proximity
5 - Use UID
?target_link_state?
The flag to set for the link entity that specifies if you are connecting to mesh or to
            geometry. The supported values are:
0 - Undefined
1 - Connect to mesh
2 - Connect to geometry
?keep_current_state?
Optional option to keep the current connector state after the update operation. Valid
            states are:
0 - Unrealize if needed (default)
1 - Keep current state

","Examples
To convert all displayed connectors at link index 0 to part
        links:*createmark connectors 1 displayed
*CE_ConvertLinksByMark 1 parts 0
To convert all links of connector 3 to part
        links:*createmark connectors 1 3
*CE_ConvertLinksByMark 1 parts -1
To convert all links of displayed connectors to part links using the UID
        rule:*createmark connectors 1 displayed
*CE_ConvertLinksByMark 1 parts -1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
123,*CE_CreateNodeOnSpotConnector,"Description
Creates a node on a spot line connector at a given position.  This node can then be used to
        trim the spot line connector at that location. To create a node with a mouse click on a
        connector, the x, y, and z values
        should all be passed as -1.
","
Inputs


mark_id
The ID of the mark of spot line connectors to trim.  Valid values are 1 and 2.
x
The x position on the spot line connector.
y
The y position on the spot line connector.
z
The z position on the spot line connector.

","Examples
To create a temp node on spot line connector 101 at (100, 50,
        50):*createmark connectors 1 101
*CE_CreateNodeOnSpotConnector 1 100 50 50
To create a temp node on spot line connector 101 at a mouse click
        position:*createmark connectors 1 101
*CE_CreateNodeOnSpotConnector 1 -1 -1 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
124,*CE_DetailDeleteByMark,"Description
Delete connector details (stored in connector metadata) from connectors specified by mark. 
","Inputs

markmask
Mark containing the connectors to delete details from.
detailType
Detail type to delete: 
int
uint
double
string
triple
detailName
The name of the detail to delete.
unknownFlag
For future use (must be 0).

","Examples
To delete user defined integer detail named ""test"" for connectors 1,
        2:*createmark(connectors, 1) 1, 2
*CE_DetailDeleteByMark(1, int, ""test"", 0)
The following commands can be used to set user-defined
        details:*CE_DetailSetUint()
*CE_DetailSetInt()
*CE_DetailSetDouble()
*CE_DetailSetString()
*CE_DetailSetTriple()
",
125,*CE_DetailSetDouble,"Description
Sets a double connector detail for a single connector.
","Inputs

connector_id
The ID of connector to update.
detail_name
The name of the standard double detail, or user-defined double detail, to update.
            Standard double details include:
ce_appliedmass
The mass value to be applied.
Value ≥ 0
ce_areaconstthickness
The constant thickness (for area connectors).
Value ≥ 0
ce_aspect
Fail hexas with aspect ratio greater than this value.
Value ≥ 0
ce_bl_connection_ang
The maximum angle allowed between two shells for B connection.
Value ≥ 0
ce_bodylen
The bolt body length.
Value ≥ 0
ce_boltmaxdiameter
The maximum diameter to be considered a bolt hole.
Value ≥ 0
ce_boltmaxfeatureangle
The maximum feature angle to identify a solid bolt hole.
Value ≥ 0
ce_boltmindiameter
The minimum diameter to be considered a bolt hole.
Value ≥ 0
ce_boltminfeatureangle
The minimum feature angle to identify a solid bolt hole.
Value ≥ 0
ce_boltthread
The bolt thread length.
Value ≥ 0
ce_centered_quad_pos_tol
The quad position tolerance.
Value ≥ 0
ce_centered_quad_scale_tol
The quad scale tolerance.
Value ≥ 0
ce_centered_quad_size_tol
The quad size tolerance
Value ≥ 0
ce_centered_quad_translate_tol
The quad translate tolerance.
Value ≥ 0
ce_cylinder_diameter
Define cylinder using this value as diameter.
Value ≥ 0
ce_cylinder_diameter_factor
Define the cylinder using this value as a factor.
Value ≥ 0
ce_dia_factor
The cylinder bolt diameter factor.
Value ≥ 0
ce_diameter
The diameter required by the realization.
Value ≥ 0
ce_fe_capangle
The angle between an ending cap element face and shell edge.
Value ≥ 0
ce_fe_const_height
The hexa constant thickness.
Value ≥ 0
ce_fe_depth
The penta width.
Value ≥ 0
ce_fe_factor_a
The hexa thickness, by multiplying this value using the smallest shell
                  thickness.
Value ≥ 0
ce_fe_factor_b
The hexa position, by adding this value using the half of the thickness.
Value ≥ 0
ce_fe_featureangle
The feature break angle for locating RBE3 nodes.
Value ≥ 0
ce_fe_hexa_to_washer_offset
The offset from the hexa boundary to the washer inner diameter.
Value ≥ 0
ce_fe_height
The quad position in the vertical direction.
Value ≥ 0
ce_fe_maint_gaps
The gap value between a hexa face and a shell.
Value ≥ 0
ce_fe_offsetangle
The angle between quad and vertical direction.
Value ≥ 0
ce_fe_rbe3radius
The radius defining the circular area for locating RBE3 nodes.
Value ≥ 0
ce_fe_runoffangle
The deviating angle of the quad next to an ending cap element.
Value ≥ 0
ce_fe_tapered_t_angle
The angle of the tapered T weld.
Value ≥ 0
ce_fe_tapered_t_d
The thickness of the tapered T weld.
Value ≥ 0
ce_fe_tapered_t_h
The height of the tapered T weld.
Value ≥ 0
ce_fe_tapered_t_h1
The height of the tapered T weld.
Value ≥ 0
ce_fe_tapered_t_h2
The width of the tapered T weld.
Value ≥ 0
ce_fe_width
The penta depth.
Value ≥ 0
ce_hexa_position_distance
Move hexa by this distance from default position.
Value ≥ 0
ce_jacobian
Fails hexas with Jacobian less than provided value.
Value ≥ 0
ce_l1
The cylinder bolt length for L1 direction.
Value ≥ 0
ce_l1d1
The cylinder bolt diameter for L1 direction.
Value ≥ 0
ce_l2
The cylinder bolt length for L2 direction.
Value ≥ 0
ce_l2d2
The cylinder bolt diameter for L2 direction.
Value ≥ 0
ce_lt_connection_ang
The minimum angle allowed between two shells for T connection.
Value ≥ 0
ce_new_diameter
The diameter value used for punching a new bolt hole during realization.
Value ≥ 0
ce_no_hole_diameter
The diameter value when there is no hole during realization.
Value ≥ 0
ce_normal_angle
The deviation angle allowed for normal projection.
Value ≥ 0
ce_offset
Line connector end offset value.
Value ≥ 0
ce_quad_size
The quad size for the quad transition.
Value ≥ 0
ce_seam_break_len
The break length before the next weld.
Value ≥ 0
ce_seam_elem_len
The hexa element length.
Value ≥ 0
ce_seam_discontinuity_lower_tol
The lower bound tolerance allowed by the weld length.
Value ≥ 0
ce_seam_discontinuity_upper_tol
The upper bound tolerance allowed by the weld length.
Value ≥ 0
ce_seam_weld_len
The weld length before the next break.
Value ≥ 0
ce_spacing
The spacing value for a line or seam connector.
Value ≥ 0
ce_tolerance
The tolerance value specified during connector FE realization.
Value ≥ 0
ce_washer_elem_size
The element size around a bolt hole.
Value ≥ 0
ce_washer_scale_1
The 1st washer's width using a scale of bolt radius.
Value ≥ 0
ce_washer_scale_2
The 2nd washer's width using a scale of bolt radius.
Value ≥ 0
ce_washer_width_1
The 1st washer's width using this value.
Value ≥ 0
ce_washer_width_2
The 2nd washer's width using this value.
Value ≥ 0


double_value
The double value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the tolerance to 10.0 for connector
        1:*CE_DetailSetDouble 1 ce_tolerance 10.0 0 0
To set a user-defined double detail ""test"" to a value of 5.0 for connector
        2:*CE_DetailSetDouble 2 ""test"" 5.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
126,*CE_DetailSetInt,"Description
Sets an integer connector detail for a single connector. 
","Inputs

connector_id
The ID of connector to update.
detail_name
The name of the standard integer detail, or user-defined integer detail, to update.
            Standard integer details include:
ce_adjust_diameter
Has different meaning based on ce_hole_option value. 
Case 1: Options to adjust hole diameter during realization. 
0 - Create hole diameter (2D).
1 - Create and adjust hole diameter (2D).


Case 2: Options to use the new diameter during realization.
0 - Do not adjust hole diameter.
1 - Adjust hole diameter (2D).


ce_adjust_hole
Flag to specify whether to adjust the hole or the realization to make the
                  connection successful.
0 - Adjust realization.
1 - Adjust hole position (2D).


ce_allow_recenter
Recenter CWELD elements.
0, 1
ce_allowadjacent
Flag to allow adjacent projections.
0, 1
ce_appliedmassdis
Applied mass distribution type.
0, 1
ce_areastacksize
Density for area connector.
Value ≥ 0
ce_areathicknesstype
Thickness type for area connector.
0, 1
ce_aspect_flag
Fail hexa seam or area, as per aspect ratio check.
0, 1
ce_centered_quad
Allow centered quad mesh imprint.
0, 1
ce_collectorid
Component ID of the connector entity.
ce_configval
FE configuration value of the realized connector.
Value ≥ 0
ce_connectivity
FE connectivity.
0 - Mesh independent 
1 - Mesh dependent + remesh 
2 - Mesh dependent + ensure projection 
3 - Mesh dependent + quad transition 
4 - Mesh dependent + projection and find nodes 
5 - Mesh dependent + find nearest nodes


ce_cweld_option
CWELD options.
1 - GRIDID 
2 - ELEMID 
3 - PARTPAT 
4 - ELPAT 
5 - ALIGN


ce_cweld_suboption
Sub-options for CWELD. The use/availability of sub-options is dependent on
                    ce_ceweld_option.
1 - GA-GB 
2 - GS (face to face) 
3 - GS (point to face)


ce_density
The line or seam density value.
Value ≥ 0
ce_fefactorreverse
Vector reverse flag for seam connectors.
0, 1
ce_fe_acm_numhexa
Hexa cluster pattern.
1 - 1 hexa 
4 - 4 hexa 
8 - 8 hexa 
12 - 12 hexa 
16 - 16 hexa 
32 - 32 hexa


ce_fe_createcap
Allow to create cap elements in the begining and end.
0, 1
ce_fe_density
Number of coats of hexas.
Value ≥ 0
ce_fe_edgesnapping_l
Tolerance options to determine snapping to edge in L connection.
0 - no 
1 - maximum 1 element row 
2 - maximum 2 element rows


ce_fe_edgesnapping_t
Tolerance options to determine snapping to edge in T connection.
0 - no 
1 - maximum 1 element row 
2 - maximum 2 element rows


ce_fe_normal_wt_cal
Allow to normalize RBE3 weights.
0, 1
ce_fe_orthohexa
Allow to make orthogonal faces for a single hexa.
0, 1
ce_fe_proj_hexa_face
Allow to project hexa faces to shell planes.
0, 1
ce_fe_rows
Number of rows of realization.
Value ≥ 0
ce_fe_sharpcorner
Allow a sharp corner during mesh imprint.
0, 1
ce_fe_strips
Number of strips of realization.
Value ≥ 0
ce_fe_tapered_t_input
Options to input parameters for tapered T.
0 - thickness dependent 
1 - angle, H and D 
2 - H1, H2 and D


ce_fe_thck_flag
Options to position hexa between shells. This has different meanings under
                  different realization types.
For spots:
1 - equival (T1+T2)/2 
2 - detached (T1+T2)/2 
3 - shell gap 
4 - mid thickness 
5 - const thickness 
7 - maintain gaps


For seams:
0 - (T1+T2)/2 
1 - shell gap 
2 - mid thickness 
3 - const thickness 
6 - maintain gaps


ce_fesolver
FE solver number.
Value  > 0
ce_fetype
Type value for realized connector as defined in
                    feconfig.cfg file.
Value ≥ 0
ce_fileattribute_opt
File attribute option.
1 - From search file 
2 - From current model 
3 - From connector metadata""


ce_fill_hole
Allow to fill any 2D bolt holes during realization.
0, 1
ce_fill_hole_num
Number of pie pieces to fill a bolt hole during realization.
Value ≥ 0
ce_fill_hole_pattern
Options to what pattern is used to fill a bolt hole during realization.
-1 - pie pieces preserve 
0 - pie pieces= 
1 - 3 quads 
2 - 4 quads 
3 - 9 quads 
4 - 12 quads 
5 - 16 quads 
6 - 60 quads


ce_folderattribute_opt
Folder attribute option.
1 - From search folder 
2 - From current model 
3 - From connector metadata""


ce_forcecollinear
FE force collinear flag.
0, 1
ce_half_spacing
Half spacing offset flag for seams and lines.
0, 1
ce_hexa_position_opt
Options to determine hexa position related to edge.
0 - midpoint 
1 - offset from edge 
2 - positive edge 
3 - negative edge


ce_hexa_tapered_t_position_opt
Options to determine hexa position related to edge.
0 - connector side 
1 - positive side 
2 - negative side 
3 - element normal


ce_hexaoffsetcheck
Consider shell thickness and offset for solid positioning.
0, 1
ce_hole_option
Bolt hole determination options.
0 - consider existing hole only. 
1 - create hole, if none. 
2 - use hole, if available. 
3 - fill and remesh hole, if available.


ce_jacobian_flag
Fail hexa seam or area, as per Jacobian check.
0, 1
ce_layers
The number of thickness layers.
Value ≥ 0
ce_link_option
Link position related to seam connector.
0 - closest 
1 - opposite


ce_n_node_flag
Limit the number of nodes per layer.
0, 1
ce_nonnormal
Allow non-normal projections.
0, 1
ce_num_nodes_per_layer
The number of nodes per layer.
Value ≥ 0
ce_pass_through_ce
Force weld going through connector position.
0, 1
ce_penta_fit_option
Options to fit penta between shells.
1 - fitted 
2 - equilateral 
3 - equilateral/fitted


ce_penta_right_angled
Allow to create right-angled pentas.
0, 1
ce_penta_side_option
Options to the side(s) of penta location.
1 - positive side 
2 - negative side 
3 - both sides


ce_property_option
Property assignment options.
0 - no property 
1 - select property


ce_propertyid
FE property ID.
Value ≥ 0
ce_realizeto
Organize realization results options.
0 - elems to current comp 
1 - elems to connector comp


ce_remesh
Mesh dependent flag.
0, 1
ce_seam_discontinuity
Allow to create discontinuous hexas.
0, 1
ce_snaptonode
FE snap to node flag.
0, 1
ce_spot_rbe_radius_option
Allow to define a circle area to locate nodes for RBE3s.
0, 1
ce_state
Connector entity state.
0, 1
ce_style
Connector style.
0, 1
ce_systems
FE build system flag.
0, 1
ce_trimsurfeachside
Trim surfaces on each side flag for area connector.
0, 1
ce_usercontrol
User control flag.
0, 1
ce_washer_elems
Number of elements of washers.
ce_washer_elems_num
Number of elements around bolt hole.
Value ≥ 0


integer_value
The integer value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the thickness (number of layers) to 3 for connector
        1:*CE_DetailSetInt 1 ce_layers 3 0 0
To set a user-defined double detail ""test"" to a value of 5 for connector
        2:*CE_DetailSetInt 2 ""test"" 5 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
127,*CE_DetailSetString,"Description
Sets a string connector detail for a single connector.
","Inputs

connector_id
The ID of connector to update.
detail_name
The name of the standard string detail, or user-defined string detail, to update.
            Standard string details include:
ce_collectorname
The component name of the connector entity.
ce_configname
The FE config name of the realized connector.
ce_connectivity
The connector FE connectivity.
independent
FE connectivity
dependent
use_shell_node, etc...


ce_fesolver
The FE solver name.
Nastran
ce_fetypename
The realized FE type name defined in the feconfig.cfg
                  file.
ce_fe_fileattribute_entids
The entity IDs related to the file attribute option.
entity_type ID_1 ID_2 ... (example: ""materials 3 6 7"")


ce_fe_folderattribute_entids
The entity IDs related to the folder attribute option.
entity_type ID_1 ID_2 ... (example: ""materials 3 6 7"")


ce_positionstring
A list containing the entity type, followed by the entity IDs selected to create
                  the connector.
ce_propertyscript
The user property script used for realization.
Full absolute path and file name.
ce_state
The connector entity state.
failed
realized
unrealized


ce_style
The connector style.
app_mass
area
bolt
seam
spot


ce_type
The connector entity type based on its creation.
area
line
node/point
seam




string_value
The string value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the user property script for connector
        1:*CE_DetailSetString 1 ce_propertyscript ""C:/temp/scripts/connectors/test.tcl"" 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
128,*CE_DetailSetTriple,"Description
Sets a triple connector detail for a single connector.
","Inputs

connector_id
The ID of connector to update.
detail_name
The name of the standard triple detail, or user-defined triple detail, to update.
            Standard triple details include:
ce_dircords
The coordinates of the direction node.


ce_ijk
The vector definition used for realization.


triple_value1
The first triple value to update for the detail.
triple_value2
The second triple value to update for the detail.
triple_value3
The third triple value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the projection vector to (0.0, 1.0, 0.0) for connector
        1:*CE_DetailSetTriple 1 ce_ijk 0.0 1.0 0.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
129,*CE_DetailSetUint,"Description
Sets an unsigned integer as connector detail for a connector specified by ID.
","Inputs

ce_id
ID of the connector to which you wish to attach detail.
detailName
Name for a user-defined unsigned integer detail.
unit_val
The unsigned integer value for the detail.
unknownFlag
Reserved for future use. Must be set to 0.
force_storage_flag
The flag indicating whether or not to store a user-defined detail.
1 =  yes 
0 = no

 .

","Examples
To set a user-defined unsigned integer detail ""test = 2.0"" for connector
        1:*CE_DetailSetUint(1, ""test"", 2.0, 0, 1)
There are currently no standard unsigned integer details, only user-defined ones.
",
130,*CE_EditSeamAndLineDetail,"Description
Edit density, spacing and offset details for seam or line spot connectors specified by
        mark.
","Inputs

ce_markmask
The mark of connectors that needs to be updated.
density
Integer number to split line into number of points. Spacing between points (=
            line_length/density).
spacing
Float number to split line into number of points with specified distance between
            points (= spacing).
half_spacing_offset
Create points from an offset (= spacing/2) from the start and end of line ().
0 = true
1 = false


offset
Create points from an offset (= offset) from the start and end of line.
param1
For future use (must be 0).
param2
For future use (must be 0.0).

","Examples
To set density=10 and offset=1.5 for line connectors 1, 2 and 3:
        *createmark(connectors, 1) 1 2 3
*CE_EditSeamAndLineDetail(1, 10, 0.0, 0, 1.5, 0, 0.0)
The specified details are modified, only if the previous values were not the same. The
        modified connectors are unrealized since editing details affects realization. 
This command is outdated. *CE_DetailSetInt() and
          *CE_DetailSetDouble() are recommended for the purpose of setting
        details for a seam connector.
",
131,*CE_ExportFile,"Description
This command exports selected connectors in the native XML/ASCII format. The exported connectors file in XML format can be
        viewed either in an internet browser or in XML notepad. The ASCII format file can be viewed in any text viewer.
","Inputs

mark_id
The ID of the mark containing the connectors to export. Valid values are 1 and 2.
ce_style
Filter the specific type of connector to exported. Valid values are: 
all
spot
bolt
apply_mass
seam
area


filename
The full path and filename of the output file (.xml or
              .mcf extension).
header_string
Optional string information that is written out only in ASCII export.
with_md
Flag to indicate whether to write metadata information. Valid values are: 
0 - Metadata is not written 
1 - Metadata is written


options
Export format: 
1 - ASCII (.mcf)
3 - XML (.xml)


reserved1
Reserved for future use. Must be set to """".
reserved2
Reserved for future use. Must be set to 0.

","Examples
To export all of the displayed connectors in XML format to the file
          C:/ce_info.xml, including all
        metadata:*createmark connectors 1 ""displayed""
*CE_ExportFile 1 ""all"" ""C:/ce_info.xml"" """" 1 3 """" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
132,*CE_ExportMasterConnectorsFile,"Description
This command exports selected connectors information into a master connectors file.
","Inputs

mark_id
The ID of the mark containing the connectors to export. Valid values are 1 and 2.
filename
The full path and filename of the output file.
header_string
Optional string information to include in the header. It must start with a # or $
            sign.
with_md
Indicates whether to write metadata information. Valid values are: 
0 - Metadata is not written 
1 - Metadata is written



","Examples
To export all of the displayed connectors to a master connectors file named
          C:/ce_info.txt, including all metadata, with a
        header:*createmark connectors 1 ""displayed""
*CE_ExportMasterConnectorsFile 1 ""C:/ce_info.txt"" ""#mcf file"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
133,*CE_FE_1DQuality,"Description
Checks the quality of 1D elements (welds) created by realizing connector entity (CE). It
        places all failed connectors on an output mark and highlights them. 
","Inputs

ce_inmark
Mark of displayed connectors.
entities
Only quality checks for Elements are now supported.
outputmark
All connectors that contain FE (welds) that failed quality check criteria are placed
            on this mark. Mark contains only connectors.
free1d
Check if any connectors realized welds that are not connected to the mesh. 
1 - turned on.
length_flag
Check if the length of FE (welds) exceeds a certain value specified by the
              length parameter. 
1 - turned on.
length
The value of the length of the weld that should not be exceeded. Used in conjunction
            with length_flag.
angle_flag
Check if the angle between the FE (welds) and the shell element normal exceeds the
            values pecified by the angle parameter. 
1 - turned on.
angle
The orientation that the weld should not exceed with respect to the shell normal. A
            proper weld is oriented along the shell normal. Used in conjunction with
              angle_flag.

","Examples
To check all the quality options of FE (weld elements) in a realized connector with IDs 1,
        2, and 3. Let the value of length be 3.0 and the value of the angle be 12.0. The failed
        connectors are placed on mark 2 and highlighted.
        *createmark(connectors,1) 1 2 3
*CE_FE_1DQuality(1,elements,2,1,1,3.0,1,12.0)
",
134,*CE_FE_Absorb,"Description
Absorbs certain FE information into connectors.
","Inputs

create_flag
0 - Spot connectors 
1 - Seam/area connectors
curr_solver
The current solver name.
num_body_cfgs
The size of the connector body configuration list.
body_cfgs
The connector body configuration list. Must be enclosed in quotes.
num_head_cfgs
The size of the connector head configuration list.
head_cfgs
The connector head configuration list. Must be enclosed in quotes.
elem_filter
A flag indicating whether to use the displayed or selected elements:0 - Displayed
            elements 
1 - Selected elements. An integer array containing the element IDs must be created
            using the *createarray command.
elem_filter_size
Integer indicating the size (number of elements) in the elem_filter
            array created using *createarray.
string_array
A string array containing optional details for absorb. 
Spot connectors:
check_for_material=<value>
0 - Do not check for material for mat100 (hexa)
1 - Check for material for mat100 (hexa)
combine=<value>
0 - Do not combine in case of equivalent body nodes
1 - Combine in case of equivalent body nodes
conn_at_centernode=<value>
0 - Do not enable Connector at Centernode for rbe3 (load transfer)
1 - Enable Connector at Centernode for rbe3 (load transfer)
force_proj=<value>
0 - Do not enable ACM pattern recognition
1 - Enable ACM pattern recognition
link_by_card=<value>
0 - Do not find link entities by card
1 - Find link entities by card
link_by_interface=<value>
0 - Do not find link entities by interface
1 - Find link entities by interface
mcf=<file>
The file name for the master connection file.
org=<value>
0 - Use current component 
1 - Move connectors to FE component
rul=<rule>
The re-connect rule ""None"", ""User id"" or ""User name"".
shell_connect=<type>
""body"", ""head"", ""projs"", or ""none"".
t_connect=<type>
""body"", ""head"", ""projs"", or ""none"".
thickness_type=<type>
The spot connector thickness type:
1 - equival (T1+T2)/2 
3 - shell gap 
5 - const thickness
tol=<value>
The maximum distance allowed between the connector and each of its links.
type2_interface=<value>
0 - Do not find link entities by interface for type2 (spring)
1 - Find link entities by interface for type2 (spring)
weld_cfg_name=<name>
The type of FE realization that needs to be converted to connectors.
weld_type_num=<id>
The selected weld type ID.
weld_type_name=<name>
The selected weld type name.


Seam/area connectors:
area_absorption=<value>
0 - Do not absorb as area 
1 - Absorb as area if possible
area_headonly=<value>
0 - Do not only absorb FE with heads as area 
1 - Only absorb FE with heads as area
area_in_middle=<value>
0 - Do not move area to the middle position 
1 - Move area to the middle position
cluster_identify=<value>
0 - Do not absorb single element cluster as area 
1 - Absorb single element cluster as area
group_links=<value>
0 - Do not organize the links into two groups 
1 - Organize the links into two groups
mcf=<file>
The file name for the master connection file.
org=<value>
0 - Use current component 
1 - Move connectors to FE component
rul=<rule>
The re-connect rule ""None"", ""User id"" or ""User name"".
seam_absorption=<value>
0 - Do not absorb as seam 
1 - Absorb as seam if possible
seam_headonly=<value>
0 - Do not only absorb FE with heads as seam 
1 - Only absorb FE with heads as seam
select_special=<value>
0 - Do not enable enhanced approach 
1 - Enable enhanced approach
tie_contact=<value>
0 - Do not enable With tie contact 
1 - Enable With tie contact
tol=<value>
The maximum distance allowed between the connector and each of its links.


number_of_strings
The size of the options string array.

","Examples
Absorb spot connectors:
*createarray 1 0
*createstringarray 10 ""weld_type_num=74"" ""weld_type_name=acm (general) "" ""weld_cfg_name=custom"" ""shell_connect=head"" ""t_connect=body"" ""mcf="" ""org=0"" ""rul=None"" ""tol=20.0"" ""thickness_type=1""
*CE_FE_Absorb 0 ""nastran"" 1 ""208"" 1 ""56"" 1 1 1 10
Absorb seam connectors:
*createarray 1 0
*createstringarray 11 ""seam_absorption=1"" "" seam_headonly=1"" ""area_absorption=0"" ""area_headonly=0""  ""area_in_middle=1"" ""cluster_identify=0"" ""mcf="" ""org=0"" ""rul=None"" ""tol=20.0"" ""group_links=0""
*CE_FE_Absorb 1 ""nastran"" 2 ""208 206"" 0 """" 1 1 1 11
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
135,*CE_FE_CreateDCC,"Description
Creates all connector control default entities.
","
Inputs


reserved
Reserved for future use, must be set to 0.

","Examples
To create all connector control default entities:
*CE_FE_CreateDCC 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
136,*CE_FE_CreateUCCFromDCC,"Description
Creates a connector control from a connector control default.
","
Inputs


cc_name
The name of the connector control to create.
ccd_name
The name of the connector control default to use.

","Examples
Create a connector control named ""my_acm"" from the connector control default
        ""acm_(general)_spot_nastran_template"":
*CE_FE_CreateUCCFromDCC ""my_acm"" ""acm_(general)_spot_nastran_template""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
137,*CE_FE_GlobalFlags,"Description
Set global flags for connectors to perform different operations.
","Inputs

ce_fe_flag
0 - false
1 - true 
function
A function value of (0) sets the global flag to delete FE with
            connectors. If ce_fe_flag is true, the realized FE is deleted with
            connectors. If it is false, then only connectors are deleted.

","Examples
Set the global flag to delete FE with
        connectors:*createmark(connectors, 1) 1 2 3
*CE_FE_GlobalFlags(1, 0)
*deletemark(connectors, 1)
When trying to delete FE with connectors, this command needs to be called before the
        connector delete function.
",
138,*CE_FE_RealizeWithDetails,"Description
Realize existing connectors, using specified details.
","Inputs

ce_mark
The mark containing the desired connector entities.
ce_style
Connector style: 
spot
bolt
apply mass
seam
area


solvername
The solver for which the connectors must be realized.
config
The element realization type:
2 - plot 
3 - weld 
5 - rigid 
21 - spring 
55 - rigidlink 
60 - bar2 
61 - rod 
70 - gap 
104 - quads 
1001 - custom


fe_type
The type ID for the current solver specified in the FE configuration file (for custom
            config 1001 only)
collectorflag
The collector that should contain the results of realization: 
0 - currently selected collector 
1 - connector’s collector


tolerance
The maximum distance allowed between the connector and each of its links during
            realization.
options
A string array specifying optional details for realization:


 Detail
Default
Meaning




ce_propertyid
0
Property ID value


ce_systems
0
build system flag: 0=do not build systems
1=build
                      systems



ce_connectivity
0
Connectivity type:0 - mesh independent
mesh dependent + remesh
mesh dependent + ensure projection
mesh dependent + quad transition
mesh dependent + projection and find nodes
mesh dependent + find nearest nodes





ce_forcecollinear
0
Collinear flag0 = non-collinear
1 = collinear



ce_nonnorma
0
Nonnormal projection:0 = normal
1 = nonnormal



ce_diameter
0.0
Diameter value for some custom types (acm, cweld, mat100 etc.)


ce_areathicknesstype
0
Area connector thickness type:0 = (T1+T2)/2
1 = shell
                        gap
2 = mid thickness
3 = const thickness



ce_areaconstthickness
0.0
Const thickness value for area connectors.


ce_areastacksize
0
Density for area connectors.


ce_boltmindiameter
0.0
Minimum diameter for a hole to be accepted as a bolt hole.


ce_boltmaxdiameter
10.0
Maximum diameter for a hole to be accepted as a bolt hole.


ce_appliedmass
0.0
Mass value assigned to applied masses.


ce_appliedmassdis
0
Mass distribution type for apply mass:0= all nodes
1= divide by
                        nodes
2= divide by area
3= unit area



ce_configfile
""""
fe configuration file.


ce_dvstfile
""""
diameter vs thickness file


ce_propertyscript
""""
property script file


ce_fevectorreverse
0
Reverse direction flag for seam connectors: 0 = no reverse 
1 =
                        reverse






options_size
The size of the options string array.

","Examples
To realize connectors 1, 2 using a LS-DYNA mat100 config type and
        the details specified in a string
        array:*createmark(connectors,1) 1, 2
*createstringarray(6) ""ce_systems=0"" ""ce_connectivity=0"" ""ce_nonnormal=0"" ""ce_configfile=C:/Altair/hw8.0/hm/bin/feconfig.cfg"" ""ce_diameter=0.000000"" ""ce_propertyscript=C:/Altair/hw8.0/hm/scripts/connectors/prop_mat100.tcl""
*CE_FE_RealizeWithDetails(1,""spot"",""dyna"",1001,100,0,6,1,6)
Note that the example above uses the custom config type (1001) to defined the LS-DYNA mat100 realization.
",
139,*CE_FE_RegisterAdvanced,"Description
Registers pre-existing FE to multiple connector IDs. Successfully registering pre-existing
        FE forces a connector to its realized state. 
To use this command, a connector must be in user control mode. Also, note that a single FE
        entity can be registered with, at most, a single connector. Any FE registered with a given
        connector is treated as part of that connector’s realization.
","Inputs

entity_type
The FE type to be registered. Supported types are elements, systems, vectors, loads
            and equations. 
integer_array
The ID of the integer array that contains the input data. The integer array is created
            using the *createarray command. This should always be set to 1. 
The array is a list of the following variables repeated in the following order: 
connector_id - A single connector ID. 
testpoint_index - The connector sub-index in which to register this FE. A
                connector line with a density of three has three sub-indices (0-2), and a connector
                point only has a single sub-index (0).
number_of_ids - The number of FE IDs for a given connector_id. 
entity_id - The ID of an FE entity (of type entity_type) to be
                registered with a given connector_id.


number_of_integers
Integer indicating the size (number of integers) in the integer array created using
              *createarray.

","Examples
First, change connector 7 to the user control
        mode:*CE_SetSpecificDetailById 7 2 1 0.0
Second, create the necessary
        arrays:*createstringarray 3 ""systems"" ""elements"" ""systems""
*createarray 3 30 2127 31
Third, call the *CE_FE_Register function for connector
        7:*CE_FE_Register 7 0 1 3 1 3
Finally, turn the user control mode off for connector 7
        (optional):*CE_SetSpecificDetailById 7 2 0 0.0
The following process registers elements 100 and 101 with connector 10, and elements 200,
        201, and 202 with connector 20. 
First, place connectors 10 and 20 in user control
        mode:*createmark connectors 1 10 20
*CE_SetSpecificDetail 1 2 1 0
Second, create the necessary array of
        ints:*createarray 11 10 0 2 100 101 20 0 3 200 201 202
Third, call *CE_FE_RegisterAdvanced
        function:*CE_FE_RegisterAdvanced elements 1 11
Finally, turn off user control mode for connectors 10 and 20
        (optional):*CE_SetSpecificDetail 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
140,*CE_FE_RegisterSharedEntitiesByMark,"Description
Registers pre-existing entities to multiple connectors.
Note that a single entity can be registered with multiple connectors.
","Inputs

mark_id
The ID of the mark containing the connectors to register to.  Valid values are 1 and
            2.
entity_type_string_array
The ID of the string array containing the additional entity types to register.  The
            array is created using the *createstringarray command.  This should
            always be set to 1.
This array should either map one-to-one with id_integer_array or it
            should have a single index indicating all of the IDs are of the same entity type.
number_of_strings
Integer indicating the size (number of entity types) in the string array created using
              *createstringarray.
id_integer_array
The ID of the integer array containing the entity IDs to register.  The array is
            created using the *createarray command.  This should always be set to
            1.
number_of_integers
Integer indicating the size (number of IDs) in the integer array created using
              *createarray.

","Example
Change connectors 1-10 to the user-control mode:
*createmark connectors 1 1-10;
*CE_SetSpecificDetail 1 2 1 0;
Create the necessary arrays to register component 3, property 7, material 8, set 12 and
        group 14:
*createstringarray 5 ""component"" ""property"" ""material"" ""set"" ""group"";
*createarray 5 3 7 8 12 14;
Register the entities with connectors 1-10:
*createmark connectors 1 1-10;
*CE_FE_RegisterSharedEntitiesByMark 1 1 5 1 5;
Change connectors 1-10 back to normal control mode (optional):
*createmark connectors 1 1-10;
*CE_SetSpecificDetail 11 2 0 0;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
141,*CE_FE_SetDetails,"Description
Set FE realization details for the connectors on a mark.
","Inputs

mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
config
Weld element type.
2 - plot 
3 - weld 
5 - rigid 
21 - spring 
55 - rigidlink 
60 - bar2 
61 - rod 
70 - gap 
104 - quads 
1001 - custom


tolerance
The maximum distance allowed between the connector and the entity in order to create
            welds.
property_id
ID of property collector. Used to retrieve property specified for connector.
system_flag
0 - Build systems. 
1 - Do not build systems.
snap_to_node
Force weld to use one of the element connectivity nodes rather than create a new
            node.
remesh
Specifies if the welded area needs to be remeshed:
0 - Do not remesh 
1 - Remesh
force_collinear
Force all the welds along all layers to be collinear:
0 - Non-collinear welds. 
1 - Collinear welds.
fe_type
The FE type for the current solver specified in the FE. Configuration File for
            user-defined FE only.

","Examples
Set the required properties for the connectors 1, 2 and 3, and create a simple bar element
        with a tolerance of
        1:*createmark connectors 1 1 2 3
*CE_FE_SetDetails 1 60 1.0 0 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
142,*CE_FE_SetSpecificDetail,"Description
Changes a single FE realization detail for connectors on the mark. 
","Inputs

connector_mark
The mark of connectors that needs to be updated.
detail_type
The connector FE detail to edit:
1 - config (integer) 
2 - tolerance (double) 
3 - property_id (integer) 
4 - systems (integer: 0 or 1) 
5 - snap_to_node (integer: 0 or 1) 
6 - remesh (integer: 0 or 1) 
7 - force_collinear (integer: 0 or 1) 
8 - fe_type (integer) 


See *CE_FE_SetDetails(),
              *CE_FE_SetDetailsAndRealize(), and
              *CE_FE_SetSpecificDetail() for a more comprehensive description of
            the details.
integer_value
Pass necessary integers values through this parameter.
double_value
Pass necessary double values through this parameter.

","Examples
Initialize a connector’s FE details, and then change the tolerance from 1.0 to
        2.0.*createmark connectors 1 1 2 3
*CE_FE_SetSpecificDetail 1 2 0 2.0
Generally, this command is most useful to change a single previously set connector FE
        value. It can be used to populate all the connector’s FE values from scratch, but it is
        necessary that a config (or fe_type) and tolerance be properly set for
        realization to occur. This command makes it possible to change a single connector FE value,
        such as the weld config, while leaving all other FE values intact. 
This command will not operate on a connector unless either the
          *CE_FE_SetDetails() or the
          *CE_FE_SetDetailsAndRealize() command has been called first on that
        connector (without being rejected). Before you can update a specific FE detail
          (*CE_FE_SetSpecificDetail), all the main FE details must be initialized
        (which is what the other two commands do).
",
143,*CE_FE_UCCUpdateByDCC,"Description
Updates a connector control using a connector control default.
","
Inputs


cc_name
The name of the connector control to update.
ccd_name
The name of the connector control default to use.

","Examples
Update a connector control named ""my_acm"" from the connector control default
        ""acm_(general)_spot_nastran_template"":
*CE_FE_UCCUpdateByDCC ""my_acm"" ""acm_(general)_spot_nastran_template""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
144,*CE_FE_UnregisterRealizedEntities,"Description
Unregister the realization entities from connectors. On successful unregistration, the
        state of the connector is changed to MODIFIED. Realization entities which were unregistered
        will not get deleted on connector unrealization.
","
Inputs



ce_mark_id

The ID of the mark containing the connectors to unregister the realization entities
            from. Valid values are 1 and 2. 

input1

The entity type of the realization entities to unregister from the connectors. Valid
            values are ""all"" and other relevant entity types.

input1

The ID of the mark containing specific realization entities to unregister from the
            connectors. Valid values are 1 and 2.

","Examples
To unregister all the realization entities from all the displayed connectors:
*createmark connectors 1 ""displayed""
*CE_FE_UnregisterRealizedEntities 1
To unregister all the realization systems from all the displayed connectors:
*createmark connectors 1 ""displayed""
*CE_FE_UnregisterRealizedEntities 1 systems
To unregister elements with IDs 348, 349 and 350 and systems with IDs 15, 16 and 17 from
        all the displayed connectors:
*createmark connectors 1 ""displayed""
*createmark elements 2 348 349 350
*createmark systems 2 15 16 17
*CE_FE_UnregisterRealizedEntities 1 all 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
145,*CE_GlobalSetDouble,"Description
This command sets global double parameters to control the display of connectors.
","Inputs

name
The name of the parameter to set:
g_ce_size
Determines the display size of connectors.
Range > 0.0


value
The double value to set for the name parameter.

","Examples
To set the global connector display size to
        2.0:*CE_GlobalSetDouble g_ce_size 2.0
",
146,*CE_GlobalSetString,"Description
Set a value to a global string variable.
","
Inputs



name

The name of the string variable to set. Currently only
            g_ce_post_collector_name_setting is supported.

value

The value of the string.  Currently only ""use link names"" and ""use link ids"" are
            supported.

","Examples
To set global string variable ""g_ce_post_collector_name_setting"" to ""use link ids"":
*CE_GlobalSetString ""g_ce_post_collector_name_setting""  ""use link ids""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
147,*CE_MarkRemoveLink,"Description
Remove a link entity of a specific type and ID or name from the connectors on mark. 
","Inputs

ce_mark
Mark of connectors.
option
Specifies if all the links in the connector or a specific link needs to be removed.
0 - Remove all links in the connector.
1 - Remove the link specified by type and ID/name.


linktype
Specific link type to search in the connector. If link ID/name is not specified, the
            first link found with the same type defined by proximity rule is removed.
link_id
Link ID to remove from connector. This is optional, if the name is specified.
link_name
Link name to remove from the connector. This is optional, if the ID is specified.

","Examples
To remove all links from the displayed
        connectors:*createmark connectors 1 ""displayed"" 
*CE_MarkRemoveLink 1 0 0 0 """"
To remove the component with ID 10 from the displayed
        connectors:*createmark connectors 1 ""displayed""
*CE_MarkRemoveLink 1 1 comps 10 """"
",
148,*CE_MarkReplaceLinkEntities,"Description
Replaces the links from scratch in connectors.
","
Inputs


mark_id
The ID of the mark of connectors.  Valid values are 1 and 2.
link_type
The type of link to replace.
link_mark_id
The ID of the mark of link entities to remove.  Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are area, bolt, seam, and spot.
num_ents
The number of links to replace.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
link_elems_geom=<value>
Specifies whether to connect elems (default) or geom.
link_rule=<value>
Specifies the link rule. Valid values are now, at_fe_realize or none
                  (default).
relink_rule=<value>
Specifies the relink rule. Valid values are id, name or none (default).
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
Flag for seam or area connector grouping:
0 - Do not use tol (default)
1 - Use tol


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
Replace links for spot connectors 1 and 2 by removing existing links
        first:*createmark connectors 1 1 2
*createmark comps 1 1 2 3 4
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=id"" ""tol=99.0"" "" tol_flag=1""
*CE_MarkReplaceLinkEntities 1 comps 1 ""spot"" 4 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
149,*CE_MarkUpdateLink,"Description
Allows search and replace of an existing link in the specified connector mark with a new
        link entity.
","Inputs

mark_id
Mark of connectors.
search_type
The entity type to search in the connector. This must be specified. The supported
            entities are comps, props, assems, surfs, tags, elems, nodes and parts.
search_id
The link entity ID to replace in the connector. The ID is optional only if one of the
            following is true:
3 - Use name
4 - Proximity
5 - Use UID
search_name
The name of the link entity to replace in the connector. The name is optional only if
            one of the following is true:
1 - None
2 - Use ID
4 - Proximity
5 - Use UID
?search_rule?
The rule by which the link entity was added to the connector. The following codes
            define the different rules:
0 - Undefined
1 - None
2 - Use ID
3 - Use name
4 - Proximity
5 - Use UID
If the rule is specified, the entity search is performed in accordance with the rule.
            For example, a search_rule of 2 requires
            search_id.
?replace_type?
The type of entity that replaces the found link entity
            (search_type) in the connector. If not specified, the entity type
            information is not replaced for the found link (replace_type =
              search_type). The supported types are the same as that for
              search_type.
?replace_id?
The entity ID that replaces the found link entity. If not specified, the entity ID
            information is not replaced for the found link (replace_id =
              search_id).
?replace_name?
The entity Name that replaces the found link entity. If not specified, the entity name
            information is not replaced for the found link (replace_name =
              search_name).
?replace_rule?
The rule to set for the found link entity. All the rules supported for
              search_rule parameters are supported.
?replace_state?
The flag to set for the link entity that specifies if you are connecting to mesh or to
            geometry. The supported values are:
0 - Undefined
1 - Connect to mesh 
2 - Connect to geometry
?keep_current_state?
Optional option to keep the current connector state after the update operation. Valid
            states are:
0 - Unrealize if needed (default)
1 - Keep current state
At most, one of the ""replace"" data must be specified to see a change in the link
            attributes. If the replace data exactly matches the search data, the connector is not
            unrealized and no change is made to the link entity.
?search_uid?
The UID of the link entity to replace in the connector. The UID is optional, only if
              search_rule is 1, 2, 3 or 4.
?replace_uid?
The entity UID that replaces the found link entity. If not specified, the entity UID
            information is not replaced for the found link (replace_uid =
              search_uid).

","Examples
To replace component ID 10 with component ID 20 for displayed
        connectors:*createmyark connectors 1 ""displayed""
*CE_MarkUpdateLink 1 comps 10 """" 0 0 20 """" 0 0
To replace component name ""comp1"" with component name ""bumper"" for displayed
        connectors:*createmaryk connectors 1 ""displayed""
*CE_MarkUpdateLink 1 comps 0 ""comp1"" 0 0 0 ""bumper"" 0 0
To replace use ID with use name rule for component ID 10 for displayed
        connectors:*createmark connectors 1 ""displayed""
*CE_MarkUpdateLink 1 comps 10 """" 2 0 0 """" 3 0
To replace the state for component ID 10 for displayed connectors from ""connect to elems""
        to ""connect to
        geom"":*createmark connectors 1 ""displayed""
*CE_MarkUpdateLink 1 comps 10 """" 0 0 0 """" 0 2
Note that in all of the above cases, the connector entity is unrealized and any existing
        welds are removed from the connector. At most, one of the ""replace"" data must be specified
        to see a change in the link attributes. If the replace data exactly matches the search data,
        the connector is not unrealized and no change is made to the link entity.
",
150,*CE_MarkUpdateLinkMark,"Description
Allows search and replace of existing links in the specified connectors with new link
        information.
","Inputs

mark_id
Mark of connectors.
search_type
The entity type to search in the connector. This must be specified. The supported
            entities are comps, props, assems, surfs, tags, elems, nodes and parts.
search_mark_id
The ID of the mark containing the link entities to be updated.
replace_type
If specified with IDs/names/UIDs in the string_array, existing
            links in search_mark_id get replaced with the new information. The
            supported values are comps, props, assems, surfs, tags, elems, nodes and parts.
If specified with no IDs/names/UIDs in the string_array, existing
            links in search_mark_id get converted to the
              replace_type. The supported values are comps, props, and
            parts.
replace_rule
If specified with IDs/names/UIDs in the string_array, existing
            links in search_mark_id get replaced with the new information.
If specified with no IDs/names/UIDs in the string_array, existing
            links in search_mark_id get converted to the
              replace_rule.
The following codes define the different rules:
0 - Undefined
1 - None
2 - Use ID
3 - Use name
4 - Proximity
5 - Use UID
replace_state
The flag to set for the link entity that specifies if you are connecting to mesh or to
            geometry. The supported values are:
0 - Undefined
1 - Connect to mesh 
2 - Connect to geometry
string_array
A string array containing the list of new IDs/names/UIDs, created using
            *createstringarray.  This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            replace_rule.
number_of_strings
The number of strings in string_array.
?keep_current_state?
Optional option to keep the current connector state after the update operation. Valid
            states are:
0 - Unrealize if needed (default)
1 - Keep current state
At most, one of the ""replace"" data must be specified to see a change in the link
            attributes. If the replace data exactly matches the search data, the connector is not
            unrealized and no change is made to the link entity.

","Example
To convert component links 1-10 to part links across all displayed connectors:
*createmark connectors 1 ""displayed""
*createmark components 2 ""by id only"" 1-10
*CE_MarkUpdateLinkMark 1 comps 2 parts 0 0 1 0 0
To convert link rule for component links 1-10 to ""use-name"" across all displayed
        connectors:
*createmark connectors 1 ""displayed""
*createmark components 2 ""by id only"" 1-10
*CE_MarkUpdateLinkMark 1 comps 2 comps 3 0 1 0 0
To convert link state for component links 1-10 to ""geom"" across all displayed
        connectors:
*createmark connectors 1 ""displayed""
*createmark components 2 ""by id only"" 1-10
*CE_MarkUpdateLinkMark 1 comps 2 comps 0 2 1 0 0
To replace component 1 with component group (2 and 3) across all displayed connectors:
*createmark connectors 1 ""displayed""
*createmark components 2 ""by id only"" 1
*createstringarray 2 ""2"" ""3""
*CE_MarkUpdateLinkMark 1 comps 2 comps 2 0 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
151,*CE_PreviewBoltCylinder,"Description
This command sets cylinder bolt parameters for bolt connectors and displays the graphical
        preview.
","Inputs

mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
solver_name
The name of the solver to query. Examples include: Nastran, Abaqus, LS-DYNA, etc.
config
The connector config. Must always be set to 1001 at the present time.
fe_config
The FE element config.
tolerance
The realization tolerance.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Possible keywords and the corresponding values can be separated by blanks and/or by ""="":
ce_bodylen <value>
The length of the bolt when it is a spring.
ce_dia_factor <value>
The factor for the bolt diameter.
ce_diameter <value>
The diameter of the bolt.
ce_ijk ""<i> <j> <k>""
The bolt vector.
ce_l1 <value>
The length of the bolt upper half.
ce_l1d1 <value>
The diameter of the bolt upper half, overriding ce_diameter.
ce_l2 <value>
The length of the bolt lower half.
ce_l2d2 <value>
The diameter of the bolt lower half, overriding ce_diameter.
ce_notuseijk <value>
0 - Do not use the bolt vector. 
1 - Use the bolt vector.
ce_passthroughce <value>
0 - Do not enforce passing through connector position. 
1 - Enforce passing through connector position.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To assign values of parameters for ""bolt (cylinder rigid)"" for Nastran to connectors 1-3 using a tolerance of
        10.0:*createmark connectors 1 1 2 3
*createstringarray 9 ""ce_notuseijk=1"" ""ce_diameter=2.000000"" ""ce_l1d1=1.000000"" ""ce_l2d2=1.000000"" ""ce_l1=5.000000"" ""ce_l2=5.000000"" ""ce_bodylen=-1.000000"" ""ce_passthroughce=0"" ""ce_dia_factor=1.000000""
*CE_PreviewBoltCylinder 1 ""nastran"" 1001 60 10.0 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
152,*CE_PreviewDuplicates,"Description
Find duplicate connectors and place them on the output mark.
","Inputs

outputmark
Connector mark to be populated.
tolerance
Search radius to determine duplicates.

","Examples
Duplicate connectors found inside a tolerance of 0.5 will be populated on output mark 1.
        *CE_PreviewDuplicates(1, 0.5)
This command works similar to the preview empty or preview unused options in the HyperMesh Delete panel. The output mark should not contain any
        connectors prior to calling this command. The preview duplicates feature highlights all
        connectors that share exactly the same information within the specified tolerance.
",
153,*CE_ReadXmlString,"Description
This command creates a connector from an XML string.
","Inputs

string
The string containing the XML connector definition.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Examples
To create a connector from an XML
        string:*CE_ReadXmlString <CE_Connectors><CE_Link_List NumberOfLinks=""2""><CE_Link Type=""comps"" Id=""1"" Rule=""none"" State=""elems"" /><CE_Link Type=""comps"" Id=""2"" Rule=""none"" State=""elems"" /></CE_Link_List><CE_Spot Id=""1""><Location><Cords>8.514332 0.150252 0.000000</Cords></Location><CE_Detail CompID=""2"" CompName=""bottom_square"" Thickness=""2"" /><FE_Detail Config=""rigid"" Tolerance=""7.000000"" FESolver=""0"" System=""0"" Connectivity=""0"" Nonnormal=""0"" /><CE_Metadata_List><CE_Metadata Type=""Int"" Name=""ce_fe_acm_numhexa"" Value=""1"" /><CE_Metadata Type=""String"" Name=""ce_comp"" Value=""bottom_square"" /></CE_Metadata_List></CE_Spot></CE_Connectors> 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
154,*CE_RemoveLink,"Description
Remove a link entity of a specific type and/or ID/name from a connector entity.
","Inputs

ce_id
ID of the connector entity.
option
Specifies if all the links in the connector or a specific link needs to be removed.
0 - Remove all links in the connector.
1 - Remove the link specified by type and/or ID/name.


linktype
Specific link type to search in the connector. If link ID/name is not specified, the
            first link found with the same type defined by proximity rule is removed.
link_id
Link ID to remove from connector. Optional, if the name is specified.
link_name
Link name to remove from the connector. Optional, if the ID is specified.

","Examples
To remove all links from a connector entity of ID
        1:*CE_RemoveLink 1 0 0 0 """"
To remove the component with ID 10 from the connector with ID
        1:*CE_RemoveLink 1 1 comps 10 """"
",
155,*CE_ReviewConnectorsReverse,"Description
longDescription
","
Inputs


entity_type
The entity type on which the reverse review operation will be performed. Valid values
            are connectors and attachments.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
first_connector_entity=<value>
Defines if the first connector entity needs to be considered for reverse review
                  operation. Valid values are 1 or 0.
linked_entity=<value>
Defines if the linked entites need to be considered for reverse review
                  operation. Valid values are 1 or 0.
realization_connector=<value>
Defines if the realized/solver entites need to be considered for reverse review
                  operation. Valid values are 1 or 0.
second_connector_entity=<value>
Defines if the second connector entity needs to be considered for reverse review
                  operation. Valid values are 1 or 0.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
output_mark_id
The ID of the mark onto which the reviewed entities are placed. Valid values are 1 and
            2.

","Examples
To perform reverse review operation on
        connectors:*createstringarray 4 ""realization_connector=1"" ""first_connector_entity=1"" ""linked_entity=0"" ""second_connector_entity=0""
*CE_ReviewConnectorsReverse connectors 1 4 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
156,*CE_ReviewLinks,"Description
Review links according to user options.
","
Inputs



link_type

The type of link to review.

mark_id

The ID of the mark to review.  Valid values are 1 and 2.

operation_type

The string for the type of operation to be performed:
find
findattached
findbetween
hide
isolate
isolateonly
show
To operate on between links:
cebetween_hide
cebetween_isolate
cebetween_isolateonly
cebetween_show

string_array

A string array containing any additional input parameters, created
              using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            link_rule.



consider_geom=<value>

Defines if geometry is also considered along with elements during
                  show/hide/isolate operations. Valid values are true and false.

consider_HAZ_elems=<value>

Defines if HAZ (Heat Affected Zone) elements should also be considered during
                  show/hide/isolate operations. The possible values are true and false.

find_twince_option=<value>

Find twin connectors according to:
1 - Minimum two links
2 - Exact links

filter_projection_entities=<value>

Filters links to the projection entities during show/hide/isolate operations,
                  according to following options which are possible values:
0 - None
1 - Projection components
2 - Projection elements
3 - Projection and attached elements



number_of_strings

Integer indicating the size (number of strings) in the string_array
            created using *createstringarray.

output_mark

The ID of the mark onto which reviewed entities are placed.  Valid values are 1 and
            2.

","Examples
To isolate components with ID 2 and 4 with no overwritten user options:
*createmark components 1 component2 component4
*CE_ReviewConnectors components 1 isolate 1 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
157,*CE_SetLinkChangeManagerSettings,"Description
Modifies/unrealizes/rerealizes connectors when there is change in attribute values or
        deletion of referenced entities.
","
Inputs


perform
0 - Do not perform operation
1 - Perform operation
operation
0 - Modify
1 - Unrealize
2 - Realize

","Examples
Modify connectors upon
        changes:*CE_SetLinkChangeManagerSettings 1 0
Unrealize connectors upon
        changes:*CE_SetLinkChangeManagerSettings 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
158,*CE_SetSpecificDetailById,"Description
Sets a specific detail for a specific connector ID.
","Inputs

ce_id
A single connector ID.
detail_type
The number for the connector detail you are editing:
Generic Connector Details:
1 = thickness (integer) 
2 = user control (integer: 0 or 1) 
3 = state (integer: 1 = realized, 2 = failed)


Connector Line Details:
101 = spacing (double) 
102 = density (integer) 
103 = offset (double) 
104 = half spacing (integer: 0 or 1)


int_val
Pass necessary integers values through this parameter.
dbl_val
Pass necessary double values through this parameter.

","Examples
Note: A connector must be in user control mode in order to edit the state.
To change the thickness of the connector with ID 8 from 2T to
        3T:*CE_SetSpecificDetailById 8 1 3 0.0
To change the spacing for the line connector with ID 13 to
        5.0:*CE_SetSpecificDetailById 13 101 0 5.0
",
159,*CE_UpdateCustomMessage,"Description
This command attaches a custom error message to a connector.
","Inputs

id
The ID of the connector to update.
message_code
This is the message code as specified in the
              Connector_Message.txt file, which is available in the HyperMesh installation directory. 
This file contains code-message pairs (i.e. for each code a user-defined message is
            available). You can edit/add messages to this file and provide the message code for this
            argument.

","Examples
The Connector_Message.txt file contains the following lines of
        code-message
        pairs:11110 ""Connector failed to create proper system.""
11111 ""Not a valid tag as link.""
11112 ""CE link does not have properties.""
To attach the first message to connector
        100:*CE_UpdateCustomMessage 100 11110
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
160,*cfdoutput,"Description
This command writes a CFD output deck.
","Inputs

output_file
The full name and path of the output file.
format
The format of the output file. Valid values are ASCII
            and BINARY.
solver
The solver to export for. Valid values are FLUENT and SC-TETRA.
use_existing
A flag that indicates whether to use an existing solver deck's information during export.
0 - Do not use an existing deck. 
1 - Use an existing deck. existing_file must be
                specified.


existing_file
The full name and path of the existing solver deck file. This is ignored, if
              use_existing is 0.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To export the displayed entities to a Fluent ASCII file,
        using an existing solver
        deck:*createstringarray 1 ""Model_Dimension: mm""
*cfdoutput C:/temp/fluent.out ASCII FLUENT 1 C:/temp/fluent_existing.out 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
161,*check_symmetric_mesh,"Description
Checks whether a selection of meshes is symmetric. If the source and target are surfaces,
        it is optional to provide a transformation. The transformation can be supplied as a
        translation, a rotation, or a 4x4 transformation matrix. If not supplied, the transformation
        is computed internally. The tolerance for matching the mesh can also be supplied. If not
        given, the global geometry cleanup tolerance is used instead. 
The output information is logged into two global Tcl arguments:
          g_hw_argc and g_hw_argv. These can be accessed after
        the execution of the command. 
If a transformation was not supplied to the command, the internally computed transformation
        is logged in terms of translation and rotation. It also contains the general status of the
        command (whether the surfaces are symmetric or not).
","Inputs

entity_type
The type of source/target entity. Valid values are surfaces and elements.
mark_id_source
The ID of the source mark of entities. Valid values are 1 and 2.
mark_id_target
The ID of the target mark of entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
rotation:
angle: <angle in degrees> 
axis: <axis, x component> <axis, y component > <axis, z component > 
base: <base, x component> < base, y component > < base, z component
                  >
tolerance:
<value> 
transformation:
<tr11> <tr12> <tr13> <tr14> <tr21> <tr22> <tr23> <tr24>
                  <tr31> <tr32> <tr33> <tr34> <tr41> <tr42> <tr43>
                  <tr44>
translation:
<x component> <y component > <z component>


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To check if the meshes on surfaces with ID’s 10 and 20 are symmetric with a translation
        along the y direction, and a rotation of 90 degrees along the global
        y-axis:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 {{translation: 0 1 0} {rotation: angle :90 axis : 0 1 0 base: 0 0 0}}
*check_symmetric_mesh surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
To do the check using a custom tolerance and transformation
        matrix:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""transformation: 0 0 1 0 0 1 0 0 -1 0 0 0 2.5 0 12.5 1"" ""tolerance: 0.1""
*check_symmetric_mesh surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
To do the check by auto-detecting the
        transformation:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""tolerance: 0.1""
*check_symmetric_mesh surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
162,*checkpenetration,"Description
Checks a group of elements for penetrations and/or self-interference.
","Inputs

entity_type
Entity type to check for element penetration: 
Elements
Components
Groups


mark_id
The ID of the mark containing the entities that you want to check for
            penetrations.
dim_type
The dimensionality of the elements to check within the mark:
0 - Check 2D and 3D elements.
2 - Check 2D elements only. 
3 - Check 3D elements only.


penetrations
0 - Ignore penetrations
1 - Consider penetrations
self-interference
Flag to consider self-intersections and penetrations within component.
thickness_adjust
Adjust thickness flag:
0 - Use components' thickness values. 
1 - Multiply component's by thickness_param.
2 - To directly specify all thicknesses via
                thickness_param.


thickness_param
Thickness, or thickness multiplier, depending on the
              thickness_adjust setting.
threshold_depth
Do not consider penetrations with depths less than this value. To find zero-depth
            penetrations, specify any negative value.
reserved
Reserved for future use. Must be set to 0.

","Examples
Describes when to consider two separate geometric entities the same. The value should not
        be less than 10 times the geometric tolerance.
",
163,*cleanupmodelfile,"Description
This command cleans up model specific data after a box trim operation.
","Inputs

mark_id
The ID of the mark containing the input entities. The use depends on the
              operation argument. Valid values are 1 and 2. Supported entity types include:
Groups
Controlvols
Loads


x0
Lower bound x-coordinate.
y0
Lower bound y-coordinate.
z0
Lower bound z-coordinate.
x1
Upper bound x-coordinate.
y1
Upper bound y-coordinate.
z1
Upper bound z-coordinate.
operation
The operation to perform. Valid values are:
deleteoutsidebox
Deletes all elements, connectors, blocks and groups outside the specified box.
                
deleteemptyunused
Deletes all empty comps, assems, sets, contactsurfs, outputblocks, groups, plies
                  and rigidwalls, and all unused mats, props, sets, beamsects, curves, systems,
                  vectors, laminates, plies and tables. mark_id and
                    x0 through z1 are ignored. 
preservesolverdata
Preserves all control cards by adding them to mark_id.
                    x0 through z1 are ignored.
postclean
Delete the rest of the items not on mark_id.
                    x0 through z1 are ignored.



","Examples
To cleanup model and solver data for LS-DYNA, using a box of 0, 0,
        0 -
        100,100,100:*createmark elems 2 ""by box"" $x0 $y0 $z0 $x1 $y1 $z1 0 ""outside"" 1 0 0
*cleanupmodelfile 2 0 0 0 100 100 100 ""deleteoutsidebox""
*cleanupmodelfile 2 0 0 0 0 0 0 ""deleteemptyunused""*createmark comps 1 all
hm_getincludeisolationentitiesmark 1 2 1 1
*cleanupmodelfile 2 0 0 0 0 0 0 ""preservesolverdata""
if { $template_type == ""lsdyna"" } {
*solverdeckcleanup LsDyna 2
*solverdeckcleanup LsDyna 2
}
*cleanupmodelfile 2 0 0 0 0 0 0 ""deleteemptyunused""
*cleanupmodelfile 2 0 0 0 0 0 0 ""postclean""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
164,*clearallpreservednodes,"Description
This command clears the preserve nodes flag from all the nodes that were marked as
        preserved.
","Examples
To clear all preserved nodes:*clearallpreservednodes
",,
165,*clearlist,"Description
This command clears the specified list.
","Inputs

entity_type
The type of entity on the list.
list_id
The ID of the list to clear. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to clear the list from.  If not specified, the current model is
            used.

","Examples
To clear the elements on list 1 before creating a new
        list:*clearlist elems 1
*createlist elems 1 3 4 5 6
To create, query, and clear a list from nodes 2, 10, and 3 for model
        model-2:*createlist nodes 1 ""by model"" model-2 2 10 3
set my_list [hm_getlist nodes 1 0 model-2]
*clearlist nodes 1 ""by model"" model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
166,*clearlock2,"Description
Clears all entity locks.
","
Inputs



entity_type

The entity type to clear locks for.

pool_id

The solver pool ID.

dataname

Must be set to id.

","Examples
To clear locks for all elements:
*clearlock2 elems 0 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
167,*clearmarkall,"Description
This command clears all entity IDs for all entity types from the specified mark.
","Inputs

mark_id
The ID of the mark. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to clear all marks from.  If not specified, the current model is
            used.

","Examples
To clear the contents of mark 2 for all entity
        types:*clearmarkall 2
To clear the contents of mark 2 for all entity types for model
        model-2:*clearmarkall 2 ""by model"" model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
168,*clearunresolvedid,"Description
When importing a file that references entities that are in another file that is not
        imported at the same time, those entities are recorded and protected from overwrite so that
        the links will not be lost. This way, fragments of a larger model can be edited while
        keeping links to the other parts of the model intact. 
If another fragment of the larger model containing some of the unresolved references is
        imported, HyperMesh will complete the links between the two
        model fragments and remove the protected entity IDs from the unresolved IDs database. 
If you wish to discard one of those links for a certain entity type, this command will
        clear that unresolved ID from the database for that entity type. 
Normally, the feinput system handles everything automatically. Therefore, the need to use
        this command is very rare and is provided for situations that need to exactly target the
        creation of new entities to fulfill the unresolved links.
","Inputs

entity_type
The type of entity to remove the unresolved ID for.
entity_id
The ID of the entity to remove from the unresolved ID database.

","Examples
To remove ID 5 from the unresolved IDs database for
        properties:*clearunresolvedid props 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
169,*coarsen_and_decimate_mesh2,"Description
Performs mesh coarsening and decimation on selected components. The ability exists to
        specify sacred nodes that will be maintained after coarsening/decimation. The command has
        additional options that allow adjusting the element size for small components and deleting
        elements of small components.
","Inputs

comps_mark_id
The ID of the mark containing the input components. This must also include any 1D
            multi-leg rigid elements that will be processed by the options flags.
              Valid values are 1 and 2.
nodes_mark_id
The ID of the mark containing any nodes to be treated as sacred/fixed. These nodes
            must belong to the initial mesh. These nodes will be maintained during
            coarsening/decimation. Valid values are 1 and 2.
failed_comps_mark_id
The ID of the mark to store any failed components. Valid values are 1 and 2.
elem_size
The element size to use for coarsening/decimation. This must be larger than the
            initial mesh size.
elem_type
Element type flag to generate for the coarsened mesh. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


feature_angle
This specifies the maximum angle between the normals of two connected elements. This
            value is ignored for shell elements. For 3D elements, the appropriate free faces of
            shell elements are created and meshed with the given feature angle. This value is also
            used to construct the connected edges for the failed components. Then these components
            are coarsened in a second attempt. 
If this value is less than 1.0, the default value of 85.0 degrees is used.
max_diameter
This option specifies the maximum hole diameter that will be filled by the coarsening
            operation. The default value is 0.0 (do not fill any holes).
options
Flags that specify various methods of pre-processing and post-processing of 1D and 2D
            elements. Bit values are used and the value is calculated as (Bit0 + 2*Bit1 +
              4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6). 
Bit0
0 - Do not utilize this option.
1 - All selected 1D element paths not sharing sacred nodes must be deleted
                  before mesh coarsening. 1D elements paths comprising sacred nodes are preserved.
                  Unselected 1D elements are ignored. Preserved 1D elements which are not free
                  should be attached to the shell mesh after coarsening..


Bit1
0 - Do not utilize this option.
1 - Selected 1D elements that appear free (are not attached to the shell or
                  solid mesh) after mesh coarsening must be deleted after meshing. 1D elements
                  sharing sacred nodes must be preserved.


Bit2
0 - Do not utilize this option.
1 - Selected 1D multi-leg elements having free legs after meshing (are not
                  attached to shell or solid mesh) must be updated by deleting the free legs.


Bit3
0 - Do not utilize this option.
1 - Selected 1D elements remaining after meshing should be converted to plot
                  elements.


Bit4
0 - Do not utilize this option.
1 - Selected 2D elements should be converted to plot elements after meshing.
                  This flag is utilized only for the OptiStruct user
                  profile.


Bit5
0 - Do not utilize this option.
1 - Retain the input mesh, and organize the coarsened mesh into a new
                  component.


Bit6
0 - Do not utilize this option.
1 - Creates 1D plotel elements on coarsened 2D element edges.


string_array
The ID of the string array that contains the additional option parameters that allow
            tuning of algorithms to make adjustments to the element size. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
There is no upper or lower limit to the number of the parameter strings can be any
            used. All parameters can be combined in a single string, or separate strings can be
            created for each parameter.
Each algorithm parameter is defined by a keyword and value pair that are to be
            separated by spaces. The input string can comprise any number of parameters separated by
            spaces, and in any order.
The supported parameters and their keywords are:
delete_comp_size
Controls the deletion of small components' elements while coarsening. It
                  specifies the upper limit for the component bounding box maximum dimension for
                  components in which 2D and 3D elements must be deleted while coarsening. If the
                  parameter is set to 0.0 (default), then no components will be purged during
                  coarsening.
max_compsize_factor
Controls a prioi adjustment of the mesh element size for small size components.
                  max_compsize_factor must be ≥ 1.0. For max_compsize_factor < 1 a prioi
                  adjustment of the component element size is disabled. The default value is 3.0. 
To explain the algorithm, here are some definitions: 
elem_size - Regular input mesh element size for coarsening 
comp_max_size - Maximum dimension size of a component bounding box 
comp_mesh_size - Mesh size used for component coarsening. 


The algorithm of a prior adjustment of element size for small components is as follows:
If comp_max_size > max_compsize_factor * elem_size, then comp_mesh_size =
                      elem_size. 
If comp_max_size < elem_size / max_compsize_factor, then comp_mesh_size
                      = comp_max_size. 


For intermediate component sizes, an embedded formula for component mesh element
                  size is used so that elem_size / max_compsize_factor < comp_mesh_size <
                  elem_size.
elsize_autoreduce_factor
This controls a posteriori iterative adjustments of the component mesh size by
                  the results of the meshing. The result of meshing for each component is estimated
                  by distortion of the original mesh shape. If a distortion limit is exceeded, or
                  meshing failed, then the component mesh size is divided by the
                  elsize_autoreduce_factor and the meshing is repeated until the mesh is
                  satisfactory. The parameter must be greater the 1.0, otherwise this algorithm is
                  disabled. The default value is 0.0 meaning the auto-reduction is disabled. The
                  recommended value for this factor once it is enabled is 1.5.
max_adjust_iters
The maximum number of mesh size auto-reducing iterations. The default value is
                  4.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. If no strings are provided, set this to 0 and
            the default algorithms will be used.

","Examples
Create a coarsened and decimated mesh with mixed type elements of element size 30 using all
        components. Put failed components on mark ID 2. Keep node IDs 16 and 27 as anchor nodes.
        Ignore all internal loops with diameter less than 65. If the model has solid elements,
        create free faces of shell elements and mesh them with a feature angle of 45 degrees. Delete
        selected 1D elements not sharing sacred nodes before meshing (option Bit0=1). Delete
        selected free 1D elements after meshing (option Bit1=1). If the model has rigidlink/RBE3
        elements, delete any free legs in the input components (option Bit2=1). Convert 1D elements
        to plot elements after meshing (option Bit3=1). The options are computed as 1 + 2 + 4
          + 8 = 15. Delete shell and solid elements of components with maximum bounding box
        dimension less then 25.0. Use a prior small components mesh with factor 3.0. Use iterative
        component element size reducing with factor
        1.5:*createmark components 1 ""all""
*createmark nodes 1 16 27
*createstringarray 1 ""delete_comp_size 25.0  max_compsize_factor 3.0 elsize_autoreduce_factor 1.5""
*coarsen_and_decimate_mesh2 1 1 2 30.0 2 45.0 65.0 15 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
170,*collectormarkmove,"Description
This command moves and/or sorts the entities on a mark. This affects their order within the
        browser and the advanced entity selection menus.
","Inputs

entity_type
The type of entity to move. Valid values can be found from the organize panel.
mark_id
The ID of the mark containing the entities to move. Valid values are 1 and 2.
move_to_front
A flag that indicates if the selected entities should be moved to the front of the
            list. Valid values are:
0 - Move the marked entities to the end of the list. 
1 - Move the marked entities to the front of the list.


sort
A flag that indicates how the entities will be sorted. Valid values are:
0 - The marked entities are not to be sorted. 
1 - The marked entities are sorted by name. 
2 - The marked entities are sorted by ID.



","Examples
To move the displayed components to the top of the list with no
        sorting:*createmark comps 1 displayed
*collectormarkmove comps 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
171,*collisioncheck2_temp,"Description
Performs a collision detection using the provided entities. Creates collision result
        entities that can be rendered in the UI or used as input to other commands.
Equivalent to calling hm_collisioninit,
          hm_collisionentitycreate and *collisioncheck_temp
        with the corresponding input each.  Must be followed by a call to
          hm_collisionend.
Based on the input, the command switches between the collirad collision detection engine
        (mainly based on Radioss algorithms, provides an automatic fix),
        which gets selected by default, and the opcode collision detection engine (supports some
        additional options, but no automatic fix as of now), which gets selected if any option is
        used which is not supported by the collirad engine.
Note that hm_collisionend does not delete any collision result entities.
        The deletion must be handled using *deletemark.
This command is a temporary command and may be deprecated in a future release.
","Inputs

entity_type
The type of entity to check. Valid values are groups, comps (only elems in comps are
            considered) and elems.
mark_id
The ID of the mark containing the entities to check.  Valid values are 1 and 2.
config
The configuration that defines the collision behavior. This value is obtained by
            running hm_collisiongetconfig. Default is 0.  See
              hm_collisiongetconfig for the possible options and their
            compatibilities.
thickness
The assigned thickness or thickness multiplier. Default is 0, which means that element
            thickness is applied.
allowable_depth
The allowable depth to use when finding and reporting interferences.  If specified,
              config should not contain the intersect_planar
            option and tolerance should be -1.0. If not specified, this is
            ignored.
Not supported in the collirad engine, so non-zero input selects the opcode engine
tolerance
The tolerance to use for intersection checks (for
              hm_collisiongetconfig
intersect_planar keyword) or penetration checks (for
              hm_collisiongetconfig
?penetrat_min_overlap? keyword). If not specified, the default is
            1.e-08.
Not supported in the collirad engine, so non-zero input selects the opcode engine
pair_angle
The maximum allowed angle between penetrating pair normals. Meaningful values are 0.0
            < angle < 90.0. Other values disable this functionality.
Not supported in the collirad engine, so non-zero input selects the opcode
            engine.
minimum_penetration_depth
The minimum penetration depth value to be reported.  All penetrations with depths
            below the specified value will not be reported.  If not specified, the default is 0.0,
            which implies that all detected penetrations will be reported.

","Example
To check intersections and penetrations of groups 1001 and 1002:
*createmark groups 1 1001 1002
*collisioncheck2_temp groups 1
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
172,*collisionrecheck_temp,"Description
Updates the results of a collision detection that had been done using
          *collisioncheck2_temp.
There are some restrictions regarding the collision result entities that are used as
          input:
Only possible for either intersections or penetrations at a time.  All provided
            collision result entities should have the same ""config"" (otherwise the ones with another
            config than the first one are ignored).
Only possible for one group at a time.  All provided collision result entities have to
            have the same ""parent"" (otherwise the ones with another parent than the first one are
            ignored).
A ""fast recheck"" of collision result entities is only implemented for intersections.
            If penetration result entities are passed to the function, a complete recheck of the
            given group is performed,


Note that hm_collisionend does not delete any collision result entities.
        The deletion must be handled using *deletemark.
This command is a temporary command and may be deprecated in a future release.
","Inputs

entity_type
The type of entity to check. Valid values are groups and collisions.
mark_id
The ID of the mark containing the entities to recheck.  Valid values are 1 and 2.

","Example
To recheck all groups for which outdated collision result entities are existing:
*createmark collisions 1 all
set lst_groups """"
foreach coll_id [hm_getmark collisions 1] {
    set isOutdated [hm_getvalue collisions id=$coll_id dataname=outdated]
    if {$isOutdated} {
        lappend lst_groups [hm_getvalue collisions id=$coll_id dataname=parent]
    }
}
eval *createmark groups 1 $lst_groups;
*collisionrecheck_temp groups 1;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
173,*colormark,"Description
Colors the entities on a mark a specified color.
","Inputs

entity type
The type of entities contained on the mark. Valid entity types are components, system
            collectors, and load collectors. 
mark
The ID of the mark.
color
The color which the selected entities should be colored. Valid colors are 1 through
            64. 

","Examples
To color the component frame red:
        *createmark(components,1) frame
*colormark(components,1,12)

",
174,*combineplotels,"Description
Creates a line from a group of plot elements.
","Inputs

mark_id
The ID of the mark containing the plot elements.  Valid values are 1 and 2.

","Examples
Combine plotels 1-100:*createmark elems 1-100
*combineplotels 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
175,*complexanimatemodal,"Description
Creates a complex modal animation from results data. The results file must be loaded before
        executing this command. The *freesimulation command clears the
        animation.
","Inputs

title
The title to use for the animation.
max_deflection
The maximum deflection in model units, or the scale factor, to which the maximum
            analysis result should be scaled. Use a negative value for model units and a positive
            value for scale factor.
frames
The number of frames to use during the animation sequence. The maximum value is
            machine dependent.
display_mode
Display type to generate. Valid values are:
0 - mesh wireframe only 
1 - rendered with mesh lines 
2 - feature lines only 
3 - rendered with feature lines 
4 - rendered only



","Examples
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements (c) data type, using a 10.0 model unit
        scaling:*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements (c)""
*animatecycles 10
*complexanimatemodal """" 10.0 4
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
176,*compute_midmesh_thickness,"Description
Computes the thickness of the midmesh elements based on the proximity with the geometry.
        New properties are created with thickness assigned. The command expects a baseline property
        with the name t0 to exist before execution. It estimates thickness and assigns the
        thicknesses to new properties, using the t0 property as a template. Optionally, an expected
        minimum and maximum thicknesses can be supplied, which will be used and a guide for the
        computation. 
This functionality is currently supported for the OptiStruct,
          Radioss, Nastran, Abaqus, LS-DYNA and ANSYS user profiles.
","Inputs

mesh_entity_type
Entity type used for mesh input. Valid values are:
Elements
Components


mesh_mark_id
The ID of the mark containing the mesh input. Valid values are 1 and 2.
geom_entity_type
Entity type used for geometry input. Valid values are:
solids
surfaces
elements
components


geom_mark_id
The ID of the mark containing the geometry input. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
AbsoluteGroupingTolerance: <tolerance>
The band width of the thickness group. This is applicable only when
                  ThicknessOutputOption is PropertyOnElements or PropertyOnComponents, or when
                  GroupThickness is enabled.
Range > 0 
Default = 0, which means this option is ignored and GroupingTolerance is
                  used.
AppendToTable: <value>
If set to 1, when run for the second time, the current computation results will
                  be added to an existing table. This option is valid only for Radioss.
AssignMidIntervalAsThickness: <value>
Specifies whether to use the mid-value of the interval as the thickness of the
                  group.  Valid values are:
0 - Assigns the average thickness of all elements in the group.
1 - Assigns the mid-value of the interval. 
-1 - The command chooses the behavior (for FixedInterval = 1, behaves as 1,
                      0 otherwise).  Default if not specified.


CardImage: <card image name>
The card image to be used to create new properties. This is applicable only if
                  the ThicknessOutputOption is set to PropertyOnElements or PropertyOnComponents. 
Default - A suitable default card image is used according to the selected solver
                  profile.
ConnectionInterpolationFactor: <factor>
The factor used in interpolating the thickness values near a connection (sharp
                  corners, t/x-junctions). Valid factors are:
0 - Approximate mass conserved thickness estimation at connections. 
0 < factor < 1 - Thickness linearly decreases towards the connection. 
1 - Thickness is interpolated constantly (default). 
> 1 - Thickness linearly increases towards the connection.


CornerThicknessCorrectionThreshold: <value>
The ratio of the maximum thickness allowed at corners to the maximum thickness
                  of the rest of the face. If a thickness exceeds this ratio at the corners, it will
                  be corrected. The inverse of this ratio is used to limit the maximum thickness at
                  the corners as well. 
Range > 1.0 
Default - 1.5
FeatureAngle: <value>
The angle used to decide the features of the mid-mesh. The corner scaling
                  options are applied to these features. 
Range - (0, 180) 
Default - 30
FixedInterval: <value>
Alternative option to GroupingTolerance or AbsoluteGroupingTolerance.  Groups
                  the thickness into intervals with a constant span given by this value.  A negative
                  value means the option is disabled.  StartThickness must also be specified.
This is applicable only when ThicknessOutputOption is PropertiesOnElements or
                  PropertiesOnComponents, or when GroupThickness is enabled.
Default is -1 (disabled).
GroupThickness: <value>
Defines whether the calculated exact thickness needs to be grouped and an
                  average value needs to be assigned. This helps reduce the number of different
                  thickness values, at the cost of accuracy of the results. This is applicable only
                  if ThicknessOutputOption is Element. This is always turned on if
                  ThicknessOutputOption is PropertyOnElements or PropertyOnComponents, and always
                  turned off if ThicknessOutputOption is Node or ElementNodal.
0 - Do not group thickness (default). 
1 - Group thickness.


GroupingTolerance: <tolerance>
The relative band width of the thickness group (in terms of a factor of the
                  average group thickness). This is applicable only when ThicknessOutputOption is
                  PropertyOnElements or PropertyOnComponents, or when GroupThickness is enabled.
                  This is ignored if, AbsoluteGroupingTolerance is provided. 
Range - (0, 1.0) 
Default - 0.2
HighlightCorrected: <value>
0 - Assign an extrapolated thickness value to any mesh outside the solid. 
1 - Highlight the corrected entities.
LogFile: <file>
The full path and name of the file where the command execution information is to
                  be logged.
MaxInclinationOfMidMeshWithSolid: <angle>
The maximum angle that the mid-mesh makes with the solid, beyond which the
                  estimated thickness will be ignored and corrected. 
Range - (0, 90) 
Default - 35
MaxInclinationOfMidMeshWithSolidAtFreeEdges: <angle>
The maximum angle that the mid-mesh makes with the solid at the free edges of
                  the mid-mesh, beyond which the estimated thickness will be ignored and corrected. 
Range - (0, 90) 
Default - 35
MaxRelativeChordalDeviation: <value>
The maximum chordal deviation to use when generating facets used for internal
                  calculations, relative to the minimum thickness. Applicable only if
                    geom_entity_type is surfaces or solids. The default is 0.1,
                  which means for a minimum thickness of 1.0, the geometry faceting will use a
                  maximum chordal deviation of 0.1.
MaxSearchDistance: <distance>
The maximum proximity distance which is considered for the thickness
                  calculation.
Range ≥ 0, where 0 means the max distance is calculated internally, based on the
                  model bounding box dimensions.
MaxThickness: <value>
The maximum thickness expected in the model. Any thickness estimated more than
                  this is set to this value.
MaxThicknessGradient: <factor>
The maximum change in thickness allowed across two adjacent measurement
                  locations, as a factor of the distance between the locations. 
Range - (0, 10.0] 
Default - 2.0
MinThickness: <value>
The minimum thickness expected in the model. Any thickness less than this is
                  corrected.
NeedOffset: <value>
Defines whether element offset values are required or not.
0 - Offset values are not needed (default). 
1 - Offset values are needed.


NewPropertyPrefix: <prefix>
The prefix to be used for naming the newly created properties/components. This
                  is applicable only if the ThicknessOutputOption is set to PropertyOnElements or
                  PropertyOnComponents. 
Default - 'thickness'. If SampleProperty is supplied, its name is used
                  instead.
NumDecimals: <value>
The number of decimal digits to use in the output. The output will be truncated
                  with the given value.
> 0 - The number of digits required after the decimal point. 
0 - Rounded off to nearest integer. 
< 0 - The minimum number of zeros required before the decimal point. 
auto - 1% of the estimated min thickness. 
AbsoluteGroupingTolerance - Use the same precision as
                      AbsoluteGroupingTolerance.


Examples:
NumDecimals: 2
303.2134 --> 303.21 
316.6666 --> 316.67


NumDecimals: 0
303.2134 --> 303 
316.6666 --> 307


NumDecimals: -1
303.2134 --> 300 
316.6666 --> 310


NumDecimals: auto
303.2134 --> 303 
4316.6666 --> 4320


SampleProperty: <property name>
If CardImage is not supplied, a sample property can be supplied which will be
                  used as a template to create the new properties. This is applicable only if the
                  ThicknessOutputOption is set to PropertyOnElements or PropertyOnComponents. This
                  is also applicable when the CardImage option is not supported by this
                  command.
SkipOutsideMeshFromCorrection: <value>
0 - Assign an extrapolated thickness value to any mesh outside the solid
                  (default). 
1 - Do not assign any thickness to any mesh which is determined to be outside
                  the solid, even if it is connected to the mid-mesh inside.
StartThickness: <value>
A reference thickness for one of the thickness groups.  All thickness groups
                  will be assigned thicknesses as StartThickness+i*FixedInterval, where i is the
                  interval integer.
This is applicable only when ThicknessOutputOption is PropertiesOnElements or
                  PropertiesOnComponents, or when GroupThickness is enabled and FixedInterval is >
                  0.
Default is -1 (disabled).
ThicknessCorrectionMethod: <method>
The method to be used to correct the thickness on elements/nodes where thickness
                  could not be estimated, or estimated incorrectly. Valid methods are:
Interpolation - Interpolates the thickness from the neighborhood (default). 
UseMinOrMaxThickness - Resets the estimated thicknesses which exceeds the
                      min or max limits to the set limits.


ThicknessOutputOption: <option>
Specify how the thickness data should be output. Valid options are:
Node - Thickness assigned on node card.
Element - Thickness assigned on element card (default for Radioss).
ElementNodal - Thickness assigned as nodal thickness on element card
                      (default for LS-DYNA).
PropertyOnComponents - Thickness assigned to components.
PropertyOnElements - Thickness assigned on element properties (default for
                        OptiStruct, Abaqus
                      and Nastran).


WriteToInclude: <value>
If set to 1, the computation results will be written to an include file. This
                  option is valid only for Radioss.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To calculate the midmesh thickness for all shell elements, based off of the displayed
        surfaces, using a min thickness of 0.1 and a max thickness of
        1.0:*createmark elems 1 all
*createmark surfs 1 displayed
*createstringarray 2 {MinThickness: 0.1} {MaxThickness: 1.0}
*compute_midmesh_thickness elems 1 surfs 1 1 2

To calculate the midmesh thickness for all shell elements, based off of the displayed
        surfaces, using a min thickness of 0.1 and a max thickness of 1.0 with REAL SET for
          ANSYS:*createmark elems 1 all
*createmark surfs 1 displayed
*createstringarray 14 ""ThicknessOutputOption : PROPERTYONCOMPONENTS"" ""NeedOffset : 0"" \
  ""ThicknessCorrectionMethod : Interpolation"" ""ConnectionInterpolationFactor : 1.0"" \
  ""LogFile : C:/Users/ Temp/__ThicknessCalculationLog263.log"" \
  ""CardImage : SHELL63p"" ""GroupingTolerance : 0.2"" ""NumDecimals : Automatic"" \
  ""NumDecimalsOffset : Automatic"" ""MaxInclinationOfMidMeshWithSolid : 35"" ""MaxThicknessGradient : 2.0"" \
  ""ThicknessMeasurementLocation : Default"" ""SkipOutsideMeshFromCorrection : 0"" \
  ""MaxRelativeChordalDeviation : 0.1""
*compute_midmesh_thickness elems 1 surfs 1 1 2
To calculate the midmesh thickness for all shell elements, based off of the displayed
        surfaces, using a min thickness of 0.1 and a max thickness of 1.0 with SECTYPE for ANSYS:*createmark elems 1 all
*createmark surfs 1 displayed
*createstringarray 14 ""ThicknessOutputOption : PROPERTYONCOMPONENTS"" ""NeedOffset : 0"" \
  ""ThicknessCorrectionMethod : Interpolation"" ""ConnectionInterpolationFactor : 1.0"" \
  ""LogFile : C:/Users/Temp/__ThicknessCalculationLog263.log"" \
  "" CardImage : SECTYPE"" ""GroupingTolerance : 0.2"" ""NumDecimals : Automatic"" \
  ""NumDecimalsOffset : Automatic"" ""MaxInclinationOfMidMeshWithSolid : 35"" ""MaxThicknessGradient : 2.0"" \
  ""ThicknessMeasurementLocation : Default"" ""SkipOutsideMeshFromCorrection : 0"" \
  ""MaxRelativeChordalDeviation : 0.1""
*compute_midmesh_thickness elems 1 surfs 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
177,*configedit,"Description
Changes the configuration of a selection of elements.
","Inputs

mark_id
The ID of the mark. Valid values are 1 and 2.
config
The new configuration name to assign. The new configuration cannot add new nodes.

","Examples
To set all plot elements to
        bar2:*createmark elements 1 ""by config"" plot
*configedit 1 bar2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
178,*contactsurfcreatewithfaces,"Description
Creates a contact surface using 2D element edges or 2D/3D element faces.
","Inputs

name
The name of the contact surface to create.
color
The color of the contact surface. Valid values are 1 through 64.
elem_mark_id
The ID of the mark that contains the elements to use. Valid values are 1 and 2.
node_mark_id
The ID of the mark that contains the nodes that define an edge or a face of an
            element. Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
0 - Create contact surface along element normal.
1 - Create contact surface opposite element normal.
of_face
0 - Create contact surface on edge.
1 - Create contact surface on face.

","Examples
To create a contact surface named ""test"" with elements 1-100 with faces defined by nodes
        1-5 and a breakangle of
        30.0:*createmark elems 1 1-100
*createmark nodes 1 1-5
*contactsurfcreatewithfaces ""test"" 5 1 1 30.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
179,*contactsurfcreatewithshells,"Description
Creates a contact surface using 1D or 2D elements.
","Inputs

name
The name of the contact surface to create.
color
The color of the contact surface. Valid values are 1 through 64.
mark_id
The ID of the mark that contains the 1D and 2D elements to use. Valid values are 1 and 2.
reverse_normals
0 - Create contact surface along element normal.
1 - Create contact surface opposite element normal.

","Examples
To create a contact surface named ""test"" with elements
        1-100:*createmark elems 1 1-100
*contactsurfcreatewithshells ""test"" 5 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
180,*control_sum_print,"Description
Outputs a control sum number to the specified text file. The control sum value is computed
        as a certain average using coordinates of the geometry and mesh present in the model.
The options can be specified in any order.
","
Inputs


file_name=<value>
The full path and file name to write the result to.  This is a mandatory option.
comment=<value>
This specifies an optional comment to be written to the text file prior to the control
            number.
method=<value>
This optional parameter specifies which points are to be used to compute the sum.
            Valid values are:
from_surface_geom - The points are taken as all vertices of all surfaces, as well as
            one point per each surface inside the surface (default)
from_surface_vertices - The points are taken from all surface vertices present in the
            model
from_elements - The points are taken to be all elements’ centroids in the model
from_nodes - The points are taken to be all nodes in the model
output_format=<value>
This optional parameter specifies the output format for the control sum number.  Valid
            values are:general  - Write the output real number in general format
scientific
              - Write the output real number in scientific format (default)

shift_to_center=<value>
This optional parameter specifies whether the coordinates of the points are taken in
            global coordinate system or shifted to the center of the bounding box containing all the
            points.  Valid values are:
0 - Take the coordinates with respect to global coordinate system
1 - Take the origin of the coordinate system to be the center of the bouding box
            containing all points (default)

","Examples
To write the control number to C:/test/test.txt, taking the sum of coordinates of all nodes
        present in the model with respect to the global coordinate system, and write the output in
        scientific notation:
*control_sum_print file_name=""C:/test/text.txt"" comment=""My comment"" method=from_nodes shift_to_center=0 output_format=scientific
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
181,*convertelements,"Description
Converts certain elements from one solver to another.  Currently it converts CONN3D2
        elements from Abaqus to JOINTG/CBUSH elements in OptiStruct. This command works when the destination template is loaded
        after the model is imported in the source profile.
","
Inputs



source_solver

The source solver.  Currently supported for Abaqus.

source_element_type

The source element type.  Valid values are CONN3D2.

destination_solver

The source solver.  Currently supported for Optistruct.

destination_element_type

The destination element type.  Valid values are JOINTG and CBUSH..

","Examples
Convert Abaqus CONN3D2 to OptiStruct JOINTG:
*convertelements Abaqus Optistruct CONN3D2 JOINTG
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
182,*convertinclude,"Description
Converts a regular include file into an include transform include file or vice versa.
","Inputs


id

The include ID, or 0 to use shortname.

shortname

The short name of the include file. This can be empty if id is
            specified other than 0.

flag

1 - Convert a regular include into an include transform include
2 - Convert an include transform include into a regular include

","Example
To convert regular include file with ID 10 into an include transform include file:
*convertinclude 10 """" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
183,*convertthickness,"Description
Converts the thickness of the specified entities to the target solver. 
Currently this is supported only for Nastran to Abaqus conversion. It converts the element thickness to nodal thickness
        and puts the converted nodes on mark 1.
","Inputs

entity_type
Entity type to convert. Currently only elements are supported.
mark_id
The ID of the mark containing the entities to update. Valid values are 1 and 2.
source_solver_id
The ID of the source solver for the specified entities. This can be queried using
              hm_getsolver.
target_solver_id
The ID of the target solver for the specified entities. This can be queried using
              hm_getsolver.

","Examples
To convert elements 1-100 from Nastran to Abaqus:*createmark elems 1 1-100
*convertthickness elements 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
184,*copymark,"Description
Copies entities from one collector to another.
","Inputs

entity_type
Entity type to copy. Any collected entity type (aside from master/slave elements) is
            valid.
mark_id
The ID of the mark containing the entities to copy. Valid values are 1 and 2.
name
The name of the collector to copy the entities to. The collector type is determined by
            the entity_type.

","Examples
To copy all elements in comp1 to
        comp2:*createmark elems 1 ""by collector name"" comp1
*copymark elems 1 comp2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
185,*correctoverflowsubmodelentityids,"Description
This command corrects an entity ID range overflow for a submodel.
","Inputs

submodel_type
Submodel type to correct the ID range overflow for. Valid values are:
includes
includefiles


id
The ID of the submodel.
entity_type
The type of entity to correct the overflow for. 
0 - All entity types in the submodel are considered.
option
0 - Overflow IDs 
1 - Underflow IDs 
2 - Both overflow IDs (default)
renum_option
1 - Compact and fit (default) 
2 - Move after max 
3 - Move before min 
4 - Insert in gaps 
5 - Offset and fit (not yet supported)
pool_id
The optional ID of the solver pool.

","Examples
To correct components in include file 1 with ""both"" overflow option and using ""move after
        max"" renumber
        option:*correctoverflowsubmodelentityids includes 1 comps 2 2
To correct all entities in include file 1 with ""both"" overflow option and using ""move after
        max"" renumber
        option:*correctoverflowsubmodelentityids includes 1 0 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
186,*create_bead_elements,"Description
This command is used to generate beads on 2D elements.
","Inputs

mark_id
The mark ID containing two nodes defining the centers of two circular bead ends. Valid values are 1 and 2.
radius
The radius of the circular bead ends.
height
The height of the beads.
make_sharp
This flag indicates the bead shape when the element density on bead cross profiles is
            less than or equal to 3.


1 - A sharp bead (profile element density is 2).
0 - A flat bead (profile element density is 3). 


feature_angle
Defines the feature lines of the mesh on which the beads lie. Range is between 0 and
            180.

","Examples
To generate a flat bead with the end centers at nodes 81 and 119, radius 10, height 10, and
        feature angle
        30:*createmark nodes 1 81 119 
*create_bead_elements 1 10.0 10.0 0 30.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
187,*create_springs,"Description
Creates spring elements between selected coincident nodes.
<option>=<value> options can be provided in any order.
","
Inputs



entity_type

The type of input entity.  Must be set to nodes.

DestinationComp =<value>

The components to which spring elements will be stored. This is a required
            option.
0 - New component
1 - Current component

EntityMark=<value>

The ID of the mark containing the nodes. Valid values are 1 and 2.

Property=<value>

The property ID to be assigned to the spring elements.

PropertyMode=<value>

The properties to be assigned to the spring elements. This is a required option.
0 - New property
1 - Existing property

System=<value>

The system ID to be assigned to the spring elements.

Tolerance=<value>

The tolerance to consider coincident nodes.

","Examples
To create spring elements between selected coincident nodes:
*createmark nodes 1 3-1000
*create_springs nodes EntityMark=1 Tolerance=0.1 DestinationComp=1 PropertyMode=1 Property=8

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
188,*create_voxel_lattice_mesh,"Description
Creates 1D and 2D axis parallel lattice meshes.
","Inputs

entity_type_2d
2D input entity types. Valid values are:
surfs
elems


mark_id_2d
The ID of the mark containing the 2D input entities. Valid values are 1 and 2. If no 2D entities are used as input, this should be 0.
mark_id_1d
The ID of the mark containing the 1D input entities. Valid values are 1 and 2. If no 1D entities are used as input, this should be 0.
origin_x
The coordinates of the domain origin.
origin_y
The coordinates of the domain origin.
origin_z
The coordinates of the domain origin.
voxel_size_x
The voxel size discretization along the axes.
voxel_size_y
The voxel size discretization along the axes.
voxel_size_z
The voxel size discretization along the axes.
mesh_extent_x
The boundary of the domain to be considered, specified using the rightmost corner of
            the domain bounding box relative to the origin. The rightmost extreme of the domain is
            calculated as (voxel_size_x * mesh_extent_x).
mesh_extent_y
The boundary of the domain to be considered, specified using the rightmost corner of
            the domain bounding box relative to the origin. The rightmost extreme of the domain is
            calculated as (voxel_size_y * mesh_extent_y).
mesh_extent_z
The boundary of the domain to be considered, specified using the rightmost corner of
            the domain bounding box relative to the origin. The rightmost extreme of the domain is
            calculated as (voxel_size_z * mesh_extent_z).

","Examples
To create a lattice mesh for all surfaces and lines that fall within the domain boundary
        defined by a box with corners (0,0,0) and (100, 100, 100), with unit size discretization
        along all
        axes:*createmark surfs 1 all
*createmark lines 1 all
*create_voxel_lattice_mesh surfs 1 1 0 0 0 1 1 1 100 100 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
189,*createandadjustmass,"Description
Adjusts mass for a selection of source components by creating solvermasses on the target
        components.
","
Inputs


addnumericalmass=<value>
0 - Do not add numerical mass (default)
1 - Add numerical mass coming from time step on the source entities
entitysource=<value>
The source entity type.  Must be set to comps.  This is mandatory.
entitytarget=<value>
The target entity type.  Valid values are comps and nodes.  If not specified, the
            source entities are updated.
marksource=<value>
The ID of the mark of source entities.  Valid values are 1 and 2.  This is
            mandatory.
marktarget=<value>
The ID of the mark of target entities.  Valid values are 1 and 2.
targetcogx=<value>
The target x-COG.  This is mandatory.
targetcogy=<value>
The target y-COG.  This is mandatory.
targetcogz=<value>
The target z-COG.  This is mandatory.
targetmass=<value>
The target mass value.  This is mandatory.
tolerance=<value>
The percentage tolerance on mass to be adjusted.
usestructuralmass=<value>
0 - Use engineering mass (default)
1 - Use structural mass

","Examples
To adjust mass on all the components with specific target mass and COG values:
*createmark comps 1 all
*createandadjustmass marksource=1 entitysource=comps targetmass=0.0245 targetcogx=-277.65 targetcogy=-0.49188 targetcogy=-0.49188 tolerance=10.0 usestructuralmass=1 addnumericalmass=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
190,*createautoddp,"Description
Create a design points from the selected elements.
<option>=<value> options can be provided in any order.
","Inputs


entity_type

The type of entity. Only elements are supported.

mark_id

The ID of the mark containing the entity_type entities. Valid
            values are 1 and 2.

autoddptype=<value>

The type of design point:
1 - Generic
2 - Beam
5 - Rivet
7 - Spring
30 - Panel metallic
31 - Panel composite

groupid=<value>

The ID of the design point set.

","Example
To create a spring design point from elements 1000-2000:
*createmark elements 1 1000-2000
*createautoddp elems 1 groupid=1 autoddptype=7
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
191,*createCAERO1,"Description
Creates an aero component of type CAERO1.
","
Inputs



start_id

The ID from which the component and element numbering will start.

n_span

The number of spanwise boxes to create.

n_chord

The number of chordwise boxes to create.

coordinates

The location of the four corner points. This must be 12 values enclosed in double
            quotes.

mode

Flag for create or update of component:
0 - Create
1 - Update



table_id_1

The ID of the AEFACT table containing the 1D array of custom element sizes along the
            span direction.



table_id_2

The ID of the AEFACT table containing the 1D array of custom biasing sizes along the
            span direction.

","Examples
Create an aero component with ID 910001, with 5 span and 10 chord boxes, and custom biasing
        defined by tables 31001 and 31002:
*createCAERO1 910001 5 10 ""1011.96772 124.925267 172.770859 1030.13113 214.800926 176.849632 882.388330 306.675850 186.826681 835.294585 239.767672 184.962570"" 0 31001 31002
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
192,*createcaero2bodymeshing,"Description
Creates a component for aeroelastic panel mesh CAERO2.
","
Inputs


bodyname=<value>
The name of the CAERO2 body entity.  If not specified, CAERO2_<componentid> is
            used.
componentid=<value>
The start value for component and element numbering.  This is mandatory.
halfwidths={<value>}
The halfwidth or radius of the body at each interval along the length of body.  A
            single value makes a body with a constant radius.
igid=<value>
The interference group identifier.
interferenceangles={<value>}
The angles along the radial direction of the body elements.
length=<value>
The length of the body in the local x direction of the aerodynamic coordinate
            system.
location={<value>}
The coordinates of the origin point (3 values).  This is mandatory.
mode=<value>
0 - Create component (default)
1 - Update component
nint=<value>
The number of interface elements.  If not provided, must specify
              tableid2.
nsb=<value>
The number of slenderbody elements.  If not provided, must specify
              tableid1.
systemid=<value>
The ID of the system for locating the origin point.
tableid1=<value>
The ID of an AEFACT table containing the list of division points for slenderbody
            elements. Used only if nsb is not provided.
tableid2=<value>
The ID of an AEFACT table containing the list of division points for interface
            elements. Used only if nint is not provided.

","Examples
Create an aero component with ID 62001, nsb=10, and nint=6:
*createcaero2bodymeshing componentid=62001 systemid=503 mode=0 nsb=10 nint=6 location={248 35.0 274.62} length=476 halfwidths={20 40 60 80 90 80 70} interferenceangles={0.0 60 120 180 240 300} tableid1=0 tableid2=0 igid=1 bodyname=CAERO2_62001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
193,*createcenternode,"Description
Creates a node at the center of a circle defined by 3 input nodes.
","Inputs

node_id1
The ID of the first node defining the circle.
node_id2
The ID of the second node defining the circle.
node_id3
The ID of the third node defining the circle.

","Examples
To create a node at the center of the circle defined by nodes 100, 200 and
        300:*createcenternode 100 200 300
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
194,*createcirclefromcenterradius,"Description
This command creates a circle or arc given the center and radius.
","Inputs

list_id
The ID of the list containing the nodes to be used as center points. A circle or arc
            is created for each node in the list.
vector_id
The ID of the vector defining the circle normal, defined using the
              *createvector command. This must be set to 1.
radius
The radius of the circle or arc.
angle
The angle of the arc. To create a circle, set to 360.
offset
Sets the starting offset for an arc.

","Examples
To create a circle centered at node 18, with radius 3.0, and in the plane whose normal is
        defined by (0.0, 0.0,
        1.0):*createvector 1 0.0 0.0 1.0
*createlist nodes 1 18
*createcirclefromcenterradius 1 1 3.0 360.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
195,*createcirclefrompoints,"Description
This command creates a circle or arc from 3 nodes.
","Inputs

list_id
The ID of the list containing the nodes that define the circle. The order of the nodes
            is important if creating an arc.
cirlce_flag
1 - Create a circle.
2 - Create an arc.

","Examples
To create a circle through nodes 100, 200 and
        300:*createlist nodes 1 100 200 300
*createcirclefrompoints 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
196,*createconnectionelements,"Description
Creates elements of a specified type between input nodes and nodes determined from the
        nearest elements within tolerance.  To search nearest elements for a given node, provide
        either the comp, elem, or part mark.  Options can be specified in any order.
","
Inputs



elem_type=<value>

The type of 1D element to create.  Must be set as rbe3.

node_mark=<mark_id>

The ID of the mark containing the input nodes.  Valid values are 1 and 2.

tolerance=<value>

The tolerance used to search nearest elements. Must be greater than 0.0.

<type_mark>=<mark_id>

The ID of the optional mark containing the input comp_mark ,
              elem_mark, or part_mark.  Valid values are 1 and
            2.

","Examples
To create RBE3 elements between the nodes associated with comp ID 20038 and all displayed
        components, using a tolerance of 10.0:
*createmark nodes 1 ""by collector"" 20038
*createmark comps 1 ""displayed""
*createconnectionelements node_mark=1 comp_mark=1 elem_type=rbe3 tolerance=10.0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
197,*createcrbrelation,"Description
Creates a master-slave relationship for LS-DYNA
        *CONSTRAINED_RIGID_BODIES keyword.
","Inputs

master_component_id
The ID of the master rigid component.
slave_component_id
The ID of the slave rigid component.

","Examples
To create a master-slave relationship between master rigid component 100 and slave rigid
        component 200:*createcrbrelation 100 200
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
198,*createdoublearray2d,"Description
Creates a 2D array of doubles for use in a subsequent command.
","Inputs

rows
The number of rows in the array.
cols
The number of columns in the array.
doubles
The doubles to put in the array.

","Examples
To create a 2D double array with 2 rows, 3 columns and the values (1.5, 2.5, 3.5) and (5.5,
        6.5, 7.5) in each respective
        row:*createdoublearray2d 2 3 1.5 2.5 3.5 5.5 6.5 7.5
",
199,*createelements,"Description
Create multiple 1D elements from a list of nodes.
","
Inputs


config
The HyperMesh element config number.
type
The solver type number.
integer_array
The ID of the integer array created using *createarray containing
            the pairs of nodes.  Must be set to 1.
number_of_integers
The number of integers in the array.

","Examples
To create two PLOTEL elements between nodes 1001 and 1003, and 1007 and 1009:
*createarray 4 1001 1003 1007 1009
*createelements 2 1 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
200,*createelementsbetweennodes,"Description
Creates a spotweld element between two surfaces at the selected nodes with an element type,
        coordinate system, and property ID.
","Inputs

surf1_markmask
First or multiple surfaces in the mark.
surf2_markmask
Second surface in the mark, if given.
markmask
Marked nodes.
tol
Search tolerance to identify surfaces.
createplot
Creates a plot.
configval
Element type configuration value.
syst
Local coordinate system switch.
0 - Without coordinate system.
1 - With coordinate system.


code
Code for one or all surface options.
0 - All surfaces.
1 - One surface.


*property
Name of property collector. Retrieves property ID.

","Examples
To create spotweld (spring elements) between surfaces 1 and 2, using the option individual
        surface and within a tolerance of 0.01 at the nodes. Elements are created with the
        coordinate system and property collector
        name_prop.*createelementsbetweennodes(1,2,2,0.01,1,21,1,1,""name_prop"")
",
201,*createellipsoids,"Description
Creates one or more ellipsoids based on the information given.
","Inputs

markmask
The mark of nodes used for the center of the ellipsoids.
type
1 - Ellipsoids.
2 - Cylinder.
name
The name of the ellipsoids.
radiusa
The length of an ellipsoid in the A direction. Real number value.
radiusb
The length of an ellipsoid in the B direction. Real number value.
radiusc
The length of an ellipsoid in the C direction. Real number value.
shape
The shape of an ellipsoid. Must be a real number between 2 and 8.
systemid
The ID of the system to which the ellipsoid is attached.
multibodyid
The ID of the multibody to which the ellipsoids are attached.
color
The color value of the ellipsoid.

",,
202,*createentitiesfromsource,"Description
Creates entities using an external source file.
","
Inputs



entitytype=<value>

The type of entity to create.  Currently only supported for beamsects.

source=<file>

The path and file name to the source file.

","Examples
Create beam sections using a csv file:
*createentitiesfromsource entitytype=beamsects source=C:/temp/beam_section.csv
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
203,*createentityarray2d,"Description
Creates a 2D array of entities for use in a subsequent command.
","Inputs

rows
The number of rows in the array.
cols
The number of columns in the array.
entities
The entities to put in the array.

","Examples
To create a 2D entity array with 2 rows, 3 columns and the entities with IDs (1, 2, 3) and
        (6, 7, 8) in each respective
        row:*createentityarray2d 2 3 1 2 3 6 7 8
",
204,*createentitysameas,"Description
Create a new entity that is a clone of the original. Attributes and data names are both
        cloned, however, collected entities are not cloned along with collectors. 
There are also a few limitations to this command: 
Rigid wall entities are not supported.


","Inputs

entity_type
Entity type to use as source.
entity_id
The ID of the source entity to clone.

","Examples
To duplicate the component with ID
        100:*createentitysameas comps 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
205,*createfbddisplacementtable,"Description
Creates an FBD displacement summary table.
This queries the GPF, Applied, SPC and MPC data from the result entity on a
        freebodysection.
Options can be provided in any order.
","Inputs

set_ids=<value>
The set entity IDs.
subcase_ids=<value>
The subcase info as an array.  Values are specified as resultfile_id subcase_id
            step_id, with each list separated by a comma.  For example: 1 1 0, 1 2 0, 2 1 0, 2 1
            1.
data_strings=<value>
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
displacement=<value>
0 - Applied forces are not particupating in the FBD calculation (default)
1 - Applied forces are particupating in the FBD calculation
freenode=<value>
Currently must be set to 2.  This is a mandatory argument.
resolvein_sys=<value>
0 - Resolve in analysis system (default)
1 - Resolve in global system
2 - Resolve in user system
resultid=<value>
The result entity ID.
rotation=<value>
0 - SPC forces are not particupating in the FBD calculation (default)
1 - SPC forces are particupating in the FBD calculation
tolerance=<value>
The tolerance to limit the values. Default is 0.00001.
user_sys_id=<value>
The system ID when resolvein_sys=2.


num_strings=<value>
Integer indicating the size (number of strings) in the data_strings
            array.

","Example
To create an FBD displacement summary table:
*createstringarray 7 ""resultid=1"" ""resolvein_sys=3 "" ""user_sys_id=2"" ""displacement=1"" ""rotation=1"" ""freenode=2"" ""tolerance=0.00001""
set setIds {1 2 3}
set scIds {1 1 0, 1 2 0, 2 1 0, 2 1 1}
*createfbddisplacementtable $setIds $scIds 1 7
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
206,*createfbdgroupfortraceplot,"Description
Creates a freebodygroup entity, used for FBD trace plots.
Options can be provided in any order.
","Inputs

name=<value>
The name of the freebodygroup to create.
node_ids=<value>
The node IDs for the trace path, given in sequence.  A minumum number of 2 nodes are
            required.
entType=<value>
Must be set to elems.
num_cuts=<value>
The number of cuts between each sequential node in node_ids. If 0
            then sections are only created at the nodes.
path_dir=<value>
0 - User direction
1 - Trace path direction
userDir=<dx dy dz>
When path_dir=0 , this is a triple double defining the direction
            vector.
sys_id=<value>
The ID of the system entity.

","Example
To create a freebodygroup named test with no cuts, a user direction, and system
        1:*createfbdgroupfortraceplot name=test node_ids={813 664} entType=elems num_cuts=0 path_dir=0 userDir={0.803557 0.595228 0.000000} sys_id=1
To create a freebodygroup named test with 4 cuts, a trace path direction, and no
        system:*createfbdgroupfortraceplot name=test node_ids={813 664} entType=elems num_cuts=4 path_dir=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
207,*createfbdsummarytable,"Description
Creates an FBD summary table or min/max table.
This queries the GPF, Applied, SPC and MPC data from the result entity on a
        freebodysection.
","Inputs

freebodysection_ids=<value>
The freebodysection entity IDs.
subcase_ids=<value>
The subcase info as an array. Values are specified as resultfile_id subcase_id
            step_id, with each list separated by a comma. For example: 1 1 0, 1 2 0, 2 1 0, 2 1
            1.
data_strings=<value>
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
appf=<value>
0 - Applied forces are not particupating in the FBD calculation (default)
1 - Applied forces are particupating in the FBD calculation
freenode=<value>
0 - Free nodes.  Fild the nodes which are shared by elements other than the
                  elements contained in the freebodysection.
1 - Boundary nodes.  Find only the boundary nodes of the elements contained in
                  the freebodysection.
2 - All nodes.  Find all nodes of the elements contained in the
                  freebodysection.
gpf=<value>
0 - Grid-point forces are not particupating in the FBD calculation
                  (default)
1 - Grid-point forces are particupating in the FBD calculation
intf=<value>
0 - Internal forces are not particupating in the FBD calculation (default)
1 - Internal forces are particupating in the FBD calculation
minmax=<value>
0 - Create FBD summary table (default)
1 - Create FBD min/max table
mpcf=<value>
0 - MPC forces are not particupating in the FBD calculation (default)
1 - MPC forces are particupating in the FBD calculation
resultid=<value>
The result entity ID.
spcf=<value>
0 - SPC forces are not particupating in the FBD calculation (default)
1 - SPC forces are particupating in the FBD calculation
tolerance=<value>
The tolerance to limite the values for table creation. Defaul is 0.00001.


num_strings=<value>
Integer indicating the size (number of strings) in the data_strings
            array.

","Example
To create an FBD summary
        table:*createstringarray 9 ""tolerance=0.00001"" ""resultid=1"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""freenode=2"" ""minmax=0""
set fbdIds {1 2 3}
set scIds {1 1 0, 1 2 0, 2 1 0, 2 1 1}
*createfbdsummarytable $fbdIds $scIds 1 9
To create an FBD min/max
        table:*createstringarray 9 ""tolerance=0.00001"" ""resultid=1"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""freenode=2"" ""minmax=1""
set fbdIds {1 2 3}
set scIds {1 1 0, 1 2 0, 2 1 0, 2 1 1}
*createfbdsummarytable $fbdIds $scIds 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
208,*createfilletmidlines,"Description
This command is applied to a selection of surfaces given by mark_id. It
        first recognizes triangular or rectangular fillet surfaces with radius among the range
          (min_radius, max_radius), and fillet profile arc
        length among the range (min_width, max_width). Then it
        splits the recognized fillets along longitudinal center lines.
","Inputs

mark_id
The mark of surfaces. Valid values are 1 and 2.
max_radius
The maximum fillet radius (must be greater than min_radius).
min_radius
The minimum fillet radius (must be greater than or equal to 0). 
max_width
The maximum fillet profile arc length (must be greater than
              min_width).
min_width
The minimum fillet profile arc length (must be greater than or equal to 0).
suppress_rib
The option for suppressing original fillet tangent lines.
0 - Do not suppress.
1 - Suppress.



","Examples
To create fillet midlines for all of the displayed surfaces with a max radius of 40, a min
        radius of 0.0001, a max width of 100000, a min width of 0, and do not suppress fillet
        tangent
        lines:*createmark surfaces 1  ""displayed""
* createfilletmidlines 1 40 0.0001 100000 0 0
",
209,*createinclude,"Description
Defines a new include file in the database.
","Inputs

id
Use 0, if HyperMesh should take the next available ID.
            Specifying a non-zero value will overwrite any existing include that already uses that
            ID value.
shortname
The last portion of the fullname (not including path). Short names must be
            unique.
fullname
The include’s full name, including file path. Must be unique, and must conform to the
            shortname, as described above.
parentid
The identifier for the file that includes this file. 
0 - Means the new file is included by the main (master) file. 
Non-unique shortnames or fullnames produce errors.

","Examples
To create a new include called mat1.dyn, using the master file as its
        parent:*createinclude(0,mat1.dyn,C:/common files/mats/mat1.dyn,0)
",
210,*createintarray2d,"Description
Creates a 2D array of integers for use in a subsequent command.
","Inputs

rows
The number of rows in the array.
cols
The number of columns in the array.
integers
The integers to put in the array.

","Examples
To create a 2D integer array with 2 rows, 3 columns and the values (1, 2, 3) and (5, 6, 7)
        in each respective row:*createintarray2d 2 3 1 2 3 5 6 7
",
211,*createjointelement_twonoded,"Description
Creates a two-noded joint element.
","Inputs

type
Element type to create. Valid values are 1 and 25 through 33.
node1
The ID of the first node.
node2
The ID of the second node.
orientation
A flag indicating how the orientation of the element is defined. Valid values are:
0 - None.
1 - Systems.
2 - Nodes.


o_node1
The ID of the first orientation node. Ignore, if orientation is not 2.
o_node2
The ID of the second orientation node. Ignore, if orientation is not 1.
o_system1
The ID of the first orientation system. Ignore, if orientation is not 2.
o_system2
The ID of the second orientation system. Ignore, if orientation is not 1.
property
The ID of the property to assign to the element.

","Examples
To create a two-noded joint element of type 25, using nodes 62 and 2, with systems 454 and
        465 used for orientation, with no
        property:*createjointelement_twonoded 25 62 2 1 0 0 454 465 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
212,*createlistbypathpanel,"Description
Provides a panel to create an ordered list of entities for use in a subsequent command,
        with the collector set to ""by path"".
","Inputs

entity_type
Entity type to put on the list. Valid values are:
elems
laminates
lines
nodes
plies
surfs


list_id
The ID of the list to populate. Valid values are 1 and 2.
message
A string indicating a message to display in the status bar.

","Examples
To create a line from a user specified list of
        nodes:*createlistbypathpanel nodes 1 ""Select nodes for the line:""
set node_list [ hm_getlist nodes 1 ];
if { ! [ Null node_list ] } {
    *linecreatefromnodes 1 0 150 5 179
}

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
213,*createmark,"Description
This command will place entities of entity_type onto
          mark_id. Valid mark_ids are 1 and 2. Depending on
        the options specified, the supported entity_types will change.
All options only return entities that are defined as
          active in the database, unless otherwise noted. 
If no ?option? is specified, ""by name only"" is used for entities with
        names. Otherwise, ""by id only"" is used. This can be specified using the command
          hm_marksearchmode. 
If no ?option? is specified, both active and inactive entities may be
        selected. 
For options that allow both ""ids or names"" in the list, entities are found first using
        names. Entities not found using names are then found using IDs. This order can be specified
        using the command hm_marksearchmode. 
When specifying entity names that contain spaces, group the name using brackets, {Comp name
        with spaces}, or use a Tcl list. 
When specifying the list using a Tcl variable, the
          eval
Tcl command must precede the *createmark command (see
        example below). This expands (substitutes) the Tcl list before executing
        the command. It is also important to use brackets around any options that contain spaces
        when using eval (eval
*createmark solids 1 {""by comp name""} $comp_names). Otherwise, the quotes
        will be expanded before the option reaches the *createmark command and it
        will not function as expected. 
Negative values can be used to find recently created entities (see example below). This
        functionality selects entities in the reverse order they are stored in the database (the
        order they are created, regardless of ID). However, any operations that affect the order of
        entities in the database (organize, reorder, etc.) will change the returned/selected
        entities. It is recommended to use this option only immediately after entity creation and
        before any other operations that may modify the database.
","Inputs

entity_type
Entity type to use. Depending on the options specified, the supported entity types
            will change.
mark_id
The ID of the mark. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to create the mark from.  If not specified, the current model is
            used.
?""options""?


","Examples
To delete components with names FRONT and
        SIDE:*createmark comps 1 FRONT SIDE
*deletemark comps 1
To delete components with names ""Name with spaces"" and
          SIDE:*createmark comps 1 {Name with spaces} SIDE
*deletemark comps 1orset names [list {Name with spaces} SIDE]
eval *createmark comps 1 $names
*deletemark comps 1
To mark the last 3 components that were
        created:*createmark comps 1 -1 -2 -3
To delete all elements in the
        database:*createmark elems 1 ""all""
*deletemark elems 1
To delete displayed
        elements:*createmark elems 1 ""displayed""
*deletemark elems 1
To detach the elements (by .5) that failed the quality index (you must first use the save
        failed button in the quality index
        panel):*createmark elems 1 ""retrieve""
*detachelements 1 .5
To delete all elements except the element with ID =
        10:*createmark elems 1 10
*createmark elems 1 ""reverse""
*deletemark elems 1
To set all inactive assemblies to
        active:*createmark assems 1 ""inactive""
*setvalue assems mark=1 activesuppressed=0
To split all elements found in assemblies with IDs 10 and
        20:*createmark elems 1 ""by assem id"" 10 20
*splitelements 1 1
To split all elements found in assemblies A and
        B:*createmark elems 1 ""by assem name"" A B
*splitelements 1 1
To delete all systems in the system collector with ID
        100:*createmark systems 1 ""by collector id"" 100
*deletemark systems 1
To delete all loads in load collector
        loadcol1:*createmark loads 1 ""by collector name"" loadcol1
*deletemark loads 1
To change elements in component with ID 200 to 2nd
        order:*createmark elems 1 ""by comp id"" 200
*orderchangetosecond 1 0 0
To change elements in components named left and right to 2nd
        order:set list ""left right""
eval *createmark elems 1 ""by comp name"" $list
*orderchangetosecond 1 0 0
To place components X and Y on mark 1 and translate elements in these components by
        (5,0,0):*createmark comps 1 ""by name only"" X Y
*createmark elems 1 ""by comps on mark"" 1
*createvector 1 1.0 0.0 0.0
*translatemark elements 1 1 5
To split all quad4 elements in the
        model:*createmark elems 1 ""by config"" quad4
*splitelements 1 1
To mark all rigidlink elements that are of type RgdBody or ConNode. (The LS-DYNA template must be
        loaded.):*createmark elems 1 ""by config type"" 1 rigidlink RgdBody ConNode
To mark elements whose component references material with ID 50 or whose property
        references material with ID
        50:*createmark elems 1 ""by material id"" 50
To mark elements that point to the property with name prop1 or, if no property is assigned
        to the element, whose component points to the property with name
        prop1:*createmark elems 1 ""by property name"" prop1
To split all elements if their center is on the X-Y
        plane:*createmark elems 1 ""on plane"" 0 0 0 0 0 1 .1 1 1
*splitelements 1 1
To get a list of the elements referenced by outputblock
        OPB:*createmark elems 1 ""by outputblock name"" OPB
set elem_list [hm_getmark elems 1]
To mark elements that share a face with elements 50 and 100 for model
        model-2:*createmark elems 1 ""by model"" model-2 50 100
*appendmark elems 1 ""by model"" model-2 ""by face""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
214,*createmarkpanel,"Description
Provides a panel to add entities to a mark.
","Inputs

entity_type
The type of entities to add.
mark_id
The ID of the mark. Valid values are 1 and 2.
message
A string to show in the message bar when entering the panel.
?face_edge_mode?
The default face/edge selection mode to use when entering the panel. This is valid
            only for nodes and elements. An invalid value defaults to 0, or is ignored for
            non-supported entity types.
0 - Standard entity selection
1 - 2D faces (elems) or faces (nodes)
2 - 2D faces ext (elems and nodes)
3 - Free edges (nodes only)
4 - Edges (nodes only)
5 - Loops (nodes only)
6 - Free edges ext (nodes only)
7 - Edges ext (nodes only)


?filter?
Defines which selection modes should be allowed. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6 +
            128*Bit7).
A value of 0 (default) means all selection modes are available.
For nodes, if the sum does not include Bit0 set to 1, although nodes are collected,
            what is highlighted are the faces/edges. Proceed from the panel, and the corresponding
            nodes will be highlighted.
Bit0:
0 - Do not allow standard selection (elems and nodes)
1 - Allow standard selection (elems and nodes).
Bit1:
0 - Do not allow 2D faces (elems) or faces (nodes)
1 - Allow 2D faces (elems) or faces (nodes)
Bit2:
0 - Do not allow 2D faces ext (elems and nodes)
1 - Allow 2D faces ext (elems and nodes)
Bit3:
0 - Do not allow free edges (nodes only)
1 - Allow free edges (nodes only)
Bit4:
0 - Do not allow edges (nodes only)
1 - Allow edges (nodes only)
Bit5:
0 - Do not allow loops (nodes only)
1 - Allow loops (nodes only)
Bit6:
0 - Do not allow free edges ext (nodes only)
1 - Allow free edges ext (nodes only)
Bit7:
0 - Do not allow edge ext (nodes only)
1 - Allow edge ext (nodes only)



","Examples
To create a mark of elements in a
        panel:*createmarkpanel elems 1 ""Please select the elements""
hm_getmark elems 1
To create a mark of elements in a panel using 2D faces as the default selection
        mode:*createmarkpanel elems 1 ""Please select the elements"" 1
hm_getmark elems 1
To create a mark of elements in a panel using 2D faces as the default selection mode, only
        allowing 2D faces and 2D faces ext
        modes:*createmarkpanel elems 1 ""Please select the elements"" 1 6
hm_getmark elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
215,*createnodesandspotweldelems,"Description
 Creates nodes and spotweld elements between two surfaces on the selected lines at a
        specified spacing or density with an element type, coordinate system, and property ID.
","Inputs

surf1_markmask
First or multiple surfaces in the mark.
surf2_markmask
Second surface in the mark, if given.
tol
Search tolerance to identify the surfaces.
createplot
Creates a plot.
configval
Element type configuration value.
syst
Local coordinate system switch.
0 - Do not build systems.
1 - Build systems.


code
Code for one or all surface options.
0 - All surfaces.
1 - One surface.


num_nodes
Number of nodes on the line (for Density option only).
entities
Line entity.
markmask
Marked lines.
biasstyle
1 - Linear.
biasingintensity
0.0 - Equal spacing.
spacing
Spacing between weld elements.
= 0.00 for Density option.
offset_type
0 - End offset.
1 - Half spacing.
endoffset
End offset from the edge (= value).
*property
Name of property collector. Used to retrieve property.

","Examples
To create five spotwelds (bar2 elements) between surfaces, using the all surfaces option,
        within a tolerance of 0.01 along four marked lines at equal spacing. Elements are created
        without a coordinate system and property collector
        name_prop.*createnodesandspotweldelems(2,2,0.01,1,60,0,0,5,lines,1,
  1,0.0,0.00,0,0.0,""name_prop"")
To create the same with an end offset value of
        2.0,*createnodesandspotweldelems(2,2,0.01,1,60,0,0,5,lines,1,1,0.0,
  0.00,0,2.0,""name_prop"")
",
216,*createnodesbetweennodes,"Description
Creates a user-specified number of nodes between two nodes. 
","Inputs

node1
The first of 2 nodes between which new nodes should be created. 
node2
The second of 2 nodes between which new nodes should be created. 
number
The number of nodes which should be created between node1 and node2. 

","Examples
To create 5 nodes between nodes 100 and 101:
        *createnodesbetweennodes(100,101,5)
",
217,*createplane,"Description
Defines a plane for use in a subsequent command.
","Inputs

plane id
The ID of the plane being defined (1 or 2). 
normal x
The x component of the normal of the plane. 
normal y
The y component of the normal of the plane. 
normal z
The z component of the normal of the plane. 
base x
The x component of the base point of the plane. 
base y
The y component of the base point of the plane. 
base z
The z component of the base point of the plane. 

","Examples
To create plane 1 with a normal along the x axis and a base point of (2.0, 3.0, 4.0):
        *createplane(1,1.0,0.0,0.0,2.0,3.0,4.0)
",
218,*createpointsbetweenpoints,"Description
Creates a specified number of points between points.
","Inputs

point_id1
IDs of the points between which the specified number of points will be created.
point_id2
IDs of the points between which the specified number of points will be created.
count
The number of points to create.

","Examples
This command is called from the Distance
        panel.*createpoint(0,0,0,0)
*createpoint(10,0,0,0)
*window(0,0,0,0,0)
*pointmodify(2,5,0,0)
*createpointsbetweenpoints(1,2,1)
",
219,*createpositionformech ,"Description
Creates a new position for a mechanism. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the position to be created. If the provided name already exists, an
            incremental name will be used.

","Example
To create a new position with name newposition:
*createpositionformech newposition
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
220,*createsectioncut,"Description
This command computes area moments of inertia and stiffness terms of a planar section cut
        from a 1D/2D selection. The computed data is stored in a resultant section cut table.
        Moreover, it can create shell beam sections from the cuts and create beam elements along the
        consecutive cuts. Every beam element created has a PBEAM property assigned to it. The
        property refers to the beam sections, along the start and end of the beam element, at
        stations 0 and 1. The command currently works for OptiStruct and
          Nastran user profiles.
","Inputs

sectionmethod=<value>
auto - Uses the element selection to compute the bounding box and creates section cut
            along the longest dimension of the box. In case of ambiguity, considers the global axis
            in the order of X and Y respectively as section cut normal.
byplane - Uses the plane information to create the cut (default)
beamoffset=<value>
Available if includebeams is specified.
0 - Do not consider 1D offset in the section cut (default)
1 - Consider 1D offset in the section cut
createbeamelems=<value>
0 - Do not create beam elements between consecutive cuts (default)
1 - Create beam elements between consecutive cuts, and create and assign PBEAM
            properties.
createbeamsect=<value>
0 - Do not create shell beam section from the section cut (default)
1 - Create shell beam section from the section cut
createelemsat=<value>
Available if createbeamelems=1.
1 - Create beam elements at the centroid (default)
2 - Create beam elements at the neutral axis
createelemsets=<value>
0 - Do not create sets of intersecting elements for each cut (default)
1 - Create sets of intersecting elements for each cut
createsectiondata=<value>
0 - Do not create resultant section cut table (default)
1 - Create resultant section cut table
detaileddata=<value>
0 - Do not create a table with detailed element level section cut data (default)
1 - Create a table with detailed element level section cut data
elemscomp=<value>
Available if createbeamelems=1.
0 - Create in current component (default)
1 - Create in new component
includebeams=<value>
0 - Do not consider beam/bar elements in the section cut
1 - Consider beam/bar elements in the section cut (default)
includeenttype=<value>
The include entity type, elems or comps.  Requires includemark to
            be specified.
includemark=<value>
The ID of the mark containing the entities for the section cut.  If provided, only the
            given elements will be used for the cut.  Valid values are 1 and 2.  Required if
              includeenttype is specified.
includerods=<value>
0 - Do not consider rod/truss elements in the section cut
1 - Consider rod/truss elements in the section cut (default)
includeshells=<value>
0 - Do not consider 2D elements in the section cut
1 - Consider 2D elements in the section cut (default)
intertiaat=<value>
centroid - Output the MOI at the section's centroid
neutralaxis - Output the MOI at the section's neutral axis (default)
neutralaxis - Output the MOI at the section's neutral axis (default)
<x y z> - Output the MOI at the user-defined position projected onto the section's
            plane
keepintersectlines=<value>
Available if createbeamsect=1.
0 - Do not keep intersect lines (default)
1 - Keep intersect lines
linescomp=<value>
Available if keepintersectlines=1.
0 - Keep in current component (default)
1 - Keep in new component
nodeatcentroid=<value>
0 - Do not create a node at the centroid (default)
1 - Create a node at the centroid
nodeatneutralaxis=<value>
0 - Do not create a node at the neutral axis (default)
1 - Create a node at the neutral axis
numcuts=<value>
The number of cuts to be made.
offset=<value>
The offset from the section plane base to make consecutive cuts. Requires the use of
              numcuts.  Available if sectionmethod=byplane and
              sectionbase is provided.
refenttype=<value>
The type of reference entities to use, nodes or points.  Requires
              reflistid to be specified.
reflistid=<value>
The ID of the list containing the reference nodes or points for the section plane
            base.  Valid values are 1 and 2.  Required if refenttype is
            specified.
sectionbase=<x y z>
The coordinates of the section base.  Required if
              sectionmethod=byplane and offset is to be
            used.
sectionnormal=<x y z>
The component of the section plane normal pointing to the positive side.  Only
            elements from that side are considered to evaluate interias.  Required if
              sectionmethod=byplane.
shelloffset=<value>
Available if includeshells is specified.
0 - Do not consider shell offset in the section cut (default)
1 - Consider shell offset in the section cut
verticalaxis=<x y z>
The global coordinates of the YZ section vertical axis.  The actual vertical axis will
            be recomputed as 2 cross-products using the section's normal vector.  Required if
              sectionmethod=byplane.

","Example
Create a section cut using offset
        information:*createmark comps 1 displayed
*createsectioncut sectionmethod=byplane sectionnormal={-1 0 0} verticalaxis={0 0 1} sectionbase={8000 1.5916157281026e-12 1125} offset=300 numcuts=2 inertiaat=centroid includemark=1 includeenttype=comps createelemsets=1 createsectiondata=1 detaileddata=1 nodeatcentroid=1 createbeamsect=1 keepintersectlines=1 linescomp=1 createbeamelems=1 createelemsat=1 elemscomp=1
Create a section cut using
        nodes:*createlist nodes 2 10 11 12
*createsectioncut sectionmethod=byplane sectionnormal={1 0 0} verticalaxis={0 0 1} refenttype=nodes reflistid=2 inertiaat=centroid createelemsets=1 createsectiondata=1 detaileddata=1 nodeatcentroid=1 createbeamsect=1 keepintersectlines=1 createbeamelems=1 createelemsat=1
Create a section cut using
        auto:*createsectioncut sectionmethod=auto numcuts=4 inertiaat=centroid createelemsets=1 createsectiondata=1 detaileddata=1 nodeatcentroid=1 createbeamsect=1 keepintersectlines=1 createbeamelems=1 createelemsat=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
221,*createsolidsfromshells,"Description
Creates solid elements from shell elements. This API currently works only on composite
        ply-based models for OptiStruct/Nastran and Abaqus. Zone-based models are
        not supported, nor are metallic models.
","Inputs

entity_type
The type of entity that holds the shell elements. Valid values are plies and
            laminates.
Plies need to be part of the laminate, each ply needs to have thickness and an
            associated set (with relevant elements assigned to it).
input_mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
output_mark_id
The ID of the mark containing the newly created solid elements. Valid values are 1 and 2.
comp_create_option
Organization method for newly created solid elements:
0 - Current component.
1 - Create a new component for each ply (valid only if entity_type
            is set to plies and solid_layers is set to 0).
2 - Create a new component for all solid elements created.
solid_layers
Valid if entity_type is set to plies only:
0 - Create solids for each layer.
1 - Create single solids for all layers.
fill_gaps
0 - Gaps between layers will not be filled.
1 - Gaps between layers filled with solids.
delete_shells
0 - Keep input shell elements.
1 - Delete input shell elements.
property_create
0 - No properties created/assigned for created solids.
1 - An appropriate property will be created and assigned to the solid elements. 
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
reserved3
Reserved for future use. Must be set to 0.

","Examples
To convert all shell elements in a ply named ""Ply3"" to solids, creating solids for each
        layer, without filling the gaps between layers. A new component and appropriate property
        should be created and assigned to the solids, deleting the existing
        shells:*createmark plies 1 ""Ply3""
*createsolidsfromshells plies 1 2 0 0 1 1 1 0 0 0 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
222,*createstringarray,"Description
Creates an array of strings for use in a subsequent command.
","Inputs

size
The size of the array.
strings
The strings to put in the array.

","Examples
To create a string array with the strings ""abc"" and
        ""def"":*createstringarray 2 ""abc"" ""def""
",
223,*createweldelemsfromalinelist,"Description
Creates weld elements between surfaces using a line list to determine the weld points.
","Inputs

surf1_markmask
First or multiple surfaces in the mark.
surf2_markmask
Second surface in the mark, if given.
Tol
Search tolerance to identify the surfaces.
createplot
Creates a plot.
configval
Element type configuration value.
Syst
Local coordinate system switch:
0 - Do not build systems.
1 - Build systems.


Code
Code for one or all surface options:
0 - All surfaces.
1 - One surface.


num_nodes
Number of nodes on the line (for Density option only).
Linelist1
The line list on the mark.
Nodelist1
The node list associated with the line list on the mark.
biasstyle
1 - Linear.
biasingintensity
0.0 - Equal spacing.
Spacing
Spacing between weld elements (= 0.00 for Density option).
offset_type
0 - End offset.
1 - Half spacing.
endoffset
End offset from the edge (=value).
Property
Name of property collector. Used to retrieve the property.

","Examples
To create five equally spaced spotwelds on different lines: Lines 95, 96, and 97 are joined
        together into a single line. Each of these nodes is projected normally on the two surfaces
        (237 and 253) within a tolerance of 1.0. Then the two surfaces are welded together at the
        projection
        points.*createweldelemsfromalinelist(2,2,1.0,1,3,0,0,5,2,2,1,
  0.0,0.0,0,0.0,""myprop"")
To create the same with spacing value of 2.0 and half spacing
        option,*createweldelemsfromalinelist(2,2,1.0,1,3,0,0,5,2,2,1,0.0,2
  0,1,0.0,""myprop"")
",
224,*createweldsbetweenelemsusingnodes,"Description
Creates weld element(s) between pre-existing elements at the given node(s).
","Inputs

elem1_mark
The element mark for the first element collector.
elem2_mark
The element mark for the second element collector, if given
single_col
Flag for the number of element collectors used:
1 - One element collector. 
0 - Two element collectors.


node_mark
The node mark for the node collector.
tol
The maximum distance allowed between the node (from the node mark) and the element
            (from the element mark) to weld this element.
syst
Systems flag:
1 - Build systems.
0 - Do NOT build systems.


configval
Type of weld element created:
2 = plot 
3 = weld 
5 = rigid 
21 = spring 
60 = bar 
61 = rod 
70 = gap


property
Name of the property collector. Used to retrieve the property ID.
remesh
Remesh flag (always 0).

","Examples
Each of the three nodes on the mark (16, 17, and 18) try to project normally onto as many
        elements as they can that are within a tolerance of 1.0. All of the non-adjacent elements
        found for each node's projections are then welded together at their projection
        points.*createmark(elems, 2) ""all""
*createmark(nodes, 2) 16 17 18
*createweldsbetweenelemsusingnodes(2, 2, 1, 2, 1.0, 1, 3, ""myprop"")
If the single_col flag equals 1, then elem2_mark flag
        is ignored.
",
225,*criteria_update,"Description
Updates the global mesh quality values.
","
Inputs

Criteria Options
<criterion>={<option1>=<value1> ?<option2>=<value2>? ...
                ?<optionN>=<valueN>?}
Supported criteria are:
aspect_ratio_2d
aspect_ratio_3d
cell_squish_3d
chord_dev_2d
equiangular_skew_3d
jacobian_2d
jacobian_3d
max_angle_quad_2d
max_angle_quad_3d
max_angle_tria_2d
max_angle_tria_3d
max_size_2d
max_size_3d
min_size_3d
min_angle_quad_2d
min_angle_quad_3d
min_angle_tria_2d
min_angle_tria_3d
min_size_2d
orthogonality_3d
percent_tria_2d
size_ratio_3d
skew_2d
skew_3d
taper_2d
tetra_collapse_3d
time_step_2d
volume_aspect_ratio_3d
volume_skew_3d
warpage_2d
warpage_3d
The list of valid options are:


color=<value>
The color of the criterion.  Valid values are 0-63.
fail=<value>
The fail threshold value for the criterion.  Must be a valid value.
good=<value>
The good threshold value for the criterion.  Can be set to ""auto"" to
                    auto-calculate based on the fail value.  Not valid for
                    time_step_2d.
ideal=<value>
The ideal threshold value for the criterion.  This is only valid for
                    max_size_2d, max_size_3d, min_size_2d, and min_size_3d.  If specified,
                      max_fail and min_fail must also be
                    provided (e.g. *criteria_update target_element_size_2d = {ideal = 7, min_fail =
                    2, max_fail = 15}).
max_fail=<value>
The max fail threshold value used when ideal is specified.
                    Can also be used independently with element_size_3d.
method=<value>
The calculation method to apply to the criterion. Available methods vary for
                    each criterion. Individual methods for quality parameters can be set only if
                      global_solver=individual_methods (except for min_size_2d,
                    min_size_3d, jacobian_2d and jacobian_3d).
Valid values for min_element_size_2d and min_element_size_3d:
minimum_height
minimum_normalized_height
ls_dyna_isdo=0
ls_dyna_isdo=1
ls_dyna_isdo=2
pam-crash_large
pam-crash_small
radios_default_formation
shortest_edge
Valid values for jacobian_2d and jacobian_3d:
corner_mid_points
corner_points
high_order_integration_points
integration_points
Valid values for other quality checks:
abaqus
ansys
hypermesh
hypermesh-alt
ideas
medina
moldflow
nastran
optistruct
patran
min_fail=<value>
The min fail threshold value used when ideal is specified.
                    Can also be used independently with element_size_3d.
state=<value>
The state of the criterion:
0 - Disabled
1 - Enabled
warn=<value>
The warn threshold value for the criterion.  Can be set to ""auto"" to
                    auto-calculate based on the fail value.  Not valid for
                    time_step_2d.
worst=<value>
The worst threshold value for the criterion.  Can be set to ""auto"" to
                    auto-calculate based on the fail value.  Not valid for
                    time_step_2d.




Global Options
global_solver=<value>
Specifies the global calculation method to be used for all quality parameters.
              Individual quality methods for each quality check with be modified accordingly.  Valid
              values are:
abaqus
ansys
hypermesh
hypermesh-alt
ideas
individual_methods
medina
moldflow
nastran
optistruct
patran
legend_colors={qiview_color=<value>, ideal_color=<value>,
                good_color=<value>, warn_color=<value>, fail_color=<value>,
                worst_color=<value>}
Sets the color values for the 6 legend thresholds.  Valid colors are 1-64.


","Examples
Update the thresholds of min size for 2D by providing all the thresholds
        values:*criteria_update min_size_2d = {state=1, color=59, method=shortest_edge, good=9, warn=4, fail=2, worst=1}
Auto update the thresholds for 3D jacobian by providing just the fail
        value:*criteria_update jacobian_3d = {state=1, color=43, good=auto, warn=auto, fail=0.5, worst=auto}
Change the global methods to
        Abaqus:*criteria_update global_solver = abaqus
Change the global methods to individual
        methods:*criteria_update global_solver = individual_methods
Update the target element size for 3D quality
        checks:*criteria_update target_element_size_3d = {ideal=6, min_fail=1, max_fail=10}
Update the ideal size and other thresholds for min size and max size 2D
        quality:*criteria_update min_size_2d = {ideal=10.1, good=9, warn=4, fail=2, worst=1} max_size_2d = {ideal=10.2, good=12, warn=15, fail=20, worst=30}
Update the legend
        colors:*criteria_update legend_colors = {qiview_color=5, ideal_color=59, good_color=33, warn_color=7, fail_color=60, worst_color=4}
Update the 2D time step
        criteria:*criteria_update time_step_2d = {state = 1, fail = 0.1, color = 43}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
226,*currentcollector,"Description
Sets the current collector. 
","Inputs

entity type
Collector type which the current collector should be set to. Valid types are:
component
systcol
loadcol


name
The name of the collector which should be made current. 

","Examples
To set the current component to be the component named stuff:
        *currentcollector(component,stuff)
",
227,*curvedeletepoint,"Description
Deletes a point from the curve.
","Inputs

curve_id
The ID of the curve.
point_number
The point number on the curve to be deleted. Point numbering starts with 1.

",,
228,*curvemodifypointcords,"Description
Modifies the x or y coordinate of an existing point on a curve.
","Inputs

curve_id
The ID of the queried curve.
point_number
The point number on the curve to be modified. Point numbering starts with 1.
-x
The string identifiers to modify the x coordinate of the point.
xvalue
The value to be modified of the x coordinate of the point.
-y
The string identifiers to modify the y coordinate of the point.
yvalue
The value to be modified of the y coordinate of the point.

","Examples
To modify the x coordinate of the second point to
        5.0:*curvemodifypointcords($curve_id, 2, -x, 5.0)
To modify the y coordinate of the second point to
        100.0:*curvemodifypointcords($curve_id, 2, -y, 100.0)
To modify the second point x coordinate to 5.0 and y co-ordinate to
          100.0:*curvemodifypointcords($curve_id, 2, -x, 5.0, -y, 100.0)Either -x xvalue or -y yvalue, or both can be specified. 
If only x coordinate needs to be modified, specify -x xvalue.
        
If only y coordinate needs to be modified, specify -y yvalue.
        
If both x and y coordinates need to be modified, specify -x xvalue
          -y yvalue.
",
229,*decimate_mesh,"Description
Performs mesh decimation on selected components. The decimation is performed either based
        on the element size, or based on a decimation factor.
","Inputs

comps_mark_id
The ID of the mark containing the input components. This must also include any 1D
            multi-leg rigid elements that will be processed by the update_rigids
            option. Valid values are 1 and 2.
nodes_mark_id
The ID of the mark containing any nodes to be treated as sacred/fixed. These nodes
            must belong to the initial mesh. These nodes will be maintained during decimation. Valid values are 1 and 2.

failed_comps_mark_id
The ID of the mark to store any failed components. Valid values are 1 and 2.
size_or_factor
If Bit10 is set to 0 in the options flag, this is the element size
            to use for decimation. This must be larger than the initial mesh size. The coefficient
            for the decimation is found by dividing the average triangle’s area for the input mesh
            to the equilateral tria’s area for the output size. 
If Bit10 is set to 1 in the options flag, this is the decimation
            factor.
feature_angle
This specifies the maximum angle between the normals of two connected elements. This
            value is ignored for shell elements. For 3D elements, the appropriate free faces of
            shell elements are created and meshed with the given feature angle. This value is also
            used to construct the connected edges for the failed components. Then these components
            are decimated in a second attempt. 
If this value is less than 1.0, the default value of 85.0 degrees is used.
update_rigids
0 - Do not delete the free legs of any rigidlink/RBE3 elements that are part of the
            input components. 
1 - After decimation, delete the free legs of any rigidlink/RBE3 elements that are
            part of the input components.
options
Flags that specify various additional options/behaviors. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 +
              1024*Bit10).
Bit0
1D handling before coarsening.
0 - Do not utilize this option. 
1 - All selected 1D element paths not sharing sacred nodes must be deleted
                      before mesh coarsening. 1D elements paths comprising sacred nodes are
                      preserved. Unselected 1D elements are ignored. Preserved 1D elements which are
                      not free should be attached to the shell mesh after coarsening.




Bit1
1D free element handling after coarsening.
0 - Do not utilize this option. 
1 - Selected 1D elements that appear free (are not attached to the shell or
                      solid mesh) after mesh coarsening must be deleted after meshing. 1D elements
                      sharing sacred nodes must be preserved.




Bit2
1D element free leg handling after coarsening.
0 - Do not utilize this option. 
1 - Selected 1D multi-leg elements having free legs after mesh coarsening
                      (are not attached to shell or solid mesh) must be updated by deleting the free
                      legs.




Bit3
1D elements convert to plot elements.
0 - Do not utilize this option. 
1 - Selected 1D elements remaining after meshing should be converted to
                      plot elements after coarsening.




Bit4
2D elements convert to plot elements.
0 - Do not utilize this option. 
1 - Selected 2D elements should be converted to plot elements after
                      coarsening. This flag is utilized only for the OptiStruct user profile.




Bit10
Element size versus decimation factor.
0 - Perform decimation based on element size. 
1 - Perform decimation based on a decimation factor.





","Examples
Create a decimated mesh with element size 30 using all components. Keep node IDs 16 and 27
        as anchor nodes. If the model has rigidlink/RBE3, delete any free legs in the input
        components:*createmark components 1 ""all""
*createmark nodes 1 16 27
*decimate_mesh 1 1 2 30 45
Create a decimated mesh of all displayed components with deformation factor of
        0.5:*createmark components 1 ""displayed""
*createmark nodes 1 """"
*decimate_mesh 1 1 2 0.5 45 1025
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
230,*defaultmeshsurf,"Description
Meshes a selection of surfaces using saved or default parameters and various options.
","Inputs

mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 1 and 2.
elem_size
The default element size used to calculate element densities along edges (when
            necessary).
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


previous_settings
Flag indicating whether to break, keep or redo connectivity between neighboring
            surfaces. Valid values are:
0 - Keep previous settings and do not break connectivity between neighboring
                surfaces. 
1 - Break connectivity between neighboring surfaces. 
2 - Keep connectivity between neighboring surfaces. 
3 - Redo connectivity between neighboring surfaces by expanding surface selection
                by one layer of adjacent surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. 
1 - Elements are created in the same components as their parent surfaces.


size_control
Flag indicating whether to create uniformly sized elements. Valid values are:
0 - Do not create uniformly sized elements. 
1 - Create uniformly sized elements.


skew_control
Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid values are:
0 - Do not create optimally shaped elements. 
1 - Create optimally shaped elements.


mesh_type
Parameter specifying the meshing algorithm for edge/surface meshing. Valid values are:
1 - Standard edge meshing. 
2 - Chordal deviation edge meshing. 
3 - Proximity based surface meshing. 
4 - Proximity and curvature based surface meshing. 
5 - Curvature based surfaced meshing. 
6 - Proximity and curvature based meshing with free edge deviation. 
7 - Curvature based surface meshing with free edge deviation. 
11 - Standard edge meshing with flow ""align"" control. 
12 - Chordal deviation edge meshing with flow ""align"" control. 
14 - Standard edge meshing with flow ""align"" and ""size"" control.


min_size
The minimum edge size for chordal deviation meshing. Ignored otherwise.
max_size
The maximum edge size for chordal deviation meshing. Ignored otherwise.
chordal_dev
The chordal deviation value for chordal deviation meshing. Ignored otherwise.
max_angle
The maximum angle (in degrees) between edges for chordal deviation meshing. Ignored
            otherwise.

","Examples
To create quads using a default edge size of 1.0 for the surface with ID
        3:*createmark surfaces 1 3
*defaultmeshsurf 1 1 1 1 1 0 0 0 1 0 0 0 0
To create mixed type elements for the size controlled mapping algorithm using tria
        transitions, trias for free mesh and chordal deviation edge meshing for surfaces 3, 5 and
        6:*createmark surfaces 1 3 5 6
*defaultmeshsurf 1 1 2 0 1 0 1 0 2 0.5 30 0.1 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
231,*defaultremeshelems,"Description
Re-meshes a selection of elements using various options, and deletes the original
        elements.
","Inputs

mark_id
The ID of the mark containing the elements to re-mesh. Valid values are 1 and 2.
elem_size
The default element size used to calculate element densities along edges (when
            necessary).
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. Boundaries between components
                are not maintained when remeshing. 
1 - Elements are created in the same components as the source elements.
                Boundaries between components are maintained when remeshing


size_control
Flag indicating whether to create uniformly sized elements. Valid values are:
0 - Do not create uniformly sized elements. 
1 - Create uniformly sized elements.


skew_control
Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid values are:
0 - Do not create optimally shaped elements. 
1 - Create optimally shaped elements.


edge_mesh_type
Determines the algorithm for edge meshing:
1 - Standard edge meshing. 
2 - Chordal deviation edge meshing. 
11 - Standard edge meshing with flow ""align"" control. 
12 - Chordal deviation edge meshing with flow ""align"" control. 
14 - Standard edge meshing with flow ""align"" and ""size"" control.


min_size
Minimum edge size for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_size
Maximum edge size for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_deviation
Maximum deviation for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_angle
Maximum angle value (in degrees) between edges for chordal deviation edge meshing.
            Ignored, if edge_mesh_type is not set to 2 or 12.
previous_settings
Flag indicating whether to break, keep or redo connectivity between neighboring
            surfaces. Valid values are:
0 - Keep previous settings and do not break connectivity between neighboring
                surfaces. 
1 - Break connectivity between neighboring surfaces. 
2 - Keep connectivity between neighboring surfaces. 
3 - Redo connectivity between neighboring surfaces by expanding surface selection
                by one layer of adjacent surfaces.


vertex_angle
When the vertex between two edges exceeds this value, a new node is created to form a
            vertex. Thus, using high values results in fewer nodes on curved edges, and therefore
            less-accurate edge approximation. A standard value is 30.

","Examples
To remesh all elements with a first order mixed mesh of size 4.5, maintaining the original
        components,with size and skew control, with flow and alignment control, keeping the existing
        connectivity, a vertex angle of 25, and automatically detecting connected features with a
        feature angle of
        20:*setoption element_order=1
*setoption feature_angle=20
*setusefeatures 3
*createmark elems 1 all
*defaultremeshelems 1 4.5 2 2 1 1 1 14 0 0 0 0 2 25
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
232,*deformedshape,"Description
Creates a deformed shape plot from results data. The results file must be loaded before
        executing this command. The *freesimulation command clears the plot.
","Inputs

title
The title to use for the plot.
undeformed_color
The color used to plot the undeformed shape. Valid values are 1 through 64. 
-1 - Uses the elements color.
0 - Uses the background color.

A value of 
deformed_color
The color used to plot the deformed shape. Valid values are 1 through 64. 
-1 - Uses the elements color. 
0 - Uses the background color.


scale_factor
The maximum deflection in model units to which the results should be scaled.
hidden_line
This argument is no longer supported and is ignored.
full_size
Determines whether the deformed plot fills the entire screen. Valid values are:
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return.



","Examples
To load the result file named C:/my_results/test.res and generate a
        deformed plot for Subcase 1 with Displacements data type, an undeformed mesh color of the
        elements, a deformed mesh color of red, and normal plot
        size*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*deformedshape """" -1 3 1.0 0 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
233,*delete_logo,"Description
Removes small geometric features that represent company logos from the model design.
","Inputs

mark_id
The ID of the mark containing the surfaces or solids to consider for logo removal.
            Valid values are 1 and 2.
max_height
The maximuml height/depth of a letter in the logo, as measured normal to the ""shiny""
            surface.
If a negative value is provided, the max height is auto-calculated based on the
            geometry dimensions.
max_size
The maximum size of a letter in the logo, as measured along/parallel to the ""shiny""
            surface.
If a negative value is provided, the max size is auto-calculated based on the geometry
            dimensions.
concavity_factor
Creates a filter to provide more flexible control of automatic logo recognition. This
            is a heuristic tool and may remove real features (such as flat bottom round dimples)
            which are not intended for removal. 
This is a quantitative measure of a letters' shape complexity, formally defined as
              (contour_accumulated_turn_angle/360)-1. The
              contour_accumulated_turn_angle is the sum of angles between a letters'
            contour straight parts. Curved parts of a contour letter are approximated by a segmented
            line composed of short straight segments. For completely concave contours (such as
            circles, quads and hexagons) the concavity factor is (360/360)-1=0. 
To extend the recognition and removal of logos, this value should be reduced.

","Examples
To remove logos from all surfaces, using a max size of 30.0, a max height of 1.1 and a
        concavity factor of
        2.0:*createmark surfs 1 all
*delete_logo 1 1.1 30.0 2.0
To remove logos from all surfaces, auto-calculating the max height and
        size:*createmark surfs 1 all
*delete_logo 1 -1.0 -1.0 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
234,*deletefeatures,"Description
Deletes the features in a model. 
","Examples
This function can also be performed by using the function *deletemark(). 
",,
235,*deletefillet,"Description
Deletes a fillet from a line. 
","Inputs

line id
The ID of the line from which the fillet line is to be deleted. 

",,
236,*deletemark,"Description
Deletes entities from the database. 
","Inputs

entity type
The type of entity contained on the mark. 
mark
The ID of the mark to be deleted. 

","Examples
To delete lines 12, 13, and 14:
        *createmark(lines,1) 12 13 14
*deletemark(lines,1)
This command cannot be used to delete nodes, unless they are temporary nodes that are not
        connected to any other HyperMesh entity.
",
237,*deletesolidswithelems,"Description
Deletes solids. Includes the option to keep boundary surfaces, and an option to keep
        attached elements.
","Inputs

mark
The mark containing the solids that you want to delete.
keep_shell
If zero, solids are deleted along with their connected boundary surfaces (except any
            surfaces connected to other solids that are not being deleted). 
If set to any nonzero value, the surfaces that make the boundary of each solid are not
            deleted. 
keep_elems
Overrides the auto delete elements setting in the options panel. 
If set to zero, elements associated with solids will be deleted along with the solids. 
If set to any nonzero value, such elements will not be deleted.

","Examples
To delete solid with ID 5 and keep its boundary surfaces, but delete
        elements:*createmark(solids, 1) 5
*deletesolidswithelems(1,1,0)
",
238,*descriptormove,"Description
Moves the plot descriptor. 
","Inputs

xmin
The x value of the upper left corner of the plot descriptor (0.0 - 1.0). 
ymin
The y value of the upper left corner of the plot descriptor (0.0 - 1.0). 
xmax
The x value of the lower right corner of the plot descriptor (0.0 - 1.0). 
ymax
The y value of the lower right corner of the plot descriptor (0.0 - 1.0). 

",,
239,*descriptorsetfont,"Description
Sets the font for the plot descriptor. 
","Inputs

font
The font number for the descriptor (1 through 4). 

",,
240,*detach_fromelements,"Description
Detaches elements from selected elements or nodes.
","Inputs

elements
The elements to be detached.
from_type
Entity type (elems or nodes) from which you want to detach the elements.
from_mark
Selected elements (nodes) from which you want to detach the elements.
offset
Offset value of the newly detached nodes.

","Example
To detach element number 16 from two elements with numbers 228 and 243, and an offset of
        1:*createmark(elements,1) 16
*createmark(elements,2) 228 243
*detach_fromelements(1,elements,2,1)
",
241,*detach_solids,"Description
Separates solids that have shared boundary surfaces by duplicating the common surfaces and
        breaking, when possible, the connectivity between the edges and vertices of shared
        surfaces.
","Inputs

entity_type
Input geometry type. Valid value is solids.
mark_id
The ID of the mark of input solids. Valid values are 1 and 2.
options
Defines the separation method. Valid values are:
0 - Selected solids are separated from those not selected. Shared boundary
                between selected solids is preserved. 
1 - Selected solids are separated from each other. Shared boundary between
                selected solid and those not selected is preserved. 
2 - Each selected solid is separated from all solids it has a shared boundary
                with.
3 - Same as 0.



","Examples
Assume that solids with IDs 1, 2, 3 have shared boundary surfaces between each other.
To separate solids 1 and 2 between each other, but keep solid 3 connected to both solid 1
        and solid 2:*createmark solids 1 1 2
*detach_solids solids 1 1
To separate solids 1 and 2 from solid 3 and keep shared boundary between solids 1 and
        2:*createmark solids 1 1 2
*detach_solids solids 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
242,*detachelements,"Description
Detaches elements as a unit from the attached structure, using the specified offset
        value.
","Inputs

mark_id
The ID of the mark of elements to detach. Valid values are 1 and 2.
offset
The distance by which the elements should be offset from the attached structure.

","Example
To detach elements 10 and one layer of adjacent elements from the remainder of the
        structure:*createmark elems 1 10
*appendmark elems 1 adjacent
*detachelements 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
243,*display_thickness,"Description
This command sets or reviews the thickness assigned to a midsurface.
","Inputs

mark_id
The ID of the mark containing the surfaces to set or review. Valid values are 1 and 2.
thickness
The thickness to assign to the surfaces on the mark. A negative or zero value sets the
            thickness to 0. This is ignored, if update is set to 0.
update
0 - Display the thickness of the selected surfaces in the graphics area. 
1 - Update the thickness of the selected surfaces.

","Example
To display the thicknesses of surfaces 1, 5, 6, 7, and
        10:*createmark surfaces 1 5 6 7 10
  *display_thickness 1 0 0
To assign surfaces 1, 5, 6, 7, and 10 a thickness of
        5:*createmark surfaces 1 5 6 7 10
  *display_thickness 1 5 1
To remove the thickness attribute from surfaces 1, 5, 6, 7, and 10 (e.g. set thickness to
        zero):*createmark surfaces 1 5 6 7 10
  *display_thickness 1 -1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
244,*displaycollector,"Description
Controls the display state of a collector. 
","Inputs

entity type
Collector types. Valid types for this function are:
Components
Loadcols
Systcols
Vectorcols
Multibodies


mode
The mode being performed, defined by the following:
on - All collectors are turned on. 
all - All collectors are turned on. 
off - All collectors are turned off. 
none - All collectors are turned off. 
toggle - All collectors are toggled (visible become invisible and vice-versa). 
reverse - All collectors are toggled (visible become invisible and
                vice-versa).


name
The collector name to be used in the above functions. This parameter may be left
            blank, if function is set to all, none, or toggle.
elements
Indicates if elements within components are to be turned on or off.
1 - Yes 
0 - No


geometry
Indicates if geometry within components is to be turned on or off.
1 - Yes
0 - No



","Example
To turn the elements and geometry on in the component
        fender:*displaycollector(component,on,fender,1,1)

",
245,*displaycollectorsallbymark,"Description
This command turns the display of a mark of entities on or off, including toggling their
        current state. The function argument tells the command what it is supposed to do to the
        entities collected on the mark_id. Entities of many different types can,
        at the same time, be on the same mark_id.
","Inputs

mark_id
The ID of the mark containing the entities. Entities of different types can be
            contained on their respective mark and will be operated on together.
mode
The mode being performed, defined by the following:
on - All collectors are turned on. 
all - All collectors are turned on. 
off - All collectors are turned off. 
none - All collectors are turned off. 
toggle - All collectors are toggled (visible become invisible and vice-versa). 
reverse - All collectors are toggled (visible become invisible and vice-versa). 
isolate - For the entity types that have entities on mark_id,
                the marked entities are displayed, and all unmarked entities are hidden. 
""isolate only"" - For all entity types (regardless if any are on
                  mark_id), the marked entities are displayed, and all unmarked
                entities are hidden.


elements
For components and load collectors, determines whether the display affects
            elements/loads on elements.
1 - Control elements/loads on elements.
0 - Do not control elements/loads on elements.


geometry
For components and load collectors, determines whether the display affects
            geometry/loads on geometry.
1 - Control geometry/loads on geometry.
0 - Do not control geometry/loads on geometry.



","Example
To turn on the element in all the components, and the loads-on-elements of load collector
        IDs
        1-3:*createmark components 1 all
*createmark loadcols 1 1 2 3
*displaycollectorsallbymark 1 on 1 0
",
246,*displaycollectorwithfilter,"Description
Changes the active state of a collector using the menu filter.
","Inputs

entity type
The collector type. Valid types for this function are:
Components
Loadcols
Systcols
Vectorcols
Multibodies


mode
The mode being performed, defined by the following:
on - All collectors are turned on. 
all - All collectors are turned on. 
off - All collectors are turned off.
none - All collectors are turned off. 
toggle - All collectors are toggled (visible become invisible and vice-versa). 
reverse - All collectors are toggled (visible become invisible and
                vice-versa).


name
The collector name to be used in the above functions. This parameter may be left
            blank, if function is set to all, none, or toggle. 
elements
Indicates if elements within components are to be turned on or off.
1 - Yes
0 - No


geometry
Indicates if geometry within components is to be turned on or off.
1 - Yes
0 - No



","Example
To turn the elements and geometry on in component fender:
        *displaycollectorwithfilter(component,on,fender,1,1)
",
247,*displayelementsbypropertybymark,"Description
Displays elements that have either a direct, indirect or mixed property assignment for a
        selection of properties.
","Inputs

mark_id
The ID of the mark containing the properties to consider. Valid values are 1 and 2.
mode
The mode to control the element display. Valid values are:
on - Turn on the elements. 
off - Turn off the elements. 
reverse - Reverse the display of the elements (if off, turn on and if on, turn
                off). 
isolate - Isolate the display of the elements (turn off all others).


type
The property assignment type to use for selecting the elements to display. Valid
            values are:
0 - Direct property assignment. 
1 - Indirect property assignment. 
2 - Any property assignment.



","Example
To turn on the display of all elements with a direct property assignment for properties
        1-4:*createmark props 1 1-4
*displayelementsbypropertybymark 1 on 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
248,*displaynone,"Description
Turns off the display of all entities in the model.
","Example
To turn off the display of all entities:*displaynone
",,
249,*dragnodestoformsurface,"Description
Drags a list of nodes to create a surface, and optionally, prepares it for immediate use
        within the automesher. It can also identify a region in the shape of a dragged surface for
        the automesher to use under the mesh without surface option. 
","Inputs

list
The nodes to be dragged. 
direction_vector
The direction to drag the nodes. 
distance
The distance to drag the nodes.

","Example
To drag six nodes -100 units in the direction of the y-axis, creating a surface but no
        elements:
        *surfacemode(4)
*createlist(nodes,1) 5 10 6 11 12 7
*createvector(1,0.0000,1.0000,0.0000)
*dragnodestoformsurface(1,1,-100.0000)
The *surfacemode(4) directive tells HyperMesh not to pass the
        information on to the automesher for element creation. 
*createlist() and *createvector() are required for
        this command. 
If one of the surface creation modes has been set, a smooth is put through the nodes to
        create the surface.
",
250,*dummyplacerootbodytopoint,"Description
Moves a dummy from a source point to a target point. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the root body of the dummy.
sx
The x-coordinate of the source point. This is usually the x-coordinate of the H-Point
            of the dummy.
sy
The y-coordinate of the source point. This is usually the y-coordinate of the H-Point
            of the dummy.
sz
The z-coordinate of the source point. This is usually the z-coordinate of the H-Point
            of the dummy.
tx
The x-coordinate of the target point.
ty
The y-coordinate of the target point.
tz
The z-coordinate of the target point.
tolerance
The tolerance allowed during the placement.

","Example
To move a dummy with root body named ""Pelvis Angle Gauge"" from (0,0,0) to
        (150,100,200):
*dummyplacerootbodytopoint ""Pelvis Angle Gauge"" 0 0 0 150 100 200 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
251,*duplicatemark,"Description
Duplicates entities.
","Inputs

entity_type
The entity type to duplicate.
mark_id
The mark ID containing the entities to duplicate. Valid values are 1 and 2.
current_collector
0 - New entities should be placed in the collector(s) in which the source entities
            exist.
1 - New entities should be placed in the current collector.

","Example
To duplicate the elements 1-100 and place the new elements in the current
        component:*createmark elems 1 1-100
*duplicatemark elems 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
252,*dynamicviewbegin,"Description
Begins a block of *rotate(), *window(), or
          *quatrotate() commands.
",,,
253,*edgerelease,"Description
Unstitches the selected edge.
","Inputs

edge
The edge to release.

","Example
To release edge 96:*edgerelease(96)
Only unsuppressed face edges can be released.
",
254,*edgesmarkaddmidpoint,"Description
Splits each of the input face edges at its midpoint by adding a fixed point on the
        edge.
","Inputs

markmask
The mark ID containing the edges.

","Example
To split edges 95, 101 and 102 at their
        midpoints:*createmark(lines,1) 95 101 102
*edgesmarkaddmidpoint(1)
",
255,*edgesmarkrestore,"Description
Unsuppresses a group of edges.
","Inputs

mark
The mark ID that contains the edges to unsuppressed.

","Example
To unsuppress edges 5, 14, 21, and
        30:*createmark(lines,1) 5 14 21 30
*edgesmarkrestore(1)
Only face edges which are interior to a surface or shared between two surfaces may be
        suppressed and unsuppressed. Unsuppressing an edge can split a surface into two new
        surfaces, and causes it to affect the mesh. The *createmark() command is
        required.
",
256,*edgesmarksuppress,"Description
Suppresses a group of edges.
","Inputs

mark
The mark ID that contains the edges to suppressed.
break angle
If the angle between the surfaces at the shared edge is less than or equal to the
            break angle, then the edge is suppressed. If the angle between the surfaces at the
            shared edge is greater than the break angle, the edge is not suppressed.

","Example
To suppress edges 5, 14, 21, and 30, with a break angle of 30
        degrees:*createmark(lines, 1) 5 14 21 30
*edgesmarksuppress(1, 30)
Only face edges which are interior to a surface or shared between two surfaces may be
        suppressed and unsuppressed. Suppressing an edge can combine two separate surfaces, and
        removes its affect on the mesh. The *createmark() command is
        required.
",
257,*edgesmerge,"Description
Combines two edges to create one unsuppressed common edge.
","Inputs

edge1
The first of two surface edges that you wish to combine
edge2
The second of two edges to be combined.
edge_tolerance
The edges must be within this tolerance; if they are further apart than this, they
            will not combine.

","Example
To combine edges 25 and 26, using a tolerance of
        0.1:*edgesmerge(25,26,0.1)
This command is different from *linescombine() in that it enables
        combining edges that are not necessarily free but already have more than one surface
        connected. This provides a tool to create non-manifold (T-joint) topology, which may be
        required in tasks like thin plate modeling.
",
258,*editmarkpanel,"Description
Provides a panel to add or remove entities to a mark.
","Inputs

entity_type
The type of entities to add or remove.
mark_id
The ID of the mark. Valid values are 1 and 2.
message
A string to show in the message bar when entering the panel.
?face_edge_mode?
The default face/edge selection mode to use when entering the panel. This is valid
            only for nodes and elements. An invalid value defaults to 0, or is ignored for
            non-supported entity types.
0 - Standard entity selection 
1 - 2D faces (elems) or faces (nodes) 
2 - 2D faces ext (elems and nodes) 
3 - Free edges (nodes only) 
4 - Edges (nodes only) 
5 - Loops (nodes only) 
6 - Free edges ext (nodes only) 
7 - Edge ext (nodes only)


?filter?
Defines which selection modes should be allowed. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6 +
              128*Bit7). 
A value of 0 (default) means all selection modes are available. 
For nodes, if the sum does not include Bit0 set to 1, although nodes are collected,
            what is highlighted are the faces/edges. Proceed from the panel, and the corresponding
            nodes will be highlighted.
Bit0
0 - Do not allow standard selection (elems and nodes).
1 - Allow standard selection (elems and nodes).


Bit1
0 - Do not allow 2D faces (elems) or faces (nodes).
1 - Allow 2D faces (elems) or faces (nodes).


Bit2
0 - Do not allow 2D faces ext (elems and nodes).
1 - Allow 2D faces ext (elems and nodes).


Bit3
0 - Do not allow free edges (nodes only).
1 - Allow free edges (nodes only).


Bit4
0 - Do not allow edges (nodes only).
1 - Allow edges (nodes only).


Bit5
0 - Do not allow loops (nodes only).
1 - Allow loops (nodes only).


Bit6
0 - Do not allow free edges ext (nodes only).
1 - Allow free edges ext (nodes only).


Bit7
0 - Do not allow edge ext (nodes only).
1 - Allow edge ext (nodes only).



","Examples
To prepopulate mark 1 with elements and then edit the mark in a
        panel:*createmark elems 1 1-100
*editmarkpanel elems 1 ""Please edit the mark""
hm_getmark elems 1
To prepopulate mark 1 with elements and then edit the mark in a panel using 2D faces as the
        default selection
        mode:*createmark elems 1 1-100
*editmarkpanel elems 1 ""Please edit the mark"" 1
hm_getmark elems 1
To prepopulate mark 1 with elements and then edit the mark in a panel using 2D faces as the
        default selection mode, only allowing 2D faces and 2D faces ext
        modes:*createmark elems 1 1-100
*editmarkpanel elems 1 ""Please edit the mark"" 1 6
hm_getmark elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
259,*element1dswitch,"Description
Switches the order of 1D element nodes.
","Inputs

mark_id
The mark ID containing the 1D elements to switch.

","Example
To switch the node order of 1D elements
        5-10*createmark elems 1 5-10
*element1dswitch 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
260,*element2Dshiftnodes,"Description
Reorders the nodes in 2D elements based on various modes.
","Inputs

element_id
The 2D element ID to reorder.
mode
Determines how the nodes are reordered.
1 - Shift the first node by the value given by shift_value. 
2 - Shift the first node by the value given by shift_value and
                reverse the element orientation. 
3 - Make first_node_id the first node. 
4 - Make first_node_id the first node and reverse the element
                orientation. 
5 - Make first_node_id the first node and
                  second_node_id the second. This may reverse the element
                orientation. 
6 - Find the element’s oriented side closest to the direction of
                  direction_vector and set the first 2 nodes to be this side. 
7 - Find the element’s oriented side closest to the direction of
                  direction_vector and set the first 2 nodes to be this side with
                the reverse orientation.


shift_value
When mode is 1 or 2, this is an integer defining the shift of the
            element nodes.
first_node_id
When mode is 3, 4 or 5, this defines the first node in the
            reordered 2D element. 
second_node_id
When mode is 5, this defines the second node in the reordered 2D
            element.
direction_vector
The vector ID closest to the orientation of the element’s first and second nodes. This
            vector is created with *createvector.

","Example
If the original element ID 100 is ordered with nodes 34, 62, 88, 11.
To reorder element ID 100 as 88, 11, 34,
        62:*element2Dshiftnodes 100 1 2 0 0 0
To reorder element ID 100 as 88, 62, 34, 11 (reverse element
        normal):*element2Dshiftnodes 100 2 2 0 0 0
To reorder element ID 100 as 62, 88, 11,
        34:*element2Dshiftnodes 100 3 0 62 0 0
To reorder element ID 100 as 62, 34, 11,
        88:*element2Dshiftnodes 100 4 0 62 0 0
To reorder element ID 100 as 88, 62, 34, 11 (in this example it reverses the element normal
        too):*element2Dshiftnodes 100 5 0 88 62 0
To reorder element ID 100 such that the two nodes that form a vector that is closest to the
        selected vector direction will chosen as n1, n2 while maintaining the element’s
        normal:*createvector 1 0.0000 1.0000 0.0000
*element2Dshiftnodes 100 6 0 0 0 1
To reorder element ID 100 such that the two nodes that form a vector closest to the
        selected vector direction will be chosen as n1, n2 (this option may reverse the elements
        normal):*createvector 1 0.0000 1.0000 0.0000
*element2Dshiftnodes 100 7 2 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
261,*element3Dshiftnodes,"Description
Reorders the nodes in 3D elements based on various modes.
","Inputs

element_id_3D
The 3D element ID to reorder.
node
Determines how the nodes are reordered.
1 - Reorder the nodes as defined by the shift_value argument
                (2 digit value). 
2 - Reorder the nodes defined by 3 nodes in the 3D element. The
                  first_node_id, last_node_id and
                  second_node_id arguments define the new base face. 
3 - Reorder the nodes by referencing a face element defined by the
                  element_id_2D argument. 
4 - Reorder the nodes as defined by the shift_value (1 digit
                value) and first_node_id arguments.


shift_value
When mode is 1, this is a 2 digit integer. The first digit defines
            the element’s new base face index, while the second defines the index of the new first
            node for that face. 
When mode is 4, this is a 1 digit integer. The digit defines the
            element’s new base face index.
first_node_id
Defines the first node in the reordered 3D element, when mode is
            2.
Defines the first node in the new base, when mode is 4.
last_node_id
Defines the last node in the reordered 3D element base face, when
              mode is 2.
second_node_id
Defines the second node in the reordered 3D element base face, when
              mode is 2.
element_id_2D
The 2D element ID to use as the base face for the reordered 3D element. The first node
            of this 2D element becomes the first node of the 3D element.

","Example
To reorder nodes in hexa element 213 so that the first node of the third face becomes the
        element’s first node:*element3Dshiftnodes 213 1 31 0 0 0 0
To reorder nodes in hexa element 213 so that the face containing nodes 137, 138, and 139
        becomes the hexa’s base
        face:*element3Dshiftnodes 213 2 0 137 138 139 0
To reorder nodes in hexa element 213 so that its quadrilateral face element with ID 94
        becomes the hexa’s new base face, and quad 94’s first node becomes the hexa's first
        node:*element3Dshiftnodes 213 3 0 0 0 0 94
To reorder nodes in hexa element 213 so that node 94 of the third face becomes the hexa's
        first node:*element3Dshiftnodes 213 4 3 94 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
262,*elementmarksplit,"Description
This command splits a group of shell/solid elements based on a graphical split line. The
        split line cannot be defined manually and this command should only be run from the
        workspace.
","Inputs

mark_id
The mark ID containing the elements to split.
crosscode
The array ID containing the crossing codes. The crosscode array is calculated
            internally by HyperMesh depending on the selected split line
            drawn in the graphics area and cannot be calculated manually.
crosscode_size
The size of the crosscode array. This must be equal to the number of elements on the
            mark.

","Example
To split elements 1-21 using a line drawn in the graphics
        area:*createmark elems 1 1-21
*createarray(21) 33 18 12 192 18 34 34 64 72 136 136 136 72 136 72 1 132 40 132 132 48
*elementmarksplit 1 1 21
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
263,*elementqualitycollapseelems,"Description
This command collapses/combines two adjacent trias into a quad. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_id1
The first tria element ID.
elem_id2
The second tria element ID.

","Example
To collapse tria elements 10 and 11 using quality criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualitycollapseelems 10 11
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
264,*elementqualitymodifyhole,"Description
This command modifies holes in a mesh using radial, angular and circumferential adjustment
        methods. If washers are linked with the hole, then the hole and washers move together. If
        they are not linked, the hole and washers move independently. The surrounding elements are
        also re-meshed based on the number of layer specified. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. The index is purely a local value
        appropriate to that session of the tool, and it cannot be computed from the node ID you want
        to change.
","Inputs

node_index
The index of a node on the hole/washer within the internal data structures of the
            interactive element cleanup and quality index edit/optimize tools.
move_option
Hole node movement.
1 - In radial direction.
2 - In angular direction.
3 - In radial and angular directions.
4 - In circumferential direction.


x
x-coordinate of a target location for the selected node used for hole/washer
            modification.
y
y-coordinate of a target location for the selected node used for hole/washer
            modification.
z
z-coordinate of a target location for the selected node used for hole/washer
            modification.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. Valid parameters include:
InputRadius: <radius>
The target radius to use for hole/washer modification (Optional).
InputAngle: <angle>
The rotation angle to use for hole/washer modification (Optional).
InputArcLen: <length>
The circumferential arc length to use for hole/washer modification
                  (Optional).
LinkWasher: <value>
0 - Hole and washers are not linked and move independently.
1 - Hole and washers are linked and move together.
NumRemeshLayer: <value>
The number of layers to be re-meshed after hole/washer modification.
RetainWasher: <value>
0 - Do not retain the washer of nearby holes on re-meshing. 
1 - Retain the washer of nearby holes on re-meshing.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To modify the hole/washer associated with node index 278, using circumferential
        adjustments, a target point of (5.3, -8.4, and 0.0), using linked hole/washer option with 2
        layers of
        re-meshing:*createmark elems 1 displayed
*elementqualitysetup 1
eval *createstringarray 3 ""LinkWasher: 1"" ""NumRemeshLayer: 2""
*elementqualitymodifyhole 278 4 5.3 -8.4 0.0 1 2
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
265,*elementqualityoptimizeelementnew,"Description
This command optimizes 2D element node locations to improve the element and adjacent
        elements' quality index according to pre-set quality criteria. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

element_id
The element ID.
midnodes_flag
0 - Do not consider neighboring mid-nodes during optimization.
1 - Consider neighboring mid-nodes during optimization.

","Example
To optimize the node locations of the elements with IDs 397, 432 and 102 using quality
        criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualityoptimizeelementnew 397 1 
*elementqualityoptimizeelementnew 432 0
*elementqualityoptimizeelementnew 102 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
266,*elementqualityplacenodenew,"Description
This command moves the specified node to a target point. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command.
","Inputs

node_id
The node ID.
x
The x-coordinate of the target point.
y
The y-coordinate of the target point.
z
The z-coordinate of the target point.
normal_flag
0 - Allow movement along the surface.
1 - Allow movement normal to the surface.
boundary_flag
0 - Allow movement within the boundary.
1 - Allow movement out of the boundary.
midnodes_flag
0 - Do not consider neighboring mid-nodes during optimization.
1 - Consider neighboring mid-nodes during optimization.

","Example
To place the node with ID 102, using a target point of 10.0, 5.0, 0.0, allowing normal
        movement within the
        boundary:*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualityplacenodenew 102 10.0 5.0 0.0 1 0 0
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
267,*elementqualitysetup,"Description
Prepares a mark of elements for use within the interactive element cleanup tool.
","Inputs

elementmark
The mark ID containing the elements to be modified. 

","Example

*createmark(elements,1) 10 11 12 13 14 15 16
*elementqualitysetup(1)
<<various *elementquality commands>>
*elementqualityshutdown(0)

This function interacts closely with the other *elementquality()
        commands, and cannot function separately from them. It must be accompanied by a
        corresponding *elementqualityshutdown() command.
",
268,*elementqualityshutdown,"Description
Closes down a session of the interactive element cleanup tool.
","Inputs

dontsaveflag
A nonzero value tells the system that it should not transfer your changes from within
            the element cleanup tool to the permanent database.

","Example

*createmark(elements,1) 10 11 12 13 14 15 16
*elementqualitysetup(1)
<<various *elementquality commands>>
*elementqualityshutdown(0)

",
269,*elementqualitysplitedge,"Description
This command splits an edge between two elements. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_id
The element ID.
edge_index
The index of the edge to split.

","Example
To split edge 1 for element 20 using quality criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualitysplitedge 20 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
270,*elementqualityswapedgenew,"Description
This command switches the connectivity of the two elements that share the specified edge to
        the next legal configuration. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command.
","Inputs

element_id
The element ID.
edge_index
The index of the edge to swap, starting from 0.

","Example
To swap elements 27 edge 3, 22 edge 0, 21 edge 2 and 26 edge
        1:*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualityswapedgenew 27 3
*elementqualityswapedgenew 22 0
*elementqualityswapedgenew 21 2
*elementqualityswapedgenew 26 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
271,*elementsaddelemsfixed,"Description
This command changes the densities of selected surface edges and remeshes the adjacent
        surfaces, according to the specified mode. This is an automesh function.
","Inputs

mark_id
The mark ID containing 1D plot elements that should be considered to form feature
            edges in the subsequent element remesh operation.
Use of this command implies that it will be followed by a command that performs
            remeshing/meshing by
            elements:*defaultremeshelems
*defaultmeshelems
*interactiveremeshelems
*interactivemeshelems

","Example
To remesh the displayed elements and keep lines formed by plot elements with IDs
        1600-2220:*createmark elems 1 ""displayed""
*setusefeatures 1
*createmark elems 2 1600-2220
*elementsaddelemsfixed 2
*defaultremeshelems 1 3.0 2 2 0 1 1 1 0 0 0 0 0 30
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
272,*elementsettypes,"Description
Sets the element types to the current global value. 
","Inputs

mark
The mark ID that contains the elements to be set. 

","Example
To set the displayed elements to the current global types:
        *createmark(element,1) displayed
*elementsettypes(1)
Each of the HyperMesh element configurations has a global type
        associated with it which is stored in a variable. When a new element is created, the type
        will be set to the current value of the global type. 
Types are how different analysis elements are assigned to the same HyperMesh element configuration. 
",
273,*elementtestaspect,"Description
Tests 2D and 3D elements using the aspect element quality check.
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
aspect
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
dimension
The option of whether to measure 2D or 3D elements:
2 - Measure 2D elements. 
4 - Measure 3D elements.


output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
Flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. Only required, if
              contour is 2.

","Example
To test all displayed 3D elements for an aspect of
        5.0:*createmark elems 1 ""displayed""
*elementtestaspect elems 1 5.0 0 4 0 """"
To test all displayed 2D elements for an aspect of
        6.0:*createmark elems 1 ""displayed""
*elementtestaspect elems 1 6.0 0 2 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
274,*elementtestchordaldeviation,"Description
Fits an inferred surface through the selected plate or shell elements and measures their
        chordal deviation from the inferred surface or from the geometric surface to which they
        belong, and puts those that exceed the given threshold on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
maxdeviation
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. 

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestchordaldeviation(elements,1,0.1,2,0,""Element Chordal Deviation"")

It is somewhat problematic to define chordal deviation for second order elements. HyperMesh treats second order elements as if they were first order for
        the purposes of this check.
",
275,*elementtestdependancy,"Description
Tests 1D weld and rigid elements for double dependencies and puts those that fail on the
        specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestdependancy(elements,1,2)

",
276,*elementtestequiaskew,"Description
Tests 2D and 3D elements using the equiangle skew element quality check.
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
equiangle_skew
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
dimension
A code telling to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
Flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. Only required, if
              contour is 2.

","Example
To test all displayed elements for a cell squish of
        0.7:*createmark elems 1 ""displayed""
*createmark elems 2
*elementtestequiaskew elems 1 0.7 0 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
277,*elementtestinterangle,"Description
Tests 2 and 3 dimensional elements for whether or not they pass the interior angle element
        quality check, and puts those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
testangle
The value to use as a threshold beyond which elements should be considered to have
            failed the test (in degrees).
trias
A nonzero value indicates to test trias or tria faces, as opposed to quads or quad
            faces.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
wantmin
A nonzero value indicates to check if the element's smallest angle is less than the
            threshold, as opposed to its largest angle being greater than the threshold.
dimension
A code telling to measure the dimension of:
1 - Measure 1D elements. 
2 - Measure 2D elements. 
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestinterangle(elements,1,135.0,0,2,0,2,0,""Quad Max Angle"")

The details of the interior angle element quality check can be found in the online help for
        the Check Elements panel.
",
278,*elementtestlength,"Description
Tests elements for whether or not they pass the edge length element quality check, and puts
        those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is supported.
markmask
The mark that contains the elements to test.
length
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
wantmin
A nonzero value indicates to check if the element's smallest edge is less than the
            threshold, as opposed to its largest edge being greater than the threshold.
dimension
A code telling to measure the dimension of:
1 - Measure 1D elements. 
2 - Measure 2D elements.
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""all""
*createmark(elements,2)
*elementtestlength(elements,1,20,2,1,2,0,""2D Element Length"")

With 2D and 3D elements, the only concern is if the element is too small. 
With 1D elements, there is an additional test available to test if the element is too
        large. To activate that test, set dimension to 1 and
          wantmin to 1. 
The details of the edge length element quality check can be found in the online help for
        the Check Elements panel. 
",
279,*elementtestrigidloops,"Description
Tests 1D rigid elements for possible rigid loops, and puts those with rigid loops on the
        specified outputmark. 
","Inputs

entities
The entity types to be checked. Currently, only elements is supported.
markmask
The mark that contains the elements to test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestrigidloops(elements,1,2)


",
280,*elementtestskew,"Description
Tests 2D and 3D elements for whether or not they pass the skew element quality check, and
        puts those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, only elements is supported.
markmask
The mark that contains the elements to test.
skew
The value to use as a threshold beyond which elements should be considered to have
            failed the test (in degrees).
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestskew(elements,1,60,2,2,0,""2D Element Skew"")

The details of the skew element quality check can be found in the online help for the Check
        Elements panel. 
",
281,*elementtesttimestep,"Description
Tests beam, spring, shell, solid and thick shell elements using the time step element
        quality check.
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
time_beam
The value to use as a threshold beyond which beam elements should be considered to
            have failed the test.
time_spring
The value to use as a threshold beyond which spring elements should be considered to
            have failed the test.
time_shell
The value to use as a threshold beyond which shell elements should be considered to
            have failed the test.
time_solid
The value to use as a threshold beyond which solid elements should be considered to
            have failed the test.
time_tshell
The value to use as a threshold beyond which thick shell elements should be considered
            to have failed the test.
dimension
A code to measure the dimension of:
1 - Measure 1D (beam and spring) elements only. 
2 - Measure 2D (shell) elements only. 
4 - Measure 3D (solid) elements only. 
6 - Measure 2D (shell) and 3D (solid) elements. 
7 - Measure all elements


output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
Flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings.


added_mass
A flag indicating what to contour.
0 - Time step
1 - Added mass, when contour is set to 1.


title
The title for the contour, when contour is set to 1.

","Examples
To test all displayed shell elements for a time step of
        0.0001:*createmark elems 1 ""displayed""
*elementtesttimestep elems 1 0 0 0.0001 0 0 2 1 0 0 """"
To test all displayed shell and solid elements for a time step of 0.0001 and display a
        contour:*createmark elems 1 ""displayed""
*elementtesttimestep elems 1 0 0 0.0001 0 0 6 1 1 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
282,*elementtestvolumetricskew,"Description
Tests tetra elements for whether or not they pass the volumetric skew element quality
        check, and puts those that fail on the specified output mark. 
The tetra element volumetric skew corresponds directly to the Abaqus and Fluent CFD tetra element quality checks. It is calculated by
        fitting a sphere through the four vertex nodes of the element. An ideally shaped tetra
        element with nodes on that sphere would have a volume of 3.



I
d
e
a
l
V
o
l
=


8
*
R
a
d
i
u
s


9
*
S
q
r
t
(
3
)





So,



V
o
l
S
k
e
w
=


I
d
e
a
l
V
o
l
−
Re
a
l
V
o
l


I
d
e
a
l
V
o
l





In the CFD community, this quantity is traditionally referred to as ""skew."" To
        differentiate it from the finite element quantity of the same name, HyperMesh notes this as ""volumetric skew.""
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the tetra elements to test. Valid values are 1 and 2.
skew
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
A flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. Only required, if
              contour is 2.

","Example
To test all displayed elements for a skew of
        0.6:*createmark elems 1 ""displayed""
*createmark elems 2
*elementtestvolumetricskew elems 1 0.6 0 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
283,*elementtype,"Description
Sets the global element type variable.
","Inputs

config
The configuration whose global type is set with this command. 
type
The type whose global type is set with this command. 

","Example
To set the global element type of configuration 103 to 3:
        *elementtype(103,3)
",
284,*elemoffset_thinsolid,"Description
A thin solid is a volume defined either by a solid entity or enclosed by a combination of
        elems and surfs, in that the volume faces are well separated into source, destination, and
        along groups either by the feature angle with the auto-detection option, or by user manual
        selection. The source, destination, and along face groups are related to each other similar
        to that used for solid map, except each face group here can have multiple faces with more
        arbitrary connectivity. In the resulting mesh, the unsuppressed edges inside each group are
        not preserved. 
There are some rules for how entities can be specified:
Confined to the valid entity types for each face group, not all combination of
            selections are valid. Specifically, among the 3 face groups, only one can be solid and
            not more than 2 can be surfs. 
If solids are one of the selections, the 2 non-solid selections must be of surfs. If
            in addition, auto-detection is on, the 2 surfs selections can be empty and, internally,
            these will be auto-detected.


","Inputs

entity_type_source
The source entity types:
Solids
Surfaces
Elements


mark_id_source
The mark ID containing the source entities. Valid values are 1 and 2.
entity_type_target
The target entity types. Valid values are surfaces.
mark_id_target
The mark ID containing the target entities. Valid values are 1 and 2.
entity_type_along
The type of along entities. Valid values are:
Solids
Surfaces 
Elements.


mark_id_along
The mark ID containing the along entities. Valid values are 1 and 2.
modes
An integer used as bit field flags to define mesh modes.
Bit0
Reserved
Bit1
Organizational.
0 - Elements to original component.
2 - Elements to current component.


Bit2-Bit3
Bias style.
0 - Linear 
4 - Exponential 
8 - Bell curve


Bit4
Layer type.
0 - Create solid element layers.
16 - Create shell element layers.


Bit5
Layer normal.
0 - Use smooth normal to generate element layers.
32 - Use simple layer normal to generate element layers.


Bit6-Bit7
Manual or auto-detection mode. Used only when one input is solids 
0 - Reserved, use manual selections as-is. 
64 - Use manual selections as-is. You must ensure all 3 selections are
                      correct. 
128 - Do auto selection determination, then mesh the thin solids. 
192 - Do auto selection determination, but no not do meshing. Instead, save
                      the auto-detected selections to the input marks for all 3 inputs.


Bit8
Auto-detection save. Used only when one input is solids.
0 - Do not save auto-detected selections.
256 - Save auto-detected selections.




density
 The number of elem layers to be creates in the along direction. 
biasing
The biasing intensity value. The bias style is encoded in the modes flags.
string_array
The string array ID that contains the array of meshing parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
See the *tetmesh string_array argument CFD, 2D and pars strings for
            supported syntax and options.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.

","Example
To mesh solid 1 by auto thin-solid detection with 5 layers of solid elems to the current
        comp. The 2D source mesh size is to be
        2.2:*createstringarray 2 ""pars: bl_iter_max=300 bl_res_thr=0.03"" ""2d: 1 2 1 2.2 0.22 30 1""
*createmark solids 1 1
*createmark surfs 1 """"
*createmark surfs 2 """"
*elemoffset_thinsolid solids 1 surfaces 1 surfaces 2 130 5 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
285,*elempatchincraction,"Description
Increases the QI patch checker patch size by one element layer. 
This command only functions between an *elempatchstartaction command and
        an *elempatchstopaction command. 
","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
286,*elempatchprevaction,"Description
Moves to the previous failed element patch in the QI patch checker patch. 
This command only functions between an *elempatchstartaction command and
        an *elempatchstopaction command.
","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
287,*elempatchstopaction,"Description
Stops the QI patch checker. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command.
","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
288,*encryptentity,"Description
Encrypts an entity. Currently only supported for Radioss.
","Inputs

entity_type
The type of entity to encrypt. Valid values are curves, mats and props.
id
The ID of the entity to encrypt.
key
For Radioss, this is the value to use for /KEY. Valid
            values are 01-99.

","Example
To encrypt material 100 using key 55:
*encryptentity mats 100 55
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
289,*endnotehistorystate,"Description
Defines the end of a history state. Must be preceded by a call to
          *startnotehistorystate with the same name value. 
This is used to group a set of commands into a single undo/redo operation. All commands
        that appear within the start/end block must be supported for undo/redo.
","Inputs

name
The name of the history state. If the name contains spaces, it must be enclosed in
            curly braces or quotes.

","Example
To execute an element remesh operation on two selections of elements, but consider them as
        a single history
        operation:*startnotehistorystate {Remesh two element selections}
*setedgedensitylinkwithaspectratio 0
*setoption element_order=1
*setusefeatures 3
*createmark elements 1 1-100
*defaultremeshelems 1 1 2 2 1 1 1 1 0 0 0 0 2 30
*createmark elements 1 1-1-200
*defaultremeshelems 1 2 2 2 1 1 1 1 0 0 0 0 2 30
*setusefeatures 0
*endnotehistorystate {Remesh two element selections}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
290,*entitybundleaddmark,"Description
Adds the entities on a mark to a data item of an entity bundle.
","Inputs

name
The name of the entity bundle to be modified.
data_item
The data item of the entity bundle to be modified. Note that these indices start with
            0.
entity_type
The entity type of the mark to be used. This, currently, must match the entity type
            for the data item as was specified in the definition of the entity bundle.
mark_id
The ID of the mark containing the entities to add to the bundle. Valid values are 1 and 2.

","Example
To add all comps in the model to the first data item of the bundle ""compbundle"":
*createmark components 1 all
*entitybundleaddmark ""compbundle"" 0 components 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
291,*entitybundleregister,"Description
Defines a name and signature for a new entity bundle.
In that case, you would usually use alsodeleteinstance to additionally discard that data
        saved with that bundle name. It is not necessary to discard the data. You could have the
        bundle registered and active only while a particular dialog or browser is displayed and
        unregister the definition whenever it is not displayed, but let the data persist between
        uses.
","Inputs

name
The name to use for the entity bundle. If the name is already in use, this overwrites
            the prior definition.
entity_type_list
The signature to use for the data of the entity bundle. This is a list of entity type
            names (e.g. ""components materials elements"") with each item being a list of entities of
            those particular entity types. A maximum of 10 entity types can be provided.
If the signature specified is empty (""""), then any existing definition is
            discarded.
also_delete_instance
If entity_type_list is empty, any data associated with that
            definition may be kept in the database for future use.
0 - Retain the data for future use
1 - Discard the data

","Examples
To define a new of bundle named ""compbundle"" having 2 data items:
*entitybundleregister ""compbundle"" ""components components"" 1
To discard the bundle definition for ""compbundle"" and any data that may have been
        associated with it:*entitybundleregister ""compbundle"" """" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
292,*entitybundleremovemark,"Description
Removes the entities on a mark from a data item of an entity bundle.
","Inputs

name
The name of the entity bundle to be modified.
data_item
The data item of the entity bundle to be modified. Note that these indices start with
            0.
entity_type
The entity type of the mark to be used. Currently, this must match the entity type for
            the data item as was specified in the definition of the entity bundle.
mark_id
The ID of the mark containing the entities to remove from the bundle. Valid values are 1 and 2.

","Examples
To remove all comps in the model from the first data item of the bundle ""compbundle"":
*createmark components 1 all
*entitybundleremovemark ""compbundle"" 0 components 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
293,*EntityDeleteUnused,"Description
Deletes the entities in the outputmark by
          *EntityPreviewUnused().
","Inputs

entity type
The entity type to check.
outputmark
The unused entities IDs.

",,
294,*EntityMoveUsingArray,"Description
Organize a different group of elements to their respective collectors.
","Inputs

entity_col
Entity collector type that holds the entity IDs.
IdSizeArray
A 2D array that contains the collector IDs specified by the
              entity_col variable and a size value that specifies the number of
            entities that need to be moved from the entityIds array. 
numRows
The number of rows for the 2D array.
numCols
The number of columns for the 2D array. This MUST always have a value of 2.
ent_to_move
The entity type to be organized in the collector.
entityIds
Array of specific entity type IDs to be organized into specific collectors.
numEnts
The size of the entity ID array.

","Example
This command currently supports moving elements to components only. This is optimized for
        organizing a different group of elements to their respective collectors from a Tcl script. For example, elements with IDs 1 to 5 must be moved to component ID
        1, elements with IDs 6 to 10 must be moved to comp ID 2 and elements with IDs 11 to 15 must
        be moved to comp ID 3. 
The command below accepts a 3 X 2 matrix with its values specified in a single line. The
        number of rows is 3 and number of columns is 2. The rest of the parameter specifies that the
        first 5 elements from the entityIds array must be moved to comp ID 1, the next 5 elements
        moved to comp ID 2, and the last 5 elements moved to comp ID
        3.*createentityarray2d 3 2 1 5 2 5 3 5;
The following command accepts the number of elements to move and the IDs of all the
        elements that need to be
        moved.*createarray 15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15;

Note: The number of elements to move MUST be equal to the sum of the values specified for
          the number of elements to move in the 2D array.


*EntityMoveUsingArray COMPS 1 3 2 ELEMS 1 15;

",
295,*EntityPreviewUnused,"Description
Searches the specified entities for any unused entities, and stores them in the
          outputmark. 
","Inputs

entity type
The entity type to check.
outputmark
The unused entities IDs.

","Example
To store all unused properties in the
        mark:*EntityPreviewUnused(props, mark)
The following elements can be used with *EntityPreviewUnused():
Props
Unused when there are no components, elements, or attributes pointing to the
              property.
Mats
Unused when there are no components, properties, groups, or attributes pointing to
              the material
Curves
Unused when the curve is not contained in any plots or when no attributes point to
              the curve. 


",
296,*equationcreatebylist,"Description
This command creates an equation between a dependent node and multiple independent
        nodes.
","Inputs

list_id
The list ID containing the independent nodes. Valid values are 1 and 2.
independent_dofs
The ID of the array containing the degrees of freedom for which each respective
            independent node of the equation is active. This array is created with the
              *createarray command. 
The DOFs use bit operations to represent the value. In order to specify multiple DOFs
            for a node, corresponding values for the required DOFs must be summed.
DOF1 - 1 
DOF2 - 2 
DOF3 - 4 
DOF4 - 8 
DOF5 - 16 
DOF6 - 32


For example, there are 2 independent nodes with DOF1 and DOF3. The array of
            independent DOFs will be [5 5].
dof_size
The size of the independent_dofs array. This should be equal to the
            number of independent nodes.
independent_weights
The ID of the array containing the weight for each respective independent node. The
            size of array is 6*dof_size. This array is created with the
              *createdoublearray command. 
For example, there are 2 independent nodes with DOF1 weights 1.2 and DOF3 weights 1.3.
            The array of independent weights will be [1.2 1.2 1.2 1.2 1.2 1.2 1.3 1.3 1.3 1.3 1.3
            1.3].
weight_size
The size of the independent_weights array. This should be equal to
              6*dof_size.
dependent
The dependent node ID.
dof
The degree of freedom for which the dependent node of the equation is active. Valid
            values are 1 through 6.
weight
The independent node weight.
constant
The constant value assigned to all independent and dependent nodes.

","Example
To create an equation with dependent node 100 and independent nodes 101-103 with all
        independent nodes having DOF1, DOF3 and DOF4, a weight of 1.23 and a constant of 5.0, and
        the dependent node having
        DOF5:*createlist nodes 1 101 102 103
*createarray 3 13 13 13
*createdoublearray 18 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23
*equationcreatebylist 1 1 3 1 18 100 5 1.23 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
297,*equivalence,"Description
Equivalences or finds duplicate nodes of selected components or elements within a
        tolerance.
","Inputs

entity_type
The entity types to consider. Valid values are elems, comps and nodes.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
tolerance
The tolerance used to find neighboring nodes to equivalence.
mode
Operating mode of the command:
0 - Preview found nodes. 
1 - Equivalence found nodes. 
3 - Place found nodes on user mark.


location
Location of equivalenced nodes:
0 - Equivalence at the location of the node with the lowest ID.
1 - Equivalence at the location of the node with the highest ID.
2 - Equivalence at the midpoint of the two nodes.


numbering
The numbering of the retained node:
0 - Retain the number of the node with the lowest ID.
1 - Retain the number of the node with the highest ID.



","Example
To equivalence the nodes of all displayed components, using a tolerance of 0.1 and keeping
        the location and number of the lowest ID
        nodes:*createmark comps 1 displayed
*equivalence comps 1 0.1 1 0 0
To equivalence nodes 1-100, using a tolerance of 0.1 and keeping the location and number of
        the lowest ID
        nodes:*createmark nodes 1 1-100
*equivalence nodes 1 0.1 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
298,*evaltclscript,"Description
Run a Tcl/Tk based script file.
","Inputs

filename
Tcl/Tk file name to run.
flag
Flag to run command end functions. 
Default = 0

","Example
This command allows you to run the Tcl/Tk based script supplied in
        filename. 
The flag argument should be specified as 0.
",
299,*exclusiveidrange,"Description
This command sets an exclusive ID range for a submodel.
","Inputs

submodel_type
The submodel type to sets the exclusive ID range for. Valid values are includes and
            includefiles.
id
The submodel ID. Not required, if shortname is used.
shortname
The shortname of the submodel. Not required if id is used.
entity_type
The entity type to set the exclusive ID range for.
pool_id
The optional ID of the solver pool.

","Example
To set an exclusive component ID range for include
        1:*exclusiveidrange includes 1 """" comps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
300,*exportbif,"Description
Exports the current database to Medina .bif format. Currently only
        nodes, elements, node sets and element sets are supported.
","Inputs

filename
The full path and file name to export to.

","Example
To export to a file named
        C:/temp/test.bif:*exportbif C:/temp/test.bif
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
301,*exportshapes,"Description
Exports shape design variables and shapes in several formats.
","Inputs

analysiscode
The analysis code for which the output is needed. 
OptiStruct
Nastran
Genesis
HyperStudy
Templex
HyperOpt


subcode
This indicates the specific format/item to be output. 
Valid subcodes for each analysis code
OptiStruct, Nastran,
                  Genesis None, long, force, moment, temperature
Templex, HyperStudy
OptiStruct, HyperForm,
                    Nastran, Dynakey, Dynaseq, Radioss, PAM-CRASH, Marc, ANSYS, Abaqus, Abaqus2D, MADYMO
HyperOpt, OptiStruct, Nastran, Abaqus


outputfile
The output file name.

","Example
To create an OptiStruct long format deck shape.dat containing
        design variables and
        shapes:*exportshapes(""OptiStruct"",""long"",""shape.dat"")
",
302,*extend_elements,"Description
Extends, connects and optionally remeshes 2D elements onto target 2D elements. 
Additionally, this detects whether the elements to be extended intersect the target
        elements. If they do intersect, small penetrations are also removed during the extension and
        connection. Such small penetrations are defined as ≥ half of the average element size.
","Inputs

mark_id_source
The mark ID containing the source nodes to extend over. Valid values are 1 and 2.
entity_type_target
The entity type to use as the target (destination) for the extension. Valid values are
            components and elements.
mark_id_target
The mark ID containing the target entities to extend to. Valid values are 1 and 2.
options
Additional strings defining extended parameters/options. Options are defined in ""name
            value(s)"" format. Valid options are:
projection value


0 - Extend along tangent direction (default, if not provided). 
1 - Project normal to destination. 
2 - Use direction specified by projection_vector.


projection_vector x y z
3 doubles defining the vector direction. Must be defined, if
                    projection is 2.
angle value
The angle used to define feature edges on the mesh. If not defined, 25.0 is
                  used.
remesh_extension value
0 - Do not remesh extension. 
1 - Remesh extension (default if not provided).
remesh_dest_mode value


0 - Do not remesh destination. Destination mesh is stitched to maintain
                      element connectivity. 
1 - Remesh all input destination elements. 
2 - Remesh destination elements defined by
                        remesh_dest_layers.


remesh_dest_layers value
Must be defined, if remesh_dest_mode is 2.
0 - Remesh only the destination elements attached to the extended element
                      edges.
> 0 - Remesh additional layers in addition to the destination elements
                      attached to the extended element edges.


mesh_dest_type value
Automatically detected from input mesh, if not provided.
0 - tria 
1 - quad 
2 - mixed 
3 - R-tria 
4 - quad only


mesh_dest_size value
Automatically detected from input mesh, if not provided.



","Example
To extend using nodes 704-734, targeting elements 381-605, using a tangent projection, a
        feature angle of 30, remeshing the extension, and remeshing the destination using 2
        layers:*createmark nodes 1 704-734
*createmark elements 2 381-605
*extend_elements 1 elements 2 ""projection 0 angle 30.000000 remesh_extension 1 remesh_dest_mode 2 remesh_dest_layers 2""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
303,*facepreviewduplicates,"Description
Finds duplicate faces.
","Inputs

mark
The mark ID which contains the faces to compare for and delete duplicates.
tol
The tolerance used to find duplicate faces.

","Example
To find duplicates within a tolerance of 0.1, among the faces 2, 4, 7, 14, and
        23:*createmark(faces,1) 2, 4, 7, 14, 23
*facepreviewduplicates(1, 0.1)

This command removes any non-duplicate faces from the mark. The
          *createmark() command is required.
",
304,*facesmarktosurface,"Description
Assigns a group of faces to a different surface.
","Inputs

mark
The mark ID containing the faces to assign to a different surface.
surface
The surface to which the selected faces are to be assigned. 
0 - A new surface is created.



","Example
To create a new surface which contains the faces 13, 18, 20, and
        21:*createmark(faces,1) 13 18 20 21
*facesmarktosurface(1,0)

The faces are removed from the surfaces that previously contained them. If this empties a
        surface of faces, the surface is automatically deleted. On the Geom Cleanup panel, this command corresponds to the moving faces tool.
",
305,*fatiguewrite,"Description
Creates a fatigue analysis input file in the format specified. 
","Inputs

entities
The entity types on the mark.
Elements
Nodes


markmask
The mark ID containing the entities.
filename
The specified file name into which the fatigue analysis results are written.
datagroup
The data group type chosen (depending upon the solver).
filetype
The file type.
BINARY
ASCII


analysistype
The analysis type.
Linear
Transient


simulationtype
The simulation types.
0
1
2


sim1
If simulationtype = 0, writes all simulations for the specified
            entities.
sim2
If simulationtype = 1, writes only the simulation values for a
            specific simulation.
sim3
If simulationtype = 2, writes only the simulations in the specified
            range, given start and end simulation values.

","Example

*fatiguewrite(entities    element (entity selected)
markmask    200 (element number(s))
filename    c:\temp\fatg, (file name)
datagroup   Stress TOP SURFACE
filetype    ascii
analysistypelinear
simulationtype   0
sim1   all
sim2   NULL
sim3 NULL

Load the HyperMesh model or solver input data and results files
        prior to using this command. 
",
306,*fbdforce,"Description
Creates an FBD force plot, and fields or loads from the results.
This queries the GPF, Applied, SPC and MPC data from the result entity on a
        freebodysection.
","Inputs

freebodysection_ids=<value>
The freebodysection entity IDs.
data_strings=<value>
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
appf=<value>
0 - Applied forces do not participate in the FBD calculation (default)
1 - Applied forces do participate in the FBD calculation
arrlen=<value>
Controls the FBD plot arrow length.  Default is 75 (%).
arroworigin=<value>
0 - Tail of arrow at node for the plot (default)
1 - Tip of arrow at node for the plot
colorfx=<value>
The color of the Fx arrow.  Valid values are 1-64.
colorfxy=<value>
The color of the Fxy arrow.  Valid values are 1-64.
colorfxyz=<value>
The color of the Fxyz arrow.  Valid values are 1-64.
colorfxz=<value>
The color of the Fxz arrow.  Valid values are 1-64.
colorfy=<value>
The color of the Fy arrow.  Valid values are 1-64.
colorfyz=<value>
The color of the Fyz arrow.  Valid values are 1-64.
colorfz=<value>
The color of the Fz arrow.  Valid values are 1-64.
colormx=<value>
The color of the Mx arrow.  Valid values are 1-64.
colormxy=<value>
The color of the Mxy arrow.  Valid values are 1-64.
colormxyz=<value>
The color of the Mxyz arrow.  Valid values are 1-64.
colormxz=<value>
The color of the Mxz arrow.  Valid values are 1-64.
colormy=<value>
The color of the My arrow.  Valid values are 1-64.
colormyz=<value>
The color of the Myz arrow.  Valid values are 1-64.
colormz=<value>
The color of the Mz arrow.  Valid values are 1-64.
createfield=<value>
0 - Do not create a nodal force and moment field (default)
1 - Create a nodal force and moment field
createload=<value>
0 - Do not create FBD force and moment loads (default)
1 - Create FBD force and moment loads
declim=<value>
Controls the decimal limit.  Default is 2.
display=<value>
0 - Do not plot FBD forces
1 - Plot FBD forces (default)
freenode=<value>
0 - Free nodes.  Find the nodes shared by elements other than the elements in
                  the freebodysection (default).
1 - Boundary nodes.  Find only te boundary nodes of the elements in the
                  freebodysection.
2 - All nodes.  Considers all nodes of the elements in the freebodysection.
fx=<value>
0 - Fx forces are not included in the plot, load or field creation
                  (default)
1 - Fx forces are included in the plot, load or field creation
fxy=<value>
0 - Fxy resultant forces are not included in the plot (default)
1 - Fxy resultant forces are included in the plot
fxyz=<value>
0 - Fxyz resultant forces are not included in the plot (default)
1 - Fxyz resultant forces are included in the plot
fxz=<value>
0 - Fxz resultant forces are not included in the plot (default)
1 - Fxz resultant forces are included in the plot
fy=<value>
0 - Fy forces are not included in the plot, load or field creation
                  (default)
1 - Fy forces are included in the plot, load or field creation
fyz=<value>
0 - Fyz resultant forces are not included in the plot (default)
1 - Fyz resultant forces are included in the plot
fz=<value>
0 - Fz forces are not included in the plot, load or field creation
                  (default)
1 - Fz forces are included in the plot, load or field creation
gpf=<value>
0 - Grid-point forces do not participate in the FBD calculation (default)
1 - Grid-point forces do participate in the FBD calculation
intf=<value>
0 - Internal forces do not participate in the FBD calculation (default)
1 - Internal forces do participate in the FBD calculation
mpcf=<value>
0 - MPC forces do not participate in the FBD calculation (default)
1 - MPC forces do participate in the FBD calculation
mx=<value>
0 - Mx moments are not included in the plot, load or field creation
                  (default)
1 - Mx moments are included in the plot, load or field creation
mxy=<value>
0 - Mxy resultant moments are not included in the plot (default)
1 - Mxy resultant moments are included in the plot
mxyz=<value>
0 - Mxyz resultant moments are not included in the plot (default)
1 - Mxyz resultant moments are included in the plot
mxz=<value>
0 - Mxz resultant moments are not included in the plot (default)
1 - Mxz resultant moments are included in the plot
my=<value>
0 - My moments are not included in the plot, load or field creation
                  (default)
1 - My moments are included in the plot, load or field creation
myz=<value>
0 - Myz resultant moments are not included in the plot (default)
1 - Myz resultant moments are included in the plot
mz=<value>
0 - Mz moments are not included in the plot, load or field creation
                  (default)
1 - Mz moments are included in the plot, load or field creation
resfileid=<value>
The result file ID for resultid. Useful when multiple result
                  files are loaded for a single result entity.
resolvein_sys=<value>
0 - Resolve in analysis system (default)
1 - Resolve in global system
2 - Resolve in user system
resultant=<value>
0 - Free body force/moment plot
1 - Resultant force/moment plot
resultid=<value>
The result entity ID.
scid=<value>
The results subcase ID for resultid.
scientific=<value>
0 - Fixed format text (default)
1 - Scientific format text
showvalue=<value>
0 - Show text (default)
1 - Hide text
sizescale=<value>
0 - Constant FBD plot arrow length (default)
1 - Magnitude FBD plot arrow length
spcf=<value>
0 - SPC forces do not participate in the FBD calculation (default)
1 - SPC forces do participate in the FBD calculation
stepid=<value>
The step/simulation ID for scid.
tolerance=<value>
The tolerance to limit the values. Default is 0.00001.
user_sys_id=<value>
The system ID when resolvein_sys=2.
vecstyle=<value>
0 - 3D FBD plot arrow (default)
1 - 2D FBD plot arrow


num_strings=<value>
Integer indicating the size (number of strings) in the data_strings
            array.

","Example
Create an FBD force
        plot:*createstringarray 48 ""scientific=1"" ""resultant=1"" ""arroworigin=0"" ""tolerance=0.00001"" 
""scid=1"" ""resfileid=1"" ""resultid=1"" ""showvalue=1"" ""stepid=1"" ""sizescale=0"" ""vecstyle=0"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""fxy=1"" ""fyz=1"" ""fxz=1"" ""mxy=1"" ""myz=1"" ""mxz=1"" ""fxyz=1"" ""mxyz=1"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""arrlen=75"" ""declim=2"" ""freenode=2"" ""display=1"" ""colorfx=3"" ""colorfy=4"" ""colorfz=5"" ""colorfxy=7"" ""colorfyz=8"" ""colorfxz=9"" ""colorfxyz=12"" ""colormx=3"" ""colormy=4"" ""colormz=5"" ""colormxy=7"" ""colormyz=8"" ""colormxz=9"" ""colormxyz=12""
set fbdIds {1 2 3}
*fbdforce $fbdIds 1 48
Create
        loads:*createstringarray 21 ""createload=1"" ""resolvein_sys=3 "" ""user_sys_id=2"" ""scid=1"" ""resfileid=1"" ""resulted=1"" ""stepid=1"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""tolerance=0.00001"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""display=0"" ""freenode=1""
set fbdIds {1 2 3}
*fbdforce $fbdIds 1 21
Create a
        field:*createstringarray 21 ""createfield=1"" ""resolvein_sys=3 "" ""user_sys_id=2"" ""scid=1"" ""resfileid=1"" ""resulted=1"" ""stepid=1"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""tolerance=0.00001"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""display=0"" ""freenode=1""
set fbdIds {1 2 3}
*fbdforce $fbdIds 1 21
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
307,*feabsorbtomassentity,"Description
Finds and absorbs relevant FE entities into mass entities.
","Inputs

config
1 - Point mass
2 - Rigid mass
3 - NSM
entity_type
The type of entity to absorb.  Valid values are groups and elements.
mark_id
The ID of the mark containing the entities to absorb.  Valid values are 1 and 2.
mark_behavior
0 - FE entities on mark_id will be ignored.  FE absorb will be
            performed on all FE entities in the model.
1 - FE absorb will be performed only on the FE entities which are on
              mark_id.
reconnect_rule
The reconnect rule:
0 - None
1 - By ID
2 - By name
distribution_type
The distribution type for point mass:
0 - Apply to all nodes
1 - Total mass
create_rule
The entity creation rule for point mass:
0 - Based on magnitude
1 - Based on component

","Example
Absorb to point mass, considering all FE elements in the model:
*createmark elements 1 """"
*feabsorbtomassentity 1 elements 1 0 2 0 0
Absorb to NSM, considering all group entities in the model:
*createmark groups 1 """"
*feabsorbtomassentity 3 groups 1 0 2 0 0

Absorb to NSM, with group IDs 10 and 11 on the mark ID:
*createmark groups 1 10 11
*feabsorbtomassentity 3 groups 1 1 2 0 0
Absorb to rigid mass, considering all FE elements in the model:
*createmark elements 1 """"
*feabsorbtomassentity 2 elements 1 0 2 0 0
Absorb to rigid mass, with the elements 200 and 201 on the mark
*createmark elements 1 200 201
*feabsorbtomassentity 2 elements 1 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
308,*features,"Description
Generates plot elements between two-dimensional elements whose normals exceed the
        user-specified angle. 
","Inputs

entity type
The entity type on the mark. Valid entries are components and elements. 
mark
The mark ID that contains the above entities.
feature angle
The angle specifying the maximum angle allowed between any two plate elements, before
            a plot element or a line is generated between the shared sides of the two elements.
ignorenormals


0 - Do not create features based on normals. 
1 - Create features if the angle between adjacent elements is greater than the
                feature angle, but less than (PI-feature angle). 
2 - Use advanced analysis: this creates features based on the recognition of
                natural transitions between basic surfaces such as planes or cylinders, as well as
                features based on the feature angle. When using this option, a feature angle of 60
                degrees or more is recommended. 
3 - This value is set by the workspace when both ignore normals and advanced
                analysis checkboxes are active. However, advanced analysis overrides other
                parameters, so the ignore normals flag is ignored. Thus, this value has the same
                effect as 2.


created entity


0 - Creates plot elements to represent the features. 
1 - Creates geometric lines representing feature lines.


break angle
If created entity = 1, the angle specifying when to break the
            feature line created into multiple line segments. When the angle between adjoining
            elements along the feature is larger than the specified value, it splits the line into
            multiple segments.
smooth


0 - Do not smooth the lines. 
1 - Smooth the line created through the nodes of the feature.



","Example
To create smooth lines representing features on the component hood based on 30.0 degrees
        feature angle and 20.0 degrees break
        angle:*createmark(components,1) hood
*features(component,1,30.0,1,1,20.0,1)
*features() can be used to reduce the time it takes to generate an
        animation sequence, by reducing the number of active elements. All features generated are
        placed into a component named ^feature which HyperMesh will
        create, if necessary. 
",
309,*features_advanced,"Description
Generates plot elements between two-dimensional elements whose normals exceed the
        user-specified angle.
","Inputs

entity_type
The input entity type. Valid values are elements and components. 
mark_id
The mark ID that contains the input entities. Valid values are 1 and 2.
feature_angle
The maximum angle allowed between any two plate elements before a plot element or a
            line is generated between the shared sides of the two elements.
type


0 - Simple 
1 - Advanced. This creates features based on the recognition of natural
                transitions between basic surfaces such as planes or cylinders, as well as features
                based on the feature angle. When using this option, a feature angle of 60 degrees or
                more is recommended. 
2 - Connected


break_angle
If created_entity = 1, the angle specifying when to break the
            feature line created into multiple line segments. When the angle between adjoining
            elements along the feature is larger than the specified value, it splits the line into
            multiple segments. 
created_entity


0 - Creates plot elements to represent the features. 
1 - Creates geometric lines representing feature lines.


smooth


0 - Do not smooth the lines. 
1 - Smooth the line created through the nodes of the feature.


string_array
The ID of the string array that contains the array of parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Each argument can be either space or comma separated.
IgnoreNormal: <value>
0 - Create features if the angle between adjacent elements is greater than
                    feature_angle, but less than
                    (PI-feature_angle). 
1 - Do not create features based on normals.
MergeSmallArea: <value>
Used only when type is set to 1.
0 - Do not merge small features. 
1 - Merge features of two regions if their area ratio is less than
                        MergeSmallAreaRatio.


MergeSmallAreaRatio: <value>
The area ratio to use when MergeSmallArea is set to 1.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To create smooth lines representing features on the component hood based on 30.0 degrees
        feature angle and 20.0 degrees break
        angle:*createmark comps 1 hood
*createstringarray 2 ""MergeSmaleArea: 1"" ""MergeSmallAreaRatio 0.5""
*features_advance comps 1 30.0 1 30.0 1 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
310,*features_remove_selected,"Description
Deletes specified elements from ^feature and ^open features.
","Inputs

markmask
The element mark number (1 or 2). Elements within the ^feature or ""^open features
            components and located on the specified mark will be deleted by this command.

","Example
To remove elements within marker 2:*features_remove_selected(2)
",
311,*feinputmerge,"Description
Inputs data from FE files, additionally applying redundant entity management (REM).  REM is
        supported for properties, materials and components. Depending on the input options, entity
        names or IDs in the incoming file may be renamed/renumbered with the least disruption
        possible.
","
Inputs


reader=<value>
The name of the input reader executable.
inputfilename=<value>
The full path and file of the FE file to import.
importoptions={<option1> <option2> ... <option3>}
Specifies additional import options, compatible with the
              string_array options for *feinputwithdata2.
mergemode.comps=<value>
Specifies how to merge the attributes of incoming components identified as the same.
            Valid values are keepexisting, keepincoming and keepboth (default).
mergemode.geometryandmesh=<value>
Specifies how to merge the contents of incoming components identified as the same.
            Valid values are keepexisting, keepincoming and keepboth (default).
This only applies when mergemode.comps=keepexistingor
              mergemode.comps=keepincoming.
mergemode.mats=<value>
Specifies how to merge the attributes of incoming materials identified as the same.
            Valid values are keepexisting, keepincoming and keepboth (default).
mergemode.props=<value>
Specifies how to merge the attributes of incoming properties identified as the same.
            Valid values are keepexisting, keepincoming and keepboth (default).

","Examples
To merge C:/temp/Rail2.k, keeping all incoming
        data:*feinputmerge reader=""#ls-dyna dynakey"" inputfilename=C:/temp/Rail2.k mergemode.props=keepincoming mergemode.mats=keepincoming mergemode.comps=keepincoming mergemode.geometryandmesh=keepincoming importoptions={LsDyna Keyword971_R11.0 READ_INITIAL_STRESS_SHELL READ_INITIAL_STRAIN_SHELL SKIP_INCLUDE_STAMP}

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
312,*feinputomitincludefiles,"Description
After the next call to *feinputwithdata2, HyperMesh will revert to the default behavior of reading and merging
        include files. For behavior other than the default behavior, this command must be called
        each time.
",,,
313,*feinputwithdata2,"Description
This command inputs data from sources such as CAD files, connector files/MCF/MWF, and FE
        files, with additional input parameters.
The additional input parameters are defined using the *createstringarray
        command and the string_array and number_of_strings
        options. For a list of strings that are supported by each reader, refer to the See
          Also list. 
To determine the proper options and strings to use for this command, it is best to first
        perform the import action using the HyperMesh workspace, and
        then look at the values written to the command file.
","Inputs

import_reader
The full path and filename of the import reader program. This can indicate a CAD
            reader, Connector/MCF/MWF reader, or FE reader. Paths with spaces must be enclosed in
            quotes. Core  HyperMesh readers also support a short name,
            instead of the full path and filename.
filename
The full path and filename of the import file. Paths with spaces must be enclosed in
            quotes.
overwrite_flag
Flag indicating whether HyperMesh should offset or
            overwrite any existing entity IDs. This option is only valid for FE files. For CAD files
            and connector files/MCF/MWF, this value should always be 0.
0 - Offset any existing entity IDs.
1 - Overwrites any existing entity IDs. Also see the
                  offset_flag option.


reserved1
Not used. Always set to 0.
cleanup_tolerance
A real number indicating the cleanup tolerance to use during geometry import to clean
            the topology.
> 0 - Use this value as the cleanup tolerance. 
= 0 - Do not cleanup topology. 
< 0 - Use the automatic cleanup tolerance.


blanked_component
Flag indicating whether to create a blanked component for relevant data. This is only
            valid for IGES and CATIA
            files.
offset_flag
If overwrite_flag is set to 1, use: 
0 - For the next available entity IDs. 
1 - To apply a user-defined offset.


If the flag is set to 1, the entity offsets must be defined for each relevant entity
            using the *feinputoffsetid command. This command must be run before
            each import, if an offset is required as the offset values only apply to the next file
            import.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
scale_factor
Real value indicating the scale factor to apply to the data (CAD import only). Set to
            1.0 when not being used.
name_comps_by_layer
Flag indicating whether to name CATIA components.
1 - With the layer as part of the name.
0 - Without the layer as part of the name.



","Example
To import an Abaqus file named
          C:/model.inp, offset any existing IDs using the next available IDs,
        and skip reading any loads or loadcols from the
        file:*createstringarray 2 ""LOADS_SKIP "" ""LOADCOLS_SKIP ""
*feinputwithdata2 ""#abaqus/abaqus"" ""C:/model.inp"" 0 0 0 0 0 1 2 1 0
To read a UG input file named ug_part.prt with parameters setup from
        the UG Part browser:*createstringarray 12 ""SELECTIONS 0 1 0 0 0 1 0 0 0"" """" ""BEGIN_PARTS"" ""END_PARTS"" """" ""BEGIN_LAYERINFO"" ""DISABLE  "" ""ENABLE  *"" ""END_LAYERINFO"" """" ""COMPONENT_NAME default""
*feinputwithdata2 ""#ug/ug"" ""ug_part.prt"" 1 0 -0.01 1 0 1 12 1 0
To import connectors using a
        MCF/MWF:*createstringarray 1 ""~HM_MAX_CE_ID [hm_entitymaxid CONNECTORS]""
*feinputwithdata2 ""#connectors/connectors"" ""C:/example1.mwf"" 0 0 0 1 0 1 1 1 0
To import connectors using a MCF/MWF with the optional ID map
        file:*createstringarray 2 ""~HM_MAX_CE_ID [hm_entitymaxid CONNECTORS]"" ""~CHARTFILE C:/id_map_file.txt""
*feinputwithdata2 ""#connectors/connectors"" ""C:/example2.mwf"" 0 0 0 1 0 1 2 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
314,*feoutput_singleinclude,"Description
Creates an ASCII export file based on an output template, for a single include file.
","Inputs

id
The ID of the include to export.  If shortname is specified, this
            may be set as """".
shortname
The short name (portion without the path) of the include to export.  If
              id is specified, this may be set as """".
export_template

The full path and filename of the export template to be used. Paths with spaces must
              be enclosed in quotes.

filename

The full path and filename of the output file. Paths with spaces must be enclosed in
              quotes.

reserved1

Reserved for future use.  Must be set to 0.

reserved2

Reserved for future use.  Must be set to 0.

export_type
Flag indicating which entities will be output:
0 - Only the displayed entities will be output.
1 - All entities will be output.
2 - Entities will be output based on their/their parent collector’s output bit
                (custom output). This bit can be set using the
                *allsuppressoutput, *includesuppressoutput and
                  *setvaluecommands or using the Entity State Browser.


string_array
The string array ID that contains the additional output parameters. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented as subtopics
            for *feoutputwithdata.

","Example
To export all entities in the include with ID 10, using the OptiStruct template, to a file named C:/temp/myinclude.fem, skipping
        the export of connectors:
set template [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]
*createstringarray 1 ""CONNECTORS_SKIP""
*feoutput_singleinclude 10 """" ""$template/optistruct/"" ""C:/temp/myinclude.fem"" 0 0 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
315,*feoutputmergeincludefiles,"Description

","Inputs

code


0 - HyperMesh should segregate entities into their
                respective files. 
1 - HyperMesh should consolidate everything into one
                file.



","Example
After the next call to *feoutputwithdata, HyperMesh will revert to the default behavior of consolidating
        everything into one file. For behavior other than the default behavior, this command must be
        called each time.
","Errors
None.
"
316,*feoutputwithdata_PI,"Description
This command exports an ASCII analysis file, formatted based
        on the specified export_template.   Currently supported for OptiStruct only.
The additional output parameters are defined using the
          *createstringarray command and the string_array and
          number_of_strings options. For a list of strings that are supported by
        each reader, refer to the See Also list.
To determine the proper options and strings to use for this command, it is best to first
        perform the import action using the HyperMesh workspace and then
        look at the values written to the command file.
","Inputs

export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
export_type
Flag indicating which entities will be output:
0 - Only the displayed entities will be output.
1 - All entities will be output.
2 - Entities will be output based on their/their parent collector’s output bit
                (custom output). This bit can be set using the
                *allsuppressoutput, *includesuppressoutput and
                  *setvaluecommands or using the Entity State Browser.


string_array
The string array ID that contains the additional output parameters. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented as subtopics.
            Not all templates support all strings.

","Examples
To output all entities using the OptiStruct template, to a file
        named
        C:/model.fem:set template [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]
*feoutputwithdata_PI ""$template/optistruct/"" ""C:/model.fem"" 0 0 1 1 0
To output all entities using the OptiStruct template, to a file
        named C:/model.fem, skipping connector
        data:set template [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]
*createstringarray 1 ""CONNECTORS_SKIP""
*feoutputwithdata_PI ""$template/optistruct/"" ""C:/model.fem"" 0 0 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
317,*filewritecomponentgeometry,"Description
This command allows you to export HyperMesh files on a
        per-component basis, so you can export HyperMesh geometry that
        is part of a larger assembly without exporting the entire assembly.
","Inputs

filename
The file name to create, including the extension. Example:
              bumper.hm.
component
The component name to be exported.
compression
Flag to save the file in compressed form or not, excluding optional specific
            information such as facets or plot coordinates. Compressed files are smaller, but
            require more processing time to recalculate when loaded.
0 - Save as uncompressed file (including all optional data).
1 - Save as compressed file (excluding optional data).



","Example
To save the bumper component to a compressed file named
        bumper1.hm:*filewritecomponentgeometry(bumper1.hm,bumper,1)
",
318,*fill_circular_holes,"Description
This command is used to fill flat circular holes on 2D elements.
","Inputs

mark_id
The mark of nodes on the holes to be filled. Valid values are 1 and 2.
radius_limit
The radius limit for holes to be filled. If set to a positive value, then all circular
            flat holes with radii less than this limit are filled. In this case,
              mark_id can be set to 0 and is ignored. Otherwise, all flat holes
            containing nodes marked are filled.

","Examples
To fill the hole containing node
        7989:*createmark nodes 1 7989 
*fill_circular_holes 1 -1.0
To fill the holes with a radius less than
        5.0:*fill_circular_holes 0 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
319,*fill_fe_gaps_lines,"Description
Fills gaps in FE from lines selected on both sides of the gap.
","
Inputs


mark_id1
The mark ID containing the lines at the first boundary. Valid values are 1 and 2.
mark_id2
The mark ID containing the lines at the second boundary. Valid values are 1 and 2.
max_width
Maximum allowed gap width to be filled.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements.
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fi.
DefineMaxWidth
0 - Ignore max_width for gap filling.
1 - Consider max_width for gap filling.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To fill gaps less than 100 between lists 1 and 2, including remeshing:
*createmark lines 1 1 2 3 4 5
*createmark lines 2 6 7 8 9 10
*createstringarray 2 ""Remesh: 1"" ""DefineMaxWidth: 1""
*fill_fe_gaps_lines 1 2 100.0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
320,*fill_fe_gaps_nodelist,"Description
Fills gaps in FE from node lists selected on both sides of the gap.
","Inputs

list_id1
The list ID containing the nodes on the first boundary. Valid values are 1 and 2.
list_id2
The list ID containing the nodes on the second boundary. Valid values are 1 and 2.
max_width
Maximum allowed gap width to be filled.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements.
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fill.
DefineMaxWidth
0 - Ignore max_width for gap filling.
1 - Consider max_width for gap filling.
DetectNodeClusters
0 - The ordered input node list is used as-is for gap filling, without detecting
                  clusters in the input.
1 - The ordered input node list is split and clustered based on connectivity.
                  This is useful for supplying multiple lists as input.
GuideNodePairs
Specifies an optional list of node IDs in the form ""M1 M2 N1 N2 O1 O2 ..."" where
                  (M1, M2), (N1, N2) and (O1, O2) are node pairs. These pairs are used to divide the
                  gap to be filled into smaller loops. When provided, gaps are filled ensuring that
                  the loops are split at the specified pairs. This aids in filling complex hole
                  shapes by guiding the filling process correctly.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To fill gaps less than 100 between node lists 1 and 2, including
        remeshing:*createlist nodes 1 1 2 3 4 5
*createlist nodes 2 6 7 8 9 10
*createstringarray 2 ""Remesh: 1"" ""DefineMaxWidth: 1""
*fill_fe_gaps_nodelist 1 2 100.0 1 2
To fill multiple gaps, where the input list contains nodes from all gaps at
        once:*createlist nodes 1 18 19 22 36 56 23 34 45 20 21 67 89 71 72 73 74 75 76
*createlist nodes 2 57 98 43 13 16 17 42 43 44 48 46 49 91 92 93 94 95 96
*createstringarray 2 ""Remesh:0"" ""DefineMaxWidth:0"" ""DetectClusters:1""
*fill_fe_gaps_nodelist 1 2 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
321,*fill_fe_holes_lines,"Description
longDescription
","
Inputs


mark_id
The ID of the mark containing the lines on the hole boundary.
max_width
Maximum allowed hole width.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements. 
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fill.
DefineMaxWidth
0 - Ignore max_width for hole filling.
1 - Consider max_width for hole filling.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To fill the holes defined by the closed lines 1-5, using a max width of 20.5, remeshing
        filled elements, and creating the elements in the adjacent
        components:*createmark lines 1 1-5
*createstringarray 3 ""Remesh: 1"" ""AdjacentComp: 1"" ""DefineMaxWidth: 1""
*fill_fe_holes_lines 1 20.5 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
322,*fillet_surface_edges,"Description
This command inserts a fillet surface of a constant radius between surfaces at the selected
        edges. It is assumed that only two surfaces are linked to each other at each point of the
        selected edges. If there are more than two surfaces linked, then this is ignored for the
        filleting. It is also assumed that the angle between the two surfaces at each point of the
        edges is less than 180 degrees minus unfold_angle_limit, where
          unfold_angle_limit must be more than 0 degrees.
","Inputs

mark_id
The mark ID containing the relevant surface edges to fillet between.
fillet_radius
The radius of the fillet to create.
stitching_tol
The tolerance to use for equivalenceing the original surfaces with the fillet
            surfaces, as well as each other.
unfold_angle_limit
The angle between the surfaces must be sharper than 180 degrees minus this value. Must
            be ≥ 0. 
fillet_option
0 - Each selected edge will have its own fillet surface.
1 - The fillet surface will be continuous where the chain of edges does not have sharp
            corners between the edges. Therefore, one long fillet surface will correspond each chain
            of edges that create a smooth line.
trim_mode
0 - The fillet surfaces are created in a component named Fillet.
            The original surfaces are not modified. 
1 - The fillet surfaces are created in the same component as the original surfaces
            (one of the original surfaces, if they are in different components). The original
            surfaces are trimmed by the fillet surfaces and stitched to them. The leftovers of the
            trim (filleting chips) are retained in a component named Filleting
              chips. 
2 - Same as 1, but the filleting chips are deleted.
reserved
Reserved for future use. Value must be 0.

","Example
To create fillet of radius 2.5 at the edges 10 and 15 with the continuous fillet option,
        stitching tolerance 0.1 and not deleting the filleting chips:
        *createmark lines 1 10 15
*fillet_surface_edges 1 2.5 0.1 0 1 2 0 
",
323,*filtertable,"Description
Filter unique cells of key strings of selected column(s) and generate a new table
        considering the indices of key strings in key columns.
Unless otherwise noted, all inputs are mandatory.  They may be specified in any order.
","
Inputs


keycolumns=<column1, column2, ... columnN>
The key columns of the selected table, separated by commas.  These must follow the
            same sequence as the keystrings.
keystring=<string1, string2, ... stringN>
The key strings of the selected columns, separated by commas.  These must follow the
            same sequence as the keycolumns.
table=<name>
The name of the input/source table.
targettable=<name>
The name of the output/target table.
valuecolumns=<column1, column2, ... columnN>
The value columns of the selected table, separated by commas.  These must follow the
            same sequence as the keystrings.

","Examples
For a given sourcetable table, filter 2 from layerindex column, 2_3_0 from loadcase column
        and get elementid and TAU12 columns output to a new table named
        targTable:*filtertable table=sourcetable keystring={2,2_3_0} keycolumns={layerindex,loadcase} valuecolumns={elementid,TAU12} targettable=targTable
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
324,*findandremovethreads,"Description
This command tries to recognize threads with a depth less than the specified maximum value.
        Then the recognized threads are replaced with simple smooth surfaces (usually a combination
        of cylinders, cones and smooth NURBS surfaces). A search for recognition and removal of
        threads is performed within a given selection of surfaces or solids. Optionally, the input
        selection can be considered as a seed selection, allowing attached surfaces to also become
        involved in the recognition and removal.
","Inputs

entity_type
The entity types to find threads in. Valid values are surfs and solids. 
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
max_depth
The maximum depth of threads to find and remove.
replacement_type
The type of major cylinder surface to use for replacing the thread:
-2 - Autodecide (by minor diameter for holes, by major diameter for bolts). 
-1 - Replacement by minor diameter. 
0 - Replacement by mean diameter. 
1 - Replacement by major diameter.


flags
Flags controlling the mode of thread removal. Bit values are used and the value is
            calculated as (Bit0).
Bit0
0 - Attached surfaces can also be considered, with input surfaces used as seeds. 
1 - Only surfaces specified as input can be considered


reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To recognize and remove cylindrical threads with a depth less than 5.0 for a given surface
        selection considered as a seed selection, with auto
        replacement:*createmark surfaces 1 1583 1234
*findandremovethreads surfaces 1 5.0 -2 0 0.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
325,*findbetween,"Description
Finds entities that are between/connect other entities.
","Inputs

find_entity_type
The entity types to find. Valid values are nodes and connectors. 
between_entity_type
The entity types that the find entities are between. 
If find_entity_type is nodes, valid values are elems and
                comps. 
If find_entity_type is connectors, valid values are surfs,
                elems, tags, assems and comps.


between_mark_id
The mark ID containing the between entities. Valid values are 1 and 2.
function
Currently only a value of 0 is supported. This finds connectors between surfs, elems,
            tags, assems or comps.
numbers
A flag that determines if the numbers of the found entities will be turned on after
            they are found.
0 - Off 
1 - On


output_mark_id
The mark ID containing the found entities. Valid values are 1 and 2.

","Example
To find connectors between components 1 and
        2:*createmark components 1 ""by id only"" 1 2
*findbetween connectors comps 1 0 1 2
To find nodes between components 1 and
        2:*createmark components 1 ""by id only"" 1 2
*findbetween nodes comps 1 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
326,*findedges1,"Description
This command finds and displays element free or T-connected edges as either free lines or
        plot elements in a new component named ^edges.
","Inputs

entity_type
The entity types to find edges for. Valid values are comps and elems. 
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
edge_type
The type of edges to find:
0 - Free edges. 
1 - T-connected edge


created_entity
The entity type to create on the found edges:
0 - Plot elements 
1 - Free lines


smooth
The smoothing to use when created_entity is 1:
0 - No smoothing. 
1 - Smooth the lines through the nodes.


break_angle
The angle specifying when to break the feature line created into multiple line
            segments when created_entity is 1. When the angle between adjoining
            elements along the feature is larger than the specified value, it splits the line into
            multiple segments.

","Example
To check the free edges on all of the elements contained in the component fender and to
        create plot
        elements:*createmark comps 1 fender
*findedges1 comps 1 0 1 0 0
",
327,*findloops,"Description
Finds the closed loops in a group of elements.
","Inputs

entity type
The entity type contained on the mark. The valid types are:
components
elements


mark
The ID of the mark.
by component
0 - Finds closed loops by considering the entities on the mark as a whole. 
1 - Finds closed loops, by component, for the entities on the mark. 

","Example
To find the closed loops on all of the elements contained in the component fender:
        *createmark(components,1) fender
*findloops(components,1,0)
",
328,*fix_2d_mesh,"Description
Performs local mesh operations to resolve intersections and slivers on a surface mesh.
","
Inputs



entity_type

The type of entity to fix.  Valid values are comps and elems.

mark_id

The ID of the mark of entities.  Valid values are 1 and 2.

fix_type

0 - Attempts to detect and remove intersections using local operations.
1 - Attempts to fix sliver elements present in the mesh input. 
2 - Attempts to fix sliver elements and subsequently run intersection removal.

aspect_ratio

This specifies the aspect ratio of the triangles that are allowed in the mesh as part
            of clean up. It is a value between 0 and 1.
Intersection removal attempts not to generate new triangles with less than the
            specified aspect ratio while resolving intersections.
Sliver removal method attempts to clean up the triangles with less than the specified
            aspect ratio.

node_movement_tol

This specifies the tolerance used to compute and resolve intersections. Suggested
            value is to use the average size of the mesh.
fix_method
Bit value defining which operations are allowed while resolving mesh intersections. 0
            will allow all operations, other values are interpreted as follows (Bit0 + 2*Bit1 + 4*Bit2):
Bit0
0 - Allow edge swap
1 - Disable edge swap
Bit1
0 - Allow edge collapse
1 - Disable edge collapse
Bit2
0 - Allow node movement
1 - Disable node movement



failed_mark_id

The ID of the mark of the unresolved element intersections.  Valid values are 1 and 2.
            Only useful for fix_type 0 and 2.

","Examples
Attempt to remove intersections in the input 2D mesh selection:
#Select the portion of the mesh to smooth
*createmark elems 1 ""all""
*createmark elems 2 
#Resolve the intersections so that no new triangle with aspect ratio < 0.1 is generated while resolving intersection and restricting the node movement by 0.5. Allowing all mesh editing operations, all unresolved intersections populated in elem mark 2.
*fix_2d_mesh elems 1 0 0.1 0.5 0 2
#If intersection removal has to be performed only allowing edge swap. fix_method = (1)2
*fix_2d_mesh elems 1 0 0.1 0.5 1 2
#If intersection removal has to be performed only allowing edge swap and node movements. fix_method = (101)2 = 5
*fix_2d_mesh elems 1 0 0.1 0.5 5 2
#To cleanup slivers with less than 0.1 aspect ratio and subsequently run intersection removal with node movement tolerance as 0.5 and allowing all operations while intersection removal.
*fix_2d_mesh elems 1 2 0.1 0.5 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
329,*fixnarrowsurfaces,"Description
This command fixes narrow surfaces and surfaces having local narrow regions like tails and
        necks.
It is intended to eliminate sliver elements while meshing and sometimes to allow meshing
        surfaces otherwise non-meshable.  Different levels of fixes can be provided for different
        types of meshing.
","Inputs

entity_type
The type of entity to consider.  Valid values are surfs, solids and comps.
mark_id
The ID of the mark containing the input entities.  Valid values are 1 and2.
width_threshold

The width threshold for considering surfaces as narrow.  It should be a positive
              value much smaller than the target element size for meshing of the model.

mesh_type

The targeted mesh type:
0 - Meshing using surface topology.  Sliver surfaces, narrow surface tails and
                  necks are identified and corresponding edges are points are self-stitched
                  together.  Collapsed surfaces are removed.
1 - Meshing the splines (faces) topology.  Sliver surfaces, narrow surface tails
                  and necks are identified and corresponding edges are points are self-stitched
                  together.  Collapsed surfaces are removed.  Gaps between surfaces and vertices
                  exceeding the geometry_fix_tol are eliminated.



fix_flag

When set to 1, performs geometry topology matching to morph the geometry to close
              physical gaps caused by stitching.

string_options

An optional input string containing additional input parameters.  The data for each
              input parameter consists of the predefined parameter keyword and the parameter value
              separated by space characters and /or equality symbol:
parameter_keyword = parameter_value
or
parameter_keyword parameter_value
Supported parameters are:
geometry_fix_tol = tolerance - The maximum gap allowed between
              edges and vertices, when eliminating geometry gaps for mesh_type 1.
              If not specified, the value is auto defined.
max_sharp_angle = angle - The corner angle above which the area
              nearby a surface corner is not considered a local narrow region.  Default is 10
              degrees.


","Example
Find and fix narrow surfaces with a width less than 0.4.  Do not eliminate geometry
        gaps:
*createmark surfs 1 displayed
*fixnarrowsurfaces surfs 1 0.4 0 0 """"
Find and fix narrow surfaces with a width less than 0.4.  Eliminate geometry gaps, using an
        auto-defined tolerance:
*createmark surfs 1 displayed
*fixnarrowsurfaces surfs 1 0.4 1 0 """"
Find and fix narrow surfaces with a width less than 0.4.  Eliminate geometry gaps more than
        0.02:
*createmark surfs 1 displayed
*fixnarrowsurfaces surfs 1 0.4 1 0 ""geometry_fix_tol = 0.02""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
330,*flattenpartmodel,"Description
Converts entities that refer to parts to refer to root.
For formula sets:


All clause – Updated to refer to root
Range clause – Range IDs of the clause will now refer to the begin/end range
            equivalent to the internal IDs


","
Inputs


reserved
Reserved for future use.  Must be set to 0.

","Examples
To flatten the model:*flattenpartmodel 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
331,*freeshapedesvarcreatewithmethod,"Description
Creates a free shape design variable.
","Inputs

entity_type
The type of entity used in creating the design variable. Valid values are nodes,
            elements, sets (nodal only), or properties.
mark_id
The ID of the mark of entities used to create the design variable. Valid values are 1
            and 2.
name
The name of the design variable.
method
0 - CLASSIC
1 - GRID
2 - BLANK

","Example
To create a free shape design variable fsh1 comprised of nodes, with method
        BLANK:*createmark nodes 1 2110 3292
*freeshapedesvarcreatewithmethod nodes 1 ""fsh1"" 2
To create a free shape design variable fsh2 comprised of a node set, with method
        CLASSIC:*createmark sets 1 ""set1""
*freeshapedesvarcreatewithmethod sets 1 ""fsh2"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
332,*fuse_shell_mesh,"Description
Attempts to mesh two disconnected element/component sets within a certain proximity with
        each other. 
","
Inputs



source_entity_type

The type of entity to use as source.  Valid values are comps and elems.

source_mark_id

The ID of the mark of source entities.  Valid values are 1 and 2.

target_entity_type

The type of entity to use as target.  Valid values are comps and elems.

target_mark_id

The ID of the mark of target entities.  Valid values are 1 and 2.

proximity

The value within which the source and target elements should be fused. Value must not
            be negative.
options
List of input options, passed as a space separated string enclosed in quotes. Valid
            options are:
BridgeGaps=<value>
0 - Stitches the source and target by imprinting source on target (default)
1 - Creates bridge elements between source and target instead of stitching ,
                  thereby retaining the source curvature
BridgeGapTol=<value>
The value beyond which the source nodes found under proximity with target will
                  be bridged. Only valid when BridgeGaps is enabled. Default
                  value is the global node tolerance.
ClusterRemovalMaxWidth=<value>
During mesh fusing, some isolated clusters on source can remain. This defines
                  the mesh maximum width within which if clusters of elements formed after fusing,
                  they are removed. Value must not be negative. Default value is 0.0.
DoRemesh=<value>
0 - Do not remesh fused elements (default)
1 - Remesh fused elements
FeatureAngle=<value>
The value to define features in the range of 0 to 180. Default/common value is
                  30.0.
FuseFreeEdgesOnly=<value>
0 - Fuse all elems within proximity (default)
1 - Fuse only free edges within proximity
NodeFeatureSnapTol=<value>
The value within which the nodes positions resulting after the fusing of source
                  and target elements can be snapped to features. Value must not be negative.
                  Default value is 0.0.
ProjectionType=<value>
1 - Projection and further stitching happens along shortest projection direction
                  of source nodes to the target (default)
2 - Projection and further stitching happens along the tangential projection
                  direction of source nodes to the target
3 - Projection and further stitching is attempted along the tangential
                  projection direction of source nodes to the target, however if the tangential
                  projection fails , shortest projection is considered
RemoveTargetTails=<value>
0 - Do not remove target tails (default)
1 - Remote target tails with tolerance provided in RemoveTargetTailTolerance
                  option
2 - Remote target tails with internaly calculated tolerance
RemoveTargetTailTolerance=<value>
If the width of the tail of the target tail face lies within this value, it is
                  removed. Valid only when RemoveTargetTails is enabled. Default
                  value is 0.0.
RemoveSharedTargetFace=<value>
0 - Do not delete faces shared by source and target at all edges formed at the
                  target after fusing (default)
1 - Delete faces shared by source and target at all edges formed at the target
                  after fusing (default)



","Examples
To fuse components 100 and 200 within a proximity of 40, with various fuse options:
*createmark components 1 100
*createmark components 2 200
*fuse_shell_mesh components 1 components 2 40 ""ClusterRemovalMaxWidth=30.0 DoRemesh=1 FuseFreeEdgesOnly=1 BridgeGaps=1 BridgeGapTol=0.0 ProjectionType=3 RemoveTargetTails=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
333,*gapelementupdate,"Description
Updates the property pointer of gap elements.
","Inputs

mark
The ID of the mark.
property name
The name of the property to which the gap elements should point. 
vectorid
The orientation vector I D associated with the gap element.
Update Property
A flag indicating whether or not to update the property.
0 - Do not update. 
1 - Update.


Update Vector
A flag indicating whether or not to update the vector ID.
0 - Do not update. 
1 - Update.



",,
334,*geomimport,"Description
Imports geometry from various CAD formats.
","Inputs

translator_type
The translator to use for import. Valid values are:
acis_ct
auto_detect
catia_ct
catiav6_ct
creo_ct
dxf_altair
iges_altair
inspire_altair
intergraph_altair
jt_jtopen
nx_ct
nx_ugopen
parasolid_parasolid
pdgs_altair
solidworks_ct
step_ct
tribon_altair
vdafs_altair


input_file_name
The name of the file to import.
<name>=<value>
The name=value options that define the import behavior. The actual options usable
            depend on the translator. The allowed options correspond to those supported in the
              .ini files, in terms of both name and possible values. All
            options specified in the command line and .ini files are
            fully synchronized, i.e. every option is available in both the command line and the
              .ini file. The full list of options and values can be
            found in the CAD Import Options documentation. 
Options passed via the command line prevail over options mentioned in the .ini file; options in the .ini file are
            effective only when the corresponding option is not used in the command line. Options
            mentioned neither in the command line nor in the .ini file
            assume values taken from a default option value set internally. 
Case insensitivity is supported for option values, but not option names. For example:
            ""SplitComponentsByBody=Off"" ""SplitComponentsByBody=OFF"" ""SplitComponentsByBody=off"" will
            all provide the same result. 
The order of these options does not matter.

","Example
To import the CATIA file
          C:/temp/Part5.CATPart using various
        options:*geomimport ""catia_ct"" ""C:/temp/Part5.CATPart"" ""CleanupTol=-0.01"" ""DoNotMergeEdges=off"" ""ImportBlanked=off"" ""ImportFeatureData=off"" ""ImportPublicationData=off"" ""ReadCompositeData=off"" ""ScaleFactor=1.0"" ""SplitComponentsByBody=off"" ""SplitComponentsByPart=off""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
335,*geomupdate,"Description
Update CAD files with modified data.  Currently supported for Parasolid and NX only.  For NX, a valid license and installation is required.
","Inputs

entity_type
The type of entity to update.  Valid values are parameters (NX only), parts, components, points, lines, surfaces and
            solids.
mark_id
The ID of the mark of entities to update.  Valid values are 1 and 2.
<name>=<value>
The additional name=value options.  These are optional and may be specified in any
            order.


DataToUpdate=<value>
None - When entity_type is parameters
Metadata - For all other entity types
FileVersionSameAsCAD
If specified, saves the file in the version it was created.  Otherwise, saves in
                  the latest version.  Valid for Parasolid only.
MetadataPrefixFilter=<value>
The metadata prefix to remove when
                  RemoveMetadataPrefix=on.
OutputFolder=<directory>
The directory to write the CAD files when
                    OverWriteRepresentation=off.
If not specified the start-in directory is used.
OverWriteRepresentation=<value>
off - Do not overwrite representations and write to
                    OutputFolder instead.  The new representation files are
                  updated on the corresponding parts for parmeter updates.
on - Overwrite the original representation files (default)
RemoveMetadataPrefix=<value>
off - Do not remove any metadata prefixes (default)
on - Remove the metadata prefix specified by
                    MetadataPrefixFilter.
UpdateColorFrom=<value>
The color of the CAD entities are updated based on the color coming from the
                  component, part or metadata (UpdateMetaDataAsColor must then be
                  specified). Default is to not update colors.
UpdateMetaDataAsColor=<value>
The metadata to use for updating the color when
                    UpdateColorFrom=metadata.
UpdateMetaDataAsName=<value>
The metadata to use for updating the name when
                    UpdateNameFrom=metadata.
UpdateNameFrom=<value>
The name of the CAD entities are updated based on the name coming from the
                  component, part or metadata (UpdateMetaDataAsName must then be
                  specified).  Default is to not update names.



","Example
To update parameters 1-3, overwriting the original representations:
*createmark parameters 1 1-3
*geomupdate parameters 1 
To update parameters 1-3, writing new representations to C:\my_reps:
*createmark parameters 1 1-3
*geomupdate parameters 1 OverWriteRepresentation=1 OutputDirectory=C:/my_reps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
336,*geomvectorupdate,"Description
This command updates input vectors in such a way that vector direction coincides with line
        tangent or surface normal at closest to the node point on geometry.
","Inputs

vector_mark_id
The mark of input vectors to update.
geom_type
The input geometry type. Valid values are:
lines - If specified, then tangent at selected line is used for updated vector
                direction. 
surfs - If specified, then normal at selected surface is used for updated vector
                direction.


geom_mark_id
The mark of input lines or surfaces used to set vectors direction.
node_tol
If positive, then used as proximity tolerance for geometry points. This means that
            vector is not updated unless closest point of selected geometry is found within the
            distance specified by node_tol. 
If node_tol value is negative, then allowed distance to closest
            point is not limited.
magnitude
Parameter that specifies the length of updated vector (except for the case when
            parameter parlen is not zero).
parlen
Parameter that specifies the method to calculate resulted vector length. Valid values are:
0 - The value specified by magnitude parameter used. 
1 - Parametric value is used. For curve tangent this is the value of parametric
                curve derivative. For surface normal the value is defined by the length of cross
                product of surface parametric derivatives. Parameterization of curves and surfaces
                is normalized from 0 to 1.


reverse
Parameter that specifies direction of resulted vector. Valid values are:
0 - Direction coincides with parametric direction of curve or surface normal. 
1 - Direction is opposite to parametric direction of curve of surface
                normal.


update_geom
A flag (0 or 1) to update vectors direction. If set to 1, then input geometry is used
            to update vectors direction.
update_mag
A flag (0 or 1) to update vectors magnitude. If set to 1, then vectors magnitude is
            updated. 
The flag is ignored, if update_geom flag is set.
update_reverse
A flag (0 or 1) to update vectors magnitude. If set to 1, then vectors magnitude is
            updated. 
The flag is ignored, if update_geom flag is set.

","Example
To update vector 10 to have direction tangent to curve with ID 4 at point closest to vector
        base
        node:*createmark lines 1 4
*createmark vectors 1 10
*geomvectorupdate 1 lines 1 -1.0 1.0 0 0 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
337,*getnodesinsidedomaintomark,"Description
 Places the displayed nodes inside an element to the specified mark.
","Inputs

nodes_mark
The mark to which the nodes must be placed. Must be 1 or 2.
element_id
The element ID within which the nodes are to be found. Can only be a 2D or 3D
            element.
tolerance
Out-of-plane tolerance value, which should be between 0 and 1. 
For more information, see 1.
calcminlen
A flag to indicate if the calculation of minimum length should be exact. Can be either
            0 or 1. 
For more information, see 2.

","Example
To find the nodes inside an element of ID 101 and place them in an entity
          set:*createmark nodes 1 
*getnodesinsidedomaintomark 1 101 0.001 0
eval *createentity sets name=set1 ids=\{nodes [hm_getmark nodes 1]\}Note: The
          first command above (*createmark) clears all the nodes from the
          specified mark.

This is an example of the usage of the command in Tcl. The following
        code finds nodes inside each and every displayed hexa8 element in a model and then creates
        an entity set containing all those
        nodes.*createmark elements 1 displayed
*createmark nodes 1
set elemlist [hm_getmark elems 1]
foreach elem $elemlist {
    set config [hm_getvalue elements id=$elem dataname=config]
    if { $config == 208 } {
        *getnodesinsidedomaintomark 1 $elem 0.001 0
    }
}
eval *createentity sets name=PenetrationNodes ids=\{nodes [hm_getmark nodes 1]\}
For 2D elements, the tolerance value helps in capturing nodes that are close to, but lie
        outside the plane of the element. In the case of 3D elements, this value is applied in turn
        to each face of the element to capture out-of-plane nodes. Note: In these types of
          situations, you may either have to adjust the tolerance values to get the desired nodes,
          or manually add/remove nodes, as necessary.

The calcminlen flag is used to determine if there
            are nodes very close to the edge of a solid element, and almost collinear to it. In most
            cases, setting this value to 0 should be adequate. Setting the value to 1 slows down the
            execution of the command. 
If this command is used while working on a large model, or if this
            command is being called repeatedly in a macro, it is highly recommended to turn off the
            display of portions of the model that are known to be completely outside of the domain
            (element) where the nodes are needed. Since this command works on the displayed nodes
            and elements of the model, the speed of the command is greatly increased.


",
338,*getunmeshedsurfstomark,"Description
Places displayed, unmeshed surfaces on the specified mark. This uses only basic logic to
        find surfaces that do not have associated nodes.
","Inputs

mark_id
The mark ID that should contain the unmeshed surfaces on output. Valid values are 1 and 2.

","Example
To find all unmeshed surfaces:*getunmeshedsurfstomark 1
",
339,*graphimport_file,"Description
Imports a mesh stored in HDF5 into the graphics.
","
Inputs



filename

The full path and filename of the HDF5 mesh file.

","Examples
To impor the C:\temp\mesh.hmg file:
*graphimport_file ""C:/temp/mesh.hmg"" 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
340,*graphicsfilecolor,"Description
Sets the graphics file image color mode.
","Inputs

mode
Graphics file image color mode.
0 - Grayscale image. 
non-zero - Color image.



","Examples
To capture the modeling window to a JPEG image named
          C:/my_images/model.jpg using
        color:*graphicsfilecolor 1
*jpegfilenamed ""C:/my_images/model.jpg""
To capture the modeling window to a JPEG image named
          C:/my_images/model.jpg using
        grayscale:*graphicsfilecolor 0
*jpegfilenamed ""C:/my_images/model.jpg""
",
341,*graphuserwindow_to_XYZ,"Description
Re-centers the display on a specified point, using a specified number of animation steps to
        do so. This command differs from *graphuserwindow_byXYZandR() in that the
        re-center action is not instantaneous; the user’s view pans to the selected point at a
        specified rate, providing a sense of relative location between the original viewpoint and
        the new one.
","Inputs

x
The x coordinate of the specified point.
y
The y coordinate of the specified point.
z
The z coordinate of the specified point.
n
The number of frames of animation to use when panning from the original view point
            location to the new one.

","Example
To re-center the view on a point with coordinates (20, 15.3, and 72) and show 30 steps of
        the movement involved:*graphuserwindow_to_XYZ(20,15.3,72,30)
",
342,*groupchangetype,"Description
Changes the config and type of an existing group.
","Inputs

name
The name of the group to change.
config
The new config value for the group.
type
The new type value for the group.

",,
343,*groupdeleteunused,"Description
Deletes unused groups.
","Inputs

 f_displayed
Searches groups contained unused elements.
0 - Searches all groups. 
1 - Searches only displayed groups.



","Example
Delete the elements highlighted by:*grouppreviewunused()
",
344,*hf_Addendum_PrepareLatitudeLine,"Description
This command finds all of the model’s latitude lines to drag and organize them into the
        ^latitude_lines_drag component.
","Inputs

int_flag
Dummy integer value. Should always be set to 0.

","Example
To see all the model’s latitude lines that you can
        drag:*hf_Addendum_PrepareLatitudeLine 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
345,*hf_AddSectionHandle,"Description
This command adds a handle on a section. The position of the handle is given by
          (x_coord, y_coord, z_coord) and
        by the screen normal (dx_coord, dy_coord,
          dz_coord).
","Inputs

x_coord 
x-coordinate of the new handle.
y_coord 
y-coordinate of the new handle.
z_coord 
z-coordinate of the new handle.
dx_coord 
x-coordinate of the screen normal.
dy_coord 
y-coordinate of the screen normal.
dz_coord 
z-coordinate of the screen normal.

","Example
To add the handle on the section in the position (7214.46,-2031.49418
        1206.14793):*hf_AddSectionHandle 7214.46,-2031.49418 1206.14793 0.0733097235 -0.978155151 -0.194520399
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
346,*hf_ClearFromWorkingSection,"Description
This command clears the model of the working section and handles, used to edit the
        binder.
","Inputs

int_flag
Dummy flag. Must be set to 0.

","Example
To clean the model from the working
        section:*hf_ClearFromWorkingSection 0
",
347,*hf_Create_DieCadSys,"Description
This command creates a system from the CAD system stored in the database.
","Inputs

reserved
Reserved for future use. Must be set to 0.

","Example
To create a system from the CAD system stored in the
        database:*hf_Create_DieCadSys 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
348,*hf_createdoubleattachedparams,"Description
This command creates the base point for the symmetry plane, the n1/n2 node of the given
        line and the part of this line between n1/n2 needed for the double attached feature.
","Inputs

line_mark
The mark ID containing the single input line. Valid values are 1 and 2.
nodes_mark
The mark ID containing the input nodes. Valid values are 1 and 2. The node mark must contain 0, 1 or 2 nodes. If it contains 0 or 1
            node it will create n1/n2 from line. If it contains 2 nodes it will try to use them, but
            if they are not properly chosen, it will create n1/n2 from line.
gap
The minimum distance between the original and reflected part.
x_sym
The x-coordinate of the symmetry direction.
y_sym
The y-coordinate of the symmetry direction.
z_sym
The z-coordinate of the symmetry direction.
x_draw
The x-coordinate of the stamping direction.
y_draw
The y-coordinate of the stamping direction.
z_draw
The z-coordinate of the stamping direction.
creation_flag
0 - Create base point.
1 - Create n1/n2 and the line between.

","Example
To get the base point from line 1 and nodes 100 and 101, using a gap of 0.5, a symmetry of
        1, 0,  0, and a draw direction of 0, 1,
        0:*createmark lines 1 1
*createmark nodes 1 100 101
*hf_createdoubleattachedparams 1 1 0.5 1 0 0 0 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
349,*hf_DeleteSectionHandle,"Description
This command deletes a handle of a section. The section is automatically identified.
","Inputs

handle_id
The handle ID to delete.

","Example
To delete the handle with ID 12:*hf_DeleteSectionHandle 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
350,*hf_EditPol,"Description
This command opens the Section Editor and loads the POL profile into the 2D editor.
","Inputs

reserved
Reserved for future use. Must be set to 0.

","Example
To edit the POL profile:*hf_EditPol 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
351,*hf_FillDoubleAttachedPart,"Description
This command reflects the current die part, duplicating elements and surfaces, and fills
        the gap in between, creating the surface and the mesh in the die part component.
","Inputs

creation_flag
1 - Triangular mesh method.
2 - Ruled surface method.
x_coord
The reflection direction x-coordinate.
Y_coord
The reflection direction y-coordinate.
Z_coord
The reflection direction z-coordinate.
gap
The minimum distance between the original and reflected parts.
n1
The node ID of the first node on the part profile of the area to enclose.
n2
The node ID of the second node on the part profile of the area to enclose.

","Example
To create the double attached part using the ruled surface method, a symmetry plane of 1.,
        0., 0., a gap of 5.7 and nodes 23 and 34 on the part
        profile:*hf_FillDoubleAttachedPart 2 1 0 0 5.7 23 34
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
352,*hf_RejectDragDeleteHandle,"Description
This command rejects the edit binder drag operation.
","Inputs

int_flag
0 - Reject the drag or delete handle.
1 - Reject the binder update after drag handle.

","Examples
To reject the drag or delete handle:*hf_RejectDragDeleteHandle 0
To reject the update binder after
        drag:*hf_RejectDragDeleteHandle 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
353,*hf_RotateBinderSurf,"Description
This command rotates the binder around an axis. The axis of rotation is given by the
        plane/vector plane and the magnitude of rotation is given by.
","Inputs

plane
The temporary plane/vector ID created using the *createplane
            command.
angle
Angle of rotation.

","Examples
To rotate the binder around the x-axis with respect to the base point (7258.2607,
        -1324.2481, 1468.3770) by an angle of 90
        degrees:*createplane 1 1.0000 0.0000 0.0000 7258.2607 -1324.2481 1468.3770
*hf_RotateBinderSurf 1 90
To rotate the binder around y-axis with respect to the base point (7258.2607, -1324.2481,
        1468.3770) by an angle of -90
        degrees:*createplane 1 0.0000 1.0000 0.0000 7258.2607 -1324.2481 1468.3770
*hf_RotateBinderSurf 1 -90
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
354,*hf_setdieline,"Description
This command sets the selected lines as TL or POL.
","Inputs

entity_type
Must be set to lines.
mark_id
The mark ID containing the lines of interest. Valid values are 1 and 2.
flag
0 - Set as TL. 
1 - Set as POL.

","Example
To set line 15 as
        POL:*createmark lines 1 15
*hf_setdieline lines 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
355,*hf_setdiesymmetry,"Description
This command sets the symmetry plane for the die module.
","Inputs

normal_x
x-coordinate of the plane normal.
normal_y
y-coordinate of the plane normal.
normal_z
z-coordinate of the plane normal.
origin_x
x-coordinate of the plane origin.
origin_y
y-coordinate of the plane origin.
origin_z
z-coordinate of the plane origin.
shape_flag
A flag that identifies the following cases: 
0 - Half model 
1 - Full model that does not contain a symmetry plane 
2 - Full model that contains a symmetry plane 
3 - Symmetric model for double attached part feature
node_1
First node ID that identifies the portion of the part that is used by the double
            attached part feature.
node_2
Second node ID that identifies the portion of the part that is used by the double
            attached part feature.

","Example
To set the symmetry plane z=0 for the die module:
*hf_setdiesymmetry 0. 0. 1. 0. 0. 0. 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
356,*hf_setpartcomponent,"Description
This command sets the specified component like the die module main part.
","Inputs

entity_type
The entity type. Must be set to comps.
mark id
The mark ID containing the component. Valid values are 1 and 2.

","Example
To set component ID 22 like the die module main
        part:*createmark comps 1 22
*hf_setpartcomponent comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
357,*hf_setTLPOL,"Description
This command moves the specified line to the specified component and sets it as TL or
        POL.
","Inputs

suffix
The component suffix.
color 
The component color. Valid values are 1 through 64.
line_id
The ID of the line of interest.
flag_TL
Flag that indicates whether to set the line as TL. Valid values are:
0 - Do not set as TL. 
1 - Set as TL.


flag_POL
Flag that indicates whether to set the line as POL. Valid values are:
0 - Do not set as POL. 
1 - Set as POL.



","Example
To set line 22 like a TL into a component with suffix
        ""TL"":*hf_setTLPOL ""TL"" 7 22 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
358,*hf_TranslateBinderSurf,"Description
This command translates the binder along an axis. The direction of translation is given by
        the plane/vector plane and the magnitude of translation is given by
          distance.
","Inputs

plane
The temporary plane/vector ID created using the *createplane
            command.
distance
Translation distance.

","Examples
To translate the binder along the z-axis with magnitude
        50:*createplane 1 0.0000 0.0000 1.0000 0.0000 0.0000 0.0000
*hf_TranslateBinderSurf 1 50
To translate the binder along the x-axis with magnitude
        -50:*createplane 1 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000
*hf_TranslateBinderSurf 1 -50
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
359,*hf_TrimBinderOrAddendumWithAddDbeadDbar,"Description
Trims the current die module binder or addendum with the current addendum drawbar/bead FL. 
If an input is not specified, the binder and FL are recognized automatically and trims the
        current die module binder with the current addendum FL. If the surface mark is empty, it
        trims the current die module binder with the line contained into the line mark (trim binder
        with drawbar/bead). 
If the surface mark is full, it trims the addendum surface contained in the mark with the
        line contained into the line mark (trim addendum with drawbar).
","Inputs

entity_type_surf
Must be set to surfs
mark_id_surf
The mark ID containing the surfaces. Valid values are 1 and 2.
entity_type_line
Must be set to lines.
mark_id_line
The mark ID containing the lines. Valid values are 1 and 2.

","Example
To trim the current die module binder with the current addendum
        FL:*createmark lines 1
*createmark surfaces 1
*hf_TrimBinderOrAddendumWithAddDbeadDbar surfaces 1 lines 1
To trim addendum surface 33 with the drawbar FL
        11:*createmark lines 1 11
*createmark surfaces 1 33
*hf_TrimBinderOrAddendumWithAddDbeadDbar surfaces 1 lines 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
360,*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,"Description
This command trims surfaces with lines and deletes the part of the surfaces enclosed by the
        lines.
","Inputs

entity_type1
Must be set to surfaces.
mark_id1
The mark ID containing the surfaces to trim. Valid values are 1 and 2.
entity_type2
Must be set to lines.
mark_id2
The mark ID containing the lines to use as the trimmer. Valid values are 1 and 2. The lines must form a closed loop.

","Example
To trim surface 16 with the closed lines with ID's 2, 3, and 4, and to delete the part of
        the surface enclosed by the
        lines:*createmark surface 1 16
*createmark lines 1 2 3 4
*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 surfaces 1 lines 1
",
361,*hideall ,"Description
Turns off the display of all entities.
","Example
To turn off the display of all entities:
*hideall
","Errors
None.
",
362,*hideentitybymark ,"Description
 Turns off the display of a mark of entities.
","Inputs

mark_id
The ID of the mark containing the entities. Valid values are 1 and 2. All entities with a display state on the specified mark,
            regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To hide geometry and elements for components 1-3:
*createmark comps 1 1-3
*hideentitybymark 1
To hide all comps and load collectors, considering only elements:
*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*hideentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
363,*hm_auto_elem_cleanup_new,"Description
Attempts to automatically improve the quality of failed elements using node movements
        and/or local remeshing, along with optional tria reduction.
","Inputs

elem_mark_id
The ID of the mark containing the elements to correct.  Valid values are 1 and 2.
node_mark_id
The ID of the mark containing any anchor nodes to preserve during cleanup.  Valid
            values are 1 and 2.
feature_angle
The angle used to define features.  Valid values are 0-360, and 30 is a common
            value.
criteria_file
The path to the criteria file. If the criteria are set using
              *setqualitycriteria, ""dummy"" can be used as the criteria file
            name.
string_array
The string array ID that contains the list of entity types. A value of ALL means all
            entity types.  The string array is created using the
              *createstringarray command. This should always be set to 1.  Valid
            strings include:


ConsiderFailedElems failed adjacent layersThis defines the
                  elements affected by the cleanup. This string contains three values in fixed
                  sequence as:

failed0 - Consider all elements
1 - Consider only
                      failed elements

adjacentUsed when failed is
                      1.
0 - Do not consider adjacent elements to failed elements
1 -
                      Consider adjacent elements to failed elements

layersUsed when adjacent is
                      1.
The number of adjacent layers to consider.







FixFailedElements modeIndicates whether to use the QI-based
                  re-meshing to cleanup elements.

mode0 - Do not perform re-meshing
1 - Perform
                      re-meshing







FixWarpageByNodeMove mode toleranceThis defines the tria
                  reduction options:

mode0 - Do not fix warped elements by normal node
                      movement
1 - Fix warped elements by normal node movement

toleranceUsed when mode is
                      1.
The maximum value a node is allowed to move normally to fix the
                      warpage.







KeepNonShellConnected modeIndicates whether to maintain
                  connectivity between 2D element edges shared with 1D and 3D elements during
                  cleanup.

mode0 - Do not maintain connectivity.  Elements may
                      become disconnected after cleanup.
1 - Maintain connectivity







PreserveFeatures mark_idAny 1D plot elements to keep as
                  features during cleanup.

mark_idThe ID of the mark containing the 1D plot
                      elements.  Valid values are 1 and 2.







QISmooth mode target move_shared move_shared_tol move_free
                  move_free_tolOptions defining how to smooth nodes to correct the
                  quality.

mode0 - Do not optimize quality
1 - Optimize
                      quality

targetThe QI target value to attempt to
                    achieve.

move_shared0 - Move nodes along shared edges
                      only
1 - Move nodes along and across shared edges

move_shared_tolThe maximum amount a node is allowed to
                      move across a shared edge when move_shared is 1.

move_free0 - Move nodes along free edges only
1 -
                      Move nodes along and across free edges

move_free_tolThe maximum amount a node is allowed to
                      move across a free edge when move_free is 1.







ReduceTriaElements reduce_trias keep_edgesThis defines the
                  tria reduction options:

reduce_trias0 - Do not perform tria reduction
1 -
                      Perform tria reduction

keep_edgesUsed when reduce_trias is
                      1.
0 - Do not preserve edges
1 - Preserve edges







RemoveInverseElements mode angleIndicates whether to split
                  warped/split quads.

mode0 - Do not remove
1 - Remove

angleThe inversion angle to consider.







SplitWarpedSkewedQuads modeIndicates whether to split
                  warped/split quads.

mode0 - Do not split
1 - Split





number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
Auto correct all elements, using anchor node 50, defining the criteria via a file, no
        preserved features, considering 7 adjacent layers, using remeshing and tria reduction:
*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elements 1 all
*createmark nodes 2 50
*createstringarray 9 ""PreserveFeatures: 0"" ""ConsiderFailedElems: 1 1 7"" ""RemoveInverseElements: 1 150"" ""ReduceTriaElements: 1 1"" ""FixFailedElements: 1"" ""QISmooth: 1 0.2 0 0 0 0"" ""KeepNonShellConnected: 0"" ""SplitWarpedSkewedQuads: 1"" ""FixWarpageByNodeMove: 0 0""
*hm_auto_elem_cleanup_new 1 2 15 ""dummy"" 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
364,*hm_failed_elements_cleanup ,"Description
Cleans up the mesh by eliminating reversed and small sized elements. May create new
        elements instead of reversed. 
","Inputs

markmask
Elements of the original mesh.
Elem_type
Determines the type of new elements: 
0 - trias 
1 - mixed type (quads and trias)
min_elemsize
Determines minimum element size of elements in the mesh after cleanup.
max_feature_angle
Determines mesh feature angle for keeping features when possible after cleanup.
max_reverse_angle
Determines maximum angle between adjacent element normals for reversed elements
            detection.

","Example
To eliminate elements in the displayed tria mesh with size less than 1.5, remove reversed
        elements with adjacent normals greater than 150 degrees, trying to keep features greater
        than 60 degrees:
*createmark(elements,1) displayed
*hm_failed_elements_cleanup(1, 0, 1.5, 60, 150)
The *createmark() command is required.
","Errors
None.
"
365,*hm_meshutils_cutelements_8points,"Description
Cut elements with a general box defined by 8 points.
","Inputs

element_mark
The mark of the elements that needs to be cut.
cNx, cNy, cNz
The coordinates of the point N.
spc_collector_name
The name of the collector in which the spcs will be created for constraining cut
            elements. 
No entities will be created if the name is an empty string.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox. 
No entities will be created if the name is an empty string.

","Example
Only linear shell elements will be properly cut. For any other type of element, it will
        simply be deleted if it is completely or partially inside the cut box. 
","Errors
None.
"
366,*hm_meshutils_cutjoints,"Description
Cuts elements of a joint section orthogonal to the cross-sections for joint stiffness
        studies.
","Inputs

element_mark
The mark of the elements that needs to be cut.
center_x, center_y, center_z
The coordinates of the joint center.
extent_DIR_n
The extent of the joint section to be cut in the negative DIR axis direction.
extent_DIR_p
The extent of the joint section to be cut in the positive DIR axis direction.
rigid_collector_name
The name of the collector in which the rigid link elements will be created. Moments
            can be applied to the center node of the rigid element for performing joint stiffness
            studies. No entities will be created if the name is an empty string.
spc_collector_name
The name of the collector in which the spcs will be created for constraining joint
            cross sections. 
An spc will also be created at the center node of the rigid elements described above,
            and will go into a collector named spc_collector_name_N (where N is an
            arbitrary number). You can include/exclude these spc collectors in multiple subcases to
            perform joint stiffness studies. 
No entities will be created if the name is an empty string.
constrain
If constrain is specified as nonzero, then nodes on the joint section periphery that
            do not form a proper cross-section are constrained with spcs created in
              spc_collector_name.

","Example
Only linear shell elements will be properly cut. For any other type of element, it will
        simply be deleted if it is completely or partially inside the cut box. 
","Errors
None.
"
367,*hm_trim_elements_with_two_point_box ,"Description
Trims shell elements using a box defined by two diagonal points. Shell elements inside the
        box are kept with the elements along any cuts re-meshed. Solid elements with all nodes
        inside the box are kept, while all others are deleted.
","Inputs

mark_id
The ID of the mark containing the elements to cut. Valid values are 1 and 2.
x1 y1 z1
The coordinates of the first corner point.
x2 y2 z2
The coordinates of the second corner point.
spc_collector_name
The name of the collector in which the SPCs will be created for constraining cut
            elements.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox.
remesh_params
The parameters of re-meshing along the cut, defined as ""keyword value"" format. 
For example: ""angle 30.0 min_elem_size_rate 0.6 comp_remainder_area_rate 1.0"" 
Valid keywords and values are:
angle
Values used to define feature edges on mesh. Default if not specified is
                  30.0.
min_elem_size_rate
Defines the minimum element size locally. The valid range is between 0.0 and
                  1.0. The minimum element size is calculated locally on the mesh area being
                  re-meshed. The element size is computed for the mesh area and the minimum element
                  size is then the product of min_elem_size_rate and the element
                  size of the area. 
min_elem_size_value
Defines the minimum element size globally.
comp_remainder_elem_numb
Defines the minimum number of elements in a component. After box trimming, any
                  component with an element count less than this value is deleted.
comp_remainder_area_rate
Define the limit of shell element area of components. After box trimming, any
                  component with element areas less than this percent of its original area is
                  deleted. The valid range of the value is between 0.0 and 100.0. 



","Example
 To trim displayed elements using a box with corner points (0,0,0) and (100,100,100):
*createmark elements 1 ""displayed""
*hm_trim_elements_with_two_point_box 1 0.0 0.0 0.0 100.0 100.0 100.0 ""abc"" ""efg"" ""min_elem_size_rate 0.6 comp_remainder_elem_rate 0.01 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
368,*hmmeshlinedrag ,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *linedrag...toformsurface commands. 
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
To drag the given nodes along lines 2 and 1, trimmed by nodes 29 and 30, and using the
        given plane, create 45 elements: 
*surfacemode 3
*createlist nodes 1 5 9 1 15 18 39
*createlist lines 2 2 1
*createlist nodes 2 29 30
*createplane 1 0.0000 0.0000 1.0000 0.0000 0.0000 100.0000
*linedragnodestoformsurface 1 2 2 1
*set_meshedgeparams 0 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 9.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 9.0 0 0 0 0 0 0 0
*hmmeshlinedrag 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
369,*hmmeshspin,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *spin...toformsurface commands. 
","Inputs

quads
If nonzero, specifies that the created elements should be quads. 

","Example
This example spins line 4 forty-five degrees about the given axis to identify a region
        approximating a surface of revolution, and without actually making a surface, creates 150
        elements (15 on the line and 10 on the spin). 
*surfacemode 3
*createlist lines 1 4
*createplane 1 0.6757 0.0 0.0 860.0 0.0 332.0
*surfacecreatespinlinewithoffsetangle 1 1 0 45 0
*set_meshedgeparams 0 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshspin 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
370,*hmmeshsurfacecone,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *surfacecone... commands.
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
This example identifies a cylindrical region of radius 100 and height 200, and then has the
        automesher create 300 elements on it, with a density of 10 up the side and 30 around the
        circumference: 
*surfacemode 3
*surfaceconefull 180 86 100.0000 100.0000 1.0000 200.0000
*set_meshedgeparams 0 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 30.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 30.0 0 0 0 0 0 0 0
*hmmeshsurfacecone 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
371,*hmmeshsurfacesphere ,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *surfacesphere... commands.
","Inputs

quads 
If nonzero, specifies that the created elements should be quads.

","Example
This example identifies a spherical region passing through the given four nodes, and,
        without actually building a surface, creates 150 elements with a density of 15 along a
        longitude and 10 around the equator: 
*surfacemode 3
*createlist nodes 1 159 141 178 228
*surfacespherefromfournodes 1
*set_meshedgeparams 0 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshsurfacesphere 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
372,*hmplygeomsmoothing,"Description
This command allows you to create smoothed geometry contour lines and surfaces for ply
        entities, with various options.
","Inputs

mark_id
The ID of the mark containing the plies for smoothing. Valid values are 1 and 2.
num_iters
The number of smoothing iterations to be run ≥ 0.
small_tol
Threshold value to identify local and small ply regions for elimination. The value
            depends on the small region type (see mode below). 
0 (area ratio) - Value indicates the area ratio (calculated by local region area /
            total design area, ≥ 
0.0 and < 1.0). 
1 (elem count) - Value indicates the number of elements (≥ 0, default = 15).
create_line
0 - Do not create contour lines for plies 
1 - Create contour lines for plies
create_surface
0 - Do not create geometric surfaces for plies 
1 - Create geometric surfaces for plies
mode
Specifies modes for small ply region elimination, as well as creating the lines and
            surfaces. Bit values are used and the value is calculated as (Bit0 + 2*Bit1 +
              4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Detect small ply coverage regions by area ratio (local region area/ total
                  design area) 
1 - Detect small ply coverage regions by number of elements
Bit1
0 - Do not split disconnected ply regions into separate new ply entities 
1 - Split disconnected ply regions into separate new ply entities
Bit2
0 - Do not update ply element sets 
1 - Update ply element sets
Bit3
 0 - Create geometry entities in original component 
1 - Create geometry entities in separate components for different plies
Bit4
0 - Do not populate plies with geometry entities 
1 - Populate plies with geometry entities



","Example
To create smoothed geometry lines and surfaces in separate components, with 5 iterations of
        smoothing, eliminating small ply regions with area less than 0.05 of the total design, and
        finally populate the ply with the geometry entities.
*createmark plies 1 all
*hmplygeomsmoothing 1 5 0.05 1 1 28
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
373,*hmshrinkwrap ,"Description
The shrink wrap function allows a complex FE model to be simplified quickly into an
        approximation of the original FE representation. The capability works by removing and
        blending out features of the original part to remove complexity.
","Inputs

entity_type
Supported types are comps and elems.
entity_markId
Mark of input components or elements.
elems_markId
Mark of feature elements. Should be different from entity_markId. Considered for tight
            wrap only.
wrap_type
1 = Loose wrap mesh. 
2 = Tight wrap mesh.
elem_size
Element size for shrink wrap meshing.
warpage_value
Warpage value, above which the shrink wrap elements will be split. Enabled for tight
            wrap mesh only. 
-1 value will ignore splitting of elements in tight wrap mode. 

","Example
To loose wrap displayed elements with an element size of 2:
*createmark elems 1 ""displayed""
*createmark elems 2 
*hmshrinkwrap elems 1 2 1 2 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
374,*hwCfdSceneReverseAll,"Description
This command is used to reverse the display of a mark of entities of a given entity
        type.
This should be used in conjunction with the
          *hwCfdSceneShowHideIsolateEntity and
          *hwCfdSceneShowAll commands.
This command is valid only for the CFD profile.
","
Inputs



entity_type

The type of entity to modify. Valid values are modules, regions, surfaces and
            solids.

consider_geom

0 - Do not consider the associated geometry
1 - Consider the associated geometry (default)

consider_elems

0 - Do not consider the associated elements
1 - Consider the associated elements (default)

","Examples
To hide surfaces 1-10, reverse the display, then show all entities:
*createmark surfaces 1 1-10
*hwCfdSceneShowHideIsolateEntity hide surfaces 1 1 1 1
*hwCfdSceneReverseAll surfaces 1 1
*hwCfdSceneShowAll 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
375,*hwCfdSceneShowHideIsolateEntity,"Description
This command is used to manage the display of a mark of entities with an additional ability
        to show/hide the surfaces attached to the solid.
This should be used in conjunction with the *hwCfdSceneReverseAll and
          *hwCfdSceneShowAll commands.
This command is valid only for the CFD profile.
","
Inputs



function

The string defining the operation to be performed on the mark of supported entities.
            Valid values are:
hide - Turn off the display of the entities on mark. If the selection filter is solid,
            the hidden surfaces are shown in transparent mode.
isolate - Turn off the display of all the entities and only turn on the display of the
            entities on mark.
reverse - Turn off all display of the entities on mark and turn on the display of
            hidden entities of the same entity type.
show - Turn on the display of the entities on mark.

entity_type

The type of entity to modify. Valid values are modules, regions, surfaces and
            solids.

consider_geom

0 - Do not consider the associated geometry
1 - Consider the associated geometry (default)

consider_elems

0 - Do not consider the associated elements
1 - Consider the associated elements (default)

unhighlight

0 - Do not remove highlighting
1 - Remove highlighting (default)

","Examples
To hide surfaces 1-10, reverse the display, then show all entities:
*createmark surfaces 1 1-10
*hwCfdSceneShowHideIsolateEntity hide surfaces 1 1 1 1
*hwCfdSceneReverseAll surfaces 1 1
*hwCfdSceneShowAll 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
376,*hwct_addselectedrepsfromlibrary,"Description
Adds specific representations from a connected library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
string_array
The ID of the input string array created using *createstringarray.
            Must be set to 1.  This string must contain 3 quoted values for each representation
            prototype:  ""<proto unique ID>"" ""<proto library ID>"" ""<space separated list of
            rep library IDs>"". 
number_of_strings
The number of strings in the string array.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Valid parameters are:
load=<value>
0 - Do not load the rep alias for the subsystem
1 - Load the rep alias for the subsystem
overwrite=<value>
0 - Do not overwrite the session information
1 - Overwrite the session information
repfolder=<value>
The folder in which the representation exists.



","Examples
Load a single representation from C:/temp/subsystems:
*createstringarray 3 ""Epsilon_A_000261"" ""2ba9bfe48108c345a41efd04a39ce3b7:3"" ""cb912ce6142b314399298d61f5f63917:2"" 
*hwct_addselectedrepsfromlibrary subsystems 1 3 ""overwrite=1, repfolder=c:/temp/subsystems""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
377,*hwct_deleterepsfromlibrary,"Description
Deletes representations from a connected library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Valid parameters are:
comment=<value>
The comment to add for the action.



","Examples
Delete crash representation for subsystem 2 from the library:
*createmark subsystems 1 2
*hwct_deleterepsfromlibrary subsystems 1 crash ""removedcrash""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
378,*hwct_savetolibrary,"Description
Saves representations to a connected library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
rep_alias_list
The list of representation alias names to save.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Valid parameters are:
comment=<value>
The comment to add for the action.
overwrite=<value>
0 - Do not overwrite the library information
1 - Overwrite the library information



","Examples
Save crash and nvh representations for subsystem 2 with overwrite option:
*createmark subsystems 1 2
*hwct_savetolibrary subsystems 1 ""crash;nvh"" ""overwrite=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
379,*icelementcreate ,"Description
Creates an IC element. *addicconnectivity and
          *modifyicelement can be used to add additional details or modify the
        element.
","Example
Create an IC element and update the independent node to 15, and dependent nodes to 16, 17,
        18, 19 with DOF’s 123, 345, 1234, 123456:
*icelementcreate
*createintarray2d 2 4 16 17 18 19 123 345 1234 123456
*addicconnectivity 1 15 1 2 4
","Errors
None.
",
380,*importbom,"Description
Imports a UDMXML BOM file into a given part.
<option>=<value> options must be enclosed in quotes, but can be
        provided in any order.
","Inputs

file_name
The name and path of the file to read.

importoption=<value>

The import option as child, replace or merge.

overwriteattribs=<value>

Valid when importoption=merge.
0 - Do not overwrite attributes.
1 - Overwrite attributes.

subsystem=<value>

0 - Do not import subsystem structure.
1 - Import subsystem structure.

target_part_hmid=<value>

The HyperMesh part ID to be used as root for importing
            when importoption=child.
If not specified, part_udmid is used.

target_part_udmid=<value>

If target_part_hmid is not provided, this is the UDMID of the
              HyperMesh part to be used as root for importing when
              importoption=child.

","Example
Import UDMXML BOM under UDM part ID $udmid from file c:/temp/exportedbom.xml:
*importbom c:/temp/exportedbom.xml ""importoption=child overwriteattribs=1 target_part_udmid=$udmid"";
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
381,*imprint_geom,"Description
Imprints, connects source points, nodes, lines and surfaces onto target FE surfaces. This
        command does not support surfaces that are not FE. Points and lines could be any type. In
        the case that input is an FE entity, the command optionally remeshes the input entities.
","
Inputs



entity_type_target

The type of entity to use as the target (destination) for the imprint. Valid values
            are surfaces.

mark_id_target

The ID of the mark containing the target (destination) entities to imprint. Valid
            values are 1 and 2.

entity_type_source

The type of entity to use as the source for the imprint. Valid values are points,
            nodes, lines, surfaces.

mark_id_source

The ID of the mark containing the source entities to imprint. Valid values are 1 and
            2.
options
List of input options, passed as a space separated string enclosed in quotes. Valid
            options are:
angle <value>
The angle used to define feature edges on the mesh. If not defined, 25.0 is
                  used.
max_distance <value>
The command will exit with an error if the distance between source and
                  destination exceeds this value. If not specified, this is ignored.
mesh_size <value>
Automatically detected from input mesh if not provided.
mesh_type <value>
Automatically detected from input mesh if not provided.
0 - tria
1 - quad
2 - mixed
3 - R-tria
4 - quad only
projection_vector <x y z>
3 doubles defining the vector direction. If not defined, normal projection is
                  used.
remain <value>
1 - Source remains, source node coordinates are kept (default if not
                  provided)
2 - Destination remains, node coordinates projected to destination are used
3 - Both remain, source entities are projected and a copy is imprinted to
                  destination
remesh_mode <value>
-1 - No remesh. Element connectivity is maintained by recovery of the imprinting
                  element edges.
0 - Do not remesh destination. Destination mesh is stitched to maintain element
                  connectivity.
1 - Remesh all input destination elements.
2 - Remesh destination elements defined by remesh_layers.
remesh_layers <value>
Must be defined if remesh_mode is 2.
0 - Remesh only the elements attached to the border of the imprinted element
                  image.
> 0 - Remesh additional layers in addition to the elements attached to the
                  imprinted element image.
.
to_dest_component <value>
0 - Do not organize imprinted elements to destination component (default if not
                  provided).
1 - Organize imprinted elements to destination component.



","Examples
To imprint surfaces 20 and 21 onto surface 45, using a normal projection, a feature angle
        of 30, keeping the source, and remeshing the destination using 2 layers:
*createmark surfs 2 20 21
*createmark surfs 1 45 
*imprint_geom surfs 2 surfs 1 ""remain 1 remesh_mode 2 remesh_layers 2 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
382,*include,"Description
Includes a file. 
","Inputs

file 
The name of the file to include.

","Example
*include file commands can be nested and can appear anywhere in the
        file.
","Errors
None.
"
383,*includesuppressoutput ,"Description
This command sets the export/do not export state of all supported entities contained within
        the include file (but not the include file itself) with include_id and
          include_shortname. Only one of these two options need to be specified,
          however include_id will take precedence if specified. Double quotes """"
        must be used for an argument that is not specified. 
The state argument indicates the export/do not export status for the
        supported entities contained in the include. A state of 0 indicates to
        set the entities to ""export"". A state of 1 indicates to set the entities
        to ""do not export"". 
Include files do not have an export/do not export state that is controlled by this command.
        Instead use the command *updateincludedata2.
","Example
To set all supported entities contained within include file ID 5 to ""export"":
*includesuppressoutput 5 """" 0
To set all supported entities contained within include file shortname include.txt to ""do
        not export"":
*includesuppressoutput """" include.txt 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
384,*interactivemeshelems ,"Description
Brings all marked elements into the automeshing module and prepares them for processing,
        enabling the use of all restricted module commands.
","Inputs

markmask
The elements to be meshed. 
elementsize
The default element edge size used to calculate element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created.
1 = yes 
0 = no


break_connect
Determines if connectivity will be broken along shared edges between elements when a
            different element size is chosen. 
1 = yes 
0 = no


Element size along shared edges cannot be changed.
angle
Determines the angle between two edge segments when the vertex is created.

","Example
In this example, the automeshing module processes two separate groups with four and six
        elements each (each group forms a quad with four edges). To generate a mesh for each group,
        the automeshing module sets up values for the element densities and biasing with the
          *set_meshedgeparams command. Automeshing parameters for each group are
        specified with the *set_meshfaceparams command. Prior to meshing,
        parameters for the first group were changed. This required additional setedgeparams calls
        for four edges. Each group of elements is sent to the *automesh command
        so it can determine the appropriate meshing algorithm and create an all-quads mesh. Two
        meshes are then saved to theHyperMesh database. The automeshing
        module clears from its memory any information regarding the current group so that a new
        group can be processed. 
*surfacemode 1
*createmark elements 1 11 12 19 20 79 80 82 84 86 90
*interactivemeshelems 1 10 1 1 1 1 0 30
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0 5 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 2 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
385,*interactiveremeshelems,"Description
Brings all the marked elements into the automeshing module and prepares it for processing,
        enabling the use of all the restricted module commands.  All elements previously attached to
        this mark are deleted.
","Inputs

markmask
The elements to be meshed. 
elementsize
The default element edge size to use for calculating element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created. 
1 = yes 
0 = no


break_connect
Determines if connectivity will be broken along shared edges between elements when a
            different element size is chosen.
1 = yes 
0 = no


Element size along shared edges can not be changed.
angle
Determines angle between two edge segments when vertex is created.

","Example
In this example, the automeshing module processes two separate groups with four and six
        elements each (each group forms a quad with four edges). To generate a mesh for each group,
        the automeshing module sets up values for the element densities and biasing with the
          *set_meshedgeparams command. Automeshing parameters for each group are
        specified with the *set_meshfaceparams command. Prior to meshing,
        parameters for the first group were changed. This required additional setedgeparams calls
        for four edges. Each group of elements is sent to the *automesh command
        so it can determine the appropriate meshing algorithm and create an all-quads mesh. Two
        meshes are then saved to the HyperMesh database. The automeshing
        module clears from its memory any information regarding the current group so that a new
        group can be processed. 
*surfacemode 1
*createmark elements 1 11 12 19 20 79 80 82 84 86 90
*interactiveremeshelems 1 10 1 1 1 1 0 30
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0,5 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 2 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
386,*interfaceadd,"Description
Creates interface elements. 
","Inputs

name
The name of the group into which the interface elements should be placed. 
master
Use 1 for master; 0 for slave. 
type
The entity type of the slave entities (none, elements, nodes). 
mark
The ID of the mark containing the nodes or elements which should have slave or master
            elements placed on them.
reverse
A logical which determines if the slave elements should be reversed when created. 

","Errors
None.
",
387,*intersectmark,"Description
Creates nodes/lines by intersecting 1D/2D elements with a plane. For 1D elements, nodes are
        created at each intersection location. For 2D elements, a series of line segments are
        created at the specified plane that matches the profile of the selected elements that span
        that plane. These segments are then joined together according to the values selected for
          combine_flag, break_angle and smooth. The line
        segments are organized into the current component.
","Inputs

entity_type
The type of entities to intersect. Valid values are elems and comps (only elems in
            comps are considered).
mark_id
The ID of the mark containing the entities to intersect. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the cut. This is defined using the
              *createplane command.
combine_flag
0 - Do not combine generated lines. 
1 - Combine generated lines.
break_angle
The break angle used when combining lines. Ignored if combine_flag
            is 0.
smooth_flag
0 - Do not smooth combined lines. 
1 - Smooth combined lines. Ignored if combine_flag is 0.

","Example
To create intersection lines for the xy-plane with a base node of 0,10,0 with the displayed
        elements:
*createmark elems 1 displayed
*createplane 1 0 0 1 0 10 0
*intersectmark elems 1 1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
388,*isolateelementswithinradius ,"Description
Isolates entities within the radius specified.  Other entities in the model should be
        hidden first.
","Inputs

entity_type
The type of entity to isolate.  Valid values are masses and elements.
mark_id
The ID of the mark containing the entities to isolate.  Valid values are 1 and 2.
radius
The radius of interest from all locations.

","Example
Show elements from all locations of mass1 and mass2 within radius 50.0:
*createmark masses 1 mass1 mass2
*isolateelementswithinradius masses 1 50.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
389,*isolateonlyentity,"Description
Turns on the display of an entity and turns off the display of all others across types.
","Inputs

entity_type
The type of entity to display.
search_type
The method used to specify the entity. The entity is specified using the
              id_name argument. Valid values are: 
""by name"" - Entity is specified using the entity name. 
""by id"" - Entity is specified using the entity ID.
id_name
The ID or name of the entity, depending on search_type.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To isolate only geometry and elements for component with ID 3:
*isolateonlyentity comps ""by id"" 3
 To isolate only elements for component with ID 3:
*createstringarray 2 geometry_off
*isolateonlyentity comps ""by id"" 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
390,*jointelement_fournoded ,"Description
 Creates a four-noded joint element.
","Inputs

type
The type of the element (2,3,4,5 ONLY)
n1,n2,n3,n4
The four nodes of the element.
orientation
Orientation option for the element. Use:
0 - None 
1 - Systems


system1,2
The orientation systems IDs for the element.
property 
The property to which the element points.

","Example
To create a four-noded joint element:
*jointelement_fournoded(5,467,466,459,291,1,1595,0, ""stiffness"")
","Errors
None.
"
391,*jointelement_twonoded,"Description
Creates a spherical or two-noded joint element.
","Inputs

n1,n2
The two nodes of the element.
orientation
Orientation option for the element. Use:
0 - None 
1 - Systems 
2 - Nodes


o_node1,2
The orientation node IDs for the element.
system1,2
The orientation systems’ IDs for the element.
property
The property to which the element points..

","Example
To create a two-noded joint element:
*jointelement_twonoded(320,303,2,322,324,0,0,""shells"")
","Errors
None.
"
392,*jpegfilenamed ,"Description
Captures the graphics area to a JPEG image with the specified name. 
The color and background settings can be specified using the
          *graphicsfilecolor and *graphicscolorblankbackground
        commands.
","Inputs

filename
The full path and file name of the image.

","Example
To capture the graphics area to a JPEG image named
          ""C:/my_images/model.jpg"":
*jpegfilenamed ""C:/my_images/model.jpg""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
393,*lastsimulation ,"Description
Sets the last simulation and data type for transient animations. The results file must be
        loaded before executing this command.
","Inputs

simulation
The name of the simulation contained in the results file.
data_type
The name of the data type for the simulation.

","Example
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 through Subcase 4 with Displacements data type, using a
        10.0 model unit scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*lastsimulation ""Subcase 4"" ""Displacements""
*animatetransient """" 10.0 4 1 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
394,*legendcolorsmooth ,"Description
Performs linear interpolation between two colors. 
","Inputs

color1
The first color. 
color2
The second color. 

","Example
To smooth the colors between color 1 and color 7: 
*legendcolorsmooth(1,7)
","Errors
None.
"
395,*legendlocate ,"Description
Moves the legend to its default location (upper left corner). 
","Errors
None.
",,
396,*legendon ,"Description
Controls the display of the legend.
","Inputs

on
1 for on, 0 for off.

","Example
*legendon(0)
HyperMesh displays the legend by default. If you display the
        legend, the simulation title is also displayed.
","Errors
None.
"
397,*legendsetbordercolor ,"Description
Specifies the legend border and text color from both the hm.cfg file and a command file.
      
","Inputs

color 
The color used to specify the legend border and text color. Color must be between 1
            and 64, inclusively. 

","Errors
None.
",
398,*legendsetcolors ,"Description
 Sets the number of colors which will be used in the legend. 
","Inputs

number
The number of colors. 

","Errors
None.
",
399,*legendsetlocate,"Description
Locates the legend to the default position (upper left). 
","Errors
None.
",,
400,*linear1delements,"Description
Creates 1D elements between two sets of plate elements. 
","Inputs

mark1
The ID of the first group of plate elements.
mark2
The ID of the second group of plate elements. 
node11
The ID of the first alignment node for the first group of elements. 
node12
The ID of the second alignment node for the first group of elements.
node13
The ID of the third alignment node for the first group of elements.
node21
The ID of the first alignment node for the second group of elements.
node22
The ID of the second alignment node for the second group of elements. 
node23
The ID of the third alignment node for the second group of elements.
density
The number of elements being created between the two sets of plate elements. 
config
The config number for the 1D element (plot, rod, etc.). The default value is
            plot.

","Errors
None.
",
401,*line_trim_ends,"Description
The command trims given lines on input mark at the specified points. If the trimming
        locations are not exactly lying on a specific line, then the points on line closest to the
        given ones are used instead.
","
Inputs



mark_id

The ID of the mark containing the lines to edit.  Valid values are 1 and 2.

x1 y1 z1

Coordinates of the first trim point.

x2 y2 z2

Coordinates of the second trim point.

keep_original_lines

0 - Do not keep
1 - Keep

","Examples
To trim lines with IDs 10,20,30 from points closest to (4.5, 6.7, 8.9) to (0.1, 0.2,
        0.3):
*createmark lines 1 10 20 30
*line_trim_ends 1 4.5 6.7 8.9 0.1 0.2 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
402,*linearsolids ,"Description
Creates solid elements between two groups of plate elements. 
","Inputs

mark1
The ID of the mark containing the first group of plate elements. 
mark2
The ID of the mark containing the second group of plate elements. 
align1
The ID of the node to be used as an alignment node for the first group of elements.
          
align2
The ID of the node to be used as an alignment node for the first group of elements.
          
align3
The ID of the node to be used as an alignment node for the first group of elements.
          
align4
The ID of the node to be used as an alignment node for the second group of elements.
          
align5
The ID of the node to be used as an alignment node for the second group of elements.
          
align6
The ID of the node to be used as an alignment node for the second group of elements.
          
number
The number of solid elements to be created between the two groups of plate elements.
          
biasstyle
The type of biasing to use.
 biasing
The biasing factor for the mesh.

","Example
To create 8 solids between plates 10, 11, 12, 13 and 20, 21, 22, 23, with alignment node 1
        being node 5 and alignment node 2 being node 6: 
*createmark(element,1) 10 11 12 13
*createmark(element,2) 20 21 22 23
*linearsolids(1,2,5,0,0,6,0,0,8)

*createmark() is required and the marks used must contain plate
        elements. 
","Errors
None.
"
403,*linearsurfacebetweenlines ,"Description
Creates a ruled surface between two trimmed line lists, and optionally, prepares it for
        immediate use within the automesher. It can also identify a region in the shape of a ruled
        surface for the automesher to use under the mesh without surface option. 
","Inputs

linelist1
The ID of the first list of lines forming one side of the surface. 
endpoints1
The list ID of the list of zero or two nodes which lie on the lines in the first line
            list which will be used to trim the line during surface creation. 
linelist2
The ID of the second list of lines forming the other side of the surface. 
endpoints2
The list ID of the list of zero or two nodes which lie on the lines in the second line
            list which will be used to trim the line during surface creation. 
reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
To create a surface where lines 7 and 11 form one side, and line 5 trimmed by nodes 37 and
        38 forms the other, and not immediately bring the surface into the automesher: 
*surfacemode(4)
*createlist(lines,1) 7 11
*createlist(nodes,1)
*createlist(lines,2) 5
*createlist(nodes,2) 37 38
*linearsurfacebetweenlines(1,1,2,2,1)
All four *createlist() directives are required for this command. 
A case in which the surface is brought into the automesher is slightly more complicated. 
A case in which a region in the shape of a ruled surface is brought into the automesher to
        generate a mesh without using a surface is slightly more complicated.
","Errors
None.
"
404,*linearsurfacebetweennodesandline ,"Description
Creates a ruled surface between a node list and a trimmed line list, and optionally,
        prepares it for immediate use within the automesher. It can also identify a region in the
        shape of a ruled surface for the automesher to use under the mesh without surface
        option.
","Inputs

list1
The ID of the list of nodes forming one side of the surface. 
linelist1
The ID of the list of lines forming one side of the surface. 
endpoints
The list ID of the list of zero or two nodes which lie on the lines in the line list
            which will be used to trim the line during surface creation. 
reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
This example creates a ruled surface and brings it into the automesher, creates 16 quad
        elements, and stores the elements to the HyperMesh database: 
*surfacemode 1
*createlist nodes 1 160 161 164 168 172
*createlist lines 1 1
*linearsurfacebetweennodesandline 1 1 2 1
*set_meshedgeparams 0 4 1 0 0 0 0 0 0
*set_meshedgeparams 1 4 1 0 0 0 0 0 0
*set_meshedgeparams 2 4 1 0 0 0 0 0 0
*set_meshedgeparams 3 4 1 0 0 0 0 0 0
*set_meshfaceparams 0 1 2 0 0 0 0.1 0 0
*automesh 0 1 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
405,*linecombinemark,"Description
Combines multiple free lines into one or more continuous segments.
","Inputs

mark_id
The ID of the mark containing the free lines. Valid values are 1 and 2.
tolerance
The tolerance to use when determining if two adjacent lines should be combined. If the
            distance between the adjacent end points of the lines is greater than this value, those
            lines are not combined. 
If more than two end points are within this distance, the affected lines are not
            combined at that location.
break_angle
The break angle to use when determining if two adjacent lines should be combined. If
            the angle between the adjacent lines is greater than this value, those lines are not
            combined.
smooth
A flag that determines whether the lines should be combined with a straight line
            segment (0) or a smooth line segment (1) if the end points of the lines are not
            coincident.

","Example
Combine all free lines as straight line segments, using a tolerance of 0.01 and a break
        angle of 30:
*createmark lines 1 all
*linecombinemark 1 0.01 30 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
406,*linecreateatplanesintersection,"Description
This command creates a line at the intersection of two input planes. Only a finite
        intersection segment line is created, as defined by the input parameters
          length_option and length. An error is returned if
        the input planes are parallel or coincide.
","Inputs

plane1
ID of the first temporary plane created using *createplane.
plane2
ID of the second temporary plane created using *createplane.
 length_option
Parameter specifying how the finite segment line is created. Valid options are:
0 - Base node of the first plane is projected to segment center; length is used
                as segment length 
1 - Base node of the first plane is projected to segment start (see comments);
                length is used as segment length 
2 - Base node of the first plane is projected to segment end (see comments);
                length is used as segment length 
3 - Base node of the first plane is projected to segment start, base node of the
                second plane is projected to segment end (an error is generated if the length of the
                resulted segment is zero)



","Example
To create an intersection segment between planes x=0 and y=0 with the center at point
        (1,2,3) and having a length of 3.62:
*createplane 1 1 0 0 1 2 3
*createplane 2 0 1 0 1 2 3
*linecreateatplanesintersection 1 2 0 3.62
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
407,*linecreateatsurfparams,"Description
This command creates lines on a given surface for given parametric values.
","Inputs

surf_type
Input surface type. Valid values are surfs of faces.
surf_id
Input surface ID value.
u1
The lower bound of U parametric range. Must be within the range 0 to 1.
u2
The upper bound of U parametric range. Must be within the range 0 to 1.
ucount
The number of lines to create in U parametric direction. Must be >= 0. If the value is
            1 then u1 is taken as U parametric value for created line.
v1
The lower bound of V parametric range. Must be within the range 0 to 1.
v2
The upper bound of V parametric range. Must be within the range 0 to 1.
vcount
The number of lines to create in V parametric direction. Must be >= 0. If the value is
            1 then v1 is taken as V parametric value for created line.
mode
Specifies whether parameters are used relative to untrimmed surface parametric area or
            valid parametric area is scaled to visible region. Also used to specify whether created
            lines must reside inside visible trimmed surface area. Valid values are:
0 - Untrimmed surface parametric area is used. Created lines must be inside
                visible surface area. 
1 - Surface parametric area is scaled to visible surface area. Created lines must
                be inside visible surface area. 
2 - Untrimmed surface parametric area is used. Created lines can be outside
                visible surface area. 
3 - Surface parametric area is scaled to visible surface area. Created lines can
                be outside visible surface area.


comp_mode
Parameter specifying how entities are organized into components:
0 - Lines are created in the current component. 
1 - Lines are created in the surface component.



","Example
To create 12 lines (3 lines in U, 4 lines in V) on surface 11 between the U locations 0.5
        and 0.75, and the V locations 0.1 and 0.3:
*linecreateatsurfparams surfs 11 0.5 0.75 3 0.1 0.3 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
408,*linecreatedragnodealongvector,"Description
 This command creates straight segment lines by dragging nodes or points a user specified
        distance along a vector.
","Inputs

entity_type
Type of entities representing input points. Valid values are nodes or points.
mark_id
The mark ID containing the input points. Valid values are 1 and 2.
vector
ID of the temporary vector created using *createvector.
distance
 The distance to drag the input points. 

","Example
To create 4 straight segments with endpoints at nodes 2, 4, 6 and 8, oriented parallel to
        the x-axis, with lengths of 1.5:
*createmark nodes 1 2 4 6 8
*createvector 1 1 0 0
*linecreatedragnodealongvector nodes 1 1 1.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
409,*linecreatefromnodes ,"Description
This command creates a line which passes through a list of nodes.
","Inputs

list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
type
The type of line to generate. Valid values are:
0 - Linear 
1 - Standard 
2 - Smooth 
3 - User controlled, values of break_angle,
              aspect and linear_angle are used.
Adding 8 to any of the values above will create a closed line of that type.
break_angle
Specifies the minimum angle allowed between three points in a line. If the angle
            between a point and the two adjacent points is less than the angle specified, HyperMesh considers this point to be a point of discontinuity in
            the line and places a joint (starts a new NURBS) at this location.  Valid only for
              type 3.
aspect
Specifies the maximum ratio allowed for the distance between a point and the previous
            point in the line and the distance between the same point and the next point in the
            line. If the ratio of the distance between the two adjacent segments exceeds the aspect
            ratio defined, HyperMesh places a joint between the
            segments. Valid only for type 3.
linear_angle
Defines the angle at which HyperMesh should consider a
            line straight. For example, if the line angle between three consecutive points along the
            line is greater than the linear angle specified, HyperMesh
            removes the center point from the line. Valid only for type 3.

","Example
To create a smooth line that passes through nodes 1-4:
*createlist nodes 1 1 2 3 4
*linecreatefromnodes 1 2 0.0 0.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
410,*linecreatefromnodesonsurface ,"Description
This command creates a line that lines on a surface by interpolating input points on that
        surface. If some of the input points do not reside on the same surface, then the location
        closest to those points on the surface point are used.
","Inputs

surf_type
Input surface type. Valid values are surfs of faces.
surf_id
Input surface ID value.
point_type
Type of entities representing input points. Valid values are nodes or points.
point_list
List ID of the input points or nodes. A minimum of 2 points or nodes must be
            selected.
curve_type
Type of created curve. Valid values are: 
0 - Points are connected by linear segments. 
1 - Points are connected by linear segments into closed line. 
2 - Points are interpolated by a smooth curve. 
3 - Points are interpolated by a smooth closed curve.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).


Bit0
Additional curve construction option. Valid values are:
0 - Curve is created as free line. 
1 - Created curve is used to trim input surface.




Bit1
Specifies how entities are organized into components. Used only when Bit0 is set
                  as 0. Valid values are:
0 - Line is created in the current component. 
1 - Line is created in the surface component.





","Example
To create a spline that interpolates nodes 11, 12 and 13 on surface 10:
*createlist nodes 1 11 12 13
*linecreatefromnodesonsurface surfs 10 nodes 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
411,*linecreatenormalfromgeom ,"Description
This command creates straight segment lines of a user defined length from a given set of
        points or nodes normally to a given set of geometry entities. The segment is created for
        each pair of point and geometry. The input nodes/points must be attached or associated with
        their respective geometry.
","Inputs

point_type
Type of entities representing input points. Valid values are nodes or points.
point_mark_id
The mark of input points or nodes.
geom_type
Type of geometry entities. Valid values are lines, surfs, faces or solids.
geom_mark_id
The mark of input geometry entities.
length
The length of the normal line.
?mode?(optional)
Indicates different modes. Bit values are used and the value is calculated as (Bit0 + 2*Bit1).
Bit0
 0 - the normal direction is used, which is the default case 
1 - The direction opposite to the normal direction is used to create the
                  segment
Bit1
Specifies how entities are organized into components. Valid values are:
0 - Line is created in the current component, which is the default valule. 
1 - Line is created in the input geometry component.





","Example
To create a straight segment normally from node ID 10 to surface ID 21, with length 18:
*createmark nodes 1 10
*createmark surfs 1 21
*linecreatenormalfromgeom  nodes 1 surfs 1 18
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
412,*linecreatenurbs ,"Description
This command creates a generic NURBS type line using input parameters.
","Inputs

degree
Polynomial degree of the created line.
dimension
Dimension of created line. Valid values are:
2  - Planar line
3 - 3-dimensional line


knot_count
Number of knot values. See Comments section.
pole_count
Number of NURBS control points/poles.
ratnl
Parameter that specifies whether weights are used in addition to control points. Valid
            values are: 
0 - Use weights 
1 - Do not use weights
double_array
The ID of the double array that contains the value of the knots, control points and
            weights (if ratnl is 1). The double array is created using the
              *createdoublearray command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.

To reduce input, the usual NURBS convention that for the curve with polynomial degree first
        and last degree+1 knots must have the same value is enforced internally. Input for this
        command should only contain one value. For all internal knot values, multiplicity should
        still be provided explicitly. All knot values must be provided in non-decreasing order.
","Examples
To create a planar line segment connecting points (0,0) and (1,1):
*createdoublearray 6 0 1 0 0 1 1
*linecreatenurbs 1 2 2 2 0 1 6
To create a 90 degree arc starting at (0,0) and ending at (2.0):
*createdoublearray 11 0 1 0 0 1 1 2 0 1 0.7071067811 1
*linecreatenurbs 2 2 2 3 1 1 11

To create a 180 degree arc:
*createdoublearray 19 0 1 1 2 0 0 1 1 2 0 3 -1 2 -2 1 0.707106 1 0.707106 1
*linecreatenurbs 2 2 4 5 1 1 19
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
413,*linecreatespline ,"Description
This command creates a cubic spline curve that interpolates input points. Various
        conditions can be used to specify the spline behavior at the endpoints.
","Inputs

point_type
Type of entities representing input points. Valid values are nodes or points.
point_list
List ID of the input points or nodes. Minimum of 2 points or nodes must be
            selected.
scond, econd
Parameter specifying the constructed spline behavior at curve start
              (scond) or end (econd). Valid values are:
0 - Spline direction at endpoint is not constrained 
1 - Spline is closed. In this case any other end condition is ignored. Closed
                smooth cubic spline is constructed. 
2 - Spline direction at endpoint is tangent to direction of input vector
                  svector (for scond) or
                  evector (for econd). 
3 - Spline direction at endpoint is normal to direction of input vector
                  svector (for scond) or
                  evector (for econd). 
4 - Spline parametric derivative at endpoint equals to input vector
                  svector (for scond) or
                  evector (for econd). Normalized spline
                parameterization of 0 to 1 is implied.


svector
Vector used to apply boundary condition specified by parameter
              scond. Only required when scond is 2, 3 or
            4.
evector
Vector used to apply boundary condition specified by parameter
              econd. Only required when econd is 2, 3 or
            4.

","Examples
To create a closed spline that interpolates nodes 11, 12 and 13:
*createlist nodes 1 11 12 13
*linecreatespline nodes 1 1
 To create a spline that interpolates the same nodes, is tangent at its start to vector
        (0,0,1) and is normal at its end to vector (1,0,0):
*createlist nodes 1 11 12 13
*createvector 1 0 0 1
*createvector 2 1 0 0
*linecreatespline nodes 1 2 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
414,*linedragelements,"Description
Creates a mesh by dragging elements along a line. 
","Inputs

mark
The ID of the mark containing elements. 
guide
The guide line. 
guideendpoints
The ID of the list containing the nodes which will be used to segment the guide line.
          
plane_id
The orientation plane used to orient the line to the guide line. 
ondrag
The number of elements to be created along the drag.
biasstyle
The type of biasing to use.
biasing
The biasing intensity value.
using_default_vector
0 - Use plane normal vector 
1 - Use default normal vector 

","Errors
None.
",
415,*linedragnodestoformsurface,"Description
Drags a list of nodes along a trimmed line to create a surface, and optionally, prepares it
        for immediate use within the automesher. It can also identify a region in the shape of a
        line-dragged surface for the automesher to use under the mesh without surface option. 
","Inputs

sectionnodelist
The ID of the list of nodes to be dragged. 
draglinelist
The ID of the list of lines to drag along. 
dragnodelist
The list ID of the list of zero or two nodes which lie on the lines in the
            draglinelist which will be used to trim the line during surface creation. 
refplane
The orientation plane used to orient the section lines to the drag lines. 
using_default_vector
0 - Use plane normal vector 
1 - Use default normal vector

","Example
To drag nodes 5, 9, and 10 along lines 2 and 1, trimmed by nodes 29 and 30, and using the
        given plane, creating a surface but no elements: 
*surfacemode(4)
*createlist(nodes,1) 5 9 10
*createlist(lines,2) 2 1
*createlist(nodes,2) 29 30
*createplane(1,0.0000,0.0000,1.0000,0.0000,0.0000,100.0000)
*linedragnodestoformsurface(1,2,2,1)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation.
          *createlist() and *createplane() are required for
        this command. 
If one of the surface creation modes has been set, a smooth is put through the nodes to
        create the surface. 
","Errors
None.
"
416,*lineextenddistance,"Description
Extends the specified line.
","Inputs

line
The ID of the line to extend.
distance
The distance to extend the line.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
417,*lineextendtonode,"Description
Extends the specified line to a node.
","Inputs

line
The ID of the line to extend.
node
The ID of the node to which the line is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of the node, then force the end point to have the
            same coordinates as the node.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
418,*lineextendtosurf,"Description
Extends the specified line to a surface.
","Inputs

line
The ID of the line to extend.
surface
The ID of the surface to which the line is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of the surface, then force the end point to be on
            the surface.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
419,*lineimprintpoints,"Description
Imprints locations/points, given by coordinates, onto free lines or edges within a given
        max distance.
","
Inputs



mark_id

The ID of the mark containing the lines to imprint.  Valid values are 1 and 2.
double_array
The ID of the double array that contains the point coordinates to imprint. The double
            array is created using the *createdoublearray command. This should
            always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.  This should always be a multiple of 3.

max_distance

The maximum imprint distance.  If negative, there is no restriction.

","Examples
To imprint lines 5 and 7 with 4 locations:
*createmark lines 2 5 7
*createdoublearray 12 42.41 -35.16 65.90 42.49 -30.06 65.93 44.49 -32.58 66.97 24.41 -28.13 66.34
*lineimprintpoints 2 1 12 -1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
420,*linemarkbypath,"Description
Creates a line path from the starting line to the ending line.
","Inputs

line_id1
The ID of the first line.
line_id2
The ID of the second line.
mark_id
The ID of the line mark to populate. Valid values are 1 and 2.
flag
0 - If both line_id1 and line_id2 lie are free
            edges, the path will follow free edges where possible. Otherwise, the shortest path is
            returned. 
1 - Always return the shortest path.

","Example
To determine the path between lines 100 and 110 using the shortest path:
*linemarkbypath 100 110 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
421,*linemesh_preparedata1,"Description
Prepares the selected entities for 1D meshing. 
Each call to this command must be paired with a call to
          *linemesh_savedata1 or *linemesh_savedata_bar1 to
        clean up memory.
","Inputs

entity_type
The type of entity to 1D mesh. Valid values are lines and nodes. 
If the entities are nodes, only two nodes can be provided.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
break_angle
If the angle between the lines’ tangents at a joint is greater than this value, the
            line is split to force a node at that location. If set to 0.0, no split will occur.
config
If configuration of the element to create. Only 1D configs are valid.

","Example
To mesh lines 15 and 18 with a 30 degree break angle, creating rigid elements with no
        property:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
","Errors
None.
"
422,*linemesh_savedata_bar1,"Description
Creates 1D elements, with options for bar2 elements, and cleans up memory. 
Each call to this command must be paired with a previous call to
          *linemesh_preparedata1 or
          *linemesh_preparenodeslist1.
","Inputs

entity_type
The type of entity to 1D mesh. Valid values are lines and nodes.
create_flag
0 - Do not generate elements. 
1 - Generate elements.
config
The 1D element config ID of the elements to create. For bar2 elements, this should be
            set to 60.
property_id
The ID of the property to assign to the 1D elements.
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This argument is only used if
              auto_flag is 0 and config is 60.
offset_x_a
The offset in the x-direction at end a. This argument is only used if
              config is 60.
offset_y_a
The offset in the y-direction at end a. This argument is only used if
              config is 60.
offset_z_a
The offset in the z-direction at end a. This argument is only used if config
            is 60.
offset_x_b
The offset in the x-direction at end b. This argument is only used if
              config is 60.
offset_y_b
The offset in the y-direction at end b. This argument is only used if
              config is 60.
offset_z_b
The offset in the z-direction at end b. This argument is only used if config
            is 60.
auto_flag
If set to 0, vector_id is used. Otherwise, vector type is set to
            auto. This argument is only used if config is 60.
organize
0 - Organize new 1D elements to current component. 
1 - Organize new 1D elements to input lines component(s).

","Examples
To mesh lines 15 and 18 with a 30 degree break angle, creating bar2 elements with no
        property or offset and using the auto vector:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 60
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata_bar1 lines 1 60 0 1 0 0 0 0 0 0 1 0
To mesh between nodes 16, 17, and 2 with 3 rigid elements between nodes 16 and 17 and with
        2 rigid elements between nodes 17 and 2, with no property assignment, organizing to the
        input line component(s):
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata_bar1 nodes 1 5 0 1 0 0 0 0 0 0 1 1
","Errors
None.
"
423,*linemesh_saveparameters ,"Description
Assigns meshing parameters to line or node list segments for 1D meshing. 
Each call to this command must be paired with a call to
          *linemesh_preparedata1 or
          *linemesh_preparenodeslist1.
","Inputs

segment
The ID of the segment within the line or node list selection. This index is 0
            based.
density
The element density to use for that segment.
bias
The biasing value of the element length to use along the given segment.
bias_style
The style of biasing to use. Valid values are: 
0 - linear 
1 - exponential 
2 - bell curve

","Example
To mesh lines 15 and 18 with a 30 degree break angle, with 3 elements in the first segment,
        and 2 elements in the second segment, creating rigid elements with no property:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
","Errors
None.
"
424,*linereverse ,"Description
This command reverses the direction for a given input line. Works for free lines only.
","Inputs

 line_id
Input line ID.

","Example
To reverse line 12:
*linereverse 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
425,*linescombine ,"Description
Combines two free surface edges to create one unsuppressed common edge.
","Inputs

edge1, edge2
Two free surface edges (face edges which are attached to a surface only once).
edge_tolerance
The edges must be within this tolerance.

","Example
To combine edges 101 and 39, using a tolerance of 0.1:
*linescombine(101,39,0.1)
","Errors
None.
"
426,*linesplitatjoint ,"Description
Splits a line at a joint. 
","Inputs

line
The line which should be split. 
node
The node which represents a position close to the joint where the line should be
            split. 

","Example
To split line 10 at node 3: 
*linesplitatjoint(10,3)

","Errors
None.
"
427,*linesplitatplane,"Description
Splits a group of lines at a plane. 
","Inputs

mark
The ID of the mark containing the lines to be split. 
plane id
The ID of the plane to be used in the split operation. 

","Example
To split lines 10, 11, 12, and 13 to the plane defined by the normal (1.0, 0.0, 0.0) and
        base at (25.0, 0.0, 0.0): 
*createplane(1,1.0,0.0,0.0,25.0,0.0,0.0)
*createmark(lines,1) 10 11 12 13
*linesplitatplane(1,1)


","Errors
None.
"
428,*linessmoothtoangle ,"Description
 Smooths a line based on a give angle. 
","Inputs

mark 
The ID of the mark containing the lines to smooth.
cosangle
The cosine of the angle used to determine if two joints on a line should be combined
            (smoothed). If the angle between two joints on a line is greater than the angle the two
            joints are combined and smoothed.

","Example
To smooth all joints on line 1 that have an angle greater than 90 degrees:
*createmark(lines,1) 1
*linessmoothtoangle(1,0)
","Errors
None.
"
429,*linestoelementsaddelemsfixed,"Description
This command generates plot elements along selected lines with a given density. These plot
        elements are then used as feature edges for element remeshing. Use of this command implies
        that it will be followed by a command that performs meshing/remeshing of elements.
","Inputs

mark_id
The ID of the mark containing lines that should be considered to form feature edges in
            subsequent element remesh operations. Valid values are 1 and 2.
elem_size
The default element edge size used to calculate element densities along the
            constructed feature edges.

","Example
To remesh the displayed elements and create feature edges with element size 10.0 along
        lines with IDs 1600 and 1601:
*createmark elems 1 displayed
*setusefeatures 1
*createmark lines 2 1600 1601
*linestoelementsaddelemsfixed 2 10
*defaultremeshelems 1 3.0 2 2 0 1 1 1 0 0 0 0 0 30

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
430,*loadcreateonentity,"Description
Creates a load (forces, temperature, moment, velocity, acceleration, or constraints) on
        nodes, fixed points (surface vertices or weld points), surface edges, and surfaces.
","Inputs

geomtype
Type of entity the load is applied on (e.g. SURFS).
markmask
The ID of a mark containing the entities that will bear the load.
config
The configuration of the load:
1 - Force 
2 - Moment 
3 - Constraint 
5 - Temperature 
6 - Flux 
8 - Velocity 
9 - Acceleration


type
The type assigned to the load (as defined on the ""load types"" panel).
component[1-6])
Components of the load being applied. 
When applying a force, the active components are 1, 2, and 3, which represent a force
            x, y, and z-axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z-axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            -999999.0. All the other components of the constraints are active in the respective
            directions. 

","Example
To apply a temperature of 0 degrees on a surface
*createmark(surfaces,1) 12
*loadcreateonentity(surfaces,1,5,1,0,0,0,0,0,0)

","Errors
None.
"
431,*loadcreatewithsystem ,"Description
Creates a load (force, moment, pressure, or constraint) at a node or element defined in a
        local coordinate system.
","Inputs

mark
The ID of the mark containing the nodes or elements that will bear the load.
config
The load configuration.
type
Solver dependent types of the referenced load config.
1 - Force 
2 - Moment 
3 - Constraint 
4 - Pressure 
5 - Temperature 
6 - Nodal flux 
8 - Velocity 
9 - Acceleration


component 1-6
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            999999.0. All of the other components of the constraints are active in the respective
            directions. 
Finally, for pressures the active components are 1, 2, and 3, which represent the x,
            y, and z axes respectively. To create a pressure that is normal to the element, set all
            components to zero.
system
ID of the coordinate system to use.
transformflag
 Indicates which system supplies component values.
0 - If the component values are supplied in the global coordinate system. 
1 - If the component values are supplied in the local coordinate system.



","Example
To apply a force of magnitude 10.0 along the x axis of local system 4 to nodes 5 and 25: 
*createmark(nodes,1) 5 25
*loadcreatewithsystem(1,1,1,10.0,0.0,0.0,0.0,0.0,0.0, 4,1)
To apply a constraint of zero in the global 1, 3, 5 directions to nodes 12, 13, and 14, but
        have the constraint communicated to the solver in the local coordinate system with ID 4:
*createmark(nodes,1) 12 13 14
*loadcreatewithsystem(1,1,3,0.0,999999.0,0.0,999999.0,0.0,-999999.0, 4,0)

","Errors
None.
"
432,*loadcreatewithsystemonentity_curve,"Description
Creates loads, defined in a local coordinate system, with magnitudes defined by a
        curve.
","Inputs

entity_type
The type of entity the load is applied to. Valid values are nodes, points, lines,
            elems, surfs, comps and sets.
mark_id
The ID of the mark containing the entities.
config
The config of the load to create:
1 - force
2 - moment
3 - constraint
4 - pressure
5 - temperature
6 - nodal flux
8 - velocity
9 - acceleration
type
Solver-dependent type of the specified config.
comp[1-6]
The components of the load being applied.
For constraints, all the components are active unless they are set equal to -999999.0.
            All the other components of the constraints are active in the respective
            directions.
For other config values, the active components are 1, 2, and 3,
            which represent the x, y, and z-direction, respectively.
system_id
The ID of the local system to use.
transform_flag
Indicates which system supplies component values.
0 - The component values are supplied in the global coordinate system
1 - The component values are supplied in the local coordinate system
x_loc, y_loc, z_loc
For loads on components or sets, this is the display location where the graphical
            image for the load is drawn. If these three values are 999999, or more than one entity
            is selected, the display location is automatically generated.
curve_id
The ID of the curve defining the magnitude of the load.
x_scale
A scale factor applied to the x-axis (or time-axis) of the curve.

","Example
To apply a force of magnitude 10.0, using curve 11 along the x axis of system 4 to nodes 5
        and 25:
*createmark nodes 1 12 13 14
*loadcreatewithsystemonentity_curve nodes 1 1 3 10.0 0.0 0.0 0.0 0.0 0.0 4 0 999999 999999 999999 11 1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
433,*loadsettypes ,"Description
Sets the global load type variable. 
","Inputs

mark
The mark which contains the loads to be updated.
entities
The type of load to change.

","Example
To set all of the displayed forces to type 5, and all of the displayed moments to type 6:
*loadtype (1,5)
 sets new Forces (1) to type 5 but doesn’t change existing ones 
*loadtype (2,6)
sets new Moments (2) to type 6 (doesn’t change existing ones)
*createmark(loads,1) displayed
places all existing displayed loads into Mark1
*loadsettypes(1)
changes all the entities in Mark1 to use the types already defined for Forces (5)
              and Moments (6)


","Errors
None.
"
434,*loadsupdatecurve ,"Description
Updates the magnitude, direction, coordinate system, and other information of selected
        loads.
","Inputs

markmask
ID of the mark containing the loads to update.
config
The configuration of the load: 
1 - Force 
2 - Moment 
3 - Constraints 
5 - Temperature 
6 - Flux 
8 - Velocity 
9 - Acceleration
type
The type assigned to the load (as defined on the ""load types"" panel).
updatevector
A variable that controls if the direction of the load should be updated.
component[1-6]
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z-axis, respectively. When applying a
            moment, the active components are also 1, 2, and 3, and represent the moment about the
            x, y, and z-axis, respectively. For constraints, all of the components are active unless
            they are set equal to -999999.0. All of the other components of the constraints are
            active in the respective directions. For pressures, the active components are 1, 2, and
            3, which represent the x, y, and z-axis, respectively. To create a pressure that is
            normal to the element, set all components to zero.
updatemag
An integer variable that controls if the magnitude is updated.
magnitude
The new value of magnitude of the load.
update_system
A variable that controls if the system is updated.
system_id
The ID of the local system.
transform_flag
A simple integer variable that controls if the load is created in the local
            system.
updatecurve
A flag to indicate whether the curve should be updated (0=no, 1=yes).
curve_id
The ID of the new curve to use.
updatexscale
A flag to indicate whether the curve’s scale factor should be updated.
0 - No
1 - Yes


xscale
The new value to use for scale factor.
updatedisplaylocation
A flag to indicate whether the curve’s display location should be updated.
0 - No
1 - Yes


xlocation, ylocation, zlocation
The new display location (used only if updatedisplaylocation
            =1)

","Example
Example to update a force to use the curve with ID 7 to define its time-varying
        magnitude:
*createmark(loads,1)  4
*loadsupdatecurve(1,1,1, 0, 0,0,0,0,0,0, 0,0, 0,0,0, 1,7, 0,0, 0,0,0,0)
","Errors
None.
"
435,*loadtype ,"Description
Sets the load types to the current global value. 
","Inputs

config
The load configuration that is to have its type changed. 
type
The type which the configuration should become. 

","Example
To set the type of forces to 2: 
*loadtype(1,2)
After the type has been set, all loads of the corresponding configuration are set to the
        value of type. 
","Errors
None.
"
436,*lockentities,"Description
This command adds entity locks for a selection of entities.
","Inputs

entity_type
The type of entity to lock.
mark_id
The ID of the mark containing the entities to lock. Valid values are 1 and 2.
dataname
The dataname to lock. Currently only supported for ""id"".

","Example
To lock the displayed element IDs:
*createmark elems 1 displayed
*lockentities elems 1 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
437,*makepreservednodes,"Description
This command makes the selected nodes preserved.
","Inputs

mark_id
The ID of the mark containing the nodes to preserve. Valid values are 1 and 2.

","Example
To make nodes 1-4 as preserved:
*createmark nodes 1-4
*makepreservednodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
438,*maketempfrompreservednodes ,"Description
This command converts nodes from preserved nodes to temp nodes.
","Inputs

mark_id
The ID of the mark containing the nodes to convert. Valid values are 1 and 2.

","Example
To convert nodes 1-4 from temp to preserved:
*createmark nodes 1-4
*maketempfrompreservednodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
439,*map_symmetric_mesh,"Description
Maps the mesh from source surfaces to target surfaces with an optionally supplied
        transformation. The transformation can be supplied as a translation, a rotation, or a 4x4
        transformation matrix. If not supplied, the transformation is computed internally. The
        tolerance for associating the mapped mesh to the underlying surface can also be supplied. If
        not given, the global node tolerance is used instead.
The output information is logged into two global Tcl arguments:
          g_hw_argc and g_hw_argv. These can be accessed after the
        execution of the command. 
If a transformation was not supplied to the command, the internally computed transformation
        is logged in terms of translation and rotation. It also contains the general status of the
        command (whether the surfaces are symmetric or not).
","Inputs

entity_type
The type of source/target entity. Currently only supported for surfs.
mark_id_source
The ID of the source mark of entities. Valid values are 1 and 2.
mark_id_target
The ID of the target mark of entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
rotation:
angle: <angle in degrees> axis: <axis, x component> <axis, y component
                  > <axis, z component >
base: <base, x component> < base, y component > < base, z component
                  >
tolerance:
<value> 
transformation:
<tr11> <tr12> <tr13> <tr14> <tr21> <tr22> <tr23> <tr24>
                  <tr31> <tr32> <tr33> <tr34> <tr41> <tr42> <tr43>
                  <tr44>
translation:
<x component> <y component > <z component>
ElementMappingAsLists
If present, element lists 1 and 2 are populated with source and corresponding
                  target elements, respectively. This is useful for determining the source-to-target
                  element mapping. Case insensitive.
NodeMappingAsLists
If present, node lists 1 and 2 are populated with source and corresponding
                  target nodes, respectively. This is useful for determining the source-to-target
                  node mapping. Case insensitive.
PreferReflection
If present, reflective symmetry is preferred. Otherwise, other symmetries get
                  perference over reflective symmetry. Case insensitive.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. 

","Example
To map the mesh from surface with ID 10 to surface with ID 20 (surfaces are symmetric) with
        a translation along the y direction, and a rotation of 90 degrees along the global
        y-axis:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 {{translation: 0 1 0} {rotation: angle :90 axis : 0 1 0 base: 0 0 0}}
*map_symmetric_mesh surfs 1 2 1 2
if { [info exists g_hw_argc] } {
foreach outMessage $g_hw_argv {
puts $outMessage
}
}
To map the mesh from surface with ID 10 to surface with ID 20, auto detecting the
        transformation:*createmark surfs 1 10
*createmark surfs 2 20
*map_symmetric_mesh surfs 1 2 1 0
To map the mesh from surface with ID 10 to surface with ID 20, auto detecting the
        transformation, and getting the source to target node and element
        mappings:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""NodeMappingAsLists"" ""ElementMappingAsLists""
*map_symmetric_mesh surfs 1 2 1 2
set sourceNodeList [hm_getlist nodes 1]
set targetNodeList [hm_getlist nodes 2]
set sourceElemList [hm_getlist elements 1]
set targetElemList [hm_getlist elements 2]
To do the mapping using a custom tolerance and transformation
        matrix:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""transformation: 0 0 1 0 0 1 0 0 -1 0 0 0 2.5 0 12.5 1"" ""tolerance: 0.1""
*map_symmetric_mesh surfs 1 2 1 2
set sourceNodeList [hm_getlist nodes 1]
set targetNodeList [hm_getlist nodes 2]
set sourceElemList [hm_getlist elements 1]
set targetElemList [hm_getlist elements 2]
To do the mapping by auto-detecting the transformation, and associate the mesh with the
        given
        tolerance:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""tolerance: 0.1""
*map_symmetric_mesh surfs 1 2 1 2
set sourceNodeList [hm_getlist nodes 1]
set targetNodeList [hm_getlist nodes 2]
set sourceElemList [hm_getlist elements 1]
set targetElemList [hm_getlist elements 2]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
440,*maploadtomesh ,"Description
Creates loads on an FE mesh that correspond to a load on the underlying geometry. 
","Inputs

markmask
ID of the entity.

","Example
To create temperature loads on an FE mesh that corresponds to the given geometry load
*createmark(loadcols,1) ""m""
*maploadtomesh(1)
This command is applicable only from HyperMesh 6.0 onwards.
","Errors
None.
"
441,*markcombineelements ,"Description
Combines selected plate and shell elements into one quad or tria element. 
","Inputs

mark
The ID of the mark containing the elements to be combined. 
tolerance
The maximum tolerance allowed before a node within the group of selected elements is
            considered to be not on the plane formed by any three nodes attached to the group of
            selected elements. 
quad or tria
A flag designating the type of element you want to create. 
0 - tria 
1 - quad

","Example
To combine elements 10, 13, and 15 into a tria, using an off-plane tolerance of 0.1:
*createmark(elements, 1) 10 13 15
*markcombineelements(1, 0.1, 0)
This command works with two-dimensional elements only. 
","Errors
None.
"
442,*markercreate ,"Description
This command creates an MBD analysis marker.
","Inputs

name
The name of the marker.
node_id
The ID of the node that defines the location of the marker.
syst_id
The ID of the orientation coordinate system.
syst_flag
A flag for the coordinate system. A value of 0 indicates that the coordinate system
            will be blank.
color
The color of the marker.

","Example
To create a marker m1 at node ID 100 using coordinate system ID 10:
*markercreate ""m1"" 100 10 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
443,*markintersection ,"Description
This command determines the intersection between the entity IDs that exist on
          mark_idA on those on mark_idB. The results are then
        placed on mark_idA. 
Both entity_typeA and entity_typeB must be the
        same.
","Example
To delete the intersection between the elements on marks 1 and 2:
*createmark elems 1 1 2 3 4
*createmark elems 2 4 5 6 7
*markintersection elems 1 elems 2
*deletemark elems 1
This will delete element 4. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
444,*markmovetoinclude,"Description
This command organizes entities into an include file.
","Inputs

entity_type
The type of entity to organize.
mark_id
The ID of the mark containing the entities to organize. Valid values are 1 and 2.
include_id
The ID of the include file to organize the entities into.

","Example
To move systems 4, 8, and 12 into include file number 2: 
*createmark systems 1 4 8 12
*markmovetoinclude systems 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
445,*markmovetomodule ,"Description
This command organizes entities into a module.
","Inputs

entity_type
The type of entity to organize.
mark_id
The ID of the mark containing the entities to organize. Valid values are 1 and 2.
module_name
The name of the module to organize the entities into.

","Example
To move comps 1-4 into module ""Test"":
*createmark comps 1 1-4
*markmovetomodule comps 1 ""Test""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
446,*marknodenudge,"Description
Moves nodes along a surface. The nodes must first be associated to a surface. 
","Inputs

mark
The mark containing the nodes to be moved. 
distance
The distance to move the nodes (in the direction of the vector). 
vector
The direction to move the node (in 3D space). This vector is mapped to the surface
            before the nodes are moved. 

","Example
To move the node with ID 110 a distance of 10 in the x direction (along the surface it is
        associated to): 
*createmark(nodes,2) 110
*createvector(1,1.0,0.0,0.0)
*marknodenudge(2,10.0,1)
*createmark() and *createvector() are required for
        this command. 
","Errors
None.
"
447,*markprojectnormallytoline ,"Description
Projects entities to the line, using the normal to the line as the direction vector.
","Inputs

entities
The type of entity contained on the mark.
mark
The ID of the mark.
projectlinelist
The ID of the list of lines to which the entities are projected.
projectnodelist
The ID of the list of nodes that are on the lines in the projectlinelist. The nodes
            are used to trim the line during projection.

","Errors
None.
",
448,*markprojecttoline,"Description
Projects entities to the line.
","Inputs

entities
The type of entity contained on the mark.
mark
The ID of the mark.
vector
The vector along which the entities are projected.
projectlinelist
The ID of the list of lines to which the entities are projected.
projectnodelist
The ID of the list of nodes that are on the lines in the
              projectlinelist. The nodes are used to trim the line during
            projection.

","Errors
None.
",
449,*markprojecttosurface,"Description
 Project entities to a surface. 
","Inputs

entities
The type of entity contained on the mark. 
mark
The ID of the mark. 
vector
The direction to project the entities. 
surface
The ID of the surface to project to. 

","Example
To project elements 109 and 131 to surface 1 along the Z-axis: 
*createmark(elements,1) 109 131
*createvector(1,0.0000,0.0000,1.0000)
*markprojecttosurface(elements,1,1,1)
*createmark() and *createvector() are required for
        this command. 
",
450,*marksmoothsolids,"Description
Applies a simple smoothing algorithm to reposition the interior floating nodes in a mesh of
        solid elements, attempting to moderate variations in element size and quality.
","Inputs

mark
The mark of the solid elements. 
iterations
The number of times to apply the algorithm. 

","Example
To smooth some elements for 10 iterations: 
*createmark(elements,1) 7 8 9 11 12 13 17 54
*marksmoothsolids(1,10)
The *createmark() commmand is required. 
","Errors
None.
"
451,*maskall ,"Description
Masks all supported entities. This includes: 
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors
tags
domains
handles
morphconstraints
morphvolumes
shapes
symmetries


","Example
To mask all supported entities:
*maskall
","Errors
None.
",
452,*maskentitiesincollector ,"Description
This command masks the entities contained within the collectors of
          entity_type that are on mark_id. Valid
          mark_ids are 1 and 2. Only entities in displayed collectors may be
        masked.
The six flag arguments indicate the type of entities to mask within the
        specified collectors. If the flag is set to 1, that entity is masked. If the flag is set to
        0, that entity is not modified. See the list below for the currently supported
          entity_types and flags.
","Inputs

comps
flag_1: elements 
flag_2: points 
flag_3: lines 
flag_4: surfaces 
flag_5: solids 
flag_6: connectors
groups
flag_1: master elements 
flag_2: slave elements 
flag_3: flag_6 are not used
loadcols
flag_1: loads 
flag_2: equations 
flag_3: flag_6 are not used
multibodies
flag_1: ellipsoids 
flag_2: mbjoints 
flag_2: mbplanes 
flag_4 through flag_6 are not used

","Example
To mask all of the points and surfaces in the displayed components:
*createmark components 1 displayed
*maskentitiesincollector comps 1 0 1 0 1 0 0
To mask all ellipsoids and mbjoints in all multibodies:
*createmark multibodies 2 all
*maskentitiesincollector multibodies 2 1 1 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
453,*masknotshown,"Description
Masks all supported entities not in the current view window. For collected entities, only
        entities in displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries
","Example
To mask all supported entities in the displayed collectors that are not in the current view
        window:
*masknotshown
","Errors
None.
",
454,*maskreverse ,"Description
Reverses the masking state of a specific entity type. For collected entities, only entities
        in displayed collectors are affected. This includes: 
components (points, lines, surfaces, solids, elements, connectors)
points
lines
surfaces
solids
elements (both in components and groups)
connectors
groups (elements)
multibodies (ellipsoids, mbjoints, mbplanes)
ellipsoids
mbjoints 
mbplanes 
loadcols (loads) 
loads 
equations 
systemcols (systems) 
systems 
vectorcols (vectors) 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
To reverse the masking of all vectors in the displayed vector collectors:
*maskreverse vectorcols

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
455,*maskreverseall2 ,"Description
Reverses the masking state of supported entities. Only entities in displayed collectors are
        affected. This includes: 
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors


","Example
To reverse the masking of all supported entities in the displayed collectors:
*maskreverseall2
","Errors
None.
",
456,*masselementwithvar,"Description
Creates a mass element with aTclvariable.
","Inputs

mark
The mark ID containing nodes on which you wish to create mass elements. 
mass_var
The TCL variable to use to assign the mass to the element. This variable must be an
            array of double values and be accessible from the global scope. The index into the array
            is the node ID. 

","Errors
None.
",
457,*mbplanecreate ,"Description
 Creates a new mbplane entity.
","Inputs

name
The name of the mbplane.
color
The color value of the mbplane.
type
The MADYMO type definition to be used later.
origin
The center node for the mbplane.
xaxis
The xaxis node for the mbplane.
yaxis
The yaxis node for the mbplane.
multibodyid
The ID of the multibody to which the mbplane is attached.

","Errors
None.
",
458,*ME_CoreBehaviorAdjust ,"Description
Adjusts part and part assembly related behaviors based on certain aspects and policies.
","Inputs
Valid aspects and their policy values are:

allow_automatic_occurrence_splitting
Every occurrence has an associated base prototype.  A single prototype may provide the
            base for multiple occurrences (e.g. a prototype of a wheel might have four occurrences
            in a vehicle).  Once automatic splitting is enabled, any modification that may happen in
            an occurrence will cause it to be separated (split) from its original prototype to a new
            prototype of its own, containing all the modifications made.  In the wheel/vehicle
            example, changes made to the front left wheel will cause it to be separated in a
            different prototype, while all the rest of the wheels remain based on the original
            prototype, thus having now two prototypes instead of just one. Possible values are: 
yes - Enable automatic splitting.
no - Disable automatic slitting (default).
allowable_actions_policy
Defines the availability of various actions that operate on parts and part assemblies.
            Possible values are: 
default - Allows all actions. 
TC - TeamCenter policy. Prevents renaming, re-parenting and deleting. 
TC_lite - TeamCenter lite policy. Prevents renaming and re-parenting.

","Example
To set the allowable actions policy to TC lite:
*ME_CoreBehaviorAdjust ""allowable_actions_policy=TC_lite""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
459,*ME_ModuleOccurrenceBackPropagate,"Description
Every occurrence has an associated prototype that it came from. A single prototype may
        provide the base for multiple occurrences (like a prototype of a wheel, might have four
        occurrences in a vehicle). Once automatic splitting is enabled, any modification that may
        happen in an occurrence, will cause it to be separated (split) from its original prototype,
        to a new prototype of its own, containing all the modifications made. This command will push
        all modification made in this separated occurrence and merge them back with its original
        prototype. This will cause all occurrences based on this original prototype to inherit those
        changes. The prototype of the once separated occurrence will after that be deleted. In the
        wheel/vehicle example, all modifications made to the split wheel will be pushed back to its
        original prototype and thus to all the rest of the wheels, thus having now only one
        prototype for all four wheel occurrences.
","
Inputs



me_id

The ID of the part or part assembly of which changes will be back propagated.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
propagate_downwards=<value>
0 - Do not propogate changes of prototypes downwards in the prototype hierarchy. 
1 - Default. Propogate changes of prototypes downwards in the prototype
                  hierarchy. 
propagate_upwards=<value>
0 - Do not propogate changes of prototypes upwards in the prototype hierarchy. 
1 - Default. Propogate changes of prototypes upwards in the prototype hierarchy.
                



","Examples
Propogate changes for part 100 both upwards and downwards:
*ME_ ModuleOccurrenceBackPropagate 100 ""propagate_upwards=1, propagate_downwards=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
460,*ME_ModuleOccurrenceConvert ,"Description
Converts a module from part to part assembly and vice-versa, assuming it’s allowed from the
        current hierarchy status and entity containment rules. To check if the conversion is
        allowed, use hm_me_moduleoccurrenceconvert_isallowed.
","Inputs

id
The ID of the module to convert. The module must be an occurrence.
type
part - Converts the module to a part. That means it will become a leaf in module
            hierarchy and cannot contain other parts or part assemblies, only other entity types. A
            module explicitly created as part assembly cannot be converted to part. 
assembly - Converts the module to a part assembly. That means it will be able to hold
            other parts and part assemblies, as well as other entity types based on entity
            containment rules.
reserved
Reserved for future use. Must be set as """".

","Example
Convert module ID 168 from a part assembly to a part:
*ME_ModuleOccurrenceConvert 168 part """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
461,*ME_ModuleOccurrenceDelete,"Description
 Deletes a module part or part assembly, including any recursive contents.
","Inputs

id
The ID of the module to delete. The module must be an occurrence.
reserved
Reserved for future use. Must be set as """".

","Example
Delete module ID 168 and all its recursive contents:
*ME_ModuleOccurrenceConvert 168 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
462,*ME_ModuleOccurrenceMoveContents ,"Description
 Move the contents from one module part to another.
","Inputs

source_id
The ID of the source module part whose contents are being moved.
target_id
The ID of the target module part receiving the contents.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
purge_target=<flag>
0 - Keep the original destination part contents alongside the moved contents. 
1 - Default. Purge/delete the target module’s contents before starting the move
                  operation. 



","Example
Delete the contents in part 40, and then move the contents of part 30 to part 40:
*ME_ModuleOccurrenceMoveContents 30 40 ""purge_target=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
463,*ME_ModuleOccurrenceReparent,"Description
Move a module part or part assembly underneath another part assembly in the model
        hierarchy. This is only allowed in cases where it does not break sub-assembly
        instancing.
","Inputs

child_id
The ID of the module to move. The module must be an occurrence.
parent_id
The ID of the module part (if empty and convertible to a part assembly) or module part
            assembly to become the parent.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
matrix_mode=<mode>
0 - Retain the relative position of the child module (default). This may cause
                  the part to translate if there are matrices stored at different levels in the
                  hierarchy. 
1 - Retain the absolute position of the child module.



","Example
Reparent module 100 under part assembly 8 in the hierarchy, keeping the absolute
        matrix:
*ME_ModuleOccurrenceReparent 100 8 ""matrix_mode=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
464,*ME_ModuleOccurrencesDeleteByMark,"Description
Deletes a mark of modules.
The module must be an occurrence and cannot be root.
","
Inputs



mark_id

The ID of the mark containing the modules to delete.  Valid values are 1 and 2.

","Examples
To delete modules 1-10: 
*createmark modules 1 1-10
*ME_ModuleOccurrencesDeleteByMark 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
465,*ME_ModuleOccurrencesPurge,"Description
Empty the contents of multiple module parts or part assemblies.
","Inputs

ids
The IDs of the modules to purge, within quotes.
?options?
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
excluded_entity_types=type1 type2 … typeN
A space separated list of module entity types to not remove.
reset_representation=<flag>
0 - Keep representation reference information.
1 - Remove representation reference information.
resursive=<flag>
0 - Purge only the local module’s contents. Do not touch the child module’s
                  contents (in the case of a part assembly). 
1 - Recursively purge the module, as well as any child modules.



","Example
Purge part assemblies 168, 169, 170 and any of their child parts or part assemblies,
        removing all of their contents except for property and material entities. Remove
        representation reference information.:
*ME_ModuleOccurrencesPurge ""168 169 170"" ""recursive=1, excluded_entity_types=props mats, reset_representation=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
466,*ME_ModuleOccurrencesSyncContents,"Description
Synchronize the contents of one module occurrence to the specified target occurrences that
        shares a common module prototype.
Every module occurrence has an associated module prototype. A single module prototype may
        provide the base definition for multiple module occurrences, i.e. a prototype of a wheel,
        might have four occurrences in a vehicle. This command is applied to synchronize a single
        occurrence with one or more additional instanced occurrences of a common prototype, i.e. one
        wheel updating the 3 other wheels of a vehicle. It will clear any current contents of the
        target occurrences and copy/synchronize the contents of the source occurrence into the
        targets.
","
Inputs



source_id

The ID of the source module which provides the content to be synchronized.

target_ids

The IDs of the target modules to receive the synchronized content, within quotes if
            more than 1. Specifying a single value of 0 is a shortcut to target all other instanced
            occurrences that share a common prototype withsource_id.
?options?
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
copy_partrep_status=<value>
0 - Do not update the current rep and mapped/loaded rep status of the target
                  occurrences
1 - Update the current rep and mapped/loaded rep status of the target
                  occurrences to be same as source
excluded_entity_types=<type1> ?<type2>? ...
                    ?<typeN>?
A space separated list of module entity types to not synchronize.



","Examples
Synchronize the contents of module 22 to all other instanced occurrences that share a
        common module prototype with no additional options:
*ME_ ModuleOccurrencesSyncContents 22 0
Synchronize the contents of module 22 to specified target occurrences 24, 26 and 28. Ignore
        copying/synchronizing properties and materials (to avoid duplicates) and update the target
        occurrences’ rep statuses:
*ME_ ModuleOccurrencesSyncContents 22 ""24 26 28"" ""copy_partrep_status=1, excluded_entity_types=props mats""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
467,*ME_ModulePosition,"Description
Positions a module using its hierarchical transformation matrices.
","Inputs

id
The ID of the module to position.
position
0 - Transform to the normal position. This is the position the module will arrive to
            after applying all necessary hierarchical relative matrices. 
1 - Transform to the original position. This is the neutral position the module might
            be saved in the original representation file as. It is the original position before
            hierarchical relative matrices are applied.
reserved
Reserved for future use. Must be set to 0.

","Example
Transform module part 168 back to its original representation file position:
*ME_ModulePosition 168 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
468,*ME_TransformationMatrixSet ,"Description
Sets the transformation matrix for a module.
","Inputs

id
The ID of the module to set the transformation for.
rXcY
The row (X) and the column (Y) for the 4 x 4 transformation matrix.
is_relative
0 - An absolute matrix is passed, so internally derive the local relative matrix. 
1 - A relative (to the parent module) matrix is passed in, so use it directly. 

","Example
Translate the passed 4 x 4 absolute matrix to a relative matrix, and store this in the
        hierarchy for module 168:
*ME_TransformationMatrixSet 168 0.994123 -0.058675 0.090977 0 0.058296 0.998276 0.006823 0 -0.09122 -0.001479 0.99583 0 3171.78 508.679 1582.44 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
469,*mechadjustjoint ,"Description
Actuates a joint to reach a new value.
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the joint to adjust.
direction
The direction along which the new value will be applied: 
0 - Translation along x-axis 
1 - Translation along y-axis 
2 - Translation along z-axis 
3 - Rotation about x-axis 
4 - Rotation about y-axis 
5 - Rotation about z-axis
value
The desired value of the joint (double).
tolerance
The tolerance allowed when adjusting (double).
lock
If set to 1, all joints in the mechanism which are not part of the cycle of the given
            joint are locked.
angle_step
The size of the iterative steps used to solve for the new value of the joint. Only
            used for rotation.
hold_angles
If set to 1, this locks the rotation about axes other than the given direction. If 0,
            rotation occurs in a way such that the given axis doesn’t move. In this case the Euler
            angles about other axes can change. This is only for ball joints.

","Example
To move a joint named TORSO_to_RIGHT_UPPER_LEG to x=20 y=0 z=0 with tolerance 0.001,
        locking other joints and angle step = 0:
*mechadjustjoint ""TORSO_to_RIGHT_UPPER_LEG"" 20.0 0.0 0.0 0.001 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
470,*mechapplybodytotargetpoints ,"Description
Moves source points on the bodies of a mechanism to target points. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

bodies_array
The ID of the string array that contains the names of the bodies to update. The array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_bodies
Integer indicating the size (number of bodies) in the array created using
              *createstringarray. This must be half the
              number_of_point_pairs.
point_pairs_array
The ID of the double 2D array that contains the source and target point pairs. The
            array is created using the *createdoublearray2d command. This should always be set to 1. 
The point pair elements are given in the following order:
The point pair elements are given in the following order: 
p1x p1y p1z (coordinates of source point 1 on body1) 
p2x p2y p2z (coordinates of source point 2 on body2) 
... 
pNx pNy pNz (coordinates of source point N on body2) 
t1x t1y t1z (coordinates of target point 1 on body1) 
t2x t2y t2z (coordinates of target point 2 on body2) 
... 
tNx tNy tNz (coordinates of target point N on body2)
number_of_point_pairs
Integer indicating the rows (number of point pairs) in the array created
              using *createdoublearray2d. 
This must be twice the number_of_bodies.
number_of_point_pair_coordinates
Integer indicating the columns (number of coordinates per pair) in the array created
            using *createdoublearray2d. This must be set to 3.

","Example
To move bodies ""LEFT LOWER LEG"" and ""RIGHT LOWER LEG"", with source-target point pairs as: 
LEFT LOWER LEG: (-156.84033, 47.889306, 31.0028062) to (-148.916035, 72.1107681,
        -10.4045246) 
RIGHT LOWER LEG: (-148.979951, -66.8473281, -34.494296) to (-141.051409, -42.6880283,
        -75.937107)
*createstringarray 2 ""LEFT LOWER LEG"" ""RIGHT LOWER LEG""
*createdoublearray2d 4 3 \
-156.84033 47.889306 31.0028062 \
-148.979951 -66.8473281 -34.494296 \
-148.916035 72.1107681 -10.4045246 \
-141.051409 -42.6880283 -75.937107
*mechapplybodytotargetpoints 1 2 1 4 3

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
471,*mechcontructfromedi,"Description
Creates objects needed for solving enabled mechanisms, such as applying positions or moving
        bodies. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

mode
The mode for mechanism operations: 
0 - Move 
2 - Apply position
position
The position ID to use when mode is 2. 

","Examples
To setup mechanism with ID 1:
*mechcontructfromedi 0 0
To apply position with ID 3 on mechanism with ID 1:
*mechcontructfromedi 2 3
*mechapplyediposition 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
472,*mechimportdaf ,"Description
Imports the dummy angle file for the current dummy. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

filename
The full name and path of the file to import.

","Example
To import the current dummy DAF file as C:/temp/dummy.daf:
*mechimportdaf ""C:/temp/dummy.daf""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
473,*mechplacebodytopoint,"Description
Moves a body such that the source point on the body reaches the target point, while
        satisfying joints and constraints defined in the mechanism. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the body of the mechanism.
sx
The x-coordinate of the source point on the body.
sy
The y-coordinate of the source point on the body.
sz
The z-coordinate of the source point on the body.
tx
The x-coordinate of the target point.
ty
The y-coordinate of the target point.
tz
The z-coordinate of the target point.
tolerance
The tolerance allowed during the placement.

","Example
To move body ""LEFT LOWER LEG"" on the enabled mechanism, with tolerance 0.001, with
        source-target point pair as (-129.289718, 83.6107788, -53.376587) and target point
        (-146.452326, 80.1099172, -12.7053014):
*mechplacebodytopoint ""LEFT LOWER LEG"" -129.289718 83.6107788 -53.376587 -146.452326 80.1099172 -12.7053014 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
474,*mechrotatebody,"Description
Rotates a body of a mechanism about a normal, passing through the origin of the plane by
        given angle.
 The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the body of the mechanism.
plane
The plane, created using *createplane, whose normal is the axis of
            rotation and any point on it would be center of rotation based on the method selected.
              Valid values are 1 and 2.
angle
The angle to rotate the body about the plane.
method
Method to enforce rotation: 
0 - Free rotation, bodies orientation is rotated by angle, can result in inverted
            rotation. 
1 - Enforce axis, bodies orientation is rotated by angle. 
2 - Enforce origin, rotation will occur about line passing through origin of plane,
            inverted rotation possible. 
3 - Enforce origin and axis, direction of rotation and origin both are fixed
            (recommended).
tolerance
The tolerance allowed during the placement.
angle_step
The size of the iterative steps used to solve for the rotation.

","Example
To move body ""Move_Track"" on the current mechanism with a tolerance of 0.001, about the
        global y-axis by 20 degrees, using method 3:
*createplane 1 0 1 0 -1660.82465 103.84237 418.49172
*mechrotatebody ""Move_Track"" 1 20 3 0.001 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
475,*menufilterenable ,"Description
Enables filtering.
","Errors
None.
",,
476,*menufont,"Description
Sets the size of the menu font. 
","Inputs

size 
The size of the font to be used for the menu (1 - smallest, 4 - largest). 

","Errors
None.
",
477,*mergefile2,"Description
Merges a HyperMesh binary file into the current model,
        additionally applying Redundant Entity Management (REM). REM is supported for properties,
        materials, connectors, components and parts/part assemblies.
 Depending on the below settings, entity names or IDs in the incoming file may be
        renamed/renumbered with the least disruption possible.
","Inputs

connectors.checkattribute=<value>
This determines if connector attributes are compared when deciding if they are the
            same. Possible values are true and false. This is optional and false is the
            default.
connectors.layercheck=<value>
This determines if connector layers are compared when deciding if they are the same.
            Possible values are true and false. This is optional and false is the default.
connectors.thicknesscheck=<value>
This determines if connector thicknesses are compared when deciding if they are the
            same. Possible values are true and false. This is optional and false is the
            default.
connectors.tolerance=<value>
This specifies the tolerance to use when deciding if connectors are the same.
dropincomingmodulehierarchy=<value>
This is for special cases that need to drop any incoming module hierarchy, but keep
            the contents. Possible values are yes and no. This is optional and no is the
            default.
filename=<value>
The full path and file name of the HM binary file to merge.
mergemode.comps=<value>
Specifies how to merge the attributes of components identified as the same. Possible
            values are keepexisting, keepincoming and keepboth. This is optional and keepboth is the
            default.
mergemode.connectors=<value>
Specifies how to merge the attributes of connectors identified as the same. Possible
            values are keepexisting, keepincoming and keepboth. This is optional and keepboth is the
            default.
mergemode.geometryandmesh=<value>
Specifies how to merge the contents of components identified as the same. Possible
            values are keepexisting, keepincoming and keepboth. This option is valid only in case
            that mergemode.comps is either keepexisting or keepincoming. When mergemode.comps is
            keepboth, there will be separate components anyway. This is optional and keepboth is the
            default when valid.
mergemode.mats=<value>
Specifies how to merge the attributes of materials identified as the same. Possible
            values are keepexisting, keepincoming and keepboth. This is optional and keepboth is the
            default.
mergemode.props=<value>
Specifies how to merge the attributes of properties identified as the same. Possible
            values are keepexisting, keepincoming and keepboth. This is optional and keepboth is the
            default.
respectincomingparentmodule=<value>
This is used to guide component conflict resolution. This is necessary when an
            incoming component belongs to a different part, in comparison with the same component in
            the session. In this case the conflict is resolved either by respecting the incoming
            parent part or the in-session one. Possible values are yes and no. This is optional and
            no is the default.

","Example
To merge the file C:/temp/Rail2.hm, keeping all incoming data:
*mergefile2 filename=C:/temp/Rail2.hm mergemode.props=keepincoming mergemode.mats=keepincoming mergemode.comps=keepincoming mergemode.geometryandmesh=keepincoming
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
478,*mesh_fusing,"Description
Connect/merge the proximity regions of 2D elements within a given tolerance. Elements are
        distributed into groups based on their connectivity and component membership. The elements
        belonging to different components can be in a single group by parameter input. Only are
        different groups taken as counterparts of proximity/intersection calculation and fusing. 
","
Inputs



destination_entity_type

The destination entity type.  Valid values are elems and comps.

destination_mark_id

The ID of the mark containing the destination entities.  Valid values are 1 and
            2.
All entities can also put on this mark. The actual destination elements will be
            filtered out automatically by source_mark_id.

source_entity_type

The source entity type.  Valid values are elems and comps.

source_mark_id

The ID of the mark containing the source entities.  Valid values are 1 and 2.

""string_options""

A string that defines the advanced parameters. Each option/value pair is space
            separated, and can be specified in any order. The entire string must be enclosed in
            quotes.



adjust_elem_orientation

0 - Auto normal adjustment is not performed.
1 - For input without intersecting elements in contact regions, auto normal
                  adjustment is performed (default).

break_shell_along_component_boundaries

0 - All elements connected each other are classified as a group.
1 - Element group building stops at component boundaries. This mean that
                  elements in an element group belong to a single component. This is the
                  default.

collapse_source_fusing_lines

0 - Both source and target fusing lines remain (default).
1 - Stitch both source and target fusing lines.

excl_tangent_angle

Used to filter out some elements inside the proximity fusing regions (0,
                  90].

feature_angle

This value is used to define feature edges on mesh. Default value is 30.0.

fusing_direction

1 - The normal directions of the source elements are used as fusing directions. 
0 - Fusing direction are defined automatically (default).

fusing_elems_to_new_comp

0 - Fusing element are stored to the component of source elements
                  (default).
1 - Fusing elements are stored to the new component fusing_elems
2 - Fusing elements are stored to the current component.

keep_fusing_shell

0 - The elements inside source or destination fusing regions are deleted
                  (default).
1 - The elements inside source fusing regions are kept, while the elements
                  inside destination fusing regions are deleted.
2 - The elements inside destination fusing regions are kept, while the elements
                  inside source fusing regions are deleted.
3 - All elements inside fusing regions are kept.

kept_intersect_segment_angle

Used to decide whether some element intersection segments are kept as part of
                  fusing region boundaries (0, 90].

mark_init_prox_elems_only

1 - Only perform the proximity calculations between all source and destination
                  elements, and mark the elements within the input tolerance. 
0 - Do not do (default).

num_remesh_layers

-1 - Intersecting elements are split and stitched to obtain conformal element
                  connectivity. No remeshing is performed.
0 - Remesh only the intersecting elements.
> 0 - Remesh the specified number of layers of elements in addition to the
                  intersecting elements.

proximity_tolerance

Used to decide the fusing regions. Only the source elements with this distance
                  to the elements in the destination are considered as candidates in the source
                  fusing region. The corresponding elements in the destination within this distance
                  are the candidates corresponding to mated fusing regions.

snapping_tolerance

Used to decide whether region boundaries are allowed to snap to the free mesh
                  edges when the distance of the boundaries of the fusing regions to free mesh
                  boundaries are less than this value, and operation is possible.

tria_remesh_growth_ratio

Used to specify the triangular element size growth ratio when
                  use_adaptive_tria_remesh is 1.

use_adaptive_tria_remesh

0 - Use the default tria remesher.
1 - Use the adaptive tria remesher.



","Examples
To fuse all components, using component ""green"" as the source:
*createmark components 1 ""displayed""
*createmark components 2 ""green""
*mesh_fusing components 1 components 2 \
""feature_angle 30.0 \
 break_shell_along_component_boundaries 0 \
 mark_init_prox_elems_only 0 \
 fusing_direction 0 \
 proximity_tolerance 2.0 \
 excl_tangent_angle 65.0 \
 kept_intersect_segment_angle 45.0 \
 keep_fusing_shell 0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
479,*meshline_create_from_points,"Description
This command creates meshlines from a node list.
","Inputs

list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
reserved3
Reserved for future use. Must be set to 0.
reserved4
Reserved for future use. Must be set to 0.
reserved5
Reserved for future use. Must be set to 0.
reserved6
Reserved for future use. Must be set to 0.

","Example
To create meshlines from nodes 470, 480, 475 and 485:
*createlist nodes 1 470 480 475 485
*meshline_create_from_points 1 0 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
480,*meshline_display_scaffold ,"Description
This command deletes meshlines.
","Inputs

flag
The display state of the scaffolds. Valid values are: 
0 - Do not display scaffolds 
1 - Display scaffolds
reserved
Reserved for future use. Must be set to 0.

","Example
 To turn on display of the meshline scaffolds:
*meshline_display_scaffold 1 0
","Errors
None.
"
481,*meshline_initialize,"Description
This command initializes meshline internal structures and memory.
","Inputs

reserved
Reserved for future use. Must be set to 0. 

","Example
To initialize meshline structures and memory:
*meshline_initialize 0
","Errors
None.
"
482,*meshline_mask_class_element,"Description
This command masks underlying meshline class elements.
","Inputs

flag
0 - Turn off the underlying meshline class elements. 
1 - Turn on the underlying meshline class elements.
reserved
Reserved for future use. Must be set to 0.

","Example
To turn off the underlying meshline class elements:
*meshline_mask_class_element 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
483,*meshline_set_approximate_tol_factor ,"Description
Sets the tolerance factor for approximating meshlines with NURBs curves. 
","Inputs

tol
The tolerance factor to use. Must be > 0.0.

","Example
To set the meshline tolerance factor to 0.5:
*meshline_set_approximate_tol_factor 0.5

","Errors
None.
"
484,*meshmode ,"Description
Sets the mesh line display mode. 
","Inputs

displaylist
The display list in which the mesh mode is being set. 
mode
The mesh line mode. 
plot
1, if the display should be drawn after the mesh mode is set. 

","Errors
None.
",
485,*meshtopologyadjust ,"Description
This command is intended to work with 2D meshes created by QI meshing, batchmeshing,
        element remeshing and manual editing tools. Very often such meshes have multiple elements
        intersected by the surfaces selection boundary edges. This command attempts to adjust the
        mesh on selected surfaces to its boundary by moving nodes to the boundary, splitting
        elements or suppressing geometry edges or vertices.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
flags
A flag that controls the level of mesh adjustment to topology. Valid values are: 
0 - Adjustment ensures that all elements within the selection are not intersected by
            the selection boundary edges. It’s not guaranteed that there are no geometry vertices in
            the middle of boundary element edges. There are no topology changes for this value. 
1 - Adjustment ensures that all elements within the selection are not intersected by
            the selection boundary edges. All boundary element edges shared with any adjacent mesh
            do not have any geometry vertices in the middle. Some topology changes may occur for
            this case such as the suppression of geometry edges and vertices. 
3 - Adjustment provides that all elements within the selection are not intersected by
            the selection boundary edges. All boundary element edges (both those shared and not
            shared with any adjacent mesh) do not have any geometry vertices in the middle. Some
            topology changes may occur for this case such as the suppression of geometry edges and
            vertices.

","Example
To adjust the elements for surface 143 with full adjustment to topology edges of elements
        edges shared with adjacent mesh:
*createmark surfaces 1 143
*meshtopologyadjust 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
486,*messagefileset ,"Description
Writes certain messages to a file. All values below are case insensitive.
","Inputs

type
The type of message to write. Valid values are: 
FEINPUT - any messages passed to HM by an FE-input processes.
HM - all supported type values.
file
The full path and filename of the file to write the messages to. 

","Example
To save all FE-input error messages to a file named C:/test.dat:
*messagefileset ""feinput"" ""C:/test.dat""
*messagefilefilter ""feinput"" ""error""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
487,*metadatamarkdouble,"Description
Creates double metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The double value assigned to the metadata. 

","Example
To add metadata named Real_Val with the value 17.54 to elements 1-100:
*createmark elems 1 1-100
*metadatamarkdouble elems 1 ""Real_Val"" 17.54
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
488,*metadatamarkentityidtype ,"Description
Creates entity ID type metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
entity_type_2
The type of entity which the metadata references.
value
The entity ID value assigned to the metadata.

","Example
To add metadata named Surface with surface 100 to elements 1-100:
*createmark elems 1 1-100
*metadatamarkentityidtype elems 1 ""Surface"" surfs 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
489,*metadatamarkint ,"Description
Creates integer metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The integer value assigned to the metadata. 

","Example
To add metadata named Int_Val with the value 5 to elements 1-100:
*createmark elems 1 1-100
*metadatamarkint elems 1 ""Int_Val"" 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
490,*metadatamarkremove,"Description
Removes metadata from the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to remove metadata from the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be removed.
            Valid values are 1 and 2.
name
The name by which the metadata is referenced.

","Example
To remove metadata named Int_Val from elements 1-100:
*createmark elems 1 1-100
*metadatamarkremove elems 1 ""Int_Val""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
491,*metadatamarkstringarray,"Description
Creates string array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
string_array
The ID of the string array that contains the values. The array is created using
              the *createstringarray command. This should always be set to
            1.
number_of_strings
Integer indicating the size (number of strings) in the array created using
              *createsrtingarray. 

","Example
To add metadata named String_Vals with the values ""Warped"" and ""Elements"" to elements
        1-100:
*createmark elems 1 1-100
*createstringarray 2 ""Warped"" ""Elements""
*metadatamarkstringarray elems 1 ""String_Vals"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
492,*midmesh_inspect_delete_sets,"Description
Deletes sets created in the midmesh inspect module.  This must be preceded by a call to
          *midmesh_inspect_init. 
","
Inputs


mode
1 - Delete all midmesh inspect sets
2 - Delete empty midmesh inspect sets

","Examples
To detect and correct nodes off mid, delete empty sets, and shut down the inspect
        module:*createmark components 1 ""shell""
*createmark components 2 ""MidmeshEdges"" ""Mid""
*midmesh_inspect_init SourceEntityType=components SourceMark=1 TargetEntityType=components TargetMark=2 MinNodeOffMidDeviation=0.2
*midmesh_inspect_fix_problems nodes 2 ProblemType=NodeOffMid SmoothClusters=1 SmoothMethod=Auto
*midmesh_inspect_delete_sets 2
*midmesh_inspect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
493,*midmesh_inspect_fix_problems,"Description
Repairs found problems in the midmesh inspect module.  This must be preceded by a call to
          *midmesh_inspect_init. 
","
Inputs


entity_type
The type of entity to repair.  Valid values are elements and nodes.
mark_id
The ID of the mark of entities to repair.  Valid values are 1 and 2.
ProblemType=<value>
The type of problem to repair.  Valid values are EdgeOffSolidEdge, ElemCenterOffMid,
            NodeOffMid, and NodeOffSolidEdge.  This is a mandatory option.
SmoothClusters=<value>
Enables (1) or disables (0, default) smoothing after correction.
SmoothMethod=<value>
If SmoothClusters=1, this sets the smoothing method to use.  Valid
            values are Auto, FixShape, FixSize, and QI.

","Examples
To detect and correct nodes off mid, delete empty sets, and shut down the inspect
        module:*createmark components 1 ""shell""
*createmark components 2 ""MidmeshEdges"" ""Mid""
*midmesh_inspect_init SourceEntityType=components SourceMark=1 TargetEntityType=components TargetMark=2 MinNodeOffMidDeviation=0.2
*midmesh_inspect_fix_problems nodes 2 ProblemType=NodeOffMid SmoothClusters=1 SmoothMethod=Auto
*midmesh_inspect_delete_sets 2
*midmesh_inspect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
494,*midmesh_repair,"Description
This command provides various modes/operators to edit midmeshes. This command assumes the
        midmesh will be in single component, and the topology is well defined by 1d elements which
        are also in single component other than the midmesh component.
","
Inputs



mode

The midmesh mode/operator to use.
Each mode has a different set of required and/or optional string inputs as listed
            below.



AlignEdgeByLines

Used to align a list of nodes in order with respect to a given list of lines. It
                  will also create 1D elements between the given list of nodes if doesn’t
                  exist.
Valid strings are:

LineList1=<list_id>

The ID of the list of upper lines to align to, created by
                          *createlist. Valid values are 1 and 2.

LineList2=<list_id>

The ID of the list of lower lines to align to, created by
                          *createlist. Valid values are 1 and 2.

NodeList=<list_id>

The ID of the list of nodes to be aligned, created by
                          *createlist.  Valid values are 1 and 2.



AlignEdgeToMidOfLines

Used to align nodes/edges to the middle of two lines. This mode can also take
                  disconnected lines as input provided they are in close proximity.
Valid strings are:

LineList=<list_id>

The ID of the list of lines to align to, created by
                          *createlist. Valid values are 1 and 2.

NodeList=<list_id>

The ID of the list of nodes to be aligned, created by
                          *createlist. Valid values are 1 and 2.



AlignFace

Used to align elements to given surfaces.
Valid strings are:

Elemmark=<mark_id>

The ID of the mark of elements to align.  Valid values are 1 and 2.

Surfmark=<mark_id>

The ID of the mark of surfaces to align to.  Valid values are 1 and
                        2.

?lockBoundaryNodes=<mode>?

0 - Do not lock/anchor boundary nodes (default)
1 - Lock/anchor boundary nodes

?useOffset=<value>?

Selected elements will be aligned to this value from the surfaces (default
                        is off).



AlignTEdge

Used to align T-connections to the selected surfaces while attempting to
                  maintain the tangency of the faces which are attached to the T-edge but not facing
                  the selected surface.
Valid strings are:

a1DElemmark=<mark_id>

The ID of the mark of 1D elements corresponding to the T-edges. Valid
                        values are 1 and 2.

Surfmark=<mark_id>

The ID of the mark of the surfaces to align to. Valid values are 1 and
                        2.



AlignToMid

Used to align elements to the middle of two surfaces.
Valid strings are:

Elemmark=<mark_id>

The ID of the mark of elements to align. Valid values are 1 and 2.

Surf1mark=<mark_id>

The ID of the mark of the upper surfaces to align to. Valid values are 1
                        and 2.

Surf2mark=<mark_id>

The ID of the mark of the lower surfaces to align to. Valid values are 1
                        and 2.

?lockBoundaryNodes=<mode>?

0 - Do not lock/anchor boundary nodes (default)
1 - Lock/anchor boundary nodes



CreateMidEdge

Used to create 1D elements linearly interpolated between the selected
                  nodes.
Valid strings are:

Node1=<id>

The ID of the first node to connect by 1D elements.

Node2=<id>

The ID of the first node to connect by 1D elements.

?ElementSize=<value>?

The size of 1D element to be created.

?OutputCompId=<id>?

The ID of the compoent where 1D elements are to be created.



CreateMidEdgeByLines

Used to create 1D elements in the middle of the pair of input guiding surface
                  edges.
If no set of guide edges is selected, 1D elements are created by linearly
                  interpolating between the selected nodes.
If one set of guide edges is selected (either Lines1Mark or
                    Lines2Mark can be used), 1D elements created at an offset
                  distance of the selected nodes from the selected set of guide line(s).
If both sets of guide edges are selected, 1D elements are created in the middle
                  of the pair of guide line(s).
Valid strings are:

Node1=<id>

The ID of the first node to connect by 1D elements.

Node2=<id>

The ID of the first node to connect by 1D elements.

Lines1Mark=<mark_id>

Optional.
The ID of the mark of the first set of surface edge guiding pairs.  Valid
                        values are 1 and 2.

Lines2Mark=<mark_id>

Optional.
The ID of the mark of the second set of surface edge guiding pairs.  Valid
                        values are 1 and 2.

?ElementSize=<value>?

The size of 1D elements to be created.

?OutputCompId=<id>?

The ID of the compoent where 1D elements are to be created.



DetectIntersections

Detects intersections/overlaps and free edges (gaps) in the provided input
                  elements and groups them into element clusters. The clusters are added as element
                  sets in the model.
Valid strings are:

ElementMark=<mark_id>

The ID of the mark of elements for which intersections/overlaps/free edges
                        (gaps) are to be detected. Valid values are 1 and 2.

?ShowIntersectionLines=<value>?

0 - Do not show intersection lines (default)
1 - Show intersection lines



FillLoop

Used to fill a loop of 1D elements and free edges. Free edges are considered in
                  order to form the desired loop. If unable to detect the loop, it will create
                  temporary 1Ds in sets for the traversed path so as to lay a platform to complete
                  the loop in the subsequent selection.
Valid strings are:

ElemMark=<mark_id>

The ID of the mark of elements on the edges of the desired loop. Valid
                        values are 1 and 2.

delete1D=<value>

Option whether to delete 1Ds which will become internal after fill. 1D
                        elements which will become non-manifold and boundary after fill will not be
                        deleted.
0 - Do not delete
1 - Delete



RepairFace

Used to repair minor problems in the midmesh output automatically, such as
                  intersections, element overlaps, sliver elements and holes, provided the mesh
                  topology is close to the required topology.  Set entities with the prefix
                  ^Midmesh_IntxnCluster- , as created by the DetectIntersections
                  mode, are reevaluated for newly generated elements for intersection and gaps.
Valid strings are:

ElementMark=<mark_id>

The ID of the mark of elements to repair. Valid values are 1 and 2.

?ElementSize=<value>?

The size of 1D and 2D elements to be created.

?OutputComp1Id=<id>?

The ID of the compoent where 1D elements are to be created.

?OutputComp2Id=<id>?

The ID of the compoent where 2D elements are to be created.



SplitByNodeEdge

Used to trim the mesh from node-to edge, creating 1D elements in the path.
Valid strings are:

NodeId=<id>

The ID of the node to use to trim.

a1DElemmark=<mark_id>

The ID of the mark of 1D elements that define the edge. Valid values are 1
                        and 2.

mode=<value>

The mesh will be trimmed from the given node to the given set of 1D
                        elements by:
1 - Shortest path, using the shortest distance from the given node to the
                        set of given 1D elements
2 - Tangential path, using the tangential direction of the scratch edge
                        connected to the node
3 - Mixed path, similar to tangential path except when the angle of
                        intersection with the selected 1D elements is < 30 degree, it recedes
                        back to an appropriate point from where it uses shortest path to the
                        selected 1D elements
4 - Point on line, split from a source node to a selected location on a 1D
                        element.  Requires SplitPoint to be defined.



?SplitPoint=<id>?

A space separated list of coordinates for the point on the 1D element when
                          mode=4.



?OutputCompId=<id>?

The ID of the compoent where 1D elements are to be created.



SplitByNodes

Used to trim the mesh from node-to-node, creating 1D elements in the path.
Valid strings are:

SourceNode=<id>

The ID of the first trim node.

TargetNode=<id>

The ID of the second trim node.

?OutputCompId=<id>?

The ID of the compoent where 1D elements are to be created.





string_array

The ID of the string array that contains the additional optional input parameters. The
            string array is created using the *createstringarray command. This
            should always be set to 1.
Valid parameters and their syntax are given above along with their corresponding
              mode.

number_of_strings

Integer indicating the size (number of strings) in
            string_array.

","Examples
AlignEdgeByLines:
*createlist nodes 1 296091 308312 308313 308314 122319
*createlist lines 2 13433 13711
*createstringarray 2 ""NodeList = 1"" ""LineList = 2""
*midmesh_repair AlignEdgeByLines 1 2
AlignEdgeToMidOfLines:
*createlist nodes 1 104348 104350
*createlist lines 1 3770
*createlist lines 2 3098
*createstringarray 3 ""NodeList = 1"" ""LineList1 = 1"" ""LineList2 = 2""
*midmesh_repair AlignEdgeToMidOfLines 1 3
AlignFace:
*createmark elements 1 775184-775196 775198-775221
*createmark surfaces 1 4458
*createstringarray 4 ""Elemmark = 1"" ""Surfmark = 1"" ""UseOffset = 2"" ""lockBoundaryNodes = 1""
*midmesh_repair AlignFace 1 4
AlignTEdge:
*createmark elements 2 641791 641801 641812 641819 641828 641839 641853
*createmark surfaces 1 4458
*createstringarray 2 ""a1DElemmark = 2"" ""Surfmark = 1""
*midmesh_repair AlignTEdge 1 2
AlignToMid:
*createmark elements 1 641791 641801 641812 641819 641828 641839 641853
*createmark surfaces 1 6945 6940
*createmark surfaces 2 4746 4731
*createstringarray 3 ""ElemMark = 1"" ""Surf1Mark = 1"" ""Surf2Mark = 2""
*midmesh_repair AlignToMid 1 3
CreateMidEdge:
*createstringarray 3 ""Node1 = 393803"" ""Node2 = 397834"" ""ElementSize = 2"" 
*midmesh_repair CreateMidEdge 1 3
CreateMidEdgeByLines:
*createmark lines 1 6825
*createmark lines 2 8525
*createstringarray 6 ""Node1 = 327644"" ""Node2 = 327650"" ""Lines1Mark = 1"" ""Lines2Mark = 2"" ""ElementSize = 2""
*midmesh_repair CreateMidEdgeByLines 1 6
DetectIntersections:
*createmark elements 1 723914 781519
*createstringarray 2 ""ElementMark = 1"" 
*midmesh_repair DetectIntersections 1 2
FillLoop:
*createmark elements 2 946766 946784 946816-946821
*createstringarray 2 ""ElemMark = 2""""delete1D = 0""
*midmesh_repair FillLoop 1 2
RepairFace:
*createmark elements 1 723914 781519
*createstringarray 2 ""ElementMark = 1"" ""ElementSize = 2""
*midmesh_repair RepairFace 1 2
SplitByNodeEdge (mode 2):
*createmark elements 1 644746 765688-765716
*createstringarray 3 ""NodeId = 375350"" ""a1DElemMark = 1"" ""Mode = 2""
*midmesh_repair SplitByNodeEdge 1 3
SplitByNodeEdge (mode 4):
*createmark elements 1 644746
*createstringarray 3 ""NodeId = 375350"" ""a1DElemMark = 1"" ""Mode = 4"" ""SplitPoint = 368.227914 -3524.695550 703.658554""  
*midmesh_repair SplitByNodeEdge 1 4
SplitByNodes:
*createstringarray 2 ""SourceNode=363142"" ""TargetNode=363179"" 
*midmesh_repair SplitByNodes 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
495,*midsurface_accept_point_target,"Description
Assigns a target point to a vertex.
","Inputs

face
The index of the surface to offset.
offset_x
The X value of the point to be offset.
offset_y
The Y value of the point to be offset.
offset_z
The Z value of the point to be offset.
target_x
The X value of the pilot point.
target_y
The Y value of the pilot point.
target_z
The Z value of the pilot point.
istarget
0 - The target is the midpoint between the offset point and the pilot point. 
1 - The target point is the pilot point. 
2 - The target is the midpoint between the offset point and the pilot point, and it is
            combined with any other targets existing at the same vertex. The combined target
            displays in the new target component. 
3 - The target is the pilot point, and it is combined with any other targets existing
            at the same vertex. The combined target displays in the new target component. 
-1 - The command ignores the pilot point and combines the targets that existed at the
            vertex.

","Example
 Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in). 
","Errors
None.
"
496,*midsurface_collapse_lines ,"Description
Sets the selection of lines to be collapsed during mid-surface extraction when performing a
        rerun operation. 
","Inputs

mark_id
The ID of the mark containing the lines to collapse. Valid values are 1 and 2.

","Example
To set the lines with IDs 5-7 to collapse during the mid-surface extraction when performing
        a rerun operation:
*createmark lines 1 5 6 7
*midsurface_collapse_lines 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
497,*midsurface_display_plate_sides,"Description
 Creates two components that contain copies of the model surfaces belonging to two sides of
        a given plate.
","Inputs

plate_number
Specifies the plate number for which the plate side information is to be created.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To show the plate information for the plate with plate number 127:
*midsurface_display_plate_sides 127 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
498,*midsurface_edit_base_surfaces,"Description
Adds or removes surfaces to the base surfaces used in midsurfacing.
","Inputs

mark_id
The ID of the mark containing the surfaces to add or remove. Valid values are 1 and 2.
mode
The mode for the selected surfaces. Valid values are: 
1 - Add to base surfaces 
-1 - Remove from base surfaces
distance
The distance from the base surfaces to the mid-surface.
skip_drawing_duplicates
0 - Draw duplicate unfaceted surfaces (with surface lines) inside the ""^Base surfaces""
            component.
1 - Skip drawing duplicate unfaceted surfaces (with surface lines) inside the ""^Base
            surfaces"" component.

","Example
To add surfaces 10 and 20 with a distance of 1.5 to the base surfaces:
*createmark surfs 1 10 20
*midsurface_edit_base_surfaces 1 1 1.5 0
","Errors
None.
"
499,*midsurface_imprint,"Description
The command modifies surfaces by adding extra trim lines obtained from the lines or
        surfaces specified by the user. The new trim lines are obtained by trimming the
        corresponding surfaces in the direction normal to that surface using the selected lines or
        edges of the selected surfaces. The command tries to detect the corresponding mid-surface
        automatically, or uses the surfaces explicitly specified by the user.
","Inputs

entity_type
The type of entity selected for imprinting. Valid values are surfaces and lines.
imprint_mark_id
The ID of the mark containing the input lines or surfaces. Valid values are 1 and 2.
target_mark_id
The ID of the mark containing the surfaces to imprint onto. Valid values are 1 and 2. If there are no surfaces on the mark, the algorithm attempts to
            automatically find all relevant middle surfaces to imprint onto.
line_extend_option
Specifies whether and how the new trim edges added upon imprinting are extended
            towards the pre-existing middle surface edges. 
0 - Imprint lines as-is without any extension, without preserving fixed or end points. 
1 - Imprint lines and extend their projections on the middle surface via a shortcut to
            the nearest surface edge, without preserving fixed or end points. 
2 - Imprint lines and extend their projections on the middle surface in the direction
            of tangents at the line endpoints towards the edge of the corresponding middle surface,
            without preserving fixed or end points. 
3 - Imprint lines as-is without any extension, preserving fixed and end points. 
4 - Imprint lines and extend their projections on the middle surface via a shortcut to
            the nearest surface edge, preserving fixed and end points. 
5 - Imprint lines and extend their projections on the middle surface in the direction
            of tangents at the line endpoints towards the edge of the corresponding middle surface,
            preserving fixed and end points.
surface_imprint_option
Specifies which edges of selected surfaces will be imprinted. 
Bit values are used and the value is calculated as (Bit0 + 2*Bit1 + 4*Bit2).
Bit0:
0 - Imprint all edges of the selected surfaces 
1 - Use ""smart imprint"" to imprint only the necessary edges of the selected
                  surfaces. The algorithm will decide if the edge needs to be imprinted or not;
                  heuristically, the algorithm will skip edges that imprinted edge would come too
                  close to a pre-exisiting surface edge on the target surface.
Bit1:
0 - Imprint edges not on the external boundary of the selected surfaces, as well
                  as edges that are common to several selected surfaces 
1 - Skip edges not on the external boundary of the selected surfaces, as well as
                  edges that are common to several selected surfaces
Bit2:
0 - Imprint edges close to junctions 
1 - Skip edges close to junctions; i.e. edges whose projections are closer than
                  a given distance to other mid-surface edges. This distance can be defined
                    by min_gap_size or detected automatically.


min_gap_size
When surface_imprint_option Bit2 is used, the imprinted lines
            should be no closer than this distance to any pre-existing edges of the mid-surface. The
            default value is 0, which indicates the parameter is calculated internally
            automatically.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
reserved3
Reserved for future use. Must be set to 0.
reserved4
Reserved for future use. Must be set to 0.

","Example
To imprint lines 36800-36802 onto the appropriate mid-surfaces, extending the projected
        lines in the direction of tangents, without preserving fixed points or endpoints:
*createmark lines 1 36800 36801 36802
*createmark surfaces 2
*midsurface_imprint LINES 1 2 2 0 0.0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
500,*midsurface_new_plate ,"Description
The command creates a new plate from the surfaces on the input mark. The plate component,
        for visualizing the newly created plate and containing copies of the original model’s
        surfaces, is also created. If the surfaces on the input mark previously had different plate
        attributes, their copies in the temporary plate components are deleted.
If the base surface information is set to be taken into account, the command will also do a
        preliminary check whether the given set of surfaces includes any base surfaces or not. If
        there is any base surface present and the intended merged plate type is ""planar"" or ""sweep"",
        the command will not do anything.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
plate_type
This parameter specifies the type of merged plate to create. Valid values are: 
0 - Create plate of type ""auto"" 
1 - Create plate of type ""planar"" 
2 - Create plate of type ""offset"" 
3 - Create plate of type ""sweep""
use_base_surfaces
This specifies whether the user-defined base surfaces will be taken into account when
            displaying the plate information. Valid values are: 
0 - Base surface information is not taken into account. There is no restriction as to
            which surfaces can be used to merge into a single plate. 
1 - Base surface information is taken into account. If the input mark contains a base
            surface, the command will not do anything in cases when the intended plate type is
            planar or sweep.
reserved
Reserved for future use. Must be set to 0.

","Example
To set the surfaces with ID 5-7 to become a new plate of type offset, without including a
        check for the input mark to contain base surfaces:
*createmark surfaces 1 5 6 7
*midsurface_new_plate 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
501,*midsurface_remove_display_plate_sides ,"Description
Deletes the two components that contain copies of the model surfaces belonging to two sides
        of a given plate.
","Inputs

plate_number
Specifies the plate number for which the plate side information is to be deleted.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To delete the plate information for the plate with plate number 127:
*midsurface_remove_display_plate_sides 127 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
502,*midsurface_remove_edge_target_by_number ,"Description
Removes a target from a surface edge specified by a line number. 
","Inputs

face
The index of the surface to offset.
e1_line_number
The edge from which targets are to be removed.

","Example
You cannot manually employ this command, because HyperMesh must
        internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
503,*midsurface_remove_new_target ,"Description
No arguments are required for this command.
","Errors
None.
",,
504,*midsurface_remove_target,"Description
Finds the surface vertex that is closest to a chosen point and, if it is close enough,
        removes targets from this vertex.
","Inputs

face
The index of the surface to offset.
offsetpoint_x
The X coordinate of a point near the desired vertex.
offsetpoint_y
The Y coordinate of a point near the desired vertex.
offsetpoint_z
The Z coordinate of a point near the desired vertex.
point_sel_code
This argument is not currently used (0).

","Example
You cannot manually employ this command, because HyperMesh must
        internally generate the index values (they cannot simply be typed in). 
","Errors
None.
"
505,*midsurface_show_for_edit,"Description
Displays all targets that are attached to the surface vertices and edges.
","Inputs

surface 
The ID of the surface whose vertex targets you wish to display.

","Example
To display the targets of a surface with ID 213:
*midsurface_show_for_edit 213
","Errors
None.
"
506,*midsurface_unsuppress_conflict_edges,"Description
Unsuppresses edges that separate surfaces with differing plate information.  This happens
        when one of the surfaces has plate information and the other does not, when the two surfaces
        have different plate numbers, or when the two surfaces have different plate types.
","Inputs

reserved1
Reserved for future use.  Must be set to 0.
reserved2
Reserved for future use.  Must be set to 0.

","Example
To unsuppress all edges of the model that separate surfaces with differing plate
        information:
*midsurface_unsuppress_conflict_edges 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
507,*midsurfaceextract,"Description
This command extracts a midsurface from a pair of two surfaces. 
Previously, this command was also used to extract a midsurface from a solid or from
        multiple surfaces. The command will still work in that manner for backwards compatibility
        but the command *midsurface_extract_10 is now recommended for those
        situations. The options listed below are the currently recommended options. See the
        documentation in 8.0 for the list of previous options.
","Inputs

entity_type
The type of surface selected for midsurface extraction. Surfaces and splines are
            supported.
mark_id
The mark of surfaces selected for midsurface extraction. The number of selected
            surfaces should be 2. The number of surfaces is counted from the total number of
            physical surfaces selected. If two surfaces are combined into one by suppressing the
            edge between them, they count as two surfaces rather than one.
mode
1 - Surface pair without ""combine with adjacent plates"" and ""combine all adjacent
            plates"" options. 
2 - Surface pair with ""combine with adjacent plates"" and without ""combine all adjacent
            plates"" options. 
3 - Surface pair with ""combine with adjacent plates"" and ""combine all adjacent plates""
            options.
thickness_bound
Not required for surface pair extraction. Value = 0.
min_thickness
Not required for surface pair extraction. Value = 0.
max_thickness
Not required for surface pair extraction. Value = 0.
reserved_1
Reserved for future development. Value = undefined.
reserved_2
Reserved for future development. Value = 0.
reserved_3
Reserved for future development. Value = 0.
new_or_curr_comp
0 - Midsurface will be created in the current component. 
1 - Midsurface will be created in a new component named middle surface.

","Example
To extract the midsurface between surfaces 10 and 15 using the ""combine with adjacent
        plates"" and ""combine all adjacent plates"" options and organize them into the ""middle
        surface"" component:
*createmark surfs 1 10 15
*midsurfaceextract surfs 1 3 0 0 0 0 0 0 1
","Errors
None.
"
508,*migratetorigidwall,"Description
Converts RWALL from groups to rigidwalls with config 301, and RWALADD from loadcols to
        rigidwalls with config 302 for OptiStruct.
","
Inputs
None.",ExamplesNone.,ErrorsNone.
509,*minmaxtitlemove ,"Description
Moves a minimum or maximum title.
","Inputs

xmin
The x value of the upper left corner of the title (0.0 - 1.0).
ymin
The y value of the upper left corner of the title (0.0 - 1.0).
xmax
The x value of the lower right corner of the title (0.0 - 1.0).
ymax
The y value of the lower right corner of the title (0.0 - 1.0).
type
0 - Node title (contour plot) 
1 - Element title (assigned plot)
minmax
0 - Minimum title 
1 - Maximum title

","Errors
None.
",
510,*minmaxtitlesetfont ,"Description
Sets the font of a minimum or maximum title.
","Inputs

font
The font number for the descriptor (1-4).
type
0 - Node title (contour plot) 
1 - Element title (assigned plot)
minmax
0 - Minimum title 
1 - Maximum title

","Errors
None.
",
511,*modelcheck_applyautocorrection,"Description
Runs auto correction on the model, if checks are run.
If executed with no arguments, then auto correction is applied on all checks for all entity
        types. The order in which auto correction is applied depends on the order in which checks
        are defined in the config file.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.
If not provided, then auto correction is applied on all the checks of the
              entity_type for the profile that are run.
If ""ALL"" is provided, then auto correction is applied on all checks of the
              entity_type.

entity_type

The type of entity to be validated.
If not provided, then auto corretion is applied on all checks of all entity types for
            the profile that are run.
If ""ALL"" is provided, then checks of all entity types are considered.

error_type

The type of errors to check, ERROR, WARNING, INFO or ALL.
If not provided or set to ""ALL"", then all checks of all error types are run.

mark_id

The ID of the mark of entities for which model checker is to be run. Valid values are
            1 and 2.

","Examples
Run auto correction on the check named ""checkname"":
*modelcheck_applyautocorrection checkname
Run auto correction on properties 1-10 :
*createmark props 1 1-10
*modelcheck_applyautocorrection """" props ERROR 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
512,*modelcheck_applycorrection,"Description
longDescription
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

correction_display_name

The GUI name of the correction. This is case sensitive.
If not provided, the then default auto correction associated with the check is
            applied.

","Examples
To run the ""Delete unused materials"" auto correction for ""Unused materials"":
*modelcheck_applycorrectionon ""Unused materials"" ""Delete unused materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
513,*modelcheck_createchecks,"Description
Loads a model check config file and creates check and correction entities.
","
Inputs



filename

The full path and file name of the config file to load.

add

0 - Only the checks in the new config file will be loaded (default)
1 - The config file is appended onto the existing checks

","Examples
To load the config file
        C:/temp/my_checks.xml:*modelcheck_createchecks ""C:/temp/my_checks.xml""
To append the config file
        C:/temp/my_checks.xml:*modelcheck_createchecks ""C:/temp/my_checks.xml"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
514,*modelcheck_organizechecks,"Description
Organize the model check entities under a given parent folder.
","
Inputs



parent_name

The name of the parent folder to move the checks into.

entity_type

Must be set to modelcheckchecks.

mark_id

The ID of the mark containing the checks to move.  Valid values are 1 and 2.

","Examples
To move checks 23, 24 and 27 to the ERROR folder:
*createmark modelcheckchecks 1 23 24 27
*modelcheck_organizechecks ""ERROR"" modelcheckchecks 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
515,*modent_addcontentsbyids,"Description
Adds entities to a modular entity via IDs. Selection by IDs is mainly useful for adding
        include entities, which cannot be selected by mark. 
Include contents will be merged.
","
Inputs


modular_entity_type
The type of modular entity to update. Valid values are subsystemconfigurations,
            subsystems and subsystemsets.
modular_entity_id
The ID of the modular entity to update.
content_entity_type
The type of entity to add.
content_entity_ids
A quoted list of the entity IDs to add.
representation_key
The representation key of the subsystem to populate.  This defaults to the only
            realized representation and can be omitted.

","Examples
Add the contents of includes 4, 6 and 8 under subsystem
        2:*modent_addcontentsbyids subsystems 2 includes ""2 4 6""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
516,*modent_addrepresentations,"Description
Adds representation information to a modular entity.
","
Inputs


entity_type
The type of modular entity to add the representation information to.  Currently only
            supported for subsystems.
entity_id
The ID of the modular entity.
representation_key
The key of the representation to add, which is unique per subsystem.
representation_file
The full path and file name of the representation.
representation_file_format
The representation file format. Valid values are Nastra, OptiStruct, Ls-Dyna, Radioss
            Block, Pamcrash 2G, and Abaqus.

","Examples
Add a representation with key ""crash5"", file C:/representations/Subsystem1_Crash5mm.k, and
        format Ls-Dyna to subsystem
        3:*modent_addrepresentations subsystems 3 ""crash5"" ""C:/representations/Subsystem1_Crash5mm.k "" ""Ls-Dyna""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
517,*modent_deleterepresentation,"Description
Deletes the representation information from a mark of modular entities.
","
Inputs


entity_type
The type of modular entity to delete the representation from.  Currently only
            supported for subsystems.
mark_id
The ID of the mark of modular entities.  Valid values are 1 and 2.
representation_key
The key of the representation to delete, which is unique per subsystem.
delete_representation_file
0 - Keep the representation file in the file system
1 - Delete the representation file from the file system

","Examples
Delete the information for representation with key ""crash5"" from subsystem 3, and keep the
        file in the file
        system:*createmark subsystems 1 ""by id only"" 3
*modent_deleterepresentation subsystems 1 ""crash5"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
518,*modent_realizerepresentation,"Description
Loads the contents of a modular entity representation.
","
Inputs


entity_type
The type of modular entity to load the representation to.  Currently supported only
            for subsystems.
entity_id
The ID of the modular entity.
representation_key
The representation key to load.  This is unqiue per subsystem.

","Examples
Load the contents of the representation key ""crash5"" to subsystem
        3:*modent_realizerepresentation subsystems 3 ""crash5""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
519,*modent_removecontentsbyids,"Description
Removes entities from a modular entity via IDs. Selection by IDs is mainly useful for
        adding include entities, which cannot be selected by mark. 
","
Inputs


modular_entity_type
The type of modular entity to update. Valid values are subsystemconfigurations,
            subsystems and subsystemsets.
modular_entity_id
The ID of the modular entity to update.
content_entity_type
The type of entity to remove.
content_entity_ids
A quoted list of the entity IDs to remove.

","Examples
Remove the contents of include 2 from subsystem
        3:*modent_removecontentsbyids subsystems 3 includes ""2"" 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
520,*modent_saverepresentation,"Description
Saves the contents of a modular entity representation.
","
Inputs


entity_type
The type of modular entity to save the representation of.  Currently only supported
            for subsystems.
entity_id
The ID of the modular entity.
options
Optional list of quoted, comma separated option strings.


repKey=<value>
The representation key.  This is unique per subsystem.


filepath=<value>
The full path and file name of the representation file.



","Examples
Save the contents of subsystem 3 as a representation with key ""crash5"" in location
        ""C:/representations/Subsystem3_Crash5mm.k"":*createmark comps 1 ""by id only"" 4 6 8
*modent_saverepresentation subsystems 3 ""repKey=crash5, filepath=C:/representations/Subsystem3_Crash5mm.k""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
521,*modifyicelement ,"Description
Modifies a dependent node of an IC element.
","Inputs

id
The ID of the IC element to modify.
mode
1 - Move up in the order 
2 - Move down in the order 
3 - Delete
node_id
The ID of the node to modify.

","Example
Create an IC element with independent node 15, and dependent nodes to 16, 17, 18, 19 with
        DOF’s 123, 345, 1234, 123456, then remove node 18:
*icelementcreate
*createintarray2d 2 4 16 17 18 19 123 345 1234 123456
*addicconnectivity 1 15 1 2 4
*modifyicelement 1 3 18
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
522,*morphalteranglevec ,"Description
Alters the angle for three nodes using morphing and measuring perpendicular to a
        vector.
","Inputs

h1type
Handles
h1mark
Handle mark number - end a
h2type
Handles
h2mark
Handle mark number - end b
n1
ID of node - end a
n2
ID of node - vertex
n3
ID of node - end b
hold
Determines which of the three nodes should be held: 
0 - Hold end a 
1 - Hold end b 
2 - Hold middle
ang
New angle between n1 and n3 with
              n2 as the vertex
sym
Flag to determine whether or not to use symmetry: d 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag to determine whether or not to use constraints: 
0 - Do not use constraints 
1 - Use constraints
vec
Vector mark number

","Example
*morphalteranglevec (HANDLES,0,HANDLES,1,132,783,171,0,45.0,1,1,1)
The handles on the marks will be moved based on hold through an angle
        based on the current angle and ang, measured perpendicular to vector
          vec, and using n1, n2, and n3 to
        determine the perturbations. If symmetry is used all handles linked to marked handles by
        symmetry will also be perturbed. If constraints are used they will be applied to the
        perturbations. 
","Errors
None.
"
523,*morphalterdistancevec ,"Description
Alter the distance between two nodes using morphing and measuring along a vector.
","Inputs

h1type
Handles
h1mark
Handle mark number - end a
h2type
Handles
h2mark
Handle mark number - end b
n1
ID of node - end a
n2
ID of node - end b
hold
Specify which part of the 2-node system to anchor: 
0 - Hold end a 
1 - Hold end b 
2 - Hold middle
dist
New distance between n1 and n2
sym
Flag for use of symmetry: 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag for use of constraints: 
0 - Do not use constraints 
1 - Use constraints
vec
Vector mark number

","Example
*morphalterdistancevec (HANDLES,0,HANDLES,1,132,783,0,100.0,1,1,1)
The handles on the marks will be moved based on hold to create the new
        distance dist between n1 and n2 as
        measured along vector vec. If symmetry is used, all handles linked to
        marked handles by symmetry will also be perturbed. If constraints are used, they will be
        applied to the perturbations.
","Errors
None.
"
524,*morphapplylargedomains ,"Description
Applies current morphing to large domains.
","Example
*morphapplylargedomains
This command applies any current morphing that affects any large domains to those large
        domains. 
This command is only needed when the bigdomainsolve parameter is set to
        manual (0.0). For other values the large domain solver will be applied automatically.
","Errors
None.
",
525,*morphbiasstyle ,"Description
Applies updated bias style retroactively to existing perturbations.
","Inputs

style
The biasing style to use: 
0 - Exponential 
1 - Sinusoidal
con
Use/do not use symmetry: 
0 - Do not use symmetry 
1 - use symmetry

","Example
*morphbiasstyle (1,1)
Recalculates and reapplies all morphs on the morph list in terms of the updated biasing
        factors.
","Errors
None.
"
526,*morphbiasupdatemulti ,"Description
Updates the bias factor for the handles on the mark.
","Inputs

htype
HANDLES
hmark
Handle mark number
bias
New bias value

","Example
*morphbiasupdatemulti(HANDLES,1,2.0)

Updates the handles on the mark to the given bias factor.
","Errors
None.
"
527,*morphcombineedges,"Description
Combines multiple edge domains into one edge domain. 
","Inputs

dtype
DOMAINS
dmark
Domain mark number
rethand
0 - Do not retain handles 
1 - Retain handles

","Example
*morphcombineedges (DOMAINS,1,1)
This command all selected edge domains into one edge domain. 
The following cases are not allowed: edges which form internal loops (but a single loop is
        fine), edges which have too many overlaps, edges which do not connect. 
","Errors
None.
"
528,*morphconnstodoms ,"Description
This command will create a general domain for each of the connectors on the mark. Each
        general domain will contain all of the elements of the associated connector regardless of
        their type.
","Inputs

entity_type
Valid value is connectors.
mark_id
Mark of connectors. Valid values are 1 and 2.
retain_handles
0 - Do not retain handles 
1 - Retain handles
create_type
0 - Create as normal general domain 
1 - Create as independent domain 
2 - Create as slave domain 
3 - Create as master domain 
4 - Create as cluster domain
If 0 is specified, the domain is created as a general domain, which means that no
            handles will be created for it and it will not share the same behavior as any 1D domains
            in the model. If one of the other options is selected, the general domain will have
            handles created for it in the same way that handles are created for 1D domains of the
            selected type. The general domain will also have the same behavior as 1D domains of the
            selected type (independent, master, slave, cluster).

","Example
To create cluster type domains for all connectors in the model:
*createmark connectors 1 ""all""
*morphconnstodoms connectors 1 0 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
529,*morphconstraintcreateangle ,"Description
Creates a model type constraint based on the angle between three nodes.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
type
0 - Measure angle node to node 
1 - Measure angle using vector
name
Name of morph constraint
n1
First end of angle
n2
Vertex of angle
n3
Second end of angle
vec
Mark number of vector
angle
Constrained angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
color
The color of the constraint. Valid values are 1 through 64.

","Example

*morphconstraintcreateangle (SHAPES,1,0,""angle"",21,22,23,1,45.0,0,32)
This command creates a model type constraint for the three selected nodes with the option
        of having those nodes measured in the plane that they lie in or perpendicular to a vector
        and the option of having the angle forced to be greater than, less than, or equal to the
        specified angle. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
530,*morphconstraintcreateavm,"Description
This command creates a model type constraint for the elements on the mark with the option
        of having the area, volume, or mass forced to be greater than, less than, or equal to the
        specified value. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
etype
Must be set to elements
emark
The ID of the mark containing the elements. Valid values are 1 and 2.
type
0 - Area 
1 - Volume 
2 - Mass
name
The name of morph constraint.
target
The constrained value for area, volume, or mass.
bound
-1 - Greater than specified target 
0 - Equal to specified target 
1 - Less than specified target
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a constraint named ""area"" where the area is specified to be exactly 3600:
*morphconstraintcreateavm shapes 1 elements 1 0 ""area"" 3600.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
531,*morphconstraintcreateedge ,"Description
This command creates a tangency type constraint either between two edge domains or 2D
        domains or at the end of one edge domain. For the master type, dptr1 is
        the master and dptr2 is the slave. For the slave type,
          dptr2 is the master and dptr1 is the slave. For the
        attached type, dptr1 follows dptr2.
","Inputs

name
The name of morph constraint.
dptr1
The ID of the edge or 2D domain.
dptr2
The ID of the edge or 2D domain.
end
The ID of node at fixed end (for fixed type).
type
1 - Fixed (edge domains only) 
2 - Master (edge domains only) 
3 - Slave (edge domains only) 
4 - Continuous 
5 - Attached (edge domains only)
vec
The ID of the vector created using *createvector. Must be set to
            1.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a continuous tangency constraint named ""tang"" between domains 12 and 14:
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateedge ""tang"" 12 14 1 4 1 44
 To create a master tangency constraint named ""master"" where domain 14 is forced tangent to
        domain 12:
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateedge ""master"" 12 14 1 2 1 44
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
532,*morphconstraintcreateeq ,"Description
This command will create a constraint for the nodes on the mark which positions the nodes
        on or a specified distance away from the surface of the function. The
          function can contain x, y, and z variables but should not contain an
        equals sign. The surface of the function is located where the value of the function equals
        zero. The function will be positioned at the global origin if meth is set
        to 0. If meth is set to 1, oid will specify the origin
        node and the global system will be used for the x, y, and z directions. If
          meth is set to 2, oid will specify the local system
        to be used for the origin and x, y, and z.
type determines if the nodes move along the surface of the function, are
        bounded by the surface of the function, remain a set distance from the surface of the
        function, or maintain their original distance from the surface of the function.
To enable mesh stretching, add 32 to the type (thus 1, 3, and 5 become
        33, 35, and 37).
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark containing the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface of the function 
1 - Bounded by the surface of the function 
3 - Remains a set distance from the surface of the function 
5 - Maintains its original distance from the surface of the function 
+32 - Enables mesh stretching around constrained nodes
name
The name of the morph constraint to create.
vec
The ID of the vector created using *createvector. Must be set to
            1.
function
String containing a surface definition function f(x,y,z)
distance
Distance nodes must remain away from the surface of the function
              (type 1 and 3 only).
ivec
0 - Project normal to function 
1 - Project along vector vector
meth
0 - Use global origin and system 
1 - Use global system with node ID oid as the origin 
2 - Use local system with ID oid as the origin and system
oid
ID of node or system specified in meth.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To create a constraint where all nodes move along the surface of a sphere and are projected
        normal to the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateeq nodes 1 0 ""sph"" 1 ""x*x+y*y+z*z-100.0"" 0.0 0 0 0 11
To create a constraint where all nodes are bounded by the sphere by a distance of 2.0,
        projected along a vector, and use a local system to orient the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateeq nodes 1 1 ""sph"" 1 ""x*x+y*y+z*z-100.0"" 2.0 1 2 1 11
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
533,*morphconstraintcreatelayer ,"Description
This command will create a layer type morphconstraint for the selected nodes such that they
        move relative to the selected elements, effectively mapping nodes in layers to those on the
        selected elements. This option works best for nodes that were created in identical layers,
        such as with the element offset or drag elements functionalities used to create a stack of
        solid elements with a shell mesh. It is intended for use with CFD boundary layer meshes.
The nodes will maintain their original distances relative to the elements when the elements
        are morphed. The nodes will also match the movements of the elements in translation,
        translation and rotation, or be allowed to slide parallel to the normal direction of the
        elements based on the type selected. Also, mesh stretching may be enabled to smooth the
        transition between the constraint and the rest of the mesh.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the nodes to be constrained. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the elements to which the nodes will be constrained. Valid values are 1 and 2.
type
0 - Force inner layers to always be normal to the outer layer 
1 - Allow sliding normal to the outer layer 
2 - Fix only translations between the elements and the layers 
3 - Fix both translation and rotation between the elements and the layers 
+8 - Stretch mesh around the constrained nodes 
+16 - Use ""CFD corners"" method to calculate normals
name
The name of the morphconstraint to be create.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a layer constraint to be fixed in both rotation and translation
          (type = 3), with mesh stretching enabled (type +8)
        and using the cfd corners method (type +16 for a total of 27):
*createmark nodes 1 ""all""
*createmark elements 1 207 213 217 218 220 221 223 225 226
*morphconstraintcreatelayer nodes 1 elements 1 27 ""mcon"" 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
534,*morphconstraintcreateline,"Description
This command creates a line type morphconstraint for the selected nodes with the option of
        having those nodes either move along the line or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the line 
1 - Bounded by the line 
3 - Remains a set distance from the line 
5 - Remains its original distance from the line 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
line
The ID of the line.
dist
The minimum distance from the bounding line.
ivec
0 - The line normal is used for distance and projection. The nodes will be moved
            normally to the line when constraining them or measuring the distance the nodes are away
            from the line. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            line.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a line and projected normally to the
        line:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateline nodes 1 0 ""line"" 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
535,*morphconstraintcreateplane,"Description
This command creates a plane type morphconstraint for the selected nodes with the option of
        having those nodes either move along the plane or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the plane 
1 - Bounded by the plane 
3 - Remains a set distance from the plane 
5 - Remains its original distance from the plane 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
plane
The ID of the plane created using *createplane. Must be set to
            1.
dist
The minimum distance from the bounding plane.
ivec
0 - The plane normal is used for distance and projection. The nodes will be moved
            normally to the plane when constraining them or measuring the distance the nodes are
            away from the plane. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a plane and projected normally to the
        plane:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*morphconstraintcreateplane nodes 1 0 ""plane"" 1 1 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
536,*morphconstraintcreatesurf ,"Description
This command creates a surface type morphconstraint for the selected nodes with the option
        of having those nodes either move along the surface or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface 
1 - Bounded by the surface 
3 - Remains a set distance from the surface 
5 - Remains its original distance from the surface 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
surface
The ID of the surface.
dist
The minimum distance from the bounding surface.
ivec
0 - The surface normal is used for distance and projection. The nodes will be moved
            normally to the surface when constraining them or measuring the distance the nodes are
            away from the surface. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a surface and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintcreatesurf nodes 1 0 ""surface"" 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
537,*morphconstraintsetcolor,"Description
Sets the color for a morph constraint. 
","Inputs

mcon
ID of morph constraint.
color
The color of the constraint. Valid values are 1-64.

","Example
*morphconstraintsetcolor (5,33)

This command sets the color of the morph constraint to the specified value. 
","Errors
None.
"
538,*morphconstraintupdatearcrad ,"Description
Updates a model type constraint based on the radius or arc length of an edge domain.
","Inputs

stype
SHAPES
smark
Mark number of shapes
atype
NODES or LINES
amark
Mark number of node or line used for radius measurement
type
0 - Measure radius or arc angle using domain 
1 - Measure radius or arc angle using axis 
2 - Measure radius or arc angle using line 
3 - Measure radius or arc angle using node
mcon
ID of morph constraint
plane
mark number of plane for axis
dptr
ID of edge domain
radius
Constrained radius or arc angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
arc
0 - Radius 
1 - Arc angle
color
The color of the constraint. Valid values are 1 through  64.

","Example
This command updates a model type constraint for the selected domain with the option of
        updating the radius or arc angle to be measured in the plane of the domain, about an axis,
        about a line or about a node, and the option of having the radius or arc angle forced to be
        greater than, less than, or equal to the specified value. 
If arc is 0, the radius will be constrained. If arc
        is 1, the arc angle will be constrained. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
*morphconstraintupdatearcrad (SHAPES,1,NODES,1,0,5,1,21,5.0,0,0,32)
","Errors
None.
"
539,*morphconstraintupdatedof ,"Description
This command creates a constraint which fixes one or more translational degrees of freedom
        for the selected nodes relative to either the global coordinate system or a specified local
        coordinate system. 
A degree of freedom for a coordinate system is one of the three translational directions.
        For a rectangular coordinate system the three degrees of freedom are along each axis: the
        x-axis, the y-axis, and the z-axis. For a cylindrical coordinate system the three degrees of
        freedom are in the the radial direction, the theta direction, and the z direction. For
        example, for a rectangular coordinate system, if the y-axis degree of freedom is fixed for a
        node, it will be allowed to move only in the x and z directions, remaining in a plane
        perpendicular to the y axis. Similarly, for a cylindrical coordinate system, if the theta
        degree of freedom is fixed for a node, it can move only in the radial and z directions. Note
        that fixing the radial and z degrees of freedom for a cylindrical coordinate system will
        force a node to move in a circle about the axis of that system.
","Inputs

entity_type
Must be set to nodes.
mark_id
The mark ID for the constrained nodes. Valid values are 1 and 2.
dof1
0 - Allow the nodes to move in the x (or radial) direction 
1 - Constrain the nodes from moving in the x (or radial) direction
dof2
0 - Allow the nodes to move in the y (or theta) direction 
1 - Constrain the nodes from moving in the y (or theta) direction
dof3
0 - Allow the nodes to move in the z direction 
1 - Constrain the nodes from moving in the z direction
system_id
The ID of the local coordinate system. Use 0 for the global coordinate system.
options
0 - Does not affect nodes near constrained nodes 
1 - Enable mesh stretching around constrained nodes
id
The ID of morph constraint to update.
color
The color of the constraint. Valid values are 1-64.

","Example
To update a DOF constraint with ID 12 for nodes 1-100 in the radial direction of a local
        coordinate system with ID 5 and mesh stretching enabled:
*createmark nodes 1 1-100
*morphconstraintcreatedof nodes 1 1 0 0 5 1 12 22
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
540,*morphconstraintupdateelems ,"Description
This command updates a mesh type morphconstraint for the selected nodes with the option of
        having those nodes either move along the specified mesh or be bounded by it.
The extended edges option is available for bounded type morphconstraint
          (type 1, 3, and 5) by adding 8 to the type (9, 11,
        and 13). This option will extend the edges of the mesh by roughly two element lengths so
        that the nodes which project close to the edges of the mesh will project on to the extended
        edges.
The depenetration option is available for bounded type morphconstraint
          (type 1, 3, and 5) by adding 16 to the type (17, 19,
        and 21). This option will treat the center of any element attached to the constrained nodes
        as a constrained node and push the element away from the mesh, if it is within the specified
        distance.
To enable both extended edges and depenetration for a morphconstraint, add 24 to the type
        (thus 1, 3, and 5 become 25, 27, and 29).
","Inputs

ntype
Must be set to nodes.
nmark
The mark ID for the constrained nodes. Valid values are 1 and 2.
etype
etype
emark
The mark ID for elements to which the nodes are constrained. Valid values are 1 and 2.
type
0 - Moves along mesh 
1 - Bounded by mesh 
3 - Remains a set distance from mesh 
5 - Maintains its original distance from mesh 
+8 - Extend edges of mesh 
+16 - Depenetration of elements attached to constrained nodes 
+24 - Extend edges and enable depenetration 
+32 - Enable mesh stretching around constrained nodes
mcon
The ID of morph constraint to update.
p_vec
The ID of the projection vector created using *createvector. Must
            be set to 1.
dist
Distance between node and mesh (types 1 and 3).
ivec
0 - Mesh normal is used for projection. The nodes will be moved normally to the mesh
            when constraining them or measuring the distance the nodes are away from the mesh. 
1 - Use p_vec for projection. The nodes will be moved along
              p_vec when constraining them or measuring the distance the nodes
            are away from the mesh.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a morphconstraint for nodes to move along a mesh and projected normally to the
        mesh:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateelems nodes 1 elems 1 0 12 1 0.0 0 13
To update a morphconstraint for nodes to be bounded by a mesh at a distance of 5.0 and
        projected along a vector to the mesh with both depenetration and extended edges:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateelems nodes 1 elems 1 27 12 1 5.0 1 13
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
541,*morphconstraintupdatefc ,"Description
This command updates either a fixed type morphconstraint or a cluster type morphconstraint
        for the selected nodes with the option of having mesh stretching around those nodes.
        Rotation options are also available for cluster type morphconstraints.
There are three options for rotation: in-plane, out-of-plane, and full rotation. In-plane
        will limit rotation of the cluster to the plane in which the cluster lies (spinning) while
        out-of-plane limits the rotation of the cluster to take place normal to the plane of the
        cluster (tilting). Full rotation allows both in-plane and out-of-plane rotation. For cluster
        constraints where the nodes do not lie in a discernable plane any rotation option results in
        full rotation.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Fixed type constraint without mesh stretching 
6 - Fixed type constraint with mesh stretching 
7 - Cluster type constraint with mesh stretching (no rotation) 
9 - Cluster type constraint without mesh stretching (no rotation) 
+10 - (type 17 and 19) enables out-of-plane rotation for clusters 
+20 - (type 27 and 29) enables in-plane rotation for clusters 
+30 - (type 37 and 39) enables full rotation for clusters
mcon
The ID of the morph constraint to update.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a cluster morphconstraint with mesh stretching and full rotation:
*createmark nodes 1 ""all""
*morphconstraintupdatefc nodes 1 37 ""rivet"" 12
To update a cluster morphconstraint without mesh stretching and with in-plane rotation:
*createmark nodes 1 ""all""
*morphconstraintupdatefc nodes 1 29 ""rivet"" 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
542,*morphconstraintupdatelength ,"Description
Updates a model type constraint based on the length of a list of nodes.
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure length node to node 
1 - Measure length using vector
mcon
The ID of the morph constraint to update.
nodes
Mark number of node list
vec
Mark number of vector
length
constrained length of node list
bound
-1 - Greater than specified length 
0 - Equal to specified length 
1 - Less than specified length
color
Color (1 through 64 inclusive)

","Example
*morphconstraintupdatelength (SHAPES,1,0,5,1,1,43.5,0,32)
This command updates a model type constraint for the selected node list with the option of
        updating those nodes to be measured node to node or along a vector and the option of
        updating the node list to be forced to be greater than, less than, or equal to the specified
        length. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
","Errors
None.
"
543,*morphconstraintupdatematch ,"Description
This command will update a match type morphconstraint between two marks of elements such
        that they maintain a similar shape if the elements of either one mark or both marks are
        morphed. The two meshes do not have to be identical but the more similar they are the better
        the constraint will work. 
This type of constraint can be used multiple times on the same set of elements in order to
        make three or more meshes match each other. Note that only shell elements can be matched
        using this constraint.
","Inputs

a_entity_type
Must be set to elems.
a_mark_id
The ID of the mark containing the first set of elems. Valid values are 1 and 2.
b_entity_type
Must be set to elems.
b_mark_id
The ID of the mark containing the second set of elems. Valid values are 1 and 2.
type
0 - Allow to slide normal to the mesh 
1 - Allow sliding normal to the specified vector vec

2 - Match the shape between the two meshes 
+4 - Stretch mesh around the constrained elements
morphconstraint_id
The ID of the morphconstraint to update.
vec
The ID of the projection vector created using *createvector. Must
            be set to 1. Only used for type 1 and 5.
dist
The distance to be maintained between the meshes. Not used for type
            2 and 6.
node_basea
ID of the base node of a local system oriented to the mesh specified by
              a_mark_id. Only used for type 2 and 6.
node_xa
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by a_mark_id. Only used for type 2 and
            6.
node_xya
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
            by b_mark_id. Only used for type 2 and 6.
node_baseb
ID of the base node of a local system oriented to the mesh specified by
              b_mark_id. Only used for type 2 and 6.
node_xb
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by b_mark_id. Only used for type 2 and
            6.
node_xyb
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
            by a_mark_id. Only used for type 2 and 6.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a match constraint which matches the shape between two meshes
          (type = 2) and uses mesh stretching (type +4 for a
        total of 6):
*createmark elements 1 83 84 86-90 93 95 96 98-102 105 107 *createmark elements 2 50-54 57 62-66 69 74-78 81
*createvector 1 1 0 0
*morphconstraintupdatematch elements 1 elements 2 6 1 1 0 133 135 110 60 62 86 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
544,*morphconstraintupdatesmooth ,"Description
This command updates a smooth type morphconstraint for the selected nodes. During morphing,
        the perturbations of the nodes or dependent handles will be modified using a spline based
        approximation so that edge domains running along the selected entities will have smooth
        contours.
","Inputs

nlist
The ID of the list containing the nodes. Valid values are 1 and 2.
type
0 - Apply to nodes. All handles on the node list serve as anchors for the spline curve
            and nodes are adjusted to the curve based on influences 
1 - Apply to dependent handles. Only the independent handles on the node list serve as
            anchors and the dependent handles are adjusted to the curve based on influences
closed
0 - Open ended 
1 - Loop. The first node on the list will be added to the end to form a loop
mcon
The ID of the morph constraint to update.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a smooth morphconstraint for nodes 1-5 with a closed loop:
*createlist nodes 1 1 2 3 4 5
*morphconstraintupdatesmooth 1 0 1 12 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
545,*morphconstraintupdatevec,"Description
This command updates a vector type morphconstraint for the selected nodes with the option
        of having those nodes bounded to move no closer than a given distance from the specified
        plane.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the vector 
1 - Moves along the vector and is bounded by the plane 
3 - Moves along the vector, at a set distance from the plane 
5 - Moves along the vector and remains its original distance from the plane 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
plane
The ID of the plane created using *createplane. Must be set to
            1.
dist
The minimum distance from the bounding plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a morphconstraint for nodes to move along a vector and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*morphconstraintupdatevec nodes 1 0 ""vec"" 1 1 0.0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
546,*morphcreatedomaindc,"Description
Creates a domain from the elements on the mark with various options.
","Inputs

elemtype
ELEMS
elemmark
Element mark number
type
-1 - Autoupdate 
11 - D domain 
22 - D domain 
33 - D domain 
6 - Local domains (1D, 2D, and 3D) 
7 - General domain
part
0 - Do not use partitioning 
1 - Partition all domains 
2 - Only partition elements on solid domains (only for type =
            6)
rethand
0 - Do not retain handles 
1 - Retain handles
bydom
0 - Do not divide selected elements by existing domain 
1 - Divide elements by existing domains
bycomp
0 - Do not divide selected elements by components 
1 - Divide selected elements by components

","Example
*morphcreatedomaindc (ELEMS,1,2,1,1,0,0)
A new domain is created from the elements on the mark. The type
        specified notes which elements in the mark will be retained. If no elements of the correct
        type are on the mark, the command will exit. Elements from existing domains may be placed on
        the mark and will be removed from their former domain and placed in the new domain.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
547,*morphcreatedomainglobalnodes,"Description
Creates a global domain governing the selected nodes.
","Inputs

ntype
NODES
nmark
Node mark number
mode
0 - Create domain only 
1 - Create domain and autogenerate global handles 

","Example
*morphcreatedomainglobalnodes (NODES,1,1)

A new global domain is created governing the selected nodes. 
","Errors
None.
"
548,*morphcreatemodelshape,"Description
This command will create a shape which, when applied, will change the value specified in
        type (length along nodes, angle measured by three nodes, the radius or arc angle of an edge
        domain, or the area, volume, or mass of selected elements) for the mesh.
This command is intended to be used as a precursor to the creation of a ""model constraint""
        where some feature of a mesh is constrained and one or more assigned shapes are used to
        adjust the mesh to meet the constraint. This command is best used to generate an arbitrary
        shape which can then be selected when creating the model constraint.
Each shape type has different required values. Length (type 0) requires
        two or more nodes in the node_list node list. Angle
          (type 1) requires three nodes in the node_list node
        list. Radius and arc angle (type 2 and 3) require an edge domain ID for
        did and for mode 1 a plane is required for plane, for
          mode 2 a line ID is required for lid, and for mode 3
        a node is required for nodes. Area, volume, and mass (type 4, 5, and 6)
        require elements in mark_id.
","Inputs

type
0 - Length 
1 - Angle 
2 - Radius 
3 - Arc angle
4 - Area 
5 - Volume 
6 - Mass
mode
Calculation mode for a radius or arc angle: 
0 - By domain 
1 - By axis 
2 - By line 
3 - By node
e_entity_type
Must be set to elems.
e_mark_id
The mark ID containing elements for types 4, 5, and 6. Valid values are 1 and 2.
node_list
The node list ID. 
For type 0, this is a list of nodes which measures the length. 
For type 1, this is three nodes which measure the angle. 
For type 2 and 3, this is the node for measuring the radius or arc
            angle (mode 3). Valid values are 1 and 2.
plane
Temporary plane ID (axis - point and vector) used to measure the radius or arc angle
              (type 2 and 3, mode 1)
did
ID of domain for measuring radius and arc angle (type 2 and 3)
lid
ID of line for measuring the radius and arc angle (type 2 and 3,
              mode 2)

","Examples
To create a shape for a model constraint for a length measured from nodes 11 to 12 to
        13:
*createmark elems 1
*createlist nodes 1 11 12 13
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphcreatemodelshape 0 0 elems 1 1 1 0 0
To create a shape for a model constraint for a radius measured about an axis:
*createmark elems 1
*createlist nodes 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphcreatemodelshape 2 1 elems 1 1 1 33 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Domain not found."" - occurs if the domain ID (did) does not exist in the model (required
        for types 2 and 3). 
""Line not found."" - occurs if the line ID (lid) does not exist in the model (required for
        types 2 and 3, mode 2). 
"
549,*morphcreatetempline,"Description
Creates a line entity for a given node list 
","Inputs

points
Mark number of nodes 

","Example

*morphcreatetempline (1)
Although the name of this function is ""temporary"", the line is not automatically
        deleted.
","Errors
None.
"
550,*morphdeletehandlesanddomains,"Description
Deletes all morphing handles and domains.
","Example
*morphdeletehandlesanddomains 
Deletes all handles and domains in the model except for any handles attached to morph
        volumes.
","Errors
None.
",
551,*morphdisplayconstraints ,"Description
This command will draw or undraw vectors to the screen for the various constraints
        specified on the mark. This command is used when reviewing constraints from the Morph
        constraints panel.
","Inputs

entity_type
Must be set to morph constraints.
mark_id
The ID of the mark containing the morph constraints. Valid values are 1 and 2.

","Examples
To display vectors for all morph constraints in the model:
*createmark morphconstraints 1 ""all""
*morphdisplayconstraints morphconstraints 1
To turn off the vector display:
*createmark morphconstraints 1
*morphdisplayconstraints morphconstraints 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
552,*morphdisplaydependencies,"Description
Displays dependencies for handles on mark. 
","Inputs

entities
Handles
markmask
Handle mark number.

","Example
*morphdisplaydependencies (HANDLES,1)
The dependencies for all handles on the mark are displayed on the screen as vectors. 
If the mark is blank, the vectors are cleared from the screen. 
","Errors
None.
"
553,*morphdomainautocolor,"Description
This command will set the color of selected domains to be a different value if possible.
        All 64 colors will be used, except for black, before the same color is used a second
        time.
","Inputs

entity_type
Must be set to domains.
mark_id
The ID of the mark containing the domains. Valid values are 1 and 2.

","Example
To assign a different color to a number of domains:
*createmark domains 1 6 15 154 153 68 143 211 208 185 184 167 157
*morphdomainautocolor domains 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
554,*morphdomainsupdatecolor,"Description
This command will update the color of selected domains to the specified color.
","Inputs

entity_type
Must be set to domains.
mark_id
The ID of the mark containing the domains. Valid values are 1 and 2.
color
The color of the domain. Valid values are 1 through 64.

","Example
To change the color of a number of domains to be violet:
*createmark domains 1 6 15 154 153 68 143 211 185 184 167
*morphdomainsupdatecolor domains 1 37 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
555,*morphentitydelete ,"Description
Deletes entities on a mark.
","Inputs

etype
Entity type
emark
Mark number of entities

","Example
*morphentitydelete (HANDLES,1)
Deletes the entities of the specified type on the mark. 
","Errors
None.
"
556,*morphfittosurface ,"Description
This command will map domains, elements, or morph volume faces to surfaces or a mesh,
        fitting the boundaries of the entities to the edges of the surfaces or mesh and projecting
        the interior nodes on to the target entities. In the case of domains and morph volume faces
        being fit to surfaces, multiple entities may be fitted to multiple surfaces with the intent
        of matching them one to one. In those cases, the interior edges of the entities will be
        mapped to interior edges of the surfaces as well.
This command can be used as a one step solution or in conjunction with the
          *morphmaptshp, *morphmaptshpedge, and
          *morphmaptshpface commands if you want to place handles, edge domains,
        2D domains, or morph volume faces before applying the fit operation.
When mapping domains to surfaces one to one, this command can also be used in conjunction
        with the *morphstorematch command which allows you to manually set which
        domains should be mapped to which surfaces or automatically have it determine matches based
        on which domains currently lie on which surfaces.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The mark ID of the nodes on the entities to be fitted. The mark is for internal use
            and may be left empty. Valid values are 1 and 2.
e_entity_type
Valid values are domains, elems, hypercubes.
e_mark_id
The mark ID of the entities to be fitted. Valid values are 1 and 2.
h_entity_type
Must be set to handles.
h_mark_id
The mark ID of the follower handles. Valid values are 1 and 2.
s_entity_type
Valid values are surfs and elems.
s_mark_id
The mark ID of the surfaces or elements onto which the entities will be fitted. Valid values are 1 and 2.
face
The mark ID of selected morph volume edges and faces to be fitted. Valid values are 0
            and 1. See the commands *morphmanageedgemark and
              *morphmanagefacemark for information on how to fill this mark.


nhand
The number of handles per edge any morph volume faces will be updated to having during
            the fitting operation. The maximum value is 5. If you want to retain the current number
            of handles on the edges, set this value to -1.
sym
0 - Do not use symmetry
con
1 - Use constraints
mode
0 - Match as group. Use with handle, edge, and face mapping commands. 
1 - Match as group. One step solution. 
2 - Match one to one. Use with handle, edge, and face mapping commands. 
3 - Match one to one. One step solution. 
4 - Match one to one. Use stored matches. Use with handle, edge, and face mapping
            commands. 
5 - Match one to one. Use stored matches. One step solution. 
When fitting to a mark of elements, only modes 0 and 1 are valid.
maxiter
When matching entities one to one (mode 2 - 5), this is the maximum
            number of iterations attempted before settling on the best current solution. For
              mode 0 and 1 it is ignored.

","Examples
To fit a domain to a surface in one step:
*createmark nodes 1
*createmark domains 1 10
*createmark handles 1
*createmark surfaces 1 3
*morphfittosurface nodes 1 domains 1 handles 1 surfaces 1 0 0 0 1 1 0
To fit multiple morph volume faces to multiple surfaces one to one, increasing the handle
        density to 3 handles per edge:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 0 1 3
*morphmanagefacemark 0 0 0 3
*morphmanageedgemark 0 0 1
*morphmanageedgemark 5 0 1
*morphmanageedgemark 1 0 1
*morphmanageedgemark 14 0 1
*morphmanagefacemark 1 4 0 1
*morphmanageedgemark 5 0 1
*morphmanageedgemark 10 0 1
*morphmanageedgemark 6 0 1
*morphmanageedgemark 19 0 1
*morphmanagefacemark 2 4 0 1
*morphmanageedgemark 13 0 1
*morphmanageedgemark 18 0 1
*morphmanageedgemark 14 0 1
*morphmanageedgemark 26 0 1
*morphmanagefacemark 3 4 0 1
*morphmanageedgemark 18 0 1
*morphmanageedgemark 23 0 1
*morphmanageedgemark 19 0 1
*morphmanageedgemark 29 0 1
*morphmanagefacemark 4 4 0 1
*createmark nodes 1
*createmark morphvolumes 1 1-4
*createmark handles 1
*createmark surfaces 1 1-4
*morphfittosurface nodes 1 morphvolumes 1 handles 1 surfaces 1 0 -1 0 1 3 50
*morphmanageedgemark 0 0 3
*morphmanageedgemark 0 1 3
*morphmanagefacemark 0 0 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
557,*morphhandlecreatenodesnodom ,"Description
Creates handles at nodes on mark with no domain given.
","Inputs

nodetype
Nodes
marknode
Node mark number
dhandletype
Handles
dmarkhandle
Dependent handle mark number
name
Name of handle(s) to be created

","Example
*morphhandlecreatenodesnodom (NODES,1,HANDLES,1,""bob"")
Handles are created at the nodes on the mark with dependencies on the handles on the mark.
        The handle mark may be empty.
The domains on which the handles are created are determined automatically based on the node
        selected. Domains which share a common node are selected in the following order: edges, 2D
        domains, 3D domains, 1D domains, general domains, and global domains. Handles touching morph
        volume nodes will not be assigned to any domain.
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
558,*morphhandlepertnormal ,"Description
Perturbs handles on mark normal to elements 
","Inputs

handletype
Handles
markhandle
Handle mark number
elemtype
Elems
markelem
Element mark number
dist
Distance of perturbation
sym
Flag to use symmetry: 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag to use constraints: 
0 - Do not use constraints 
1 - Use constraints
umark
Flag to only use in the mark: 
0 - Use all elements to calculate normals 
1 - Use only the selected elements to calculate normals

","Example
*morphhandlepertnormal (HANDLES,1,ELEMS,1,3.0,1,1,1)
All handles on the mark will be given a perturbation equal to dist in
        the normal direction as determined by either the selected elements or by all elements. If
        symmetry is used,all handles linked to marked handles by symmetry will also be perturbed. If
        constraints are used, they will be applied to the perturbations. 
","Errors
None.
"
559,*morphhandleprojectentity ,"Description
This command will move each of the selected handles onto the selected surfaces or elements
        along a direction defined by the projection type. Applying symmetry links and constraints is
        optional. All domains influenced by the selected handles will be morphed accordingly. 
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions. 
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to other lines in the model. 
Constraints may move the perturbed handles off of the selected line after the handles are
        moved to the line.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
e_entity_type
Must be set to surfs or elems.
e_mark_id
The mark ID containing the target surfaces or elements. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
nproj
0 - Project along vector proj

1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
 Temporary projection vector ID
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a surface along a vector:
*createmark handles 1 ""all""
*createmark surfs 1 12
*createmark elems 2
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 surfs 1 elems 2 0 1 1 1
To project handles to a mesh normal to the mesh:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createmark elems 2
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 elems 1 elems 2 1 1 1 1
To project handles to a surface normal to the selected elements:
*createmark handles 1 ""all""
*createmark surfs 1 12
*createmark elems 2 7 8 9 10 11 12
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 surfs 1 elems 2 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Unable to create tacit surface from elements."" - occurs if the selected target elements
        cannot be assembled into a useable tacit surface. Selected elements should be shells,
        connected to each other, and of relatively good quality. 
"
560,*morphhandleprojectplane ,"Description
This command will move each of the selected handles on to the defined plane along a
        direction defined by the projection type. Applying symmetry links and constraints is
        optional. All domains influenced by the selected handles will be morphed accordingly.
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions.
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to the specified plane.
Constraints may move the perturbed handles off of the specified plane after the handles are
        moved to the plane.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
plan
Temporary target plane ID.
nproj
0 - Project along vector proj 
1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
Temporary projection vector ID.
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a plane along a vector:
*createmark handles 1 ""all""
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 0 1 1 1
To project handles to a plane normal to the plane:
*createmark handles 1 ""all""
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 1 1 1 1
To project handles to a plane normal to the elements:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
561,*morphhandlescalexyz ,"Description
This command will scale the positions of the selected handles with respect to a reference
        node and system. Scaling factors can be assigned for the x, y, and z directions
        independently. If no system is specified, the scaling factors will apply in the global x, y,
        and z directions. If no node is specified, the handle positions will be averaged to
        determine the position of the reference node. A scaling factor of 1.0 will produce no
        movement of the handle in that direction while a scaling factor of 0.0 will move the handle
        to the x, y, or z position of the node or system origin.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID of the handles. Valid values are 1 and 2.
node_id
ID of the scaling reference node (or 0).
x
Scaling factor in the x direction (1.0 is no scaling).
y
Scaling factor in the y direction (1.0 is no scaling).
z
Scaling factor in the z direction (1.0 is no scaling).
system_id
ID of the scaling reference system (or 0).
sym
0 - Do not use symmetry links between handles 
1 - Use symmetry links between handles
con
0 - Do not apply constraints 
1 - Apply constraints

","Examples
To scale a mark of handles relative to a node and system:
*createmark handles 1 ""all""
*morphscalehandlexyz handles 1 5 2.0 2.0 2.0 2 1 1
To scale a mark of handles relative to the average position of the handles using the global
        system for x, y, and z:
*createmark handles 1 ""all""
*morphscalehandlexyz handles 1 0 2.0 2.0 2.0 0 1 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
562,*morphhandleupdatesingle,"Description
Updates position and dependencies for specified handle.
","Inputs

handleptr
ID of handle.
dhandletype
Handles
dmarkhandle
Dependent handle mark number.
xx
X coordinate of handle to be created.
yy
Y coordinate of handle to be created.
zz
Z coordinate of handle to be created.
sys
System to create handle in.
0 - Global (default.

","Example
*morphhandleupdatesingle (21,HANDLES,1,1.0,2.0,3.0,3)

Specified handle dependencies are updated to the handles on the mark. Specified handle
        coordinates are updated to the x, y, and z values for the given system. 
","Errors
None.
"
563,*morphhypermorphnormal ,"Description
Create shapes in the normal direction for handles on mark.
","Inputs

typehand
Handles
markhand
Handle mark number
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
mag
Magnitude of perturbation 

","Example
*morphhypermorphnormal (HANDLES,1,1,1,5.0)
A shape is created for each handle on the mark in the direction of the normal for the
        handle node at the given magnitude. If symmetry is used, all handles linked to marked
        handles by symmetry will also be perturbed. If constraints are used, they will be applied to
        the perturbations. 
","Errors
None.
"
564,*morphhyperpreview,"Description
Draws vectors for shapes to be created.
","Inputs

typehand
Handles
markhand
Handle mark number
xi
0 - Do not create x perturbation 
1 - Create x perturbation
yi
0 - Do not create y perturbation 
1 - Create y perturbation
zi
0 - Do not create z perturbation 
1 - Create z perturbation
xx
x perturbation magnitude
yy
y perturbation magnitude
zz
z perturbation magnitude
sys
System to create perturbations in (default = global)
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
vvec
Vector mark number
mag
magnitude of perturbation
type
0 - XYZ directions 
1 - Vector direction 
2 - Normal directions 

","Example
*morphhyperpreview (HANDLES,1,0,0,1,1.0,1.0,5.0,3,1,1,0,0.0,1)
A vector is drawn for each handle on the mark in either the xyz directions, the vector
        direction, or the normal direction. This is used to preview the shapes that will be created
        in the autoshape panel before creating them. If symmetry is used, all handles linked to
        marked handles by symmetry will also be perturbed. If constraints are used, they will be
        applied to the perturbations.
","Errors
None.
"
565,*morphinterpolatesurf ,"Description
This command will morph the elements on e_mark_id, or those of an
        internally generated mesh, to a surface interpolated from the nodes or lines on
          n_mark_id. The mode specifies the general shape of the interpolated
        surface (and internally generated mesh) and requires either a specified plane, line, node,
        node list, or system to orient the shape. This command may also be used to generate a
        surface using the interpolated surface but is limited to support only a plane as the general
        shape of the interpolated surface.
For a generated mesh the sizbld option can be used to specify the number
        of elements per side (for a rectangular mesh) or per 45 degree section (for a
        non-rectangular mesh), or it can be used to specify the average element size. For an
        existing mesh (e_mark_id) sizbld is the blend factor %
        which allows you to blend the difference between the shape of the existing mesh and the
        shape of the interpolated surface. A higher blend factor means that the mesh will match
        closer to the interpolated surface.
Covariance, drift, nugget, and nugget value are parameters sent to the Kriging algorithm
        which calculates the interpolated surface. Good default values are ""h"" for covariance,
        ""linear"" for drift, and ""off"" for the nugget.
","Inputs

n_entity_type
Valid values are nodes and lines.
n_mark_id
The mark ID of the nodes or lines. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The mark ID of the elements. Valid values are 1 and 2.
sizbld
If the element mark is empty: 
< 0 - Element density of generated mesh (or surface for mode 8) 
> 0 - Average element size of generated mesh 
If the element mark contains elements: 
blend factor % (0.0 - 100.0)
buffer
% increase in the size of the generated mesh before morphing to interpolated surface
            (0.0 - 100.0) - intended mainly for planar meshes (modes 0 and
            8)
ndens
Number of nodes created on lines for interpolated surface.
mode
Shape of generated mesh and general shape of interpolated surface:
0 - plane 
1 - cylinder 
2 - sphere 
3 - ellipse 
4 - cylinder about node list 
5 - cylinder about line 
6 - enclosed cylinder about nodelist 
7 - enclosed cylinder about line 
8 - plane - create a surface instead of a mesh
plane
Temporary plane ID for orientation or cylinder axis (modes 0, 1 and
            8)
node_id
ID of center node of sphere or ellipse (modes 2 and 3)
system_id
ID of local system for ellipse (mode 3)
line_list
Line list ID (modes 5 and 7)
node_list
Node list ID (modes 4, 5, 6, and 7)
sym
0 - Do not use symmetry links 
1 - Use symmetry links
con
0 - Do not use constraints 
1 - Use constraints
covar
Covariance for Kriging algorithm: 
0 - h 
1 - h^2log(h) 
2 - h^3 
3 - exp(-1/x)
drift
Drift type for Kriging algorithm: 
0 - no drift 
1 - constant 
2 - linear 
3 - quadratic 
4 - cubic 
5 - trigonometric
nugget
0 - off 
1 - on
nugval
The value of nugget for Kriging algorithm.
symm
0 - No symmetric surface is created (mode 8 only) 
1 - Symmetric surface is created (mode 8 only)
type
0 - Smooth surface is created (mode 8 only) 
1 - Developable surface is created (mode 8 only)
draw
Draw depth used to position the surface below the part (mode 8
            only)
offset
Used to increase the size of the surface while maintaining tangency
              (mode 8 only)
sym_plane
Temporary symmetry plane ID (mode 8 only)
model_shape
0 - The surface is created using the half model given by symplane
              (mode 8 only) 
1 - The surface is created using the complete model (mode 8
            only)
node1_id
Base point of vector defining the developable direction (mode 8
            only). Can be set to zero for other modes.
node2_id
End point of vector defining the developable direction (mode 8
            only). Can be set to zero for other modes.

","Examples
To morph a mesh to a surface interpolated from nodes which is roughly planar:
*createmark nodes 1 1 2 3 4 5 6 7 8
*createmark elems 1 ""all""
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createlist lines 1
*createlist nodes 1
*createplane 2,1.0 0.0 0.0 1.0 0.0 0.0
*morphinterpolatesurf nodes 1 elems 1 100.0 10.0 0 0 1 0 0 1 1 1 1 0 2 0 0.0 0 0 0.0 0.0 2 0 0 0
To generate a mesh, with 10 elements per 45 degree spherical section, and morph it to a
        surface interpolated from lines which is roughly spherical and oriented with a given system
        with a node as the origin:
*createmark lines 1 1 2 3 4 5 6 7 8
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createlist lines 1
*createlist nodes 1
*createplane 2,1.0 0.0 0.0 1.0 0.0 0.0
*morphinterpolatesurf nodes 1 elems 1 -10.0 10.0 10 2 1 45 3 1 1 1 1 0 2 0 0.0 0 0 0.0 0.0 2 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
566,*morphlistupdate ,"Description
This command will either clear or compress the morphs on the undo/redo list for the given
        range. If start and finish are both set to zero, the entire list will be affected. If a
        morph is cleared while still applied to the model, the morph will not be unapplied during
        clearing and thus will end up being permanently applied.
The API function hm_morph_getinfo will return the current value of the
        counter and the total number of morphs on the undo/redo list.
","Inputs

mode
The type of update to perform. Valid values are: 
0 - Clear selected morphs 
1 - Compress selected morphs
start
Starting morph number (1 or higher).
finish
Finishing morph number (1 or higher).

","Examples
To clear morphs 1, 2, and 3 from the morph list:
*morphlistupdate 0 1 3
To compress morphs 1, 2 and 3 into a single morph. If the morph list contained more morphs,
        the first morph will be the same as the first three morphs applied simultaneously followed
        by the rest of the morphs on the list:
*morphlistupdate 1 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
567,*morphloadmvols,"Description
Loads morph volume, handle, and shape data from a file.
","Inputs

morphmvolfile
Name of data file written using *morphsavemvols ().
nauto
0 - Do not register all nodes found inside morph volumes 
1 - Register all nodes found inside morph volumes

","Example
*morphloadmvols (""mvols.dat"",1)
This command will load all morph volumes, handles, and shapes in the specified file and
        load them into the model. Optionally, nodes in the model can be registered for the loaded
        morph volumes.
","Errors
None.
"
568,*morphmanageedgemark,"Description
This command allows you to add an edge, subtract an edge, or clear all edges from a
        specified morph volume edge user mark. Since morph volume edges are not treated as
        independent entities, marks containing edges can only be managed through an external
        command. For commands that require edge marks as input, this command must be used to place
        edges on the mark. The mark should be cleared before and after use to ensure proper
        operation.
","Inputs

edge_id
The ID of morph volume edge to add/subtract. Ignored if mode is 3.
user_mark_id
The ID of the user mark to operate on. Valid values are 0-3.
mode
1 - Add edge to user mark 
2 - Subtract edge from user mark 
3 - Clear all edges from user mark

","Examples
To add an edge to user mark 1:
*morphmanageedgemark 4 1 1
To clear user mark 2:
*morphmanageedgemark 0 2 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
569,*morphmanualapplyenvelope ,"Description
This command can only be used after *morphmanualinit.
If mode is 0, no other information is required, the difference in
        positions of the nodes between the *morphmanualinit command and the
          *morphmanualapplyenvelope is converted into a morph.
If mode is 1, then temporary handles are created for all moving and
        fixed nodes to determine the stretching of the affected elements. If
          integ is 0, a general domain is temporarily created for the affected
        elements. If integ is 1, the domains currently in the model are used. If
          integ is 2, 1D, 2D, 3D, and edge domains are temporarily created for
        the affected elements but the 2D domains are not partitioned. If integ is
        3, then handle influences are applied using a spatial relationship rather than through a
        domain. If integ is 4, only the selected moving nodes are moved and all
        others are held fixed. If integ is 5, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements and the 2D domains are partitioned. Any
        handles created due to partitioning are moved based on their distance from the moving and
        fixed nodes. If integ is 6, then handle influences are applied using the
        Kriging algorithm. If integ is 7, then handle influences extend only up
        to a given distance (if envelope is positive) or a given multiple of the
        applied perturbations (if envelope is negative) away from the moving
        nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If mode is set to 2, then the previous
          *morphmanualapplyenvelope command is rejected and the nodes are left in their
        manually perturbed positions. The model is still 'initialized' and thus another
          *morphmanualapplyenvelope command can be called after a reject. To
        restore the model to the way it was, call *morphmanualrestore.
If mode is set to 3 then the memory set aside by
          *morphmanualinit is freed, and
          *morphmanualapplyenvelope can no longer be used until another
          *morphmanualinit command is called. It is good practice to use this
        mode to free memory which is no longer needed.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value sent in for
          undisplayed.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
mode
0 - Apply as node perturbations 
1 - Apply as handles 
2 - Reject last *morphmanualapplyenvelope command 
3 - Clear memory set aside by *morphmanualinit
mbias
Bias factor for moving nodes on affected elements.
fbias
Bias factor for fixed nodes on affected elements. 
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing

","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
570,*morphmanualrestore ,"Description
Restores the positions of nodes after a *morphmanualinit command.
","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
None.
",
571,*morphmapdifferencesurf ,"Description
This command maps selected nodes from one surface or element mark to the other surface or
        element mark optionally following the curvature differences (rotate) between the surfaces or
        element marks and/or mapping about an axis (axis and plane) or using a number of linear
        mapping options. Note that you can map from a mesh to a surface or surface to a mesh as well
        as mapping from a mesh to a mesh or a surface to a surface.Note: This command does not do
          ""true"" mapping, that is nodes will not be ""fitted"" from one surface or element mark to
          another. Instead, a vector (the plane normal in r_plane) is used to
          find the target point on the target surface or element mark given a reference point on the
          initial surface or element mark.

If blend is set to 1, no fixed nodes have been selected, and no mapped
        nodes are a part of any domain, this command will automatically assign all non-mapped nodes
        as fixed nodes.
If blend is set to 2, the blending will only be applied to nodes which
        lie along the mesh between the fixed nodes and the mapped nodes.
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The mark ID for mapped nodes. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID for fixed nodes. Valid values are 1 and 2.
i_entity_type
Set to surfs or elems.
i_mark_id
The mark ID for initial surfaces or mesh. Valid values are 1 and 2.
t_entity_type
Set to surfs or elems.
t_mark_id
The mark ID for target surfaces or mesh. Valid values are 1 and 2.
r_plane
Plane used for axis of rotation. Valid values are 1 and 2.
rotate
0 - Linear point to point mapping between lines. 
1 - Rotate nodes along with curvature difference between lines
axial
0 - Apply mapping in x, y, z coordinates 
1 - Apply mapping about axis defined by r_plane
sym
0 - Do not use symmetry (only option).
con
0 - Do not use constraints. 
1 - Use constraints
blend
0 - Do not blend unselected nodes. 
1 - Blend all nodes other than mapped and fixed nodes 
2 - Blend only nodes on mesh between mapped and fixed nodes
mbias
Bias factor of mapped nodes.
fbias
Bias factor of fixed nodes.

","Example
To map nodes from one surface mark to another using rotation:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createmark surfs 1 22 23
*createmark surfs 2 32 33
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifferencesurf nodes 1 nodes 2 surfs 1 surfs 2 1 1 0 1 0 1.0 1.0
To map nodes from one surface mark to an element mark about an axis with no rotation,
        blending through the mesh, and biasing factors of 2.0:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createmark surfs 1 22 23
*createmark elems 1 32 33 34 35 36
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifferencesurf nodes 1 nodes 2 surfs 1 elems 1 1 0 1 1 2 2.0 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Not enough memory."" - occurs if there is not enough memory to complete the command.
"
572,*morphmapedgestoextendedoffset,"Description
This command projects the handles on the marked morph volume edges to extended surfaces or
        elements on the specified mark along the specified vector, normal to the target surfaces or
        elements, or normal to any attached shell elements (unusual for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
entity_type
The type of entity to map to. Valid values are surfs and elems.
mark_id
The ID of the mark containing the entities to map to. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links
1 - Use symmetry links
use_constraints
0 - Do not use constraints
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id
1 or 11 - Project normal to target surfaces or elements
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection direction. Must be set
            to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces or elements for
            values of project of 0, 1, and 2. The offset will be measured along the projection
            vector normal for values of project of 10, 11, and 12.

","Examples
To map edges on mark 0 to a mark of extended surfaces along a vector with offset of 1.2 and
        leaving the handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createmark surfs 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestoextendedoffset 0 surfs 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3

To map edges on mark 1 to an extended mesh along the element normals with 3 mid-handles per
        edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createmark elems 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestoextendedoffset 1 elems 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
573,*morphmapedgestonodelistoffset ,"Description
This command will fit (evenly distribute) or project (along vector or normal) the handles
        on the marked morph volume edges to a line calculated from the specified points.
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
node_list_id
The ID of the list containing the input nodes. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to line 
2 or 12 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target. Not used if project is 2.
The offset will be measured from the closest point on the line for values of project
            of 0 and 1. The offset will be measured along the projection vector normal for values of
              project of 10 and 11.

","Examples
To map edges on mark 0 offset by 1.2 from a node list along a vector leaving the handles
        unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestonodelistoffset 0 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to a node list along the node list normal with 3 mid-handles per
        edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestonodelistoffset 1 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
574,*morphmapedgestosurfaceoffset,"Description
This command will project the handles on the marked morph volume edges to the surfaces on
        the mark along the specified vector, surface normal, or normal to any attached shell
        elements (unusual for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
entity_type
Must be set to surfs.
mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id 
1 or 11 - Project normal to surfaces 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces for values of
            project of 0, 1, and 2. The offset will be measured along the projection vector normal
            for values of project of 10, 11, and 12.

","Examples
To map edges on mark 0 to a surface along a vector with offset of 1.2 and leaving the
        handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createmark surfs 1 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestosurfaceoffset 0 surfs 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to a surface along the surface normal with 3 mid-handles per
        edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createmark surfs 1 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestosurfaceoffset 1 surfs 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
575,*morphmaplinestolines ,"Description
This command maps selected elements lying on an initial set of lines to an interpolated
        cross section represented by another set of lines optionally rotating trailing nodes and/or
        mapping about an axis (axis and plane) or using a number of linear mapping options.
This command interpolates a number of *morphmapdifference() calls
        between line pairs. It is critical that the order of the initial lines match the order of
        the final lines in their respective lists for this command to function properly. For best
        results the lines should be planar (cross-sections) and should intersect at right
        angles.
If blend is set to 1, no fixed nodes have been selected, and no mapped
        nodes are a part of any domain, this command will automatically assign all non-mapped nodes
        as fixed nodes.
If blend is set to 2, the blending will only be applied to nodes which
        lie along the mesh between the fixed nodes and the mapped nodes.
The axis option allows you to apply section mapping for sections that
        apply about an axis (option 1). Section lines should lie in one or more radial planes or lie
        in planes normal to the axis of rotation.
The axis option is also used to select the type of projection for the
        nodes to the section lines. This projection determines how the section lines influence the
        nodes. Option 0 is preferred, which projects each node normal to the plane of each section
        line. Option 2 approximates the section line as a straight line and projects the nodes
        normal to the line, which is better for non-planar lines. Option 3 projects the nodes along
        a specified vector. Option 4 is like Option 2, but the projection line is forced to be in
        the specified plane, which is better for non-planar lines which you want to behave like
        planar lines. Option 5 does not project the nodes to the lines, but instead uses kriging to
        determine the morphing of the nodes.
","Inputs

m_entity_type
Must be set to elems.
m_mark_id
The mark ID for mapped elements. Valid values are 1 and 2.
t_entity_type
Must be set to nodes.
t_mark_id
The mark ID for trailing nodes. Valid values are 1 and 2.
i_line_list
The mark ID for the line list marking the initial position of the mapped elements. Valid values are 1 and 2.
f_line_list
The mark ID for the line list marking the final position of the mapped elements. Valid values are 1 and 2.
r_plane
Plane used for axis of rotation and projection options 3 and 4. Valid values are 1 and 2.
rotate
0 - Linear point to point mapping between lines. 
1 - Rotate nodes along with curvature difference between lines
blend
0 - Do not blend unselected nodes. 
1 - Blend all nodes other than mapped and fixed nodes 
2 - Blend only nodes on mesh between mapped and fixed nodes
axis
0 - Project nodes to line normal to the plane of the line (preferred) 
1 - Apply mapping about axis defined by r_plane

2 - Project nodes to line normal to the axis of the line 
3 - Project nodes to line along vector (r_plane normal) 
4 - Project nodes to line in plane (r_plane) 
5 - Use kriging to map nodes
sym
0 - Do not use symmetry (only option). 
con
0 - Do not use constraints. 
1 - Use constraints

","Examples
To map a mesh given two sets of three lines each using rotation, no blending, and
        projecting nodes normal to the planes of the lines:
*createmark elems 1 ""all""
*createmark nodes 1
*createlist lines 1 11 12 13
*createlist lines 2 21 22 23
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmaplinestolines elems 1 nodes 1 1 2 1 1 0 0 0 1
To map a mesh given two sets of three lines each about an axis using no rotation, and
        blending through the mesh: 
*createmark elems 1 ""all""
*createmark nodes 1
*createlist lines 1 11 12 13
*createlist lines 2 21 22 23
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmaplinestolines elems 1 nodes 1 1 2 1 1 2 1 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Number of lines in each list must be equal."" - occurs if the number of lines found in
          i_line_list is different than the number of lines in
          f_line_list. 
""Not enough memory."" - occurs if there is not enough memory to complete the command.
"
576,*morphmaprecalc,"Description
Recalculate influences and prepare for mapping.
","Inputs

nlist
List mark number for nodes affected by mapping.
nmark
0 - Use input list 0 
1 - Use input list 1
edgenode
NODES
markedge
Node mark number for nodes on edge domains where handles will be created.
facenode
NODES
markface
Node mark number for nodes on 2D domains where handles will be created.
mode
0 - Create temporary handles and calculate new influences 
1 - Delete temporary handles and restore old influences

","Example
*morphmaprecalc (0,0,NODES,2,NODES,3,0)
This command is called before and after mapping operations in the user control sub-panel to
        enhance mapping speed. The command makes influence recalculation necessary only once, when
        entering the panel, rather than each time the user wishes to place a handle or edge.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
577,*morphmaptoequationvecoffset ,"Description
Maps nodes to, or offset from, an equation using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the equation along a vector, normal to the surface of the
        equation, or normal to the shell elements attached to the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
equation
String containing an equation f(x,y,z). The equation can contain x, y, and z variables
            but should not contain an equals sign. The surface of the function is located where the
            value of the function equals zero.
origin
0 - Use global origin and system 
1 - Use global system with node ID = origin_id as the origin 
2 - Use local system with ID = origin_id as the origin and
            system
origin_id
The ID of node or system specified in origin. Ignored if
              origin is 0.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to surface of equation 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the equation for values of
            project of 0, 1, and 2. The offset will be measured along the projection vector normal
            for values of project of 10, 11, and 12.

","Examples
To map all nodes to a sphere of radius 10.0 with an offset of 1.2, when not using
          *morphmaprecalc:
*createmark nodes 1 ""all""
*createmark handles 1
*createvector 1 1.0 0.0 0.0
*morphmaptoequationvecoffset nodes 1 handles 1 ""x*x+y*y+z*z-100.0"" 0 0 1 1 1 1 1 1.2
To map all nodes to a sphere of radius 10.0 positioned at a system along a vector:
*createmark nodes 1 ""all""
*createmark handles 1
*createvector 1 1.0 0.0 0.0
*morphmaptoequationvecoffset nodes 1 handles 1 ""x*x+y*y+z*z-100.0"" 2 1 1 1 0 1 1 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
578,*morphmaptolinenodesoffset ,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

list_id_nodes
The ID of the list containing the input nodes. Valid values are 1 and 2.
entity_type_handles
 Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
line_list
The ID of the list containing the input lines. Valid values are 1 and 2.
node_list
The ID of the list containing any nodes to define input lines. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 -  Project along vector defined by vector_id

1 to 11 - Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
offset
The distance to offset nodes from the target. Not used if
              project is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on list 1 normal to lines and points on list 2 with an offset of 1.2:
*morphmaptolinenodesoffset 1 handles 1 2 2 0 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
579,*morphmaptonodelistvecoffset ,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the input nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
node_list_id
The ID of the list containing the target nodes. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11- Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target. Not used if project
            is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on mark 1 normal to a line with ID 23 with an offset of 1.2 when not using
          *morphmaprecalc:
*morphmaptonodelistvecoffset nodes 1 handles 1 23 0 1 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
580,*morphmaptoplanevecoffset ,"Description
Maps nodes to, or offset from, the specified plane using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the plane along a vector, normal to the plane, or projected
        normal to the elements touching the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
plane_id
The ID of plane created using *createplane to map to. Must be set
            to 1.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to the plane 
2 or 12 - Project normal to shell elements touching nodes
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10, 11 and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the plane for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Example
To map nodes on mark 1 to the x-y plane with an offset of 1.2 when not using
          *morphmaprecalc:
*createplane 1 0 0 0 1 0 0
*morphmaptoplanevecoffset nodes 1 handles 1 1 0 1 2 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
581,*morphmaptotacitvecoffset ,"Description
Maps nodes to, or offset from, a mark of elements using the temporary shape created
          by *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the target elements along a vector, normal to the target
        elements, or projected normal to the elements touching the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
entity_type_elems
Must be set to elems.
mark_id_elems
The ID of the mark containing the elems to map to. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to the elements on the mark 
2 or 12 - Project normal to shell elements touching nodes
If offset is non-zero, the offset will be measured from the closest
            point on the elements for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10, 11 and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the elements for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Example
To map all nodes to elements 1-100 with an offset of 1.2 when not using
          *morphmaprecalc:
*createmark nodes 1 ""all""
*createmark elems 1 1-100
*morphmaptotacitvecoffset nodes 1 handles 1 elems 1 0 1 2 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
582,*morphmaptshpedge,"Description
Adds and edge domain perturbation to the current temporary shape.
","Inputs

dtype
Domains
dmark
Domain mark number
etype
Elems
emark
Element mark number
stype
Surfs
smark
Surface mark number
lline
Not currently used
plane
Mark number of plane
line
ID of line
points
Mark number of points for a line
niproj
Direction of projection: 
0 - Along vector (iproj) 
1 - Normal to geom 
2 - Fit to line (if to a line or node list) normal to elems (if to
            a plane, surface, or mesh).
clear
Determine if/how to delete perturbations: 
0 - Add perturbation 
1 - Clear temporary and add perturbation 
2 - Reject last *morphmaptshpedge() operation
sym
0 - Do not use symmetry (only option)
con
1 - Use constraints (only option)
type
The type of target to be mapped to. 
0 - Node list 
1 - Line 
2 - Plane 
3 - Surface 
4 - Elements

","Example
*morphmaptshpedge (DOMAINS,1,ELEMS,1,SURFS,1,NULL,1,32,1,0,1,0,0,1,1)
This command is part of the map to geometry function which consists of multiple commands.
        This command is called any number of times, first with clear set to 1,
        then subsequently set to 0, followed either by one of the many
          *morphmapto…() commands. If clear is set to 2 then
        the last *morphmaptshpedge() command is rejected. 
Type denotes the type of target to be mapped to. Either the plane, line, points, surface
        mark, or element mark must be filled with a valid entry corresponding to the type
        selected.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
583,*morphmvskinsolve ,"Description
This command will finish the morphing applied to the model when using morph volumes in
        ""skin only"" mode. When in ""skin only"" mode, only the exterior nodes of a solid element mesh
        will be morphed, leaving the interior unmorphed. This command completes the morphing
        process, allowing you to morph the model many times without needing to wait for all of the
        nodes to be updated. Then you may call this command to solve for the entire model. If the
        morph volumes are unmorphed since the last time this command was called or the morph volumes
        are not in ""skin only"" mode, this command will perform no action. 
Use the command *morphupdateparameter with argument ""mvon"" to set and
        unset the morph volumes to inactive, active, and skin only modes.
","Example
To solve for the interior nodes after morphing morph volumes in skin only mode:
*morphmvskinsolve
","Errors
None.
",
584,*morphnodesextendedoffset,"Description
This command will move the selected nodes to extended surfaces or elements either normal to
        the surfaces or elements, along a vector, or normal to the elements attached to the nodes.
        The fixed nodes are held in place and the affected elements (or all unfixed nodes in the
        model if integ is 3, 6 or 7) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements.
If integ is 0, a general domain is temporarily created for the
            affected elements. If integ is 1, the domains currently in the model
            are used. 
If integ is 2, 1D, 2D, 3D, and edge domains are temporarily created
            for the affected elements but the 2D domains are not partitioned.
 If integ is 3 then handle influences are applied using a spatial
            relationship rather than through a domain.
 If integ is 4, only the selected moving nodes are moved and all
            others are held fixed.
 If integ is 5, 1D, 2D, 3D, and edge domains are temporarily
            created for the affected elements and the 2D domains are partitioned. Any handles
            created due to partitioning are moved based on their distance from the moving and fixed
            nodes.
 If integ is 6, then handle influences are applied using the
            Kriging algorithm.
If integ is 7, then handle influences extend only up to a given
            distance (if envelope is positive) or a given multiple of the applied perturbations (if
            envelope is negative) away from the moving nodes.


The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6, all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of undisplayed.
If offset is non-zero, the moving nodes will be offset from the extended
        surfaces or elements by the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The ID of the mark containing the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_entity_type
The type of entity to map to. Valid values are surfs and elems.
f_mark_id
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_entity_type
The type of entity to map to. Valid values are surfs and elems.
t_mark_id
The ID of the mark containing the entities to map to. Valid values are 1 and 2.
nproj
0 or 10 - Project along c_vec
1 or 11 - Project normal to target surfaces or elements
2 or 12 - Project normal to attached elements
5 or 15 - Project normal to attached elements using smoothed normals
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the mesh for values of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain)
1 - Use existing domains
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning)
3 - Morph all nodes using a proximity algorithm
4 - Morph all moving nodes and fix the unselected nodes
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning)
6 - Morph all nodes using the Kriging algorithm
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor for moving nodes on affected elements.
fbias
Bias factor for fixed nodes on affected elements.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled:
0 - Morph nodes on undisplayed elements
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the target surfaces or elements
            for values of nproj of 0, 1, 2, 5 and 6. The offset will be measured
            along the projection vector normal for values of nproj of 10, 11, 12,
            15 and 16.

","Example
To move a mark of nodes to be offset 1.2 from a mesh normal to the mesh and stretch all the
        elements in the model using the existing
        domains:*createmark nodes 1 11 12 13
*createmark elems 1 1-100
*createmark nodes 2 21 22 23
*createmark elems 2 101-200
*createvector 1 1.0 0.0 0.0
*morphnodesextendedoffset nodes 1 elems 1 nodes 2 elems 2 0 1 1 1.0 1.0 0.0 0 1.2

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
585,*morphnodesmatrixdiffenvelope,"Description
This command will reorient the selected nodes by taking the difference between two matrices
        positioned with respect to the global coordinate system. For each node, the position
        relative to the initial matrix is found and then relocated to the same relative position
        with respect to the final matrix. The fixed nodes are held in place and the affected
        elements (or all unfixed nodes in the model if integ is 3, 6, or 7) are
        stretched according to the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily created for the
        affected elements. If integ is 1, the domains currently in the model are
        used. If integ is 2, 1D, 2D, 3D, and edge domains are temporarily created
        for the affected elements but the 2D domains are not partitioned. If
          integ is 3 then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed
        elements and components can be morphed, fixed, or excluded depending on the value sent in
        for undisplayed.
","
Inputs



m_entity_type

Must be set to nodes.

m_mark_id

Mark ID of moving nodes. Valid values are 1 and 2.

e_entity_type

Must be set to elems.

e_mark_id

Mark ID of affected elements. Valid values are 1 and 2.

f_entity_type

Must be set to nodes.

f_mark_id

Mark ID of fixed nodes. Valid values are 1 and 2.

matrix_array

ID of array of doubles, created using *createdoublearray. This
            should be set to 1. This array defines two 4x4 matrices where the first matrix is at the
            final orientation and the second matrix is at the initial orientation. The matrices have
            the following format:
[rxx rxy rxz 0 ryx ryy ryz 0 rzx rzy rzz 0 tx ty tz 1]

matrix_length

The length of matrix_array. Must be set to 32.

integ

0 - Free edges (a single general domain)
1 - Use existing domains
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning)
3 - Morph all nodes using a proximity algorithm
4 - Morph all moving nodes and fix the unselected nodes
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning)
6 - Morph all nodes algorithm using the Kriging algorithm
7 - Morph all nodes within an envelope around the moving nodes

mbias

Bias factor of moving nodes.

fbias

Bias factor of fixed nodes.

envelope

If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. If integ is set to 7, the distance given defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed. If integ is set to 7, the
            calculated distance defines an envelope around the moving nodes within which the
            morphing of those nodes will linearly taper from fully matching the nearest moving node
            to zero at the edge of the envelope. If any fixed nodes are within the envelope they
            will also reduce the morphing of nearby nodes.

undisplayed

If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This field can be used to determine how undisplayed nodes are
            handled:
0 - Morph nodes on undisplayed elements
1 - Fix nodes on undisplayed elements - they will function just like nodes on the
            fixed mark
2 - Exclude nodes on undisplayed elements - they will not be morphed nor affect the
            morphing

","Examples
To translate and rotate a mark of nodes and stretch all the elements in the model using the
        existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createdoublearray 32 0.866 0.5 0 0 -0.5 0.866 0 0 0 0 1.0 0 1.8 2.6 3.5 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1
*morphnodesmatrixdiffenvelope nodes 1 elems 1 nodes 2 1 1 1.0 1.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
586,*morphnodesnodesoffset,"Description
This command will move the selected nodes to a line created using a node list. The moving
        nodes may be projected to the line along a vector, normal to the line, or fit to the line
        (even distribution). The fixed nodes are held in place and the affected elements (or all
        unfixed nodes in the model if integ is 3 or 6) are stretched according to
        the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, all elements in model are
        used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_node_list
The ID of the node list for the line to which the nodes will be moved. Valid values are 1 and 2.
m_node_list
The ID of the node list for the moving nodes. Valid values are 1 and 2.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to lines 
2 - Fit nodes to line
If offset is non-zero, the offset will be measured from the closest
            point on the lines for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the lines for values of
              nproj of 0 and 1. The offset will be measured along the projection
            vector normal for values of nproj of 10 and 11.

","Example
To move a mark of nodes to be offset 1.2 from a node list normal to the node list and
        stretch all the elements in the model using the existing domains:
*createmark elems 1 ""all""
*createmark nodes 1 21 22 23
*createlist nodes 1 51 52 53
*createlist nodes 2 61 62 63
*createvector 1 1.0 0.0 0.0
*morphnodesnodesoffset elems 1 nodes 1 1 1 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
587,*morphnodesplaneoffset ,"Description
This command will move the selected nodes to a plane. The moving nodes may be project to
        the plane along a vector, normal to the plane, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6 all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_plane
The ID of the plane created using *createplane to which the nodes
            will be projected. Must be set to 1.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to target mesh 
2 or 12 - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the plane for values of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
 The distance to offset nodes from the target.
The offset will be measured from the closest point on the plane for values of
              nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes to be offset 1.2 from a plane and stretch all the elements in the
        model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createplane 1 1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphnodesplaneoffset nodes 1 elems 1 nodes 2 1 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
588,*morphnodesshapeenvelope ,"Description
This command will apply the specified shape to the mesh be a factor specified by
          mult. The fixed nodes are held in place and the affected elements (or
        all unfixed nodes in the model if integ is 3 or 6) are stretched
        according to the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are temporarily created
        for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
a_shape
The ID of the shape to be applied.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
mult
The multiplication factor for the shape.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.

","Example
To apply a shape 3 times the original perturbation and stretch all the elements in the
        model using the existing domains:
*createmark elems 1 ""all""
*createmark nodes 1 21 22 23
*morphnodesshapeenvelope elems 1 nodes 1 14 1 1.0 1.0 3.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
589,*morphnodestranslateenvelope,"Description
This command will translate the selected nodes in the global system or using a specified
        local system. The fixed nodes are held in place and the affected elements (or all unfixed
        nodes in the model if integ is 3 or 6) are stretched according to the
        value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
x
The x direction translation.
y
The y direction translation.
z
The z direction translation.
s_system
The ID of the local system to use for translation. 0 indicates to use the global
            system.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
 7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope, they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing

","Example
To translate a mark of nodes by (5.0, 3.0, 2.0) in global coordinates and stretch all the
        elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*morphnodestranslateenvelope nodes 1 elems 1 nodes 2 5.0 3.0 2.0 0 1 1.0 1.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
590,*morphorganizedomain ,"Description
Organizes elements on mark into specified domain.
","Inputs

elemtype
Nodes (for global domains) 
Elems (for non-global domains)
elemmark
Node or element mark number
dptr
ID of domain
type
0 global domain 
11 D domain 
22 D domain 
33 D domain 
7 general domain
rethand
0 do not retain handles 
1 retain handles

","Example
*morphorganizedomain (ELEMS,1,32,2,0)
Nodes or elements on the mark are removed from the domains that they are in and placed into
        the specified domain. Nodes or elements not in the selection are removed from the specified
        domain. Thus the specified domain will retain only the selected elements. 
The type specified notes which nodes or elements in the mark will be retained. If no
        elements of the correct type are on the mark for non-global domains the command will exit. 
","Errors
None.
"
591,*morphpartition ,"Description
Organizes elements on mark into specified domain.
","Inputs

dtype
DOMAINS
dmark
Domain mark number.

","Example
*morphpartition(DOMAIN,1)

Only 2D domains on the mark will be partitioned. 
","Errors
None.
"
592,*morphrecalcmvhandles ,"Description
none.
","Example
*morphrecalcmvhandles

This command recalculates the influences for all handles on morph volumes. This will
        recalculate the dependent handle influences as well as influences between handles and nodes
        on morph volumes which do not have handles on them.
","Errors
None.
",
593,*morphreflectshapemark ,"Description
This command will reflect each shape on s_mark_id and reflect them
        according to each symmetry on sym_mark_id and affect only the nodes on
          a_mark_id. The shapes may be applied to the mesh, created as new
        shapes, added to existing shapes, or may replace existing shapes.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The mark ID of the shapes. Valid values are 1 and 2.
sym_entity_type
Must be set to symmetries.
sym_mark_id
The mark ID for symmetries. Valid values are 1 and 2.
a_entity_type
Must be set to nodes.
a_mark_id
The mark ID for target nodes. Valid values are 1 and 2.
mode
0 - Apply each shape to the mesh 
1 - Apply each shape and add the perturbations to the original shape 
2 - Apply each shape and overwrite the original shape 
3 - Apply each shape and create a new shape or shapes 
4 - Create a new shape or shapes but do not apply them to the mesh
tol
The ""envelope"" or distance around the translated shape inside which nodes are
            affected.
con
0 - Do not use constraints 
1 - Use constraints

","Examples
To reflect a shape using a symmetry and apply it to the mesh:
*createmark shapes 1 1
*createmark symmetrys 1 1
*createmark nodes 2 ""all""
*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1
To reflect all shapes using all symmetries and create new shapes, but only on selected
        nodes:
*createmark shapes 1 ""all""
*createmark symmetrys 1 ""all""
*createmark nodes 2 1 2 3 4 5 6 7 8 9 10 11 12
*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 4 3.0 1
","Errors
Incorrect usage of *morphreflectshapemark results in a Tcl error. To detect errors, you can
        use the catch
        command:if { [ catch {*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1} ] } {
# Handle error
}
""Symmetries must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if none of the
        symmetries on the mark are of a reflective type. Non-reflective symmetries are allowed on
        the mark but will be
        ignored.if { [ catch {*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1} ] } {
# Handle error
}
""Symmetries must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if none of the
        symmetries on the mark are of a reflective type. Non-reflective symmetries are allowed on
        the mark but will be ignored.
"
594,*morphremeshedges,"Description
This command will remesh the selected domains or elements using the parameters specified.
        If domains are selected, edge domains between selected domains or along free edges will also
        be remeshed. 
Shapes will be preserved no matter if they are saved as node or handle perturbations. Note
        that the morphs on the undo/redo list are not preserved unless the preserve flag is set. 
If auto smoothing is turned on, remeshed domains will also be smoothed. 
During remeshing, HyperMorph will preserve nodes which are part
        of morph constraints or which have handles attached to them.
","Inputs

e_entity_type
Valid values are domains and elems.
e_mark_id
The ID of the mark containing the domains or elements. Valid values are 1 and 2.
starg
The target element size. If ≤ 0, the target element size used will be the average
            element size for the entities on the mark.
size
0 - Do not use size control in remeshing 
1 - Use size control
skew
0 - Do not use skew control in remeshing 
1 - Use skew control
mesh
0 - Mesh with trias 
1 - Mesh with quads 
2 - Mesh with trias and quads 
3 - Mesh with right trias
preserve
0 - Do not preserve shapes after remesh, do auto QA if set. 
1 - Preserve shapes after remesh, do auto QA if set. 
2 - Do not preserve shapes after remesh, do not do auto QA if set. 
3 - Preserve shapes after remesh, do not do auto QA if set.
qa
0 - Do not wait during auto quality check 
1 - Wait for mouse click during auto quality check

","Examples
To remesh all domains with a target element size of 10.0 model units: 
*createmark domains 1 ""all""
*morphremeshedges domains 1 10.0 1 1 1 1 0
 To remesh all elements with a target element size of 10.0 model units:
*createmark elems 1 ""all""
*morphremeshedges elems 1 10.0 1 1 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
595,*morphrenamehandle,"Description
Renames a handle. 
","Inputs

nameold
Current name of handle.
namenew
New name of handle.

","Example
*morphrenamehandle (""bob"",""dave"")
Name of handle is changed from nameold to namenew. 
The new name does not need to be unique since this command will create a unique name if a
        duplicate is detected. 
This command is not called in HyperMesh. The general rename
        command is used instead. 
","Errors
None.
"
596,*morphrotatetrue,"Description
Rotates handles on mark using 'true' rotation.
","Inputs

entities
Handles
markmask
Handle mark number.
plane
Mark number of plane defined by base point and vector of rotation.
angle
Angle of rotation.
sym
Flag to use symmetry: 
0 - Do not use symmetry 
1 - Symmetry
con
Flag to use constraints: 
0 - Do not use constraints 
1 - Use constraints
vari
Type of rotation (see comments): 
0 - Constant 
1 - Linear

","Example
*morphrotatetrue (HANDLES,1,1,30.0,1,1,0)
All handles on the mark will be rotated about the axis defined by the plane. This command
        differs from *morphhandlerotate() by the behavior of the influenced
        nodes. With this command the nodes are rotated about the axis by an amount proportional to
        the influence coefficient between the rotated handle and the node. 
If vari is 0, all the handles will be rotated by the given angle. 
If vari is 1, the handle farthest from the base point of the plane will
        be rotated by the given angle and the other handles will be rotated by the given angle times
        the distance of each handle to the base point of the plane divided by the distance of the
        farthest handle to the base point of the plane. The distances are measured normal to the
        plane. 
If symmetry is used, all handles linked to marked handles by symmetry will also be rotated.
        If constraints are used, they will be applied to the rotations. 
","Errors
None.
"
597,*morphsavemvols ,"Description
Saves morph volume, handle, and shape data to a file.
","Inputs

stype
Hypercubes
smark
Mark number of morph volumes.
savefile
Name of data file.
shapes
0 - Do not save shapes for morph volumes on mark 
1 - Save shapes for morph volumes on mark

","Example
*morphsavemvols (HYPERCUBES,1,""mvols.dat"",1)
This command will save the morph volumes on the mark to the specified file along with any
        handles on those morph volumes and any shapes which affect the morph volumes. 
","Errors
None.
"
598,*morphsculptmesh3,"Description
This command sculpts the elements on the first mark according to the various parameters.
        Sculpting is treated as a morph and can be undone and redone. 
Note that you must always create all marks, lists, vectors, and the plane before
          *morphsculptmesh3, even if they are not used. Make sure the vectors and
        the plane are non-zero.
","Inputs

e_entity_type
Must be set to elems.
e_mark_id
Mark ID of elements to be sculpted. Valid values are 1 and 2.
s_entity_type
Must be set to surfs.
s_mark_id
Mark ID of surfaces defining the sculpting tool (tool 5). Valid values are 1 and 2.
t_entity_type
Must be set to elems.
t_mark_id
Mark ID of elements defining the sculpting tool (tool 6). Valid values are 1 and 2.
n_entity_type
Must be set to nodes.
n_mark_id
Mark ID of the fixed nodes. If using a finite element solver, the stretching of the
            mesh will occur between the nodes which are sculpted and the fixed nodes. Valid values are 1 and 2.
tool
0 - ball 
1 - cone 
2 - cylinder 
3 - line from line list 
4 - plane 
5 - surfaces 
6 - mesh 
7 - line from nodes
t_vec
ID of the orientation vector for cylinder tool (tool 2), created
            using *createvector . Valid values are 1 and 2.
t_line_list
ID of the line list for line tool (tool 3), created using
              *createlist. Valid values are 1 and 2.
t_node_list
ID of the node list for node tool (tool 3) and line sculpting tool
              (tool 7), created using *createlist. Valid values are 1 and 2.
t_plane
ID of plane for plane tool (tool 4), created using
              *createplane. Valid values are 1 and 2.
xbase
X-coordinate of reference point for positioning line, surface, and mesh tools
              (tool 3, 5, and 6).
ybase
Y-coordinate of reference point for positioning line, surface, and mesh tools
              (tool 3, 5, and 6).
zbase
Z-coordinate of reference point for positioning line, surface, and mesh tools
              (tool 3, 5, and 6).
tsize
Radius for ball and cylinder tools 
Angle for cone tool 
Taper angle for line, surface, and mesh tools
offset
Amount of offset for tool in sculpting direction.
path
0 - Along node list - smooth (using p_node_list ) 
1 - Along line list (using p_line_list and p_node_list
            ) 
2 - Along list of coordinates - smooth (using p_xyz
              andp_nxyz)
p_line_list
ID of the line list for path, created using *createlist. Valid values are 1 and 2.
p_node_list
ID of the node list for path, created using *createlist. Valid values are 1 and 2.
p_xyz
ID of array of doubles, created using *createdoublearray. This
            should be set to 1. The format for this array is that the first three doubles are the x,
            y, and z coordinates of the first point along the path, the next three doubles are the
            xyz coordinates of the second point along the path, and so forth.
p_nxyz
The number of doubles in p_xyz.
s_vec
ID of the vector for the sculpting direction, created using
              *createvector. Valid values are 1 and 2.
push
0 - Pull
1 - Push
remesh
0 - Do not remesh
1 - Remesh (not supported)
2 - Interactive mode
3 - Interactive mode with remesh (not supported)
solver
0 - Use mesh compression to determine mesh stretching
1 - Use linear analysis to determine mesh stretching (OptiStruct). Automatically generate properties and materials for
            the affected elements.
2 - Use nonlinear analysis to determine mesh stretching (Radioss). Automatically generate properties and materials for the
            affected elements.
3 - Use linear analysis (as 1 above) but use existing properties and materials
4 - Use nonlinear analysis (as 2 above) but use existing properties and materials
con
0 - Do not use constraints 
1 - Use constraints
comp
0.0 - 1.0 - If using fractional compression, this is the maximum amount of mesh
            compression allowed per element (1.0 allows full compression and elements may become
            flat, 0.5 allows 50% compression).
> 0.0 - If using distance-based compression, this is the distance, in model units,
            from the tool through which all compression will be applied.
Not used when sculpting using a finite element solver.
mode
0 - Sculpt along vector using fractional compression 
1 - Sculpt along vector using distance-based compression
2 - To sculpt normal to mesh using fractional compression
3 - To sculpt normal to mesh using distance-based compression
4 - To sculpt with smoothed normals using fractional compression
5 - To sculpt with smoothed normals using distance-based compression
6 - To sculpt with cfd corners for normals using fractional compression
7 - To sculpt with cfd corners for normals using distance-based compression
Note that sculpting normal to the mesh requires that shell elements be included in the
            affected elements. If solid elements are covered with a layer of shell elements then the
            solid elements will be sculpted as well.

","Example
To sculpt all elements using a ball of size 5.0 normal to the mesh using linear analysis
        and automatic properties:
*createmark elems 1 ""all""
*createmark surfs 1
*createmark elems 2
*createmark nodes 1 12 13 14 15
*createlist lines 1
*createlist nodes 1
*createlist lines 2 12
*createlist nodes 2
*createvector 1 1.0 0.0 0.0
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createdoublearray 0
*createvector 2 16.9220 -3.7030 -25.1660
*morphsculptmesh3 elems 1 surfs 1 elems 2 nodes 1 0 1 1 1 1 7027 5.0 0.0 0 2 2 1 0 2 1 0 1 1 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
599,*morphsetsmoothignoredelems,"Description
Assigns elements to be ignored when performing element test criteria for shape combination
        checking via *morphshapesmooth. Note that the excluded elements are
        retained in memory until this command is used to clear or change them, or until a new model
        is loaded.
","Inputs

entity_type
Must be set to elems.
mark_id
The ID of the mark containing the elements to ignore. Valid values are 1 and 2.

","Example
To set all elements in the component boundary to be ignored:
*createmark elems 1 ""by comp"" boundary
*morphsetsmoothignoredelements elems 1
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphsetsmoothignoredelems...} ] } {
   # Handle error
}
"
600,*morphshapeapply ,"Description
Applies the shapes on the mark to the model. 
","Inputs

shtype
Shapes
shmark
Shape mark number.
mult
Multiplier to applied shapes.

","Example
*morphshapeapply (SHAPES,1,2.0)
Shapes on the mark are applied to the model consecutively and scaled up or down by the
        multiplier. 
For HyperMesh versions 8.0 and higher, active constraints will
        be applied to the shapes. For previous versions of HyperMesh,
        constraints were not applied.
","Errors
None.
"
601,*morphshapecreatecolor,"Description
Creates a new shape out of the applied morphs, with a specified color.
","Inputs

shapename
Name of shape.
option
Set shape’s save options:
0 - Save as handle and node perturbations 
1 - Save as pure node perturbations 
2 - Save as node perturbations without global handle nodes


color
The shape’s color (an integer from 0 to 63).

","Example
*morphshapecreatecolor (""groovy"",0,15)
The specified shape will be created representing the difference between the current node
        and handle positions and the original node and handle positions.
Saving as handle and node perturbations will try to save everything done as handle
        perturbations except where biasing factors have changed and constraints have been applied.
        Saving as pure node perturbations will save the shape exclusively as node perturbations. The
        difference comes into play when new handles are created. If a shape is saved as handles and
        nodes, a new handle will not move when the shape is applied, possibly changing the shape. If
        a shape is saved as pure nodes, a new handle will move along with its grid.
Saving as node perturbations without global handle nodes (option 2) will save the shape as
        node perturbations excluding the node perturbations for global handles. 
","Errors
None.
"
602,*morphshapecreatelist,"Description
This command creates a number of new shapes from the morph list.
","Inputs

name
The base name of the shape.
option
The shape's save options. Valid values are:
0 - Save as handle and node perturbations.
1 - Save as pure node perturbations.


color
The color of of the shapes. Valid values are 1 through 64.

","Example
To create shapes with the base name ""shape"" for all morphs on the morph
        list:*morphshapecreatelist ""shape"" 1 33
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
603,*morphshapecreateorthogonalbound ,"Description
This command will convert all the shapes on the first mark into shapes, design variables,
        equations, and dlink2 entities when using the constraint and system methods. An initial
        value along with upper and lower bounds can be set for the design variables.
For the constraint method, a non-linear shape will be deduced by applying each shape on
          the s_mark_id by a number of factors from 0.0 to 1.0 equal to the value
        of prec, enforcing any active constraints, and fitting a curve through
        the intermediate positions for each node.
For the mid-shape method, a non-linear shape will be deduced by fitting a shape through a
        curve beginning at the unperturbed position, traveling through the position attained when
        the shape on the md_mark_id is applied, and ending at the position
        attained when the shape on the s_mark_id is applied.
For the system method, each shape on s_mark_id will be assumed to rotate
        about the z-axis of the selected system instead of moving linearly in the xy plane. A
        non-linear shape will be deduced from the circular node paths.
For all methods, the non-linear paths of the nodes are represented by a
        pair of linear shape variables, plus a corrective shape variable, which are linked together
        via equations and dlink2 entities. The result is a single design variable which, when
        changed, applies the linear shape variables in such a way that the nodes move along
        non-linear paths.
For the constraint and system methods, if multiple shapes are selected,
        conflicts between each pair of shapes (such as when the application of one shape causes
        another to violate constraints) are detected and resolved by adding a corrective shape which
        is linked to those two shapes through an equation and a dlink2 entity.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The ID of the mark containing the shapes. Valid values are 1 and 2.
md_entity_type
Must be set to shapes.
mdmark
The ID of the mark containing the mid-shapes (for mid-shape method). Valid values are 1 and 2.
system_id
The ID of the system about which shapes are defined (for system method).
method
0 - non-linearity is due to constraints 
1 - non-linearity is deduced from mid-shape 
2 - non-linearity is due to rotation about a system
prec
Number of intermediate positions for non-linear approximation.
tol
Tolerance for establishing linear versus non-linear.
initial
The initial value of the design variables.
l_bound
The lower bound of the design variables.
u_bound
The upper bound of the design variables.

","Examples
To create non-linear shapes, equations, etc., for all the shapes in the model using the
        constraint method, with 0.5 as the initial value, and lower and upper bounds of 0.0 and
        1.0:
*createmark shapes 1 ""all""
*morphshapecreateorthogonalbound shapes 1 shapes 1 0 0 10 0.001 0.5 0.0 1.0
To create non-linear shapes, equations, etc., for shape ""full"" using shape ""mid"" as the
        mid-shape, with 0.5 as the initial value, and lower and upper bounds of 0.0 and 1.0:
*createmark shapes 1 ""full""
*createmark shapes 2 ""mid""
*morphshapecreateorthogonal shapes 1 shapes 2 0 1 10 0.001 0.5 0.0 1.0
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphshapecreateorthogonalbound...} ] } {
   # Handle error
}
"
604,*morphshapelinkedpush ,"Description
This command will add the specified shape to an internal list along with the multiplier for
        the shape which you wish to apply. The list may contain one or more shapes. Calling the
          command *morphshapelinkedapply will apply all the shapes on the list at
        their specified multiplier values. It will also apply any shapes linked to the applied
        shapes via desvar, deqatn, and dlink2 cards, such as those created during non-linear design
        variable generation. Calling *morphshapelinkedapply will clear the
        internal list of shapes and multipliers.
","Inputs

shape_id
The ID of the shape to add.
mult
The multiplication factor for the shape.

","Example
To mark shape ID 3 with multiplier of 0.5:
*morphshapelinkedpush 3 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
605,*morphshapesmooth,"Description
This command will apply the selected shapes on the mark in every combination possible at
        their most extreme values (either 0.0 and 1.0 or the lower and upper bounds on associated
        desvar entities), checking the element quality of the mesh and reporting the worst values in
        a specified file. Optionally this command can be used to smooth the shapes on the mark
        individually or to smooth all of the combinations of the shapes simultaneously, improving
        the element quality of the mesh for each combination. The quality will be checked and a
        report issued after any smoothing is performed. The report will also include the maximum
        upper and lower bounds at which the shapes on the mark can be applied in order to avoid
        errors during shape optimization.
","Inputs

entity_type
Must be set to shapes.
mark_id
The ID of the mark containing shapes. Valid values are 1 and 2.
option
0 - Check all combinations for conflicts 
1 - Smooth each individual shape and check combinations for conflicts 
2 - Smooth all shape combinations simultaneously and check combinations for
            conflicts
report_file
Full path and file name of report file.

","Examples
To check the element quality for four shapes when applied at all possible combinations:
*createmark shapes 1 ""s1"" ""s2"" ""s3"" ""s4""
*morphshapesmooth shapes 1 0 ""C:/Temp/Report.txt""
 To smooth the shapes on the mark for all possible combinations:
*createmark shapes 1 ""s1"" ""s2"" ""s3"" ""s4""
*morphshapesmooth shapes 1 2 ""C:/Temp/Report.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
606,*morphshrinkmvols ,"Description
This command performs one or more iterations of shrinking to the selected morph volumes
        with the objective of meeting the target buffer percentage regardless of the shape of the
        mesh. 
Two methods are supported: implicit and explicit; and can be set with the
          iface option. Explicit is the older, slower method which uses
        externally calculated sensitivities for the interior nodes, and implicit is the newer,
        faster method which uses internally calculated sensitivities for the interior nodes. After
        using the intrinsic method, this command should be called with iface = 6
        to clear the memory allocated for quicker iterations. 
To perform iterations one at a time, call this command with itermax set
        to -1 for the first iteration and then decrement the value for each subsequent iteration
        (i.e. -1 first, then -2, -3, etc.). This enables proper convergence while retaining the
        option to abort the process at any time. 
Assigning a vector and setting the uvec flag will restrict the movements
        of the nodes which define the morph volumes so that they can only move in the direction of
        the vector. This will apply to all the nodes of the morph volumes.
","Inputs

ctype
morphvolumes
cmark
Mark ID of morph volumes to be shrunk. Valid values are 1 and 2.
buffer
Percentage buffer zone target.
iface
0 - extrinsic mode + do not allow inner faces to move 
1 - extrinsic mode + allow inner faces to move 
3 - extrinsic mode + grow faces to full height 
4 - intrinsic mode + do not allow inner faces to move 
5 - intrinsic mode + allow inner faces to move 
6 - intrinsic mode, clear memory allocated (no shrinking is performed)
itermax
A positive value indicates the maximum number of iterations allowed. 
A negative value indicates that one iteration is performed.
uvec
0 - Allow morph volume nodes to move in all directions. 
1 - Limit morph volume nodes to move only along vector.
vec
Vector constraining the movement of morph volume nodes.

","Examples
To shrink all the morph volumes in the model while allowing internal face movement and not
        restricting the movement of the corner nodes for four iterations:
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 4 0 1
 To shrink all the morph volumes in the model, allowing internal face movement and not
        restricting the movement of the corner nodes, for four consecutive iterations:
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 0 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -1 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -2 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -3 0 1
","Errors
This command does not return any errors that can be handled.
"
607,*morphsmoothmorphbased,"Description
This command will smooth any shell or solid element mesh, trying to improve the quality of
        the mesh while preserving the shape of the mesh. The smoothing of the mesh will be stored as
        a morph and thus can be undone, redone, or saved as part of a shape. 
Two ways are provided to allow the user to fix nodes during the smoothing. The first is
        manual selection: any nodes on the node mark will be held fixed. The second is automatic
        selection via the fix_type option where you can select all nodes that lie
        on edges, faces, or feature lines and fix them all at once. All nodes selected using both
        methods will be fixed.
","Inputs

d_entity_type
Valid values are domains and elems.
d_mark_id
The mark ID of the domains or elements to be smoothed. Valid values are 1 and 2.
f_entity_type
Valid values are nodes.
f_mark_id
The mark ID of the nodes to be held fixed. Valid values are 1 and 2.
iter
The number of smoothing iterations that will be performed on the mesh. A normal value
            is 50.
quality_level
The desired quality level you wish to attain. The higher the level, the more time
            required to smooth the mesh.
1 - low quality, faster solving 
2 - Balance between quality and solution speed 
3 - High quality, slower solving


fix_type
Specifies which parts of the mesh should be automatically fixed in addition to any
            fixed nodes. Nodes associated with morph constraints will automatically be fixed. For
            best results, at least one node should be fixed using either this parameter or the mark
            of fixed nodes.
0 - Nodes at handles (only when domains have been selected) 
1 - Fix edge domains or any nodes around the edge of selected elements 
2 - Fix nodes on feature edges 
3 - Fix nodes on the faces of the domains or elements


fix_angle
If fix_type is 3, the feature angle for determining the feature
            lines must be provided. For all other fix types this value is ignored. 
If the angle between two shell elements or the faces of two solid elements exceeds
            this value, a feature line will be placed between the two elements which will fix the
            nodes along that line. Valid values are between 0.0 and 180.0 with 0.0 meaning that the
            elements are perfectly flat. A normal value is 30.0.

","Examples
To smooth a 2D domain at a balanced quality level with only the edge domains around it
        fixed:
*createmark domains 1 9
*createmark nodes 1 
*morphsmoothmorphbased domains 1 nodes 1 50 2 1 30
 To smooth a solid mesh at the best quality level while fixing the edges, feature lines,
        and a few user specified nodes, but not the face
        nodes:*createmark elements 1 ""all""
*createmark nodes 1 6079 6080 6108 6112 6113 6114
*morphsmoothmorphbased elements 1 nodes 1 50 3 2 30
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
608,*morphstoredomains ,"Description
Stores or restores a copy of current domains, handles, and shapes.
","Inputs

mode
The mode you want to use the command in:
1 - Store domains 
2 - Restore domains 
3 - Free (empty) the memory used for storage



","Example
*morphstoredomains (1)
This command either stores a copy of all the handles, domain, and shapes in the database,
        restores that copy - replacing the current entities in the database, or clears the memory
        where the stored copy was kept. This is how HyperMorph enables
        the reject command for the extensive changes which can result from domain creation or
        updating. 
Typical usage would be to call this command with mode = 1, call any
        command which modifies handles, domains, and shapes, and then call this command with
          mode = 2 if you want to reject the previous changes. Then make sure to
        call this command with mode = 3 to free up the memory used for
        storage.
","Errors
None.
"
609,*morphstoremorphvolumes ,"Description
Stores or restores a copy of current morph volumes and handles.
","Inputs

mode
1 = store morph volumes 
2 = restore morph volumes 
3 = free memory used for storage

","Example
*morphstoremorphvolumes (1)

This command either stores a copy of all the morph volumes and handles in the database,
        restores that copy - replacing the current entities in the database, or clears the memory
        where the stored copy was kept.This is how HyperMorph enables the reject command for the
        extensive changes which can result from morph volume creation or updating. 
Typical usage would be to call this command with mode = 1, call any command which modifies
        morph volumes, and then call this command with mode = 2 if you wish to reject the changes.
        Be sure to call this command with mode = 3 to free up the memory used for storage. 
","Errors
None.
"
610,*morphsurfaces ,"Description
Calls surface morphing function. 
","Inputs

surftype
Surfs
marksurf
Surface mark number

","Example
*morphsurfaces (SURFS,1)
This command morphs the surfaces for a given model. Any surface that is associated with a
        node that has been morphed will be morphed when this command is used.
","Errors
None.
"
611,*morphsymmetryrefresh ,"Description
none.
","Example
*morphsymmetryrefresh()
All symmetries in the model will be refreshed and all symmetric relationships between
        handles will be updated. Note that handles which are linked through symmetry may become
        unlinked if they are no longer symmetric. Similarly, new links may be created between
        previously unlinked handles. 
Whenever handles and symmetries are created, updated, or deleted, the symmetries are
        refreshed automatically. This command is intended for situations where the user wishes to
        refresh the symmetries manually.
","Errors
None.
",
612,*morphsymmetryupdatebyd ,"Description
Update symmetries for a domain.
","Inputs

dptr
ID of domain.
symtype
Symmetries
marksym
Symmetry mark number.

","Example
*morphsymmetryupdatebyd (4,SYMMETRYS,1)
Domain will be updated to use the symmetries on the mark.
","Errors
None.
"
613,*morphupdatedatabase ,"Description
Updates morph volume database.
","Example
*morphupdatedatabase ()
This command updates the database for morph volumes based on the current value of the
        ""cubestat"" parameter. This command is called when necessary inside other commands and
        shouldn't need to be called by the user. 
","Errors
None.
",
614,*morphupdatedomainmethod,"Description
Updates method for selected 1D domains.
","Inputs

dtype
Domains
dmark
Domain mark number.
method
1 = Independent 
2 = Slave 
3 = Master 
4=Cluster

","Example
*morphupdatedomainmethod (DOMAINS,1,3)
This command will update the method for assigning handles and dependencies for the selected
        1D domains. Handles may be created or deleted during this operation as well as having the
        dependencies changed for handles on other domains.
","Errors
None.
"
615,*morphupdateendbymvol ,"Description
This command will update the end conditions (free, fixed, master-slave, or continuous) for
        edges on the morph volumes specified in the marks. Connecting edges from one group of morph
        volumes to another is supported as well as specifically dealing with radial and tangential
        edges for cylindrical morph volume matrices. The results depend on the selected mode.
","Inputs

a_entity_type
Must be set to hypercubes.
a_mark_id
The mark ID of the hypercubes for end 'a'. Valid values are 1 and 2.
b_entity_type
Must be set to hypercubes.
b_mark_id
The mark ID of the hypercubes for end 'b'. Valid values are 1 and 2.
vector
Temporary fixed end orientation vector ID.
system_id
The ID of the origin system for radial and tangential connections (modes 8, 9, 10, and
            11).
mode
1 - Free all edges on mvols on a_mark_id

2 - Free edges on mvols on a_mark_id from those on mvols on
              b_mark_id 
3 - Fix all edges on mvols on a_mark_id to vector which are within
            45 degrees 
4 - Free all edges on mvols on a_mark_id within 45 degrees of
            vector 
5 - Create master-slave connection between all edges on mvols on
              a_mark_id to all on mvols on b_mark_id within 60
            degrees of each other 
6 - Create continuous connection for all edges on mvols on
              a_mark_id within 60 degrees of each other 
7 - Create continuous connection between all edges on mvols on
              a_mark_id to all on mvols on b_mark_id within 60
            degrees of each other 
8 - Free all edges on mvols on a_mark_id which run radially from
            the selected system 
9 - Free all edges on mvols on a_mark_id which run tangentially
            about the selected system 
10 - Create continuous connection for all edges on mvols on
              a_mark_id which run radially from the selected system within 60
            degrees of each other 
11 - Create continuous connection for all edges on mvols on
              a_mark_id which run tangentially about the selected system within
            60 degrees of each other 
12 - Create a continuous connection for all edges on mvols on
              a_mark_id within 30 degrees of vector

","Examples
To create tangencies for all edges which connect roughly parallel end to end:
*createmark hypercubes 1 ""all""
*createmark hypercubes 2
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 0 6
To free tangencies for all edges which run tangentially about a system:
*createmark hypercubes 1 ""all""
*createmark hypercubes 2
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 1 9
To create a master-slave tangency for the edges on one morph volume to the edges on another
        morph volume:
*createmark hypercubes 1 14
*createmark hypercubes 2 15
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 0 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
616,*morphupdatemodelcheck,"Description
This command will scan through all of the morphing entities and update those which have
        been modified since the last time this command was run. This command is a maintenance tool
        used by HyperMorph to update morphing entities due to changes in
        other morphing entities or in parts of the mesh governed by domains. When HyperMesh is used interactively this command is called whenever you
        enter or leave a HyperMorph panel, leave the delete panel, or
        output shapes. 
Some of the purposes this command serves are to update the domains if any of their elements
        were deleted, update handle influence coefficients if their domains have been changed, and
        update symmetries if their handles have changed. Because performing these actions can take a
        considerable amount of time, it is done infrequently rather than whenever a handle or a
        domain is modified. This allows you to make a number of changes to the model while in the
        domain panel and only need to wait for influences to be calculated when you leave the panel. 
When running HyperMesh in batch mode it is recommended to call
        this command before any morphing command is to be called and before any shapes are to be
        output. Note that domains will only be recalculated when they need to be recalculated
        regardless of how often this command is called, thus calling this command frequently will
        not significantly slow down the performance of any batch processes.
","Example
To update all morphing entities in the model:
*morphupdatemodelcheck
","Errors
None.
",
617,*morphupdatemvnodes,"Description
 Updates nodes on mark to be registered for the morph volumes on mark.
","Inputs

ctype
Hypercubes
cmark
Mark number of morph volumes.
ntype
Nodes
nmark
Mark number of nodes.

","Example
*morphupdatemvnodes (HYPERCUBES,1,NODES,1)
This command updates the nodes on the mark to be registered to the morph volumes on the
        mark. 
If a node is not within any of the morph volumes on the mark or its original morph volume
        it will still be 'registered' but not affected by any morph volume unless a morph volume is
        morphed to enclose that node. This can occur when morphing and the morph volumes are
        ""inactive"" (see *morphupdateparameter() ""mvon""). Switching the morph
        volumes to being ""active"" automatically re-registers all nodes.
","Errors
None.
"
618,*morphupdateparameter ,"Description
This command updates integer/real morphing parameters.
","Inputs

parameter
The parameter of interest. Valid parameters are: 
handlesize: radius size of largest global handle (red) 
handletolerance: no larger than 1/10th of handle size - used to calculate a number of
            small tolerance measures in HyperMorph

symsize: symmetry size domaincolor: range is 0 through 63 inclusive 
symcolor: range is 0 through 63 inclusive 
facecolor: range is 0 through 63 inclusive 
globalmethod: method for passing down perturbations of global handles to the mesh:
1 - direct (to nodes) 
2 - hierarchical (to local handles) 
3 - mixed method (to local handles or nodes directly if outside local
                domains)


globalsolve: method for solving global domains
1 - geometric 
2 - spatial 
3 - Kriging (revert to geometric if unselected in options panel) 
4 - Kriging (revert to spatial if unselected in options panel)


domainangle: break angle for domains during partitioning 
curvetolerance: curvature tolerance angle for domains during partitioning 
partitionmethod: algorithm used for partitioning 2D domains which are at least 33% quads
0 - element based 
1 - node based


partitionmethodtria: algorithm used for partitioning 2D domains which are at least 67% trias
0 - element based 
1 - node based


partitionorder:
1 - divide when angle exceeds the domainangle 
2 - divide when angle exceeds the domainangle and when the angle between elements
                changes more than curvetolerance


partitionusegeometry: partition 2D domains along associated surfaces
0 - off 
1 - on


partitionaddgeometry: add partitions found outside of associated surfaces to
            partitions created based on surfaces
0 - off 
1 - on


influencethreshold: 0.0 - 1.0 minimum influence coefficient (must be greater than
            zero) 
globalsystemid: ID of system used for morphing 
debug: flag used for diagnostic file output
0 - off 
1 - on


modechange: flag which denotes changes to the model which will trigger a refresh of
            the domains and handles. If set to 1, call *morphupdatecheck to
            refresh model
0 - unchanged 
1 - changed


bigdomainlimit: smallest number of elements in domain for it to be considered a ""large
            domain"" 
bigdomainsolve: frequency for solving large domains
0 - manual 
1 - on release 
2 - real time


biasstyle: type of biasing used for handles
0 - exponential 
1 - sinusoidal


symlinks: use of symmetry links when perturbing handles
0 - all off 
1 - on (only active symmetries will be used)


constraints: apply constraints after morphing
0 - all off 
1 - on (only active morphconstraints will be applied)


qaparam: type of check used during auto quality and auto remesh - use negative values
            for minimum check, positive values for maximum check
1 - 1D length 
2 - 2D warpage 
3 - 2D skew 
4 - 2D aspect ratio 
5 - 2D length 
6 - 2D jacobian 
7 - 2D chordal deviation 
8 - 2D quad angle 
9 - 2D tria angle 
10 - 3D warpage 
11 - 3D aspect 
12 - 3D tetra altitude aspect 
13 - 3D skew 
14 - 3D volumetric skew 
15- 3D length 
16 - 3D jacobian 
17 - 3D tetra collapse 
18 - 3D quad angle 
19 - 3D tria angle 
20 - 1D time step 
21 - 2D and 3D time step - no added mass 
22 - 2D and 3D time step - added mass 
23 - All elements time step


qavalue: value of qaparam to be measured against 
qaplot: type of plotting of failed elements during qa check
0 - highlight failed elements 
1 - used color assigned plot


qanegjac: check for negative jacobians after morphing
0 - off 
1 - on


smoothmeth: method used for automatic smoothing
0 - none 
1 - autodecide 
2 - size corrected 
3 - shape corrected 
4 - angle corrected 
5 - QI optimized 
6 - kriging (or autodecide for elements outside of local domains) 
7 - kriging (or size corrected for elements outside of local domains) 
8 - kriging (or shape corrected for elements outside of local domains) 
9 - kriging (or angle corrected for elements outside of local domains) 
10 - kriging (or QI optimized for elements outside of local domains) 
11 - kriging (ignore elements outside of local domains)


smoothiter: number of iterations for smoothmeth (options 1 - 4 and 6 - 9 only) 
cubestat: status of morph volume database (internal use only) 
mvcolor: range is 0 through 63 inclusive 
mvdraw: number of points along morph volume edges during drawing 
mvtol: 0.0 - 1.0, determines whether a node is within a given morph volume 
mvmode: method for calculating morph volume edge shape
0 - Lagrange 
1 - spline


mvon: morphing of nodes inside of morph volumes
0 - inactive 
1 - active 
2 - skin only


mvgraph: style of graphics for morph volumes
0 - wireframe 
1 - transparent level 1 (low) 
2 - opaque 
3 - transparent level 2 (medium) 
4 - transparent level 3 (high)


mconcolor: default color for morphconstraints - range is 0 through 63 inclusive 
remesh: frequency of auto-remeshing
0 - off 
1 - manual 
2 - on release


remeshtype: elements used when auto-remeshing
0 - trias 
1 - quads 
2 - mixed 
3 - right trias


remeshsize: use size control when auto-remeshing
0 - off 
1 - on


remeshskew: use skew control when auto-remeshing
0 - off 
1 - on


remeshpres: preserve shapes when auto-remeshing
0 - off 
1 - on


remeshfail: percentage of failed elements needed to trigger auto-remeshing 
remeshtarg: default size of remeshed elements during auto-remeshing 
rmthreed: flag for remeshing 3D elements during auto-remeshing
0 - do not remesh 3D and 2D face domains 
1 - remesh 3D and 2D face domains


rmedges: flag for remeshing edge domains during auto-remeshing
0 - do not remesh edge domains 
1 - remesh edge domains


remeshstat: internal use only 
kriging: frequency of kriging solver
0 - off 
1 - manual 
2 - manual (internal use only) 
3 - automatic


krigtype: kriging will be applied to the following entities:
0 - none 
1 - global domains 
2 - local domains 
3 - local and global domains 
4 - morph volumes 
5 - morph volumes and global domains 
6 - morph volumes and local domains 
7 - morph volumes, local, and global domains


krigdrift: drift value for kriging algorithm
0 - none 
1 - constant 
2 - linear 
3 - quadratic 
4 - cubic 
5 - trigonometric


krigcovar: covariance value for kriging
0 - h 
1 - h^2 * log(h) 
2 - h^3 
3 - exp(-1/x)


krignugget: use nugget value
0 - off 
1 - on


krignugval: value of nugget used in kriging algorithm 
connectors: style of morphing for connectors
0 - off 
1 - solve all as clusters 
2 - solve all as stretchable 
3 - solve seam and area connectors as stretchable and others as clusters


onedmethod: method used for 1D and connector domains
1 - independent 
2 - slave 
3 - master 
4 - cluster


onedrot: rotation of 1D cluster domains and connectors
0 - no rotation 
1 - tilting only (out-of-plane) 
2 - spinning only (in-plane) 
3 - full rotation


fesolver: type of solver to use for domains under the fesolverlimit
0 - influence coefficients 
1 - linear (OptiStruct) 
2 - non-linear (Radioss)


fesolve: frequency of fesolver solution
0 - manual 
1 - on release 
2 - real time (interactive)


fesolverlimit: maximum number of elements in a domain to be solved using the fesolver 
feuser: specifies which properties and material to use for solver
0 - automatically generate properties and materials 
1 - use properties and materials in the model


ires: frequency of fea results plotting for the current model
0 - off 
1 - manual 
2 - on release 
3 - real time


irescon: plotting style for fea results
0 - contour plot 
1 - assign plot


iresmin: set the scale minimum value for fea results plotting
0 - find minimum value 
1 - use value given in iresminval


iresmax: set the scale maximum value for fea results plotting
0 - find maximum value 
1 - use value given in iresmaxval


iresminval: value of scale minimum used when plotting fea results 
iresmaxval: value of scale maximum used when plotting fea results 
iresmesh: color of mesh during fea results plotting (range is 0 through 63 inclusive) 
irescomp: results component for fea results plotting
0 - magnitude 
1 - x component 
2 - y component 
3 - z component


iressolver: Solution called during fea results plotting
1 - Linear Static 
2 - Nonlinear Explicit 
3 - Stamping 1-Step 
4 - Stamping Incremental


iresmmres: minimum/maximum title plotting during fea results plotting
0 - do not plot minimum and maximum titles 
1 - plot minimum and maximum titles


iresplinfo: info title plotting during fea results plotting
0 - do not plot info titles 
1 - plot info titles


iresstmpx: x component of the stamping direction for the 1-step solver 
iresstmpy: y component of the stamping direction for the 1-step solver 
iresstmpz: z component of the stamping direction for the 1-step solver
value
The new value of the parameter.

","Example
To update the current biasing style for handles to sinusoidal:
*morphupdateparameter biasstyle 1
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphupdateparameter...} ] } {
   # Handle error
}
"
619,*morphupdateshapes,"Description
This command can convert shapes to node, handle, or morph volume perturbations, convert
        shapes to load collectors and vice-versa, or correct shapes after perturbations are found on
        duplicate nodes or handles due to various operations.
","Inputs

entity_type
Must be set to shapes or loadcols.
mark_id
The ID of the mark containing the shapes or loadcols. Valid values are 1 and 2.
mode


0 - Convert shape to handle perturbations 
1 - Convert shape to node perturbations 
2 - Add duplicate perturbations 
3 - Average duplicate perturbations 
4 - Convert shapes to forces 
5 - Convert forces to shapes 
6 - Convert shapes to temperatures 
7 - Convert temperatures to shapes 
8 - Convert shapes to pressures 
9 - Convert pressures to shapes 
10 - Converts all shapes and morphs on undo/redo list to node perturbations 
11 - Convert shapes to enforced displacements 
12 - Convert enforced displacements to shapes 
13 - Convert shapes to morph volume handle perturbations 
14 - Convert shapes to pressures. This creates pressures in the normal direction
                on all elements touching perturbed nodes. 
15 - Convert shapes to pressures. This creates pressures in the direction of the
                perturbation only on elements with all nodes perturbed. 
16 - Convert shapes to pressures. This creates pressures in the normal direction
                only on elements with all nodes perturbed. 
17 - Convert shapes to enforced displacements. This constrains the XYZ directions
                with zero perturbations.



","Example
To convert all shapes for the mesh into force type load collectors:
*createmark shapes 1 ""all""
*morphupdateshapes shapes 1 4
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:
if { [ catch {*morphupdateshapes...} ] } {
   # Handle error
}
"
620,*morphvolumecreate,"Description
Creates a matrix of morph volumes.
","Inputs

etype
Elems
emark
Mark number of elements to be enclosed.
xd
Density of matrix in x direction.
yd
Density of matrix in y direction.
zd
Density of matrix in z direction.
buff
Percentage buffer zone around matrix.
sysid
ID of system used to orient matrix.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent

","Example
*morphvolumecreate (ELEMS,1,3,3,3,10.0,0,1,1,1)
This command creates a matrix of morph volumes xd by yd by zd in number aligned with the
        specified coordinate system (or the global system if zero) and enclosing the elements on the
        mark. 
The order of the morph volumes (ord) refers to the number of mid-nodes along each edge with
        an order of one meaning there will be no mid-nodes, an order of two meaning that there will
        be one mid-node, and so forth. 
If the specified system is cylindrical, the matrix will be laid out in a cylindrical
        fashion with xd, yd, and zd, relating to the radial, circumferential, and depth densities. 
If a single morph volume is being created and a cylindrical system is specified, the system
        is internally converted int a rectangular system for aligning the morph volume.
","Errors
None.
"
621,*morphvolumecreatenodes ,"Description
Creates a morph volume for the given nodes enclosing the elements on the mark.
","Inputs

nodes
Mark number of node list.
etype
Elems
emark
Mark number of elements to be enclosed.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
nauto
0 = do not register all nodes found inside morph volume 
1 = register all nodes found inside morph volume

","Example
*morphvolumecreatenodes (1,ELEMS,1,1,1,1,1)
This command creates a morph volume enclosing the elements on the mark and connecting to
        the specified nodes on the list. 
The selected nodes must either define at least one morph volume face or be eight in number.
        The element mark may be empty, but if it is not the morph volume will be created in such a
        way that it encloses the elements if possible. 
The order of the morph volumes (ord) refers to the number of mid-nodes along each edge with
        an order of one meaning there will be no mid-nodes, an order of two meaning that there will
        be one mid-node, and so forth. 
","Errors
None.
"
622,*morphvolumedeleteempty,"Description
none.
","Example
*morphvolumedeleteempty ()
This command deletes all morph volumes that have no nodes registered to them.
","Errors
None.
",
623,*morphvolumereflect ,"Description
This command will create morph volumes by reflecting the morph volumes on the mark using
        the specified reflective symmetries (1-plane, 2-plane, 3-plane, cyclical). Optionally the
        nodes inside the reflected morph volumes can be automatically registered.
","Inputs

c_entity_type
Must be set to hypercubes.
c_mark_id
The ID of the mark containing the hypercubes. Valid values are 1 and 2.
s_entity_type
Must be set to symmetries.
s_mark_id
The ID of the mark containing any symmetries. Valid values are 1 and 2.
nauto
0 - Do not register new nodes 
1 - Register new nodes

","Example
To reflect all morph volumes using a symmetry:
*createmark hypercubes 1 ""all""
*createmark symmetries 1 4
*morphvolumereflect hypercubes 1 symmetrys 1 1

","Errors
Incorrect usage of *morphvolumereflect results in a Tcl error. To detect errors, you can
        use the catch command:
if { [ catch {*morphvolumereflect hypercubes 1 symmetrys 1 1} ] } {
# Handle error
}
""Symmetrys must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if all of the
        selected symmetries are not reflective type symmetries. If only some of them are
        non-reflective, those will be ignored.
"
624,*move_clipping_sphere_to_XYZ_and_fit ,"Description
Re-centers the view around a specified point, zooms in or out to fit a specified radius
        around that point, and does all of this in a specified number of frames of animation rather
        than instantly.
","Inputs

x_center

y_center

z_center

radius

n_animation


","Example
 To pan the viewpoint to center on a point with coordinates (22, 17.5, 93) in 90 frames of
        animation, and zoom to display everything within 25 units of that point:
*move_clipping_sphere_to_XYZ_and_fit(22,17.5,93,25,90)

Using frames of animation rather than an instantaneous re-center allows a sense of relative
        location between the initial view point and the new one.
","Errors
None.
"
625,*movecuttingplane,"Description
Moves a cutting plane a specified distance.
","Inputs

axis
The axis that is normal to the plane. Valid values are: 
0 - The plane with x-axis as its normal 
1 - The plane with y-axis as its normal 
2 - The plane with z-axis as its normal
distance
The distance to move the cutting plane along the plane normal.

","Example
To move the cutting plane with y-axis as its normal by a value of 5:
*movecuttingplane 1 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
626,*moveincludecontents ,"Description
This command moves the contents of one include to another, with an option to delete the
        source include.
","Inputs

source_id
The ID of the source include file. If this is not available, use 0 and specify
              source_shortname.
source_shortname
The shortname of the source include file. This is only used if
              source_id is 0 or cannot be found. If this is not required, specify
            double quotes """".
dest_shortname
The shortname of the destination include file.
delete
Flag to indicate if the source include should be deleted. Valid values are: 
0 - Do not delete 
1 - Delete

","Example
To move the contents of include with shortname front_door to include
        with shortname front_door_new, deleting the source include:
*moveincludecontents 0 ""front_door"" ""front_door_new"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
627,*movemarkgroup ,"Description
Moves master/slave elements from one group to another.
","Inputs

entity_type
Must be set to elems.
mark_id
The ID of the mark containing the master/slave elements to move. Valid values are 1 and 2.
name
The name of the group to move the entities to.

","Example
To move all elements from group1 to group2: to :
*createmark elems 1 ""by group name"" group1
*movemarkgroup elems 1 group2
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*movemarkgroup...} ] } {
   # Handle error
}
"
628,*multi_surfs_lines_merge ,"Description
This command takes surfaces from an input set specified by the selection mark
          surf_mark_id, finds intersections between them, creates trimming lines
        at the intersections, and equivalences the resulting surface edges; thus creating a
        topologically valid body from possibly overlapping surfaces. 
Optionally, a set of lines specified by selection mark line_mark_id can
        be used to create additional edges on selected surfaces within proximity of those lines.
        This command uses the tolerance value specified as the cleanup tool in the
        Modeling Options panel (which also can be set using the *setoption
          cleanup_tolerance command) to calculate proximity and equivalence between edges.
        The options Parameter is reserved for future extensions of the command and must be set to 0.
        The surface selection mark (surf_mark_id) can have values 1 or 2. The
        Line selection mark (line_mark_id) can have values 0 (no lines used),
          1 or 2.
","Example
To find intersections and merge surfaces with IDs 30 and 31 into a single body:
*createmark surfs 1 30 31
*multi_surfs_lines_merge 1 0 0
To find intersections and merge all displayed surfaces into a single body.
*createmark surfs 1 ""displayed""
*multi_surfs_lines_merge 1 0 0
To trim surface with ID 31 by free line with ID 9 using the value of 0.1 as a proximity
        tolerance:
*createmark surfs 1 31
*createmark lines 1 9
*setoption cleanup_tolerance=0.1
*multi_surfs_lines_merge 1 1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
629,*newidoption ,"Description
This command now new IDs are assigned for a submodel.
","Inputs

id
The ID of the submodel.
option
0 - Minimum available 
1 - Maximum available (default)

","Example
To set the new ID option as using minimum available for include 1:
*newidoption 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
630,*nodecleartempmark ,"Description
Clears all of the nodes from the temporary node mark.  If a node is selected at the time
        this command is run, it will not be removed, but its graphic will be cleared.
","Errors
None.
",,
631,*nodecreateatintersection ,"Description
This command creates nodes or points at locations of intersection between two sets of input
        geometries. Only intersections between entities from different sets are calculated and are
        used to create nodes or points. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a surface edge to a parent surface is
        undefined and can return unexpected or varied results.
","Inputs

entity_type1
Type of input entities of the first set. Valid values are lines.
mark_id1
The ID of the mark of the first entity type. Valid values are 1 and 2.
entity_type2
Type of input entities of the second set. Valid values are lines, surfs, faces or
            solids.
mark_id2
The ID of the mark of the second entity type. Valid values are 1 and 2.
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes 
1 - Create points

","Examples
To create nodes at the intersections between line 12 and surface 20:
*createmark lines 1 12
*createmark surfs 1 20
*nodecreateatintersection lines 1 surfs 1 0
 To create points at intersection between lines 12 and 14:
*createmark lines 1 12
*createmark lines 2 14
*nodecreateatintersection lines 1 lines 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
632,*nodecreateatplaneintersection ,"Description
This command creates nodes or points at locations of intersection between a selection of
        input geometries and a plane or vector. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a line that lies exactly on the
        specified plane is undefined and can return unexpected or varied results.
","Inputs

entity_type
Type of input entities. 
If plane_use is 0 (plane as input entity), then the only valid
            value is lines. 
If plane_use is 1, 2 or 3 (vector as input entity), then valid
            values are lines, surfs, faces or solids.
mark_id
The ID of the mark of the first entity type. Valid values are 1 and 2.
plane
Input temporary plane ID (if plane_use is 0) created using
              *createplane or vector ID (plane_use is 1, 2 or
            3) created using *createvector. This should always be set to 1.
plane_use
Parameter specifying whether input data specified by plane parameter is interpreted as
            a plane of vector. Valid values are: 
0 - Input data specified by plane parameter is used as plane. 
1 - Input data specified by plane parameter is used as undirected vector (straight
            line that passes through the base point specified by plane parameter in the direction of
            the normal specified by plane parameter). 
2 - Input data specified by plane parameter is used as directed vector (ray that
            starts at base point specified by plane parameter and continues in the direction of
            normal specified by plane parameter). 
3 - Input data specified by plane parameter is used as finite length vector (segment
            that starts at base point specified by plane parameter and ends at the end of normal
            vector specified by plane parameter).
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes 
1 - Create points

","Examples
To create nodes at the intersections between the line with ID 12 and the plane z=2:
*createmark lines 1 12
*createplane 1 0.0 0.0 1.0 0.0 0.0 2.0
*nodecreateatplaneintersection lines 1 1 0 0

To create points at the intersection between surface 10 and a ray that starts at point (1,
        2, 4) and propagates in the direction of y axis:
*createmark surfs 1 10
*createplane 1 0.0 1.0 0.0 1.0 2.0 4.0
*nodecreateatplaneintersection surfs 1 1 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
633,*nodecreateatvectorplaneintersection ,"Description
This command creates node or point at location of intersection between two vectors or a
        vector and a plane. 
","Inputs

vector
Input temporary vector ID. Plane is used to define vector such as base point of the
            plane is used as the base point of the vector and normal of the plane is used as vector
            direction.
plane_or_vector
Input temporary plane ID (if plane_use is 0) or vector ID
              (plane_use is 1, 2 or 3). In case of vector plane base point is
            used as vector base point and plane normal is used as vector direction.
vector_use
Parameter specifying whether input data specified by vector parameter is interpreted
            as a plane of vector. Valid values are:
0, 1 - Input data specified by vector parameter is used as undirected vector
                (straight line that passes through the base point specified by vector parameter in
                the direction of the normalspecified by vector parameter). 
2 - Input data specified by vector parameter is used as directed vector (ray that
                starts at base point specified by vector parameter and continues in the direction of
                normal specified by vector parameter). 
3 - Input data specified by vector parameter is used as finite length vector
                (segment that starts at base point specified by vector parameter and ends at the end
                of normal vector specified by vector parameter).


plane_use
Parameter specifying whether input data specified by
              plane_or_vector parameter is interpreted as a plane of vector.
            Valid values are:
0 - Input data specified by plane_or_vector parameter is used
                as plane. 
1 - Input data specified by plane_or_vector parameter is used
                as undirected vector (straight line that passes through the base point specified by
                  plane_or_vector parameter in the direction of the normal
                specified byplane_or_vector parameter). 
2 - Input data specified by plane_or_vector parameter is used
                as directed vector (ray that starts at base point specified by
                  plane_or_vector parameter and continues in the direction of
                normal specified by plane_or_vector parameter). 
3 - Input data specified by plane_or_vector parameter is used
                as finite length vector (segment that starts at base point specified
                  byplane_or_vector parameter and ends at the end of normal
                vector specified by plane_or_vector parameter).


point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes (default) 
1 - Create points

","Examples
To create nodes at the intersections between straight line (x=1, y=2) and the plane
        z=2:
*createplane 1 0.0 0.0 1.0 1.0 2.0 0.0
*createplane 2 0.0 0.0 1.0 0.0 0.0 2.0
*nodecreateatvectorplaneintersection 1 2
To create points at the intersection between ray that starts at point (1,2,4) and
        propagates in the direction of y axis and a ray that starts at point (1, 4, 0) and
        propagates in the direction of z axis:
*createplane 1 0.0 1.0 0.0 1.0 2.0 4.0
*createplane 2 0.0 0.0 4.0 1.0 4.0 0.0
*nodecreateatvectorplaneintersection 1 2 2 2 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
634,*nodecreatelinemarkparams,"Description
Creates nodes or points at parametric locations on lines.
","
Inputs


entity_type
The type of input entity.  Must be set to lines.
mark_id
The ID of the mark of input entities.  Valid values are 1 and 2.
double_array
The ID of the double array that contains the parametric location values in the range 0
            to 1. The double array is created using the *createdoublearray
            command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
insert_count
The number of additional parametric values inserted between the values specified by
              double_array.
mode
Specifies how parameters specified in double_array are used. Valid
            values are:
0 - Line arc length parameterization is used
1 - Internal line parameterization is used
point_flag
Specifies whether nodes or points are created. Valid values are:
0 - Create nodes (default)
1 - Create points

","Examples
To create nodes on all lines at arc length parametric values 0.2, 0.8 and
        0.8:*createmark lines 1 all
*createdoublearray 3 0.2 0.8 0.85
*nodecreateatlinemarkparams lines 1 1 3
To create 10 points on all lines using the line’s internal parameterization with parameters
        equally distributed between 0 and
        1:*createmark lines 1 all
*createdoublearray 2 0 1
*nodecreateatlinemarkparams lines 1 1 2 8 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
635,*nodelistbypath,"Description
Creates a node path from the starting node to the ending node. If both
          node_id1 and node_id2 lie on free edges, the path
        will follow free edges where possible. Otherwise, the shortest path is returned.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
list_id
The ID of the node list to populate. Valid values are 1 and 2.

","Example
To determine the path between nodes 100 and 110:
*nodelistbypath 100 110 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
636,*nodemarkaddtempmark,"Description
Places a node on the temporary node mark. 
","Inputs

mark
The ID of the mark that contains the nodes to be placed on the temporary node
            mark.

","Example
To place nodes 100, 101, 102, and 103 on the temporary node mark: 
*createmark(nodes,1) 100 101 102 103
*nodemarkaddtempmark(1)

Placing nodes on the temporary mark prevents nodes from being deleted and identifies
        temporary nodes with a yellow circle. 
","Errors
None.
"
637,*nodemarkcleartempmark ,"Description
Clears a group of nodes from the temporary node mark.
","Inputs

mark 
The ID of the mark containing the nodes to be removed from the temporary node mark. 

","Example
To remove nodes 6, 7, and 8 from the temporary node mark: 
*createmark(nodes,1) 6 7 8
*nodemarkcleartempmark(1)

*createmark() is required.  

","Errors
None.
"
638,*nodeplaceatxyz ,"Description
Moves a node to a location on a surface and associates the node to the surface. 
","Inputs

node
The ID of the node. 
surface
The ID of the surface to which the node should be associated. 
location
The location of the point on the surface where the node is to be moved.

","Example
To move node 115 to surface 1 at location (75,30,86): 
*nodeplaceatxyz(115,1,75,30,86)

","Errors
None.
"
639,*nodesassociatetogeometry,"Description
This command is used to associate nodes to points, lines, surfaces and solids. Association
        also moves/positions the nodes onto that geometric entity.
","Inputs

mark_id
The mark of nodes to position and associate. Valid values are 1 and 2.
entity_type
The type of entity to use for the association. Valid values are points, lines,
            surfaces and solids. When surfaces are used, surface edges are also considered for the
            association
entity_id
The ID of the entity_type entity to associate to.
tolerance
The search tolerance to use for the association. Any nodes on
              mark_id that are further than tolerance away from the specified
            entity are not associated.

","Example
To associate nodes 1-100 to surface ID 5 using a tolerance of 0.01:
*createmark nodes 1 1-100
*nodesassociatetogeometry 1 surfs 5 0.01

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
640,*nonstructuralmasscreate,"Description
Creates a group with non-structural mass configuration.
","Inputs

name
The name of the non-structural mass group to create.
color
The color of the non-structural mass group. Valid values are 1-64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
entity_type
The type of entity for which the non-structural mass should be added. Valid values are
            elements and properties.
mark_id
The ID of the mark containing the entities to apply the mass. Valid values are 1 and 2.

","Examples
To create a non-structural mass named nsm1 of type 1 (NSM1) for properties with IDs 1-4
        with mass value 2.4:
*createmark props 1 1 2 3 4
*nonstructuralmasscreate ""nsm1"" 8 1 2.4 props 1
To create a non-structural mass named nsml1 of type 2 (NSML1) for elements with IDs 10, 20,
        30 and 40 with mass value 3.5:
*createmark elements 1 10 20 30 40
*nonstructuralmasscreate ""nsml1"" 8 2 3.5 elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
641,*nonstructuralmassupdate,"Description
 Updates a group with non-structural mass configuration.
","Inputs

name
The name of the non-structural mass group to update.
color
The color of the non-structural mass group. Valid values are 1-64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
entity_type
The type of entity for which the non-structural mass should be added. Valid values are
            elements and properties.
mark_id
The ID of the mark containing the entities to apply the mass. Valid values are 1 and 2.

","Examples
To update a non-structural mass named nsm1 of type 1 (NSM1) for properties with IDs 1-4
        with mass value 2.4:
*createmark props 1 1 2 3 4
*nonstructuralmassupdate ""nsm1"" 8 1 2.4 props 1
To update a non-structural mass named nsml1 of type 2 (NSML1) for elements with IDs 10, 20,
        30 and 40 with mass value 3.5:
*createmark elements 1 10 20 30 40
*nonstructuralmassupdate ""nsml1"" 8 2 3.5 elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
642,*normalsadjust2,"Description
Adjusts the normals of 2D and 3D elements. 
","Inputs

entity_type
The type of entity to adjust normals for. Valid values are elements and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
mode
The orientation mode.
0 - For each connected section, adjust the normals for all elements in that
                section to be consistent with the 'dominant normal direction' already existing
                within that section. orientation_element and
                  vector_id are ignored and can be 0. 
1 - For each connected section, the entity in the section with its normal 'most
                parallel' to the orientation_element is found. All other elements in the section are
                adjusted to be consistent with this element. orientation_element
                must be a valid selection and vector_id is ignored and can be 0. 
2 - Selected elements that are associated to surfaces are adjusted to match the
                normal of their surfaces. This is a no-op, but not an error, for elements not
                associated to a surface. orientation_element and
                  vector_id are ignored and can be 0. 
3 - For each connected section, the elements in the section are adjusted to be
                consistent with the specified vector direction. vector_id must be
                a valid selection and orientation_element is ignored and can be
                0.
4 - For each connected section, adjust the normals for all elements in that
                section to be consistent with the 'dominant normal direction' already existing
                within that section, with the sections defined based on the specified
                  feature_angle.  orientation_elementand
                  vector_id are ignored and can be 0.


orientation_element
The ID of the orientation element.
size
Specifies the size of the normal graphics to be drawn. If set to zero, the vector is
            drawn at 10% of the screen size.
display
0 - Display all elements normals upon command completion. 
1 - Display only adjusted element normals upon command completion.
vector_id
If mode is 3, this is the temporary vector ID created using
              *createvector. This should always be set to 1.
?feature_angle?
If mode is 4, this is the feature angle to use to define the
            connected sections.  This is ignored and not required otherwise.

","Example
To adjust the normals for elements 1-10 based on element 100 and to display the adjusted
        element normals with a size of 5.0:
*createmark elems 1 1-10
*normalsadjust2 elems 1 100 1 5.0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
643,*normalsdisplay ,"Description
Turns on the display of surface normals.
","Inputs

entity_type
The type of entity to turn on normals for. Valid values are elements and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn. If set to zero, the vector is
            drawn at 10% of the screen size.

","Example
To turn on the display of normals for elements 1-10 at 10% screen size:
*createmark elems 1 1-10
*normalsdisplay elems 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
644,*normalsreverse ,"Description
Reverses the normals of 2D and 3D elements.
","Inputs

entity_type
The type of entity to reverse. Valid values are elements and components.
mark_id
The ID of the mark containing the entities to reverse. Valid values are 1 and 2.
size
The size in model units of the normal display, if displayed as vectors.

","Example
To reverse the normal of element 15 using a display size of 10.0:
*createmark elements 1 15
*normalsreverse elements 1 10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
645,*numbersclear,"Description
Clears all of the entities out of the numbers mark. 
","Errors
None.
",,
646,*offset_surfaces_and_modify ,"Description
This command offsets selected surfaces or solids normally to their surface by the distance
        specified by you. It has two main modes, disjoint offset and continuous offset, and several
        modifications. 
With the disjoint offset only the surfaces selected by you will be offset. This mode cannot
        be applied to the surfaces that belong to a solid, if the selection is made ""by surfaces""
          (entity_type is not solid), because this could
        disrupt the solid. 
With the continuous offset the surfaces adjacent to the surfaces selected by you also will
        be modified, to keep continuity of the created model. The modification of the adjacent
        surfaces will be such that their edges that are shared with the selected surfaces will be
        moved together with the selected surfaces, while their edges that do not touch the selected
        surfaces will be locked (stay where they were). 
Both disjoint and continuous modes have a modification, remove degenerations. A
        degeneration is a surface (or several adjacent surfaces) that will self intersect after the
        offset. (e.g., this will occur if a cylinder or a sphere is offset inside by a distance that
        is bigger than its radius.) If the ‘remove degenerations’ modification is on, the offset
        tool will try to clean out the self-intersections automatically. It is recommended to have
        this mode ""on"" only if the degenerations are really happening and there is a need to remove
        them, because having this mode ""on"" all the time increasing the time of the command
        execution (to analyze for the degenerations) and increases the risk of a failure. 
The continuous offset can be modified by the user-selected lines, separators. If you select
        a separator line between the selected and not the offset surfaces, the non-selected surface
        will not be modified (pulled) to keep the result continuous. Instead, a new surface will be
        inserted between the separator line and the new position of the offsetted edge, to create
        the result continuity. 
If you select the separators inconsistently, it can dramatically break the result.
        Therefore, an automatic completion of the separator lines is possible, by selecting the
        ""auto-complete separators"" modification. If this mode is selected, additional separators
        will be added automatically to get a reasonable result (or, at least, to try to get the
        reasonable result). Note: The additional separators might be added not the way you would
          want them to go. This is why, if the ""auto-complete"" modification is used, a review of the
          actually used separators is recommended.

","Inputs

entity_type
The type of entity selected for the offset. Surfaces, splines and solids are
            supported.
mark_id
The mark of surfaces, splines or solids selected for the offset.
surf_mark_id 
Reserved and must be set to 0, or to a mark ID that is empty.
line_mark 
Mark of the separator lines.
offset_type 
Flag to specify the offset mode and modifications:
-13 - Continuous offset. Remove degenerations. Auto-complete separators. Update
                eccentricity. 
-11 - Continuous offset. Do not remove degenerations. Auto-complete separators.
                Update eccentricity. 
-4 - Do not offset, only display how the separators will be auto-completed, to
                review. 
-3 - Continuous offset. Remove degenerations. Auto-complete separators. Do not
                update eccentricity. 
-1 - Continuous offset. Do not remove degenerations. Auto-complete separators. Do
                not update eccentricity. 
0 - Disjoint offset. Do not remove degenerations. Do not update eccentricity. 
1 - Continuous offset. Do not remove degenerations. Do not auto-complete
                separators. Do not update eccentricity. 
2 - Disjoint offset. Remove degenerations. Do not update eccentricity. 
3 - Continuous offset. Remove degenerations. Do not update eccentricity. 
10 - Disjoint offset. Do not remove degenerations. Update eccentricity. 
11 - Continuous offset. Do not remove degenerations. Do not auto-complete
                separators. Update eccentricity. 
12 - Disjoint offset. Remove degenerations. Update eccentricity. 
13 - Continuous offset. Remove degenerations. Do not auto-complete separators.
                Update eccentricity.


offset 
The value of the offset (offset distance with a sign). The offset will occur in the
            direction of the surfaces normals, if offset > 0, and in the opposite to the normals
            direction otherwise.

","Example
To offset by -0.5 surface ID 105 using continuous offset with removal of degenerated
        surfaces, separator line ID 2471 and auto-completion of the separators:
*createmark surfaces 1 105
*createmark lines 1 2471
*offset_surfaces_and_modify surfaces 1 0 1 -3 -0.5
","Errors
None.
"
647,*optimized_elements_remesh2 ,"Description
Remeshes elements with the selection of the best meshing algorithm and optimization of node
        positions.
","Inputs

mark_id
The ID mark that contains the elements to remesh. Valid values are 1 and 2.
criteria_file
The path and file name of the criteria file. Use double quotes if no file is
            specified.
elem_size
The default element size used to calculate element densities along edges, when
            necessary. Element sizes along shared edges cannot be changed.
elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


feature_angle
The angle, in degrees, specifying the feature lines. This is approximately the minimal
            internal angle between the elements adjacent to a feature line. Valid values are between
            18-90 degrees.
vertex_angle
The angle between two edge segments when a vertex is created.
comp_mode
A flag that specifies how the elements are organized. Valid values are:
0 - Elements are created in the current component. 
1 - Elements are created in the same component as their parent surface(s).


break
Determines if connectivity will be broken along shared edges between elements when a
            different element size is chosen.
0 - Do not break connectivity. 
1 - Break connectivity.


algorithm
Determines the algorithm for meshing. Valid values are:
0 - Standard meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control



","Example
To remesh the displayed elements with element size 10, mixed elements type and optimize
        node positions using default criteria file, feature and vertex angle of 30 degrees, and mesh
        flow with align and size control
*createmark elements 1 ""displayed""
*optimized_elements_remesh2 1 ""dummy"" 10 2 30 30 1 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
648,*optimsmooth ,"Description
One or more nodes may be specified as being anchored in place and not movable. The command
        optimizes nodes location to reach the specified target Q.I. of the selected elements
        aggregate according to a given quality criteria. It moves nodes through the surface
        boundaries unless the boundaries are strong feature lines or component boundaries. The
        optimization process may be interrupted if the target Q.I. has been reached or a time limit
        is specified. The optimization may be applied recurrently with a given maximum number of
        iterations.
","Inputs

smoothmark
The mark of elements to be smoothed. Does not need to be a contiguous block.
anchormark
The mark of nodes on elements that are not adjustable.
criteria_filename
The path of the file containing quality criteria or ""dummy"" for pre-set criteria.
feature_angle
The angle in degrees specifying the feature lines (18-90 degrees). This is
            approximately the minimal angle between the elements adjacent to a feature line. 
If a negative value is used, this enables the option to maintain nodes on geometry
            edges and the absolute value is used for the feature angle.
target_QI
The target Q.I. for optimization.
max_iterations
The maximum number of recursive applications of the optimization procedure.
time_limit
Time limit in minutes for the optimization. 
If = 0, the time constraint is not applied. 

","Example
To smooth elements 100 through 110 with fixed nodes 15, 17, and 14 using the quality
        criteria file, c:/mycriteria/durability.txt, the feature angle = 30
        degrees, the target Q.I = 0.2, recursive optimization with maximum five iterations and with
        no time limit applied:
*createmark elements 1 100 101 102 103 104 105 106 107 108 109 110
*createmark nodes 2  15 17 14
*optimsmooth 1 2 c:/mycriteria/durability.txt 30 0.2 5 0
To smooth all plate elements with fixed nodes 257 and 678 using the quality criteria
        specified in the example with the feature angle = 40 degrees, target Q.I. = 0.3, no
        recursive optimization, time limit 60 minutes:
*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
*createmark elements 1 ""all""
*createmark nodes 1 257 678
*optimsmooth 1 1 dummy 40 0.3 1 60

","Errors
None.
"
649,*orderchangetosecond,"Description
Converts first order elements to second order. 
","Inputs

mark
The ID of the mark that contains the elements to be converted. 
doproject


0 - Places the new midside nodes at the exact midpoint 
1 - Projects the new midside nodes to the surfaces


tacitmode


0 - Does not project the new midside nodes to the inferred surface 
1 - Uses the inferred surface where there is no geometry



","Example
To change first order elements to second order: 
*createmark(elements,1) 25 26 35 36
*orderchangetosecond(1,1,1)
*createmark() is required.
","Errors
None.
"
650,*orient_normals_outside_solid,"Description
This command re-orients the normals of a solid inside or outside, depending on the
        orientation parameter.
","Inputs

mark_id
The mark of solids selected for orientation. Valid values are 1 and 2.
orientation
The value of orientation.
0 - Orient normals outside solid 
1 - Orient normals inside solid



","Example
To orient the normals for all solids toward the inside:
*createmark solids 1 all
*orient_normals_outside_solid 1 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
651,*ossmooth_createsurf_auto,"Description
Creates surfaces from OSSmooth isosurface and autobead results.
","Inputs

feature_angle
The feature angle to use for feature edges detection.
options
Specifies options for creating the surfaces. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 +
              64*Bit6).
Bit0
0 - Use given tolerance to control accuracy. 
1 - Use automatic calculation of approximation tolerance from input
                  elements.
Bit1
0 - Do not attempt automatic shell splitting in cases where surface
                  approximation could not be calculated for given tolerance and complexity limit. 
1 - Split shell in cases where surface approximation could not be calculated for
                  given tolerance and complexity limit.
Bit2
0 - Ignore failure on some patches and calculate the remainder. 
1 - Stop on failure.
Bit3
0 - Ignore sharp features unless specified by input feature edges. 
1 - Automatically split shell along sharp features even if not specified by
                  input feature edges.
Bit4
0 - Ignore element component information. 
1 - Use element component information to split shell and create surfaces in the
                  same component as corresponding elements.
Bit5
0 - Do not associate nodes to created surfaces. 
1 - Associate nodes to created surfaces.
Bit6
0 - Do not use automatic feature detection. 
1 - Use automatic feature detection, based on twice the value defined in the
                  feature angle setting of the Options panel.


complexity
A number controlling the maximum complexity of a single surface patch. This sets the
            maximum number of control points for a surface.
tolerance
Geometry simplification tolerance. Defines the maximum distance between original and
            simplified geometries.
reserved
Reserved for future use. Must be set to 0.

","Example
To execute OSSmooth to construct surfaces from shell elements, using 30 degree feature
        angle to create feature edges, using a tolerance of 0.1, limiting the number of control
        points to 1200:
*ossmooth_createsurf_auto 30 42 1200 0.1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
652,*ossmooth_reanalysis ,"Description
Extract the final geometry from OptiStruct topology
        optimization results and inherit the boundary conditions for reanalysis.
","Inputs

sh_filename
The full name and path to the OptiStruct
.sh results file generated from the optimization.
mode
Iso-surface mode indicating how to process non-design elements. Valid values are:
0 - keep all non-design elements with a half layer around 
1 - split only intersected non-design elements 
2 - split overlapping non-design elements with a half layer around 
3 - split overlapping non-design elements


density_threshold
Threshold value for topology optimization (0 ≤ density threshold ≤ 1).

","Example
Execute OSSmooth on the C:/test/os.sh files, loading the geometry back
        to HyperMesh, splitting all quads on non-design/design
        interface, with a density threshold of 0.3:
*ossmooth_reanalysis ""C:/test/os1.sh"" 3 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
653,*ossmooth2 ,"Description
 This command extracts the final design geometry from OptiStruct topology, topography or shape optimization results.
","Inputs

femfile
OptiStruct base input file from which to extract the final
            geometry 
load_op
Execution/load option:
0 - Create .oss file only to be used in standalone version
                (do not execute ossmooth) 
1 - Do not load geom. 
2 - Load geom


outputcode
Output file format:
1 - Nastran

2 - IGES 
3 - STL 
4 - H3D 


tetrameshingcode
Flag indicating whether to create tetramesh after creating isosurface (1=yes, 0=no).
            Only to be used in standalone version.
units
Units to use for IGES output:
1 - inch 
2 - mm 
4 - foot 
6 - meter 
10 - cm


autobead
Flag indicating whether to create an autobead design (1=yes, 0=no).
autobeadthreshold
Threshold value for autobead (real value ≥ 0 and ≤ 1).
autobeadlayer
Layer value for autobead (integer value 0 or 1).
isosurface
Flag indicating whether to create an isosurface (1=yes, 0=no).
surfacecode
The method to use:
0 - no smoothing, isosurface only 
1 - Optimization based smoothing 
2 - no smoothing, element threshold 
3 - Laplacian smoothing


densitythreshold
The density threshold for topology optimization (real value ≥ 0 and ≤ 1).
distancecoefficient
The distance coefficient to use in optimization based smoothing (real value ≥ -50 and
            ≤ 50).
 optismoothboundary
Flag indicating whether to include the boundary or not in optimization based smoothing
            (1=yes, 0=no).
lapiteration
The number of iterations to use in Laplacian smoothing (integer ≥ 0).
lapfeatureangle
The feature angle to use in Laplacian smoothing (real value ≥ 1 and ≤ 80).
lapsmoothboundary
Flag indicating whether to include the boundary or not in Laplacian smoothing (1=yes,
            0=no).
remesh
Flag indicating whether to remesh when creating an autobead design or/and isosurface
            (1=yes, 0=no).
surfacereduction
Flag indicating whether to use surface reduction (1=yes, 0=no).
reductionfeatureangle
The feature angle to use when requesting surface reduction (real value ≥ 1 and ≤
            80).

","Example
The following example executes OSSmooth on the c:/test/os1.fem,
          c:/test/os1.grid and c:/test/os1.sh files,
        loading geometry back to HyperMesh, requesting Nastran output, creating 1 layer autobead with remesh design with 0.3
        bead threshold, no surface reduction, 0.3 topology optimization threshold, Laplacian
        smoothing, 10 iterations, 30 degrees feature angle and include the boundary:
*ossmooth2 ""c:/test/os1.fem"" 2 1 0 1 1 0.3 1 1 3 0.3 0 0 10 30 1 1 0 10
","Errors
None.
"
654,*parsesolveroutputfile,"Description
Creates tables from solver output files.
","Inputs

filename=<value>
The full name and path of the file to parse.
filetype=<value>
The type of file to parse.  Valid values are:
F06
extractdata=<value>
The type of data to extract from the file.  Valid values are:
fluttercurves - Collects flutter summary data and creates tables for pk and pknl
            methods.

","Example
To generate tables from the flutter data conatined in the file C:/temp/MSCFlutter.out:
*parsesolveroutputfile filename=""C:/temp/MSCflutter.out"" filetype=F06 extractdata=fluttercurves
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
655,*penetrationcheckend ,"Description
Releases the memory from previous penetration check command operations.
","Example
To check the elements in group E2E for penetration:
*createmark groups 1 E2E
*penetrationcheck groups 1 0
*penetrationcheckend
","Errors
None.
",
656,*penetrationchecktwo ,"Description
Checks penetration for entities selection type groups, elems2elems, nodes2elems, and
        elemsonly. To release the memory after completion, use the command
          *penetrationcheckend. 
A valid template must be loaded for the check to occur.
","Inputs

entity_type1
Type of the first entity.
groups for selection type groups' 
elements for selection type elems2elems 
elements for selection type nodes2elems 
elements for selection type elemsonly


mark1
Mark of the first entity.
undefined   for selection type groups 
elements    for selection type elems2elems 
nodes        for selection type nodes2elems 
undefined   for selection type elemsonly


entity_type2
Type of the second entity.
mark2
Mark of the second entity.
segment_orientation
Flag for taking element normal into consideration for checking penetration.
0 - Elements normal will not be considered 
1 - Elements normal will be considered


partscl_contthk_toggle


1 - If part thickness scale is selected 
2 - If contact thickness is selected


part_scale
Value of part scale factor.
cont_thick
Value of contact thickness.

","Example
 For checking penetration between elems2elems with segment orientation option and part
        thickness scale:
*penetrationchecktwo(elements,1,elements,2,1,1,1,0) 
For checking penetration between nodes2elems without segment orientation option and with
        contact thickness:
*penetrationchecktwo(elements,1,nodes,1,0,2,1,1)
*createmark() for entity type 1 and createmark() for
        entity type 2 are required.
","Errors
None.
"
657,*penetrationrecheck,"Description
Modifies the element thickness to correct penetration problems.
","Inputs

mark
The mark of the entity to be modified.
reduction
The average thickness reduction.
scale
The thickness scale factor.
display_mode
The type of entity to be displayed.
0 - Nodes 
1 - Normals 
2 - Contour


normal_scale
The magnitude percentage or the uniform size.
label
The label vector option.
segment
The segment orientation option.
magnitude_mode
Determines if a magnitude percentage or a uniform size is to be used. 
1 - Magnitude percentage 
0 - Uniform size 



","Example
To modify the element thickness:
*createmark(groups, 1) ""E2E""
*penetrationrecheck(1,0,1,0,1,1,1,1)
*createmark() and *templatefileset() are required. 
","Errors
None.
"
658,*perturbationshapecreate ,"Description
Creates a perturbation shape.
","Inputs

name
The name of the shape.
vectorcolid
The ID of the vector collector that contains the perturbation vectors.

","Example
To create a shape ""sh1"" that has its perturbation vectors in a vector collector of ID 5: 
*perturbationshapecreate(""sh1"",1)
","Errors
None.
"
659,*plot,"Description
Plots the current model.
","Errors
None.
",,
660,*plotinfotitlemove,"Description
Moves the plot information title.
","Inputs

xmin
The x value of the upper left corner of the title (0.0 - 1.0).
ymin
The y value of the upper left corner of the title (0.0 - 1.0).
xmax
The x value of the lower right corner of the title (0.0 - 1.0).
ymax
The y value of the lower right corner of the title (0.0 - 1.0).

","Errors
None.
",
661,*plotinfotitlesetfont,"Description
Sets the font of the plot information title.
","Inputs

font
The font number for the descriptor (1-4)

","Errors
None.
",
662,*plotmassdistribution,"Description
Plots the mass distribution data assigned at nodal level for Radioss ADMAS type 5 and LS-DYNA config 105
        (nodes).
","
Inputs



solvermass_id

The ID of the supported solvermass.

","Examples
Plot mass distribution of solvermass with id 25:
*plotmassdistribution 25
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
663,*plottitlemove ,"Description
 Moves the plot title. 
","Inputs

xmin
The x value of the upper left corner of the plot title (0.0 - 1.0). 
ymin
The y value of the upper left corner of the plot title (0.0 - 1.0). 
xmax
The x value of the lower right corner of the plot title (0.0 - 1.0). 
ymax
The y value of the lower right corner of the plot title (0.0 - 1.0). 

","Errors
None.
",
664,*plottitlesetfont ,"Description
Sets the font for the plot title. 
","Inputs

font 
The font ID for the plot title (1-4). 

","Errors
None.
",
665,*plydrape,"Description
Drapes plies using the Laminate Tool.
","Inputs

entity_type
The type of entity to drape.  Must be set to plies.
There should not be any holes in the selected ply/plies.
mark_id
The ID of the mark containing the entities to drape.  Valid values are 1 and 2.
entity_type
The type of entity to realize.  Valid value is plies.

The following inputs may be provided in any order.  Optional arguments are listed as such,
        along with their default values.

application=<app>
The draping application to use.  Must be set to LaminateTool..
application_direction=<app_vector_id>
The ID of the vector defining the application direction of the draping.
seednode=<node_id>
The ID of the seed node/application point/start point of the ply.
showLamToolFlag=<0|1>
0 - Do not view the Laminate Tool while draping (optional, default).
1 - View the Laminate Tool while draping.
size=<size>
The step size of the drape lines (optional, default 1).
strain=<strain>
The value of the strain in the draping process (optional, default 60).
refdirection=<ref_vector_id>
The ID of the vector defining the fiber reference direction.
uninitializeFlag=<0|1>
0 - Do not uninitialize the COM object after the draping process.
1 - Uninitialize the COM object after the draping process (optional, default).

","Example
For draping ply 20 with seed node 266, reference direction vector ID 1, and application
        direction vector ID 2::
*createmark plies 1 20
*plydrape plies 1 application=""LaminateTool"" seednode=266 refdirection=1 applicationdirection=2 size=1 strain=60 uninitializeFlag=1 showLamToolFlag=0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
666,*plynormalsreverse,"Description
Reverses the 2D element ply normals.
","Inputs

ply_name
The name of the ply to reverse normals for.
mark_id
The ID of the mark containing the elements whose normals are to be reversed. Valid values are 1 and 2.

If empty, all plies in the specified ply are considered.
size
Specifies the size of the graphic normal vector. If set to zero, the vector is drawn
            at 10% of the screen size.

","Example
To reverse the normals for elements 1-10 in Ply1, and display at 10% screen size:
*createmark elems 1 1-10
*plynormalsreverse Ply1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
667,*pointmodify ,"Description
Specifies new coordinates for the point.
","Inputs

point_id
ID of the point to be modified.
x/y/z
New point coordinates.

","Example
*createpoint(0,0,0,0)
*createpoint(10,0,0,0)
*window(0,0,0,0,0)
*pointmodify(2,5,0,0)
*createpointsbetweenpoints(1,2,1)

This command is called from the distance panel.
","Errors
None.
"
668,*positionmark,"Description
This command positions a selection of entities in space.
","Inputs

entity_type
The type of entity to position.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
node1-node6
The IDs of the nodes used to position the entities. The positioning attempts to align
            the first three nodes (1-3) to the second three nodes (4-6).

","Example
To position component wheel using nodes 10-15:
*createmark comps 1 wheel
*positionmark comps 1 10 11 12 13 14 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
669,*pressureonelement_curve,"Description
Creates a pressure load on an element.
","Inputs

id
The ID of an element on which to apply the pressure.
face_index
The face index of the solid element. Ignored, if the element is a shell element.
x_comp
The x-component of pressure.
y_comp
The y-component of pressure.
z_comp
The z-component of pressure.
magnitude
The magnitude of the pressure.
curve_id
The ID of a curve defining the magnitude of the load vs time.
x_scale
A scale factor applied to the x-axis (or time axis) of the curve.

","Example
To apply a pressure of magnitude 4.0 on the solid element ID 10 face index 2, using the
        curve with ID 9 to vary the magnitude over
        time:*pressuresonelement_curve 10 2 0 0 0 4.0 9 1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
670,*pressuresonentity,"Description
Creates a pressure load on a surface or an element.
","Inputs

entity_type
Type of entity the load is applied on. (e.g. surfs or elems)
mark_id
The ID of the mark of entities on which to apply the pressure.
nodes_mark_id
The ID of the mark containing nodes that lie on the face of one or more elements
            (solids only).
x
X component of pressure. 
y
Y component of pressure. 
z
Z component of pressure. 
magnitude
The magnitude of the pressure. 
breakangle
The break angle of a solid face. 
onface
A logical which determines whether pressures are being applied to faces.

","Example
To apply a pressure of 4 on surface 11:
*createmark surfaces,1 11
*pressuresonentity surfaces 1 1 0 0 0 4 30 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
671,*processflange,"Description
Given a set of fixed points, this command splits the edges of surfaces by adding a fixed
        point on the edge. The projection of the point is controlled by tolerances for the maximum
        distance and maximum deviation from the normal. 
","Inputs

surf_markmask
The ID of the mark containing the surfaces.
point_markmask
The ID of the mark containing the points.
distance_tol
The radial distance to search around each point for surface edges to project to.
angle_tol
The maximum deviation from the normal when projecting the point to the edge. 

","Example
To process a flange on surface 91 using fixed point IDs 25-30, within a maximum distance of
        1.1 and within a maximum deviation from normal of 5 degrees:
*createmark(surfaces,1) 91
*createmark(points,2) 25 26 27 28 29 30
*processflange(1,2,1.1,5)
The command accepts an empty surf_markmask. In this case, the command
        uses any surfaces to which any of the points is associated. If none of the points is
        associated to a surface, then the command fails.
","Errors
None.
"
672,*projectpointstoedges ,"Description
Create surface vertices by projecting the points onto the edges perpendicular to the
        edge.
","Inputs

edge_markmask
The mark containing the edges to project to.
point_markmask
The mark containing the points to project.
distance_tol
The maximum distance a point can be projected.
angle_tol
The minimum angle between an existing vertex, the point being projected, and the
            projected point.

","Example
To add surface vertices on edges 56 and 57 by projecting points 78 and 79 with a maximum
        distance of .5 and a minimum angle of 30:
*createmark(lines,2) 56 57
*createmark(points,1) 78 79
*projectpointstoedges(2,1,.5.30)

Any selected edge, which is within the distance tolerance of any of the points, will have a
        vertex added at the projected point unless there is already another vertex on the edge that
        is within the angle tolerance. Therefore, if two points project to the same edge but are
        within the specified angle tolerance, then only one of the points will be added to that
        edge. It is not defined which point will be added. 
","Errors
None.
"
673,*propagate_welds ,"Description
Use this command to create a series of weld points between surfaces.
","Inputs

surfsmark
The mark containing the surfaces to be welded; valid numbers are 1 and 2, or 0 for the
            entire model.
max_proxim
The maximum distance between a weld point and an edge or between a ""child"" projection
            point and an edge for propagation. This should be 1 to 1.5 times the element size.
min_edge_len
The minimum edge length created by inserted fixed points. This should be 0.3 times the
            element size.
max_angle_dev
The maximum angle deviation of the propagation path from the surface normal.
            Approximately 30° is typical. 
select_exten_flag
This flag controls the propagation of fixed points with respect to selected surfaces.
0 - Ignores the selection and propagates to any connected surfaces. 
1 - Weld propagation is restricted to the selection area, including the selection
                boundary. 
2 - Weld propagation is restricted to the selection area, but not the selection
                boundary.


meshed_touch_flag
Controls the propagation with respect to meshed surfaces.
0 - Does not affect meshed surfaces in any way 
1 - Welds can touch mesh surfaces 
2 - Welds can touch mesh surfaces, but the mesh is deleted when this occurs



","Example
As of this writing, this command is not included in the BatchMesher and does not have an implementation from within the
          HyperMesh environment; it is only usable as a typed-in
        command, such as in user-created macros.
","Errors
None.
"
674,*pushtofront,"Description
Sets a visualization mode to keep certain entities visible in front of others.
","Inputs

entity_type
The type of entity to control. Valid values are tags.
mode
0 - Do not push to front (default) 
1 - Push to front (keep in front of other entities at all times)

","Example
To keep tags in front:
*pushtofront tags 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
675,*qismoothfixfailed ,"Description
This command is applied to a selection of elements given by the elements mark. It changes
        positions of nodes of elements violating the quality index threshold and possibly of
        adjacent elements. Maximum displacements of nodes on feature edges are limited by the
        user-specified values.
The command parameters have the following meaning:
","Inputs

smoothmark
The elements selection mark (1 or 2).
anchormark
The mark of additional (to welds) nodes not allowed to move (1 or 2).
criteria_file
The path to the criteria file. If the criteria are set by a preceding command, ""dummy""
            can be used as a criteria file name.
feature_angle
Elements feature angle for defining of features in degrees (30 degrees is a commonly
            used value).
ignore_features
The flag defining permissions of node movement across the feature edges:
0 - Nodes are not allowed to move across feature edges. 
1 - Nodes are allowed to be moved across shared edges; free edges nodes, marked
                edges, edges of features (beads, washers, dimples, birdbeaks, fillets), all fixed
                nodes are forbidden for movement across. 
2 - The same as ""1"", but nodes on some of the features surfaces (beads, vertices)
                are unfixed + end vertices of fillet edge are unfixed. 
3 - The same as ""2"", but fillet edges are released and some curves sharp break
                vertices are unfixed. 
4 - All shared edges nodes,including recognized features boundary edges, all
                non-user marked edges and fixed vertices are released for movement across; 
5 - The same as ""4"" but free edges nodes are also released, those nodes are not
                allowed to move off the surfaces; 
6 - The same as ""5"" but free edges nodes are allowed now to move off surfaces
                breaking associativity with geometry.


freenodesmovelimit
Maximum absolute movement for free edges nodes. If negative value - no constraints are
            applied.
breaknodesmovelimit
Maximum absolute movement for shared feature edges nodes. If negative value - no
            constraints are applied.
smoothedgenodesmovelimit
Maximum absolute movement for smooth (non feature) shared edges nodes. If negative
            value - no contsraints applied.
flgs
Flags controlling internal algorithms. The default is 0. flgs = 256
            should be used to mark moved free edges by plot elements placed in the predefined
            component - to account for the moved edges on the future steps.
max_iterations
Maximum number attempts to fix the failed elements. Usually 3-5 can be used.

","Example
To fix the displayed failed elements with no anchor nodes, using the quality criteria file
          C:/Altair/hw8.0/hm/batchmesh/10mm criteria, feature angle 30 degrees,
        with maximum allowed ignore_features option 6 (the free edges' nodes are
        allowed to be moved across with breaking of associativity with geometry), maximum allowed
        movement of free edges nodes is 0.5, maximum allowed movement of shared feature edges nodes
        is 1.0, no constraints applied to movement across of non-feature shared edges (-1), no
        marking of moved feature edges (flgs = 0), 5 iterations applied:
*createmark elements 1 ""displayed""
*createmark nodes 1  
*qismoothfixfailed 1 1 ""C:/temp/10mm.criteria"" 30 6 0.5 1.0 -1 0 5
To do the same, except that node IDs 2342 and 131 are not allowed to move, free edges'
        nodes are not allowed to move across edges (ignore_features =4), and the
        quality criteria are preset directly by the preceding
        command:*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0 
*createmark elements 1 ""displayed""	
*createmark nodes 1 2342 131  
*qismoothfixfailed 1 1 ""dummy"" 30 4 0.5 1.0 -1 0 5
","Errors
The command returns error codes for wrong quality criteria, no elements selected and
        internal optimization errors.
"
676,*quatrotate ,"Description

*quatrotate(-0.000125576946, 0.0107329493, -0.000656577404, 0.999942177)

","Example
The model is rotated about the matrix created from the given quaternion. 
","Errors
None.
",
677,*rbe3 ,"Description
Creates an RBE3 element.
","Inputs

mark_id
The ID of the mark containing the independent nodes. Valid values are 1 and 2.
independent_dofs
The ID of the integer array containing the degrees of freedom for which each
            respective independent node of the element is active (any of the digits 1-6), created
            using *createarray. Must be set to 1.
dof_size
The size of the independent_dofs array.
independent_weights
The ID of the double array containing the weight for each respective independent node,
            created using *createdoublearray. Must be set to 1.
weight_size
The size of the independent_weights array.
dependent_node
The dependent node of the element. If set to 0, the dependent node will be
            auto-created at the centroid of the independent nodes.
dof
The degree of freedom code for which the dependent node of the element is active (any
            of the digits 1-6).
weight
The weight assigned to the dependent node.

","Example
To create an RBE3 element with dependent node 100 and independent nodes 101, 102, and 103
        with all of the nodes having all six degrees of freedom and a weight of 1.23:
*createmark nodes 1 101 102 103
*createarray 3 123456 123456 123456
*createdoublearray 3 1.230000 1.230000 1.230000
*rbe3 1 1 3 1 3 100 123456 1.23
","Errors
None.
"
678,*readbatchparamsfile,"Description
Use this command to set cleanup parameters directly in the command file when using
        automatic topology cleanup with the *autotopocleanup command. The cleanup
        parameters file must be created using CriteriaEditor in HyperMesh or BatchMesher.
","Inputs

params_filename 
The name of cleanup parameters file to be read.

","Example
To perform topology cleanup of all displayed surfaces using the element quality criteria
        from the nvh10.criteria file and quality parameters from the
          nvh10.param file:
*readbatchparamsfile(""nvh10.param"" )
*createmark(surfaces,1) ""displayed""
*autocleanup( 1, ""nvh10.criteria"" )
The cleanup parameters are deleted just after each use and must be set before every call
        that uses the ""dummy"" parameter file name.
","Errors
None.
"
679,*readmeshcontroltemplate,"Description
Imports a Mesh Control template file. This is an XML formatted file. This contains all of
        the mesh control information, except for the entity selection. A file coming from SimLab can also be read.
","Inputs

filename
The full name and path of the file to import.

","Example
To import the file C:/temp/meshcontrol.xml:
*readcontroltemplate C:/temp/meshcontrol.xml
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
680,*readnodepositionsfromh3dfile,"Description
Modes nodes in the current model to positions given in an H3D file.
A valid Radioss model must be loaded.
","Inputs

path
The full path and file name of the H3D file.

","Example
To read node positions from C:/Users/default/result.h3d:
*readnodepositionsfromh3dfile ""C:/Users/default/result.h3d""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
681,*readqualitycriteria,"Description
Reads quality criteria from the specified criteria file and sets the criteria as
        current.
","Inputs

file_name
The path to the source criteria file (a quoted string ). The file must contain the
            criteria data in the text format supported by HyperMesh.

","Example
To read quality criteria from c:/criteria/durabilty_15.txt:
*readqualitycriteria ""c:/criteria/durabilty_15.txt""
","Errors
None.
"
682,*realizecsfbdsectiontostdfbdsection,"Description
Realize cross-section based freebodysections to standard freebodysections.
","
Inputs


freebodysection_ids=<ids>
The IDs of the cross-section based (config 1) freebodysections to realize.

","Examples
Realize sections 1, 2 and
        3:*realizecsfbdsectiontostdfbdsection freebodysection_ids={1 2 3}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
683,*realizeengineeringentity,"Description
Realize an engineering entity.
","Inputs

entity_type
The type of engineering entity to realize.
reserved
Reserved for future use.  Must be set to 0.

","Example
Realize the mass entity with ID 10:
*realizeengineeringentity masses 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
684,*realizefieldloads,"Description
Realizes engineering loads into classical loads.
","
Inputs


mark_id
The ID of the mark of engineering loads to realize into classical loads.  Valid values
            are 1 and 2.
skip_delete
0 - Delete all engineering loads after realization (default)
0 - Keep all engineering loads after realization

","Examples
Realize all engineering force
        loads:*createmark loads 1 ""by config"" 1
*realizefieldloads 1
Realize all engineering loads and skip
        deletion:*createmark loads 1 all
*realizefieldloads 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
685,*realizesetstocontactsurfs,"Description
Realizes all segment sets of a given card image to contact surfaces.
","
Inputs


card_image
The card image of the setment sets to realize.

","Examples
Realize segment sets with cardimage surfSeg to contact surfaces:

*realizesetstocontactsurfs surfSeg

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
686,*rebuild_mesh,"Description
This command rebuilds an existing mesh such that the new mesh has good quality and flow.
        It uses the same parameter and criteria files as used by BatchMesher to specify the quality criteria and mesh parameters.
The command expects that the criteria and parameter files are properly set and registered
        before execution.  It utilizes the following fields from the parameter file:
1.  Surface hole recognition table
2.  Feature angle during element cleanup
3.  Element type
4.  Mesh type
1Ds attached input shell elements are used as features and they significantly impact mesh
        quality and flow. If no 1Ds are present in the shells of the input elements, the specified
        feature angle is internally used to recognize features.
Rebuild is currently supported for first-order shell elements that are not attached to
        solid elements.
","
Inputs



mark_id

The ID of the mark containing the elements to rebuild.  Valid values are 1 and 2.

","Examples
To remesh the displayed shell elements with 5 mm criteria and parameter file settings:
*createstringarray 14 "" 0 penalty value              0.00    0.00    0.50    1.00    5.00"" \
  ""  1 min length        1 2.0   5.000   4.333   3.666   3.000   2.833    2"" \
  ""  2 max length        1 1.5   5.000   6.200   7.320   9.000  11.290    0"" \
  ""  3 aspect ratio      1 1.0   1.000   2.000   4.000   5.000  10.000    0"" \
  ""  4 warpage           1 2.0   0.000   5.000  15.000  20.000  40.000    0"" \
  ""  5 max angle quad    1 1.0  90.000 110.000 140.000 150.000 165.000    0"" \
  ""  6 min angle quad    1 1.0  90.000  70.000  40.000  30.000  15.000    0"" \
  ""  7 max angle tria    1 1.0  60.000  80.000 120.000 130.000 155.000    0"" \
  ""  8 min angle tria    1 1.0  60.000  50.000  30.000  20.000  10.000    0"" \
  ""  9 skew              1 1.5   0.000  10.000  50.000  60.000  75.000    0"" \
  "" 10 jacobian          1 2.0   1.000   0.900   0.600   0.500   0.350    0"" \
  "" 11 chordal dev       0 0.0   0.000   0.300   0.800   1.000   2.000    0"" \
  "" 12 taper             0 1.0   0.000   0.200   0.500   0.600   0.900    0"" \
  "" 13 % of trias        1 2.0   0.000   3.000   4.500   6.000   9.000    0""
*setqualitycriteria 1 14 0
*createstringarray 105 ""geometry_cleanup_flag    1"" ""meshing_flag                      5"" \
  ""element_size                      5.0"" ""element_type                      2"" \
  ""mesh_align                        3"" ""element_order                     1"" \
  ""surf_component                    1"" ""feature_angle                     30.0"" \
  ""holes_table_begin"" ""appl_surf(1)"" ""appl_solid(0)"" ""appl_cordsfiles(0)"" ""appl_flanged_suppr(1)"" \
  ""flanged_suppr_height(1.4)"" ""narrow_slots_type(0)"" ""abs_fixed_nodes_count_max(-8)"" \
  ""rad(0.0,2.2) do action(1) washer(0) "" ""rad(2.2,3.01) do action(0) elems(4) washer(0) "" \
  ""rad(3.01,4.7) do action(0) elems(6) washer(1) layers(3.5) "" ""rad(4.7,9.0) do action(0) elems(8) washer(1) layers(0.75*radius) "" \
  ""rad(9.0,11.0) do action(0) elems(8) washer(1) layers(7.0) "" ""rad(11.0,20) do action(0) elems(8) washer(1) layers(auto) "" \
  ""rad(0.0,2.2) solid(1) do action(1) "" ""rad(2.2,3.01) solid(1) do action(0) elems(4) "" \
  ""rad(3.01,20) solid(1) do action(0) elems(6) "" ""holes_table_end"" ""edge_fillet_recognition           1"" \
  ""max_fillet_radius                 5.0"" ""surface_fillet_table_begin"" ""surface_fillet_recognition(1)"" \
  ""minimize_transitions(1)"" ""rad(0,2.2) wid(3.0,6.2) do split(suppress_on)"" \
  ""rad(2.2,15) wid(3.4,6.2) do elems(1)"" ""rad(0,25.0) wid(6.2,9.2) do elems(2)"" \
  ""rad(0,35.0) wid(9.2,12.5) do elems(3)"" ""rad(0,40.0) wid(12.5,25.0) do chordal_deviation(0.2)"" \
  ""surface_fillet_table_end"" ""del_dupl_surfs_flag               2"" ""del_dupl_surfs_tol                -1"" \
  ""edges_stitch_flags                0"" ""max_edges_stitch_tol              -1.0"" \
  ""fix_overlapsurfs_flag             1"" ""overlapsurfs_maxtangangle         -1.0"" \
  ""narrow_surfs_merge_width          -1.0"" ""narrow_surfs_treat_flags          3"" \
  ""beads_suppression                 1"" ""beads_recognition                 1"" \
  ""minimal_beads_height              1.4"" ""beads_treat_flags                 0"" \
  ""flange_recognition                1"" ""flange_elements_across            3"" \
  ""flange_max_width                  30.0"" ""flange_min_width                  8.0"" \
  ""flanges_treat_flags               1"" ""flange_max_remove_width           -1.0"" \
  ""appl_tria_reduction               1"" ""tria_redu_max_elemsize            auto"" \
  ""tria_redu_min_elemsize            auto"" ""trias_around_holes                0"" \
  ""common_mesh_flow                  0"" ""extract_thinsolids                1"" \
  ""midsurf_method                    3"" ""thinsolid_ratio                   0.3"" \
  ""max_thickness                     10.0"" ""extract_feature_angle             25.0"" \
  ""pre_midsurf_cleanup               1"" ""direct_midmesh                    0"" \
  ""ignore_flat_edges                 1"" ""flatten_connections               0"" \
  ""defeat_open_width_on              1"" ""defeat_open_width                 1.0"" \
  ""supp_proxim_edges_on              1"" ""supp_proxim_edges                 0.5"" \
  ""combine_nonmanifold_on            1"" ""combine_nonmanifold               0.5"" \
  ""midmesh_extact_elem_size          10.0"" ""remove_logo                       1"" \
  ""logo_max_size                     30.0"" ""logo_max_height                   1.4"" \
  ""logo_min_concavity                1.0"" ""threads_removal                   0"" \
  ""threads_toremove_max_depth        5.0"" ""threads_replacediametertype       -2"" \
  ""folded_elems_angle                150.0"" ""smooth_elems_target               0.2"" \
  ""fillets_mesh_flow                 0"" ""failed_elems_cleanup_flgs         8"" \
  ""move_nodes_across_feature_edges   1"" ""featureedge_nodes_moveacross_max  0.1"" \
  ""move_nodes_across_free_edges      1"" ""freeedge_nodes_moveacross_max     0.05"" \
  ""move_normal_flag                  1"" ""move_normal_dist                  0.8"" \
  ""divide_warped_quads               1"" ""ignore_comps_boundary             0"" \
  ""gen_topology_prepare_flags        7"" ""cleanup_comp_flag                 0 "" \
  ""comp_select                        "" ""use_wildcards_for_compsnames      0"" \
  ""cleanup_tolerances                auto"" ""suppress_features_rate            0"" \
  ""feat_charsize_method              0"" ""custom_feat_suppr_maxangle        25.0"" \
  ""uncond_constr_lines_suppress      0"" ""aggressive_fillet_lines_suppress  0""
*createbatchparamsfromstrings 1 105
*createmark elements 1 displayed 
*rebuild_mesh 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
687,*reconcilemasslocation,"Description
Reconciles all locations of a mass to actual locations, and synchronizes the ghosts with
        actual locations.  If any ghosts are not synchronized with actual locations, they are
        lost.
","Inputs

mark_id
The ID of the mark containing the masses to reconcile.  Valid values are 1 and 2.

","Example
To reconcile masses with IDs 10 and 20:
*createmark masses 1 10 20
*reconcilemasslocation 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
688,*refine_adaptive,"Description
Refines elements based on proximity and angle.
","Inputs

entity_type
The type of entity used for refinement. Valid values are surfs, elems and
            regions.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
There can be a maximum of 3 strings. One is for general purpose refinement options.
            The second is for angle-based refinement options. The third is for proximity-based
            refinement options. 
Each string must be space separated, including between name and value. 
Valid strings for general refinement options are:
extra_layers <num_layers>
Specifies the number of additional layers that should be included in the remesh.
                  Default value is 1.


Angle-based refinement strings are used to provide options for angle-based refinement.
            This must start with the string angle. If not specified, of if angle is given with no
            other options, default values are used. To disable angle-based refinement, use angle
            off. Valid strings for angle-based refinement options are below. 
Only one of the following two types of options may be specified to select a particular
            method for determining the size for a given angle.
max_angle_limit <angle> min_angle_limit <angle> refinement_size
                  <size>
max_angle_limit is the maximum angle value above which all the angles are
                  refined.
min_angle_limit is the minimum angle value, below which all the angles are
                  refined.
refinement_size is the size with which all the elements are refined. 
If no angle refinement string is provided, or only angle is given, by default
                  min_angle_limit=45, max_angle_limit=315, and each affected element is refined to
                  half its size. 
If only min_angle_limit is specified, then max_angle_limit=360. 
If only max_angle_limit is specified, then min_angle_limit=0. 
If refinement_size is not specified, each affected element is refined to half
                  its size.
interval <angle1> <angle2> ?<refinement1>? ?<refinement2>?
The first value is the first angle, the second value is the second angle, the
                  third value is the optional refinement size at the first angle, and the fourth
                  value is the optional refinement size at the second angle. 
Providing two parameters results in the elements falling in that particular
                  interval to be refined to half their size. 
Providing three parameters results in a constant refinement size for all the
                  angles in that particular interval. 
Providing four parameters results in angles falling in that interval refined
                  with refinement sizes varying linearly from the first refinement size to the
                  second refinement size as the angle goes from the first angle to the second angle. 
Multiple intervals can be specified, each with their own parameters.


Proximity refinement strings are used to provide options for proximity refinement.
            This must start with the string proximity. If not specified, proximity is given with no
            other options, default values are used. To disable proximity refinement, use proximity
            off. Valid strings for proximity refinement options are below.
direction <direction>
The direction in which the proximity is calculated. Valid directions are: 
both_side - Checks proximity along either side of the elements. 
inwards - Checks proximity inwards to the volume. 
normal - Checks proximity along the element normal side. 
outwards - Checks proximity outwards from the volume (default).
max_gap <value>
The maximum gap value. Any detected gap larger than this is not considered
                  (optional).
min_gap <value>
The minimum gap value. Any detected gap smaller than this is not considered
                  (optional).


If neither max_gap or min_gap are specified, all gaps from smallest to largest are
            considered.
Only one of the following may be specified:
min_elems_in_gap <value>
The ratio of gap value to required element size.
proximity_size_curve <proximity1> <size1> <proximity2> <size2>
                  ...<proximityN> <sizeN> 
The values of proximity vs. size.
refinement_size <value>
The constant size with which all the affected elements are refined.
size_proximity_ratio <value>
The ratio of size to proximity.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
Here are some examples of valid input
        strings:*createstringarray 3 ""extra_layers 2"" ""proximity min_gap 0.1 max_gap 2 proximity_size_curve 0.1 0.1 0.2 0.2 0.3 0.5 0.5 1.0"" ""angle interval 0 30 0.1 0.2 interval 45 60 0.2 interval 315 360""
*createstringarray 2 ""proximity min_gap 0.1 max_gap 2 direction outwards min_elems_in_gap 2"" ""angle min_angle_limit 45 refinement_size 0.2""
*createstringarray 3 ""extra_layers 3"" ""proximity off"" ""angle""
*createstringarray 1 ""angle off""
*createstringarray 2 ""proximity proximity_size_curve 0.1 0.1 0.5 0.5 1.0 2.0"" ""angle max_angle_limit 315""
*createstringarray 3 ""extra_layers 3"" ""proximity min_gap 0.1 max_gap 2 direction both_side proximity_size_curve 0.1 0.1 0.2 0.2 0.3 0.3"" ""angle interval 0 30 0.1 0.2 interval 45 60 0.2""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
689,*refine_by_patterns_multiple_points ,"Description
Refines multiple zones of elements using an all quad pattern. The zones are described by a
        refinement box and multiple center nodes. The refined mesh is then connected to the existing
        mesh using an all quad pattern through the transition zone, described by a transition box. 
The refinement boxes will contain the refined elements, while the regions between the
        refinement boxes and the transition boxes will contain quads patterns used to transition
        between the refined mesh and base mesh size.
","Inputs

mark_id
The ID of the mark containing the refinement box center nodes. Valid values are 1 and 2.
strings
A string that contains the additional input parameters. Each string must be space
            separated, including between = and the value. All strings are mandatory. 
Valid strings are:
auto_transition = <value>
Currently unused and should be set to 0.
refine_zone_height = <value>
Defines the height of the refinement zone.
refine_zone_length = <value>
Defines the length of the refinement zone.
refine_zone_size = <value>
Defines the mesh size within the refinement zone.
refine_zone_width = <value>
Defines the width of the refinement zone.
squeez = <value>
Currently unused and should be set to 1.
system_id = <value>
The ID of a local coordinate system to which the zones are oriented. A default
                  of 0 (global system) is used if not specified.
transition_zone_height = <value>
Defines the height of the transition zone.
transition_zone_length = <value>
Defines the length of the transition zone.
transition_zone_width = <value>
Defines the width of the transition zone.



","Example
To refine elements around nodes 60, 61 and 63 with refinement size 1 using a refinement box
        of dimension (10,15,20) and transition box of dimension (40,50,45):
*createmark nodes 1 60 61 63
*refine_by_patterns_multiple_points 1 ""refine_zone_size = 1 auto_transition = 0 transition_zone_length = 40 transition_zone_width = 50 transition_zone_height = 45 refine_zone_length = 10 refine_zone_width = 15 refine_zone_height = 20 system_id = 0 squeez = 1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
690,*refineelementsbysize,"Description
Refine elements to target element size. 
","Inputs

mark
The ID of the mark which contains the elements to be refined. 
maxlength
The maximum element edge size.

","Example
To refine the elements to target element size:
*createmark(elements,1) 12 16 106 107 108 109
*refineelementsbysize(1,0.1)
*createmark() is required.
","Errors
None.
"
691,*reflectmarkwithoption ,"Description
This command reflects a selection of entities about a plane.
","Inputs

entity_type
The type of entity to reflect.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the reflection. This is defined using the
              *createplane command.
option
0 - Maintain the z-axis of bar elements during reflection. 
1 - Maintain bar element connectivity during reflection.

","Example
To reflect element 15 about a plane normal to the x-axis with its base at the origin by
        maintaining the z-axis:
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*createmark elems 1 15
*reflectmarkwithoption elems 1 1 0
To reflect element 15 about a plane normal to the x-axis with its base at the origin by
        maintaining the element connectivity:
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*createmark elems 1 15
*reflectmarkwithoption elems 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
692,*rejectmesh,"Description
Discards a generated mesh (if any) for the specified face within the automeshing
        module.
","Inputs

faceindex 
The index of the face into the particular surface under consideration. 

","Example
Must precede any call to *storemeshtodatabase for the given
        faceindex.
","Errors
None.
"
693,*remap,"Description
Remaps a list of nodes to a line. 
","Inputs

nodelist
The list of nodes to be remapped. 
linelist
The list of lines to which the nodes will be remapped. 
endpoints
The end points of the line list. 

","Errors
None.
",
694,*remesh_master_slave_boolean ,"Description
Performs intersection and Boolean operations of 2D elements. Elements are distributed into
        groups based on their connectivity and component membership. The elements belonging to
        different components can be in a single group by parameter input. Only different groups are
        taken as counterparts for the intersection and Boolean operations. Moreover, elements
        sharing a node are not counterparts of intersection calculations for element/element
        intersection.
","Inputs

selected_entity_type
The type of selected entities. Valid values are elems and comps.
selected_mark_id
The ID of the mark that contains the selected entities. Valid values are 1 and 2.
master_entity_type
The type of master entities. Valid values are elems and comps. 
Master entities are those with no elements (internal shell elements) deleted after
            conformal elements are generated for intersecting elements. Selected entities which are
            not also selected as master, are known as slave elements. After conformal elements are
            generated for intersecting elements, the slave elements inside any closed watertight
            element groups are deleted.
master_mark_id
The ID of the mark that contains the master entities. Valid values are 1 and 2.
strings
Character string containing name/value pairs. Names and values are space separated.
angle <value>
This is used to define feature edges on the mesh utilized for remeshing. If not
                  defined, its default is 30.0.
break_shell_along_component_boundaries <value>
0 - All elements connected to each other are classified as a group. 
1 - Element group building stops at component boundaries. All elements in each
                  group belong to a single component (default).
do_boolean_difference <value>
If set to 1, perform a Boolean difference to subtract slave entities from the
                  master. Default is 0.
generate_intersect_segments_only <value>
If set to 1, the command only calculates and creates the intersection segments,
                  but does not perform the intersection and remeshing. Default is 0.
keep_intersected_edges <value>
If set to 1, create 1D elements at mesh intersection locations. Default is
                  0.
num_remesh_layers <value>
The number of layers attached to intersecting elements to consider for
                  remeshing. 
-1 - Intersecting elements are split and stitched to obtain a conformal element
                  connectivity without remeshing. 
0 - Remesh only the intersecting elements 
> 0 - Remesh using the specified number of layers in addition to the intersected
                  elements.



","Example
To create intersections between the displayed comps and comps brown and blue:
*createmark components 1 ""displayed""
*createmark components 2 ""brown"" ""blue""
*remesh_master_slave_boolean components 1 components 2 ""do_boolean_difference 1 keep_intersect_edges 0 break_shell_along_component_boundaries 0 num_remesh_layers -1 angle 30.000000 ""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
695,*remove_fe_cracks,"Description
Stitches free edge loops in FE.
","Inputs

mark_id
The ID of the mark containing the elements to stitch. Valid values are 1 and 2.
stitch_tol
The tolerance to use for stitching.

","Example
To stitch all displayed element cracks, using a tolerance of 0.1:
*createmark elems 1 displayed
*remove_fe_cracks 1 0.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
696,*removeassembly,"Description
 Deletes assemblies and their contents, including recursive children.
","Inputs

mark_id
The ID of the mark containing the assemblies to delete. Valid values are 1 and 2.

","Example
To delete assemblies 1 and 2, including all recursive children and their contents:
*createmark assems 1 1 2
*removeassembly 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
697,*removeedgefillets,"Description
Defeatures surface edge fillets.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
min_radius
The minimum value of the fillet radius.
max_radius
The maximum value of the fillet radius.
min_angle
Minimum value of the fillet angle (in degrees).
failed_elem_size
Filters out edge fillets with an angle point within
              failed_elem_size from other face vertices. Additionally, it
            internally filters out some concave edge fillets on ""shelves"" so that they are not cut
            by the defeature operation.

","Example
To delete all edge fillets with a radius between 3 and 5, with an angle greater than 15
        degrees:
*createmark surfs 1 all
*removeedgefillets 1 3 5 15 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
698,*removeelemsfromcontactsurfusingnodes ,"Description
Removes elements from a contactsurf using face nodes. If all elements are removed the empty
        contactsurf still exists.
","Inputs

name
The name of the contactsurf.
elem_mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes defining the face nodes of the elements to
            remove. Valid values are 1 and 2.

","Example
To remove elements 100 and 101 from the contactsurf ""test"" for the specified face defined
        by the nodes on mark 2:
*createmark elems 1 100 101
*createmark nodes 2 201 202
*removeelemsfromcontactsurfusingnodes  ""test"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
699,*removeinclude ,"Description
Deletes the include file from the database, optionally removing all of its contents as
        well. 
","Inputs

id
Use an id of 0 to have HyperMesh to use the
              shortname to select the file.
shortname
The shortname to use to select the file. This can be left empty if the id is
            specified.
removecontents
If nonzero, and either the id or the shortname selects a single
            file, then all of the contents of that include file will be deleted from the
            database.

","Example
To remove the include file mat1.dyn from the database, and delete its contents as well:
*removeinclude(0,mat1.dyn,1)
If both id and shortname are empty, this command removes all include files from the
        database (but does not delete the files’ contents). If the contents are not deleted, they
        move to the file's parent include file.
","Errors
None.
"
700,*removemodel,"Description
Removes a secondary model.
","
Inputs



name

The name of the secondary model to remove.

make_current

The optional name of the model to make current if the current model is removed.  If
            not specified, the primary model is made current (default).

","Examples
To remove the secondary model named model-2:*removemodel model-2
To remove the secondary model named model-2 and make model-3 as
        current:*removemodel model-2 model-3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
701,*removetempcleanupfile,"Description
None required. 
","Example
This example shows a script that uses the *autotopocleanup()
        command:
*createmark(surfaces,1) ""displayed""
*autotopocleanup( 1, ""nvh10.criteria"", ""nvh10.param"" )
*removetempcleanupfile()

","Errors
None.
",
702,*removeview ,"Description
Deletes a saved view from the database.
","Inputs

name
The name of the view to delete. The view names 1-5 are reserved and cannot be
            deleted.

","Example
To delete the view with the name ""my_view"":
*removeview ""my_view""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
703,*renamecollectorbyid ,"Description
Renames a collector to its ID. 
","Inputs

entity type
The type of collector being renamed. 
prefix
A prefix which will be inserted before the ID of the collector. 

","Errors
None.
",
704,*renameviewmask,"Description
Renames a view saved using *saveviewmask.
","Inputs

old_name
The name of the view to rename. The numbers 1-5 are reserved and cannot be used.
new_name
The new name of the view. The numbers 1-5 are reserved and cannot be used.

","Example
To rename a view from ""my_view"" to ""isometric"":
*renameviewmask ""my_view"" ""isometric""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
705,*renumberall ,"Description
This command renumbers the internal HyperMesh IDs for all
        entities in the model. 
This command only renumbers HyperMesh internal IDs, even if the
        selected entities have solver IDs (see *renumbersolveridall).
","Inputs

start_id
Integer value > 0 specifying the starting value.
incr_val
Integer value > 0 specifying the renumbering increment.
offset_val
Integer value to use for offsetting. Can be positive or negative as long as after
            renumbering all entities will have a positive ID.
offset_flag
Flag to specify whether to use offsetting: 
0 Use start_id and incr_val and ignore
              offset_val. 
1 Use offset_val and ignore start_id
              and incr_val.

","Example
To renumber the internal HyperMesh IDs of all entities starting
        from 100 with an increment of 1:
*renumberall 100 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
706,*renumberinternaltosolverid,"Description
Renumbers internal IDs to match solver IDs.
","
Inputs



entity_type

The type of entity to update.  If set to 0, all entities that have solver IDs are
            considered.

output_mark_id

The ID of the mark containing the renumbered entities.  Valid values are 1 and 2.
A value of 0 does not store the renumbered entities.

","Examples
To renumber all entities:
*renumberinternaltosolverid 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
707,*renumbersolveridall,"Description
This command renumbers the solver IDs for all entities in the model. 
This command works in two ways. If the entity has solver IDs, the command will renumber the
        solver IDs and not the HyperMesh internal IDs. However, if the
        entity does not have solver IDs, the command will renumber the HyperMesh internal IDs (see *renumberall).
","Inputs

start_id
Integer value > 0 specifying the starting value.
incr_val
Integer value > 0 specifying the renumbering increment.
offset_val
Integer value to use for offsetting. Can be positive or negative as long as after
            renumbering all entities will have a positive ID.
offset_flag
Flag to specify whether to use offsetting. 
0 Use start_id and incr_val and ignore
            offset_val. 
1 Use offset_val and ignore start_id
              and incr_val.
reserved_1
Reserved for future use. Must be set to 0.
reserved_2
Reserved for future use. Must be set to 0.
reserved_3
Reserved for future use. Must be set to 0.

","Example
To renumber the solver IDs of all entities starting from 100 with an increment of 1:
*renumbersolveridall 100 1 0 0 0 0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
708,*repair_midmesh_line_imprinter,"Description
This command can be used to imprint geometric lines to the mesh in the direction provided
        by the user.
Note: If free lines and surface edges are selected together and
          ProjectionDirection is not provided, the projection direction for the
        free lines will always be by shortest distance.  Other directions will be used only for
        surface edges.
","
Inputs



line_list_id

The ID of the line list, created with *createlist to use as input.
            Valid values are 1 and 2.
options
List of input options, passed as a space separated string enclosed in quotes. Valid
            options are:
GuideSurfaceMark=<mark_id>
The ID of the mark of surfaces to consider for the imprint direction
                  calculation. Valid values are 1 and 2.
LineEndSnapTolerance=<value>
The tolerance to snap the end of the line to nearby vertex/face boundary edges.
                  Vertex is preferred over the face boundary edges. Vertex nodes are identified
                  based on the turning angle (45 degree) and the number of 1D elements connected
                  (>2). Default is minimum element size.
ProjectionDirection=<x> <y> <z>
The vector in which the lines are to be projected.
ProjectionType=<value>
0 - Shortest distance
1 - Tangential to the GuideSurfaceMark surfaces
2 - Average normal to the GuideSurfaceMark surfaces
3 - The direction given by ProjectionDirection
ProjectOnElemsMark=<mark_id>
The ID of the mark of elements to consider for imprinting. Valid values are 1
                  and 2.



","Examples
To imprint line 4905 onto elements 3000-4000, using a snap tolerance of 1:
*createlist lines 1 4905
*createmark elements 1 3000-4000
*repair_midmesh_line_imprinter 1 ""ProjectOnElemsMark=1 LineEndSnapTolerance=1 ProjectionDirection=0.0 0.0 1.0 ProjectionType=3""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
709,*replacenodes,"Description
This command replaces or moves a node with another node.
","Inputs

node1_id
The ID of the first node.
node2_id
The ID of the second node.
mode
0 - Move but do not replace. 
1 - Move and replace.
location
0 - Move node1 to node2. 
1 - Move node1 and node2 to their midpoint.

","Example
To move node 20 to node 200 without replacing:
*replacenodes 20 200 0 0
 To move node 20 to node 200 with replacing:
*replacenodes 20 200 1 0
To move node 20 and node 200 to their midpoint with replacing:
*replacenodes 20 200 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
710,*replacentitywithentitymark,"Description
This command replaces multiple components.
","Inputs

mode
The replace mode. Valid values are:
0 - Undo/reject replace operation. 
1 - Initial replace operation. 
2 - Finish/accept replace operation.


existing_component_mark
The ID of the mark containing the existing/old components.
incoming_component_mark
The ID of the mark containing the incoming/new components.
string_array
The ID of the string array that contains the input options. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
The supported options and values are:
tolerance=value
The replacement tolerance. Right now it is a global tolerance, meaning the same
                  tolerance is applied for all replace entities. The default is 0.01.
keep_src_prop=value
0 - Do not reuse/keep the property assigned to the outgoing component (default) 
1 - Reuse/ assign property of source component to the outgoing component.
keep_src_mat=value
0 - Do not reuse/keep the material assigned to the outgoing component (default) 
1 - Reuse/assign material of source component to the outgoing component.
keep_src_comp_cardimage=value
0 - Do not reuse/keep the card image assigned to the outgoing component
                  (default) 
1 - Reuse/ assign source component card image to the outgoing component.
keep_src_include=value
0 - Do not organize the incoming component to the outgoing component include
                  (default) 
1 - Organize the incoming component and its nodes/elements/reference entities to
                  the outgoing component include.
log_file=value
If a log file is desired, value should be set to the full path and file name to
                  write to.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To replace components 301 and 302 with 501 and 502 respectively:
*createmark comps 1 301 302
*replacesetentitydata componentmark=1
*createmark sets 1 20 30
*createmark groups 1 20 30
*replacesetentitydata preservemark=1 incomingonlyentities={sets groups} componentpairingstring={{301 501} {302 502}}
*createstringarray 4 ""tolerance=0.5"" ""keep_src_prop=1"" ""keep_src_mat=1"" ""keep_src_comp_cardimage=1""
*createmark comps 1 301 302
*createmark comps 2 501 502
*replacentitywithentitymark 1 1 2 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
711,*rescanunresolvedids,"Description
When importing a file that references entities that are in another file that is not
        imported at the same time, those entities are recorded and protected from overwrite so that
        the links will not be lost. This way, fragments of a larger model can be edited while
        keeping links to the other parts of the model intact. 
If another fragment of the larger model containing some of the unresolved references is
        imported, HyperMesh will complete the links between the two
        model fragments and remove the protected entity IDs from the unresolved IDs database. 
If any referring entities are deleted or re-linked to other entities, there can be left
        unnecessary entries in the unresolved IDs database. This command can be used to empty the
        database and rebuild it. 
Normally, the feinput system handles everything automatically. The last step of an feinput
        operation calls this command automatically, so the result after any import is a fully
        up-to-date unresolved IDs database. Therefore, the need to use this command is very rare and
        is provided for situations that need to exactly target the creation of new entities to
        fulfill the unresolved links.
","Example
*rescanunresolvedids
","Errors
None.
",
712,*reset_thickness_legend,"Description
Resets the thickness legend to its default values.
","Example
To reset the legend:
*reset_thickness_legend
","Errors
None.
",
713,*resetreview ,"Description
Resets the entity review of the *reviewentity command.
","Example
To reset the review:
*resetreview
","Errors
None.
",
714,*resolvemasslocation,"Description
This command resolves unresolved (unconnected to any node) mass locations, using a
        specified search technique order.  There are 5 search techniques:


Free end of CBUSH with tag and connected to RBE2
Free end of CBUSH with no tag and connected to RBE2
Shell hole
Shell mesh
Independent rigid node


","Inputs

mark_id
The ID of the mark containing the masses to resolve.  Valid values are 1 and 2.
search_technique_order
There are 5 search techniques:


Free end of CBUSH with tag and connected to RBE2
Free end of CBUSH with no tag and connected to RBE2
Shell hole
Shell mesh
Independent rigid node


These techniques are specified individually, or in combination.  If multiple search
            techniques are used, and the location is resolved with one of the techniques, it will
            not look for remaining techniques.  The order is specified using the indices from above.
            For example 1, 2, 3, 12, 21, 123, 312, etc... The search will be performed in the same
            sequence as the indices are ordered.

","Example
To resolve the mass location using technique 1 only, for mass entities with IDs 10 and
        20:
*createmark masses 1 10 20
*resolvemasslocation 1 1
To resolve the mass location using technique 3 only, for mass entities with IDs 10 and
        20:
*createmark masses 1 10 20
*resolvemasslocation 1 3
To resolve the mass location using techniques 4, 3 and 1, for mass entities with IDs 10 and
        20:
*createmark masses 1 10 20
*resolvemasslocation 1 431
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
715,*retainmarkselections ,"Description
Sets the display state of marked entities.
","Inputs

mode 
1=on, 0 = off (default)

","Example
This command will allow users to control the display of the marked entities when using
          the *createmark command. 
","Errors
None.
"
716,*reverseview,"Description
Reverses the display with respect to a view saved using
        *saveviewmask.
","
Inputs


name
The name of the view to reverse.
entity_type_id
The entity type ID to reverse.

","Examples
Reverse the comps (entity type ID 3) in view
        View2:*reverseview View2 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
717,*reviewclearbyid ,"Description
This command removes/clears entities from the review list based on an entity ID.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are blocks and groups. 
id
The ID of the entity.
review_type
The review type to control.
For blocks: 
1 = nodes 
2 = elems


For groups: 
1 = slave only 
2 = master only 
3 = master & slave



","Example
To remove master and slave review of group 5 from the review list:
*reviewclearbyid groups 5 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
718,*reviewcontactnormalinconsistency,"Description
Graphically reviews the group entity region where the contact normal is inconsistent.
","Inputs

entity_type
The type of entity to review. Currently only supported for groups.
name
The name of the entity to review.
master_slave_flag
0 - Review slave elements
1 - Review master elements
3d_elements_flag
0 - Ignore 3D elements
1 - Consider 3D elements

","Examples
To review the region where group ""group1"" has inconsistent master element contact
        normals:
*reviewcontactnormalinconsistency group ""group1"" 1 0
To review the region where group ""group1"" has inconsistent slave element contact
        normals:*reviewcontactnormalinconsistency group ""group1"" 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
719,*reviewentitybymark,"Description
This command graphically reviews a mark of entities.
","Inputs

mark_id
The ID of the mark containing the entities to review. Valid values are 1 and 2.
color
The color used to review the entities. Valid values are 1-64. 
If specified as 0, entities will be reviewed with their respective entity color (not
            yet available).
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are: 
showcomps - This indicates that components in which elements/geometry are referred
            will also be reviewed. If not provided, only specified elements/geometry are
            reviewed.

","Example
To review elements 1-100 using color 10:
*createmark elems 1 1-100
*reviewentitybymark 1 10 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
720,*reviewmaterialorientation_option ,"Description
Reads and plots the first axis of the element (material) coordinate system for selected
        elements. When review is complete, the command *vectorsoff must be
        run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64.
option
Option for review customization. Valid values are: 
1 - Abaqus rebar layer will be reviewed

","Example
To review the element (material) coordinate system of the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*reviewsystem_option elems 1 1 3 7 1
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
721,*reviewsystem,"Description
Reads and plots the x-axis of the element (material) coordinate system for selected
        elements.
","Inputs

markmask
Determines the selected elements.
onlyorient
If onlyorient = 1, the new x-element directions are displayed as
            vectors starting from the element center. 
If onlyorient = 0, the new x-element directions are shown as
            continuous gradient lines starting and ending on free edges.
normal_size
If onlyorient = 1, it determines the size of the vectors to be
            displayed.
color
Determines the color of the vector or line. The color ID numbers range from 1 to
              64.

","Example
To review the element (material) coordinate system of four selected elements and display
        them as blue vectors (color 7) with size = 3: 
*createmark(elements,2) 304 305 316 1841 
*reviewsystem(2,1,3,7) 
*vectorsoff()

The *createmark() and *vectorsoff() commands are
        required. 
","Errors
None.
"
722,*rigid,"Description
Creates a rigid element between two nodes. 
","Inputs

node1
The independent node of the element. 
node2
The dependent node of the element. 
dofs
The degrees of freedom for which the element is active (any of the digits 1-6). 

","Example
To create a rigid element between nodes 100 and 101 in all six degrees of freedom: 
*rigid(100,101,123456)
s
","Errors
None.
"
723,*rigidlinkbycollector,"Description
This command creates the rigid link with one independent node and dependent node by
        collector by mark with DOFs. 
","Inputs

node_id 
ID of independent node.
entity_type
Entity type of collector. Valid entity types are comps, mats, assems, props and
            sets.
mark_id
Collector put on mark. Valid values are 1 and 2.

dofs
The degree of freedom for which the element is active. Valid values are any of the
            digits 1-6.

","Example
To create a rigid link by collector with independent node ID 10 and independent node
        specified by comps ID 1 and 2 put on a mark 1 with DOF 123456: 
*createmark comps 1 1 2
*rigidlinkbycollector 10 comps 1 123456
","Errors
None.
"
724,*rigidlinkupdatebycollector,"Description
This command updates the rigid link with one independent node and dependent node by
        collector by mark. 
","Inputs

element_id
The id of the rigid link.
node_id
ID of independent node.
mark_id
Collector put on mark. Valid values are 1 and 2.
entity_typ
Entity type of collector. Valid entity types are comps, mats, assems, props and sets. 

","Example
To update a rigid link element ID 7 with independent node ID 10 and dependent node
        specified by comps ID 1 and 2 put on mark 1:
*createmark comps 1 1 2
*rigidlinkupdatebycollector 7 10 1 comps

","Errors
None.
"
725,*rigidlinkwithset ,"Description
 Create a rigid link element with dependent nodes attached as a node set connected to the
        element. The attached node set may exist before or may be created from a given mark of
        dependent nodes while the rigid link element is created. 
","Inputs

independent
The independent node of the element. 
mark
The ID of the mark containing the dependent nodes if the dependent nodes set is
            created for the rigid link element; 
0 - if an existing nodes set is being attached to the rigid link. 
dependent_set
The ID of an existing nodes set being attached to the rigid link; 0 - if the rigid
            link and an attached nodes set are being created using a mark of dependent nodes. 
dof
The degrees of freedom for which the element is active (any of the digits 1-6).

","Example
To create a rigid link element with independent node 100 and dependent nodes 101, 102, and
        103 with nodes having all six degrees of freedom:
*createmark(nodes,2) 101 102 103
*rigidlinkwithset(100,2,0,123456)
A new nodes set with an autogenerated name is created for the rigid link element, the
        dependent nodes 101,102,103 being placed to this nodes set. 
To create a rigid link element with independent node 100 and node set 25 attached as a
        dependent node set, with nodes having all six degrees of freedom:
*rigidlinkwithset(100,0,25,123456)
The *createmark() command is required to create a rigid link element
        with an attached independent node set. 
","Errors
None.
"
726,*rigidscombine,"Description
Combines rigids and rigidlinks.
","Inputs

mark
The ID of the mark containing the elements to combine.
combine_common_inode
If combine_common_inode =1, then rigids and rigidlinks that share a
            common independent node will be combined. 
If combine_combine_inode =0, then rigids and rigidlinks will be
            combined if they share any nodes (dependent or independent).

","Example
To combine elements 100 and 101 into one rigidlink:
*createmark(elements, 1) 100 101
*rigidscombine(1,1)
","Errors
None.
"
727,*rigidwallsize ,"Description
Sets the size for axis and motion arrow plotting.
","Inputs

size 
The size in model units in which the arrows should be plotted.

","Errors
None.
",
728,*rod,"Description
Creates a rod element. 
","Inputs

node1
The first node of the element. 
node2
The second node of the element. 
property
The property to which the element points. 

","Errors
None.
",
729,*rotateabout,"Description
Defines a new center of rotation for *rotate() and
          *quatrotate() commands.
","Inputs

overridedefault
If 1, defines the center as x, y, z. 
If 0, uses default center.

","Errors
None.
",
730,*rotatedummyrootbodytoeulerangles,"Description
Rotates a dummy about a given point. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the root body of the dummy.
ax
The desired x Euler angle of the dummy with respect to the global axes.
ay
The desired y Euler angle of the dummy with respect to the global axes.
az
The desired z Euler angle of the dummy with respect to the global axes.
cx
The x-coordinate of the center point.
cy
The y-coordinate of the center point.
cz
The z-coordinate of the center point.

","Example
To move a dummy with root body named ""Pelvis Angle Gauge"" to Euler angles 10, 50 and 20
        about the point (0,0,0):
*rotatedummyrootbodytoeulerangles ""Pelvis Angle Gauge"" 10 50 20 0 0 0 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
731,*rundesignmethod,"Description
Run the design method for a given design point set.  The design point set should contain a
        valid design point and design method.
This outputs a new table entity containing the output of the the operation.
","Inputs

entity_type
Must be set to designpointsets.
id=<value>
The ID of the design point set.
columnLabels=<value>
The input column label.
debugInfo=<value>
0 - Do not create a table with input argument data
1 - Create a table with input argument data (default)
loadcaselist=<value>
The IDs of the method loadcases.
logfileInfo=<value>
0 - Do not create a stress tool log file
1 - Create a stress tool log file (default)
tableInfo=<value>
0 - Do not overwrite output table (default)
1 - Overwrite output table
targetentitymark=<value>
The ID of the mark of entities on which the method is run.  Valid values are 1 and
            2.
targetentitytype=<value>
The entity type on which the method is run.  Valid values are elements and
            designpointsets.

","Example
To run the design method for design point set 2:
*rundesignmethod designpointsets id=2
To run the design method for design point set 2 for the target elements on mark 1:
*rundesignmethod designpointmethods id=2 targetentitytype=elems targetentitymark=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
732,*savefailedsurfstomark ,"Description
Scans all the displayed surfaces, finds those for which all the meshing algorithms failed,
        and places them on the specified mark. This command is used after one of the commands
        performing meshing by surfaces. 
","Inputs

surfs_mark 
The mark the surfaces failed to be meshed must be placed to. It must be 1 or 2.

","Example
To mesh displayed surfaces and place failed surfaces on mark 2:
*createmark(surfaces,1) ""displayed""
*defaultmeshsurf(1,20,2,2,1,0,1,1,1,0,0,0,0)
*createmark(surfaces,2)
*savefailedsurfstomark(2)
Note that *createmark(surfaces,2) is placed before
          *savefailedsurfstomark(2) to clear all the surfaces from the specified
        mark. 
","Errors
None.
"
733,*scale_thickness ,"Description
This command scales the thickness and sets the scaled thickness back to entity. This
        functionality is currently supported only in the Radioss and
          LS-DYNA user profiles.
","Inputs

entity_type
The type of entity to scale. Currently only supported for elems.
mark_id
The ID of the mark that contains the entities to scale. Valid values are 1 and 2.
string_array
The ID of the string array that contains the array of input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each argument can be either space or comma separated.
add : <value>
The value to add to the thickness of each entity. To subtract, use a negative
                  value. If not specified, multiply must be used.
multiply : <value>
The value to multiply the thickness of each entity by. To divide, use a value
                  less than one.
 If not specified, add must be used.
MaxThickness : <value>
Used to limit the maximum thickness. Not mandatory.
MinThickness : <value>
Used to limit the minimum thickness. Not mandatory.


number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray.

","Examples
Add 2 to the existing thickness of all elements in the model, with a minimum thickness of
        10 and a maximum thickness of 20:
*createstringarray 3 ""add : 2"" ""MinThickness : 10"" ""MaxThickness : 20""
*createmark elems 1 all
*scale_thickness elems 1 1 3

Multiply element 15-17 thicknesses by 0.5:
*createstringarray 1 ""multiply: 0.5""
*createmark elems 1 15-17
*scale_thickness elems 1 1 1
 Subtract 2 from the thickness of all elements:
*createstringarray 1 ""add: -2""
*createmark elems 2 all
*scale_thickness elems 2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
734,*scalemarkwithsystem ,"Description
This command scales a selection of entities by multiplying the coordinates.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
scale_x
The multiplication factor for the x-axis of the system.
scale_y
The multiplication factor for the y-axis of the system. Only used in rectangular
            coordinate systems.
scale_z
The multiplication factor for the z-axis of the system. Not used in spherical
            coordinate systems.
system_id
The ID of the system which the scaling is in relation to. Note that the type of system
            affects the scaling. For example, specifying scale_x in a cylindrical
            or spherical coordinate system scales the mark radially out from the origin. 
For scaling of rigid walls in the rigid wall local system, specify as 0.
origin
If zero, the scaling is based at the origin of the system. Otherwise, it specifies a
            node ID whose coordinates define the base point of the scaling. 
For scaling of rigid walls in the rigid wall local system, specify as 0.

","Example
To scale nodes 1-8 5 units in the x-direction of system 13 with node 20 as the origin:
*createmark nodes 1 1-8
*scalemarkwithsystem nodes 1 5.0 1.0 1.0 13 20
To scale the rigid wall rwcyl relative to the rigid wall local system:
*createmark groups 1 rwcyl
*scalemarkwithsystem groups 1 3.0 1.0 1.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
735,*screendump ,"Description
 Generates a PostScript output file from a Macro menu macro.
","Inputs

pathName
The file name and path to which the PostScript file will be output.

","Example
This command is not available through Tcl/Tk.
* screendump (c:\postscriptdumps\output1.ps)

","Errors
None.
"
736,*secondorderfix2 ,"Description
Fixes the middle nodes of second order elements, using parameters to define how the nodes
        can be moved.
","Inputs

mark_id
ID of the mark containing the elements to fix. Valid values are 1 and 2.
min_jacobian
The element Jacobian threshold of the fixed result.
max_midangle
The maximum angle of the curved edge to the straight edge.
min_midratio
The minimum ratio of the two parts of the edge separated by the middle node.
jacobian_method
The evaluation method of the Jacobian. Valid values are:
0 - Evaluate at integration points 
1 - Evaluate at corner points 
2 - Evaluate at corner and mid points 
3 - Evaluate at high order integration points


fix_method
The method used to fix the node.
0 - Just straighten surface edge, internal middle nodes are not moved. 
1 - Move internal nodes only, boundary middle nodes are not moved. 
2 - Move all nodes (both internal and surface), the boundary nodes should be
                moved along the geometry. 
3 - Move internal nodes and straighten surface nodes, the boundary nodes can be
                moved off the geometry.

Any other value - Move all nodes and straighten surface nodes. For the boundary
              nodes, first try to move along geometry. If not able to reach the target, then try to
              move off the geometry.


","Example
Fix the middle nodes of elements 2 and 4. The target Jacobian at the elements’ corner
        points should be not less than 0.1, the angle of the fixed edge to the straight edge which
        is constructed by the two end nodes should be less than 30 degrees, and the ratio of the two
        parts of the edge separated by the middle node should be greater than 0.8. Both the internal
        nodes and boundary nodes can be moved, and the boundary nodes can be kept on the
        geometry:
*createmark elements 1 2 4
*secondorderfix2 1 0.1 30 0.8 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
737,*segmentsetaddfaces,"Description
Adds elements using the face/edge option to a segment set.
","
Inputs


name
The name of the segment set to update.
elem_mark_id
The ID of the mark containing the elements to add.  Valid values are 1 and 2.
The mark must contain solid elements if specifing faces, or shell elements if
            specifying edges.
node_mark_id
The ID of the mark containing the nodes that define an edge or a face of an element.
            Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal
face_or_edge
Create segment set:
0 - On edge
1 - On face
10 - On edge for shells, do not consider break angle 
11 - On face for solids, do not consider break angle
20 - On edge for shells, consider hidden entities
21 - On face for solids, consider hidden entities
30 - On edge for shell, do not consider break angle, consider hidden entities
31 - On face for solid, do not consider break angle, consider hidden entities

","Examples
To add elements 1-100 with faces defined by nodes 1-5 to the segment set ""test"" with a
        break_angle of 30.0:

*createmark elems 1 1-100
*createmark nodes 1 1-5
*segmentsetaddfaces ""test"" 1 1 30.0 0 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
738,*segmentsetaddmixedfaces,"Description
Adds element faces to a segment set.
","
Inputs


name
The name of the segment set to update.
elem_mark_id
The ID of the mark containing the elements to add.  Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes that define an edge or a face of an element.
            Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal

","Examples
To add elements 1-100 with faces defined by nodes 1-5 to the segment set ""test"" with a
        break_angle of
        30.0:*createmark elems 1 1-100
*createmark nodes 1 1-5
*segmentsetaddmixedfaces ""test"" 1 1 30.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
739,*segmentsetadjustnormal,"Description
Adjusts a segment set normal using an orientation element.
","
Inputs


name
The name of the segment set to update.
elem_mark_id
The ID of the mark containing the elements to adjust when elem_flag
            is 1.  Valid values are 1 and 2.
elem_flag
Flag for reversing the contact normal of all or individual elements of the segment
            set:
0 - Adjust all elements, elem_mark_id is ignored
1 - Adjust individual elements, elem_mark_id is used
orientation_element
The ID of the shell element used to define the segment set normal correction.
reverse_normals
0 - Correct contact normal along orientation_element normal
            (default)
0 - Correct contact normal opposite orientation_element normal

","Examples
To adjust the normal of segment set ""test"" for the elements on mark 1 in the normal
        direction of reference element
        23:*createmark elems 1 12 29 53 23
*segmentsetadjustnormal ""test"" 1 1 23 0

To adjust the normal of segment set ""test"" for the elements on mark 1 in the reverse normal
        direction of reference element
        23:*createmark elems 1 12 29 53 23
*segmentsetadjustnormal ""test"" 1 1 23 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
740,*segmentsetcreatewithfaces,"Description
Creates a segment set using 2D element edges or 2D/3D element faces.
","
Inputs


name
The name of the segment set to create.
color
The color of the segment set.  Valid values are 1-64.
elem_mark_id
The ID of the mark containing the elements to use. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes that define an edge or a face of an element.
            Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal
face_or_edge
Create segment set:
0 - On edge
1 - On face

","Examples
To create a segment set named ""test"" with elements 1-100 with faces defined by nodes 1-5
        and a breakangle of
        30.0:*createmark elems 1 1-100
*createmark nodes 1 1-5
*segmentsetcreatewithfaces ""test"" 5 1 1 30.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
741,*segmentsetcreatewithshells,"Description
Creates a segment set using 1D or 2D elements.
","
Inputs


name
The name of the segment set to update.
color
The color of the segment set. Valid values are 1-64.
mark_id
The ID of the mark containing the elements to add. Valid values are 1 and 2.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal

","Examples
To create a segment set named ""test"" with elements
        1-100:*createmark elems 1 1-100
*segmentsetcreatewithshells ""test"" 5 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
742,*segmentsetremoveelemsusingnodes,"Description
Removes elements from a segment set using face nodes.  If all elements are removed, the
        empty segment set still exists.
","
Inputs


name
The name of the segment set to update.
elem_mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.
node_mark_id
The ID of the mark ontaining the nodes that define the faces of the elements. Valid
            values are 1 and 2.

","Examples
To remove elements 100 and 101 from the segment set ""test"", for the specified face defined
        by the nodes on mark
        2:*createmark elems 1 100 101
*createmark nodes 2 201 202
*segmentsetremoveelemsusingnodes ""test"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
743,*segregateByPatches ,"Description
This command is used to find connected patches of elements and create separate components
        for the elements in each connected patch. The number of new components created will be equal
        to number of clusters of element patches. 
For example, for element patches {1 2 3 4} {5 6 7 8 9} {10 11} there will be 3 new
        components created.
","Inputs

entity_type
Must be set to elems.
mark_id
ID of the mark containing the input shell elements. Valid values are 1 and 2.
component_name
The maximum angle of the curved edge to the straight edge.

","Example
To create new components from element patches in component ToSegregate:
*createmark elems 1 ""by comp"" ToSegregate
*segregateByPatches elems 1 ToSegregate
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
744,*separate_fillets,"Description
This command takes as input a mark of surfaces or solids of a 3D body. It recognizes
        fillets in the 3D body and groups them by radius and width. The command creates a component
        with an autogenerated name for each fillet group and moves the fillet surfaces to the
        corresponding components. 
Optionally the surfaces of the detected fillets can be put to an output mark.
","Inputs

entity_type
The type of input entities. Valid values are surfaces or solids.
input_mark_id
The ID of the input mark. Valid values are 1 and 2.
output_mark_id
The ID of the output mark to put the surfaces of the detected holes. Valid values are
            0, 1 or 2. If set to 0, no surfaces are placed on the mark.
string_array
The ID of the string array that contains the fillet width and radius group
            information. The string array is created using the *createstringarray
            command. This should always be set to 1. 
Each string may contain either two quoted values:
min_fillet_radius
(double)
or four quoted values:
max_fillet_radius
(double)
min_fillet_radius
(double)
max_fillet_radius
(double)
min_fillet_width
(double)
max_fillet_width
(double)
The groups should not overlap.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To separate fillets from all surfaces using the following groups:
Group 1: 
min_fillet_radius - 0.001 
max_fillet_radius - 10.0 
min_fillet_width - 0.01 
max_fillet_width - 30.0
Group 2:
min_fillet_radius - 10.0 
max_fillet_radius - 20.0 
min_fillet_width - 30.0 
max_fillet_width - 50.0
*createmark surfaces 1 ""all""
*createstringarray 2 ""0.001 10 0.01 30"" ""10 20 30 50""
*separate_fillets surfaces 1 2 1 2

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
745,*set_acousticmesh_options ,"Description
Assigns certain options used during acoustic cavity meshing.
","Inputs

string_array
The ID of the string array that contains the option parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Valild strings are:
DisplayCavities:
Option to control the number of cavities displayed during the preview.
NumElemPerWaveLength:
Specifies the element per wave length which is used to decide the target element
                  size. The target size is computed as
                  (WaveSpeed/MaxFrequency)/NumElemPerWaveLen
WaveSpeed:
Specifies the wave length which is used to decide the target element size.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
TBD
*createstringarray 3 ""NumElemPerWaveLength: 6"" ""WaveSpeed: 31000"" ""DisplayCavities: 10""
*set_acousticmesh_options 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
746,*set_flags_for_2dmesh_context,"Description
Preserves selection topology used by 2D meshing. This is useful while doing 2D meshing
        iteratively on fixed selections, but modifying edge and face settings iteratively.
","
Inputs



automatic

0 - Does not delete FE for failed surface selection and continues to retain previous
              topology1 - Does not populate topology information, but ensures that when meshing
              fails, existing FE is deleted for given surface selection to ease identifying failed
              surfaces


interactive

0 - Clear the last preserved topology information.1 - The next meshing command will
              populate topology information and preserve it for subsequent meshing calls. This
              allows changing meshing parameters on edges and faces. This also ensures that when
              meshing fails, existing FE is deleted for a given surface selection to ease
              identifying failed surfaces.


","Examples
To set interactive meshing option to 1:
*set_flags_for_2dmesh_context interactive=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
747,*set_meshfaceparams ,"Description
This command sets the face-specific parameters for the automeshing module.
","Inputs

face_index
The index of the surface face under consideration.
shape_type
Determines the surface-based mesh generation algorithm to use when creating elements
            on the face. Valid values are:
1 - autodecide 
2 - map as rectangle 
3 - map as triangle 
4 - map as pentagon 
5 - advancing front


elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


alg_type
0 - Standard surface meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control
elem_size
Reserved for future use. Must be set to 0.
smooth_method
The smoothing method to use during the meshing process. Valid values are:
0 - autodecide 
1 - size-corrected 
2 - shape-corrected


smooth_tol
The automesher applies the smoothing algorithm until the largest adjustment made to a
            nodal position is less than this value. Valid vales are > 0.0.
size_control
Determines if uniform size elements should be created in mapping algorithms. Valid
            values are:
0 - Do not create uniformly-sized elements. 
1 - Create uniformly-sized elements.


skew_control
Determines if optimal shape elements are created in mapping algorithms. Valid values are:
0 - Do not optimize element shapes. 
1 - Optimize element shapes.



","Example
To specify meshing parameters on face 0 of a surface for a quad dominant mesh with no size
        or skew control:
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
748,*set_preserved_edges ,"Description
Marks edge geometry to be preserved during batch meshing, or clears the ""preserved"" flag
        from preserved edges.
","Inputs

hmlinesmark
The mark containing the lines that you wish to flag as preserved or not preserved. 0
            indicates all lines.
new_stat
1 - The lines are marked as preserved. 
0 - The preservation flag is cleared from the lines.

","Example
To preserve the lines in mark 2:
*set_preserved_edges(2,1)
","Errors
None.
"
749,*setbackgroundgradient,"Description
Sets the gradient background type.
","Inputs

type
The type of gradient to use. Valid values are:
121 
diagonal1 
diagonal2 
vertical



","Example
To set the gradient background to 121:
*setbackgroundgradient 121
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
750,*setcolor,"Description
Set a colormap entry for the entity colors.
","Inputs

index
Specifies the color location (0 to 63)
red
The red component of the color. ( 0 through 255)
green
The green component of the color. ( 0 through 255)
blue
The blue component of the color. ( 0 through 255)

","Example
The changes do not take effect until you redraw the display. 
","Errors
None.
"
751,*setcomptopologydisplay ,"Description
Sets the various types of geometry display at the component level.
","Inputs

compid
The ID of the component for which you wish to set the topology display mode.
display_type
The type of topology display:
0 - Wireframe only 
1 - Shaded with edges 
2 - Shaded without edges 
3 - Wireframe with internal surface lines



","Errors
None.
",
752,*setcurrentmodel,"Description
Sets the specified model as curent.
","
Inputs



name

The name of the model to set current.

","Examples
To set model named model-2 as current:
*setcurrentmodel model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
753,*setcuttingplanecolor ,"Description
Sets the color of the base of the specified cutting plane.
","Inputs

axis
The axis that is normal to the plane. Valid values are:
0 - the plane with x-axis as its normal 
1 - the plane with y-axis as its normal 
2 - the plane with z-axis as its normal


mode
Sets the display mode for the specified cutting plane. Valid values are:
0 - solid color 
1 - contours


color
The color to use when mode=0. Valid values are 1-64.

","Example
To set the cutting plane with y-axis as its normal to use solid color 24:
*setcuttingplanecolor 1 0 24
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
754,*setcuttingplanethickness,"Description
Sets the specified cutting plane thickness value. For trim planes, this sets the thickness
        of the slice through the model. For ordinary cutting planes, this sets the distance between
        the first and second parallel planar cuts.
","Inputs

axis
The axis that is normal to the plane. Valid values are:
0 - the plane with x-axis as its normal 
1 - the plane with y-axis as its normal 
2 - the plane with z-axis as its normal


thickness
The new thickness of the planar slice, or the new separation between two parallel
            planar cuts.

","Example
 To set the separation to 25.0 between two parallel cutting planes with y-axis as their
        normal:
*setcuttingplanethickness 1 25.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
755,*setdisplayattributes,"Description
Sets all components in the model to the specified style and coloring method.
","Inputs

style
Set to:
0 wire frame 
1 hidden line 2 hidden line with mesh 3 hidden line with features 4 hidden line
                transparent


colortype
Determines how the components are colored. The options are:
0 none 
1 component color 
2 assigned plots 
3 contours



","Errors
None.
",
756,*setedgedensitylinkbytypeandaspectratio,"Description
This command sets the method for linking opposite edge densities during automeshing. This
        forces opposite edges of a surface to use consistent edge densities, provided that the
        starting densities are close enough. This creates tapered lines of elements, instead of
        using trias to transition between inconsistent densities. This is only valid for size and
        bias or edge deviation surface meshing.
","
Inputs



type

0 - No edge linking, aspect ratio is ignored.
1 - Aspect ratio is valid. Equivalent to *setedgedensitylinkwithaspectratio
2 - Forced edge linking, aspect ratio is ignored.

aspect_ratio

Specifies the aspect ratio to use for edge density linking. Valid values are:
<0 - Do not link opposite edge densities.
0 - Attempt to link opposite edge densities with default value.
> 0 - Attempt to link opposite edge densities with specified value.

","Examples
To mesh surfaces specifying an edge density link using a value of 3:
*setedgedensitylinkbytypeandaspectratio 1 3.0
To disable linking:
*setedgedensitylinkbytypeandaspectratio 0
To force edge linking, if possible:
*setedgedensitylinkbytypeandaspectratio 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
757,*setelementcheckmethod,"Description
This command sets the method (solver) used for calculating specific element quality check
        parameters which are generally those used by an FE solver. For the available element quality
        check parameters, their meaning and allowable values for each quality check parameter, see
          *elementchecksettings. 
Setting the ""solver"" parameter to a valid FE solver ID results in setting of the ""global""
        solver mode. This means that most of the element quality checks (aspect_2d, aspect_3d,
        skew_2d, skew_3d, angle, warpage, taper, chord, tetcollapse, timestep ) are set to use the
        specified FE solver methods.
","Inputs

check_name
Specifies the interrogated element quality check parameter. Valid values are:
angle 
aspect_2d 
aspect_3d 
chord_dev 
jacobian_2d 
jacobian_3d 
min_len_2d 
min_len_3d 
skew_2d 
skew_3d 
solver 
taper 
tetra_collapse 
time_step 
warpage


method
Specifies the ID of the method to be used for the specified element quality check
            parameter. See *elementchecksettings for allowable method IDs for
            specific element quality checks.

","Example
Example of usage of the command applied to 3D Jacobian. The method is temporarily being set
        to use corner elements points for the Jacobian. After execution, the previous Jacobian
        method is restored.
set integration_points 0
set corner_points_method 1
set old_jacobian_method [hm_getelementcheckmethod ""jacobian_3d""]
*setelementcheckmethod ""jacobian_3d"" $corner_points_method
...
*setelementcheckmethod  ""jacobian_3d"" $old_jacobian_method
","Errors
None.
"
758,*setelemparamscolors ,"Description
This command is related to the element quality view mode. It sets the color for all element
        quality parameters for elements violating the threshold.
","Inputs

double_array
The ID of the double array containing the color values for each quality parameter.
            Must always be set to 1. 
There are currently 12 quality parameters. The colors for each parameter must be
            specified, using a value of 1-64 for each. The order of the parameters is:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation 
11 - quality index


number_of_doubles
Must currently be set to 12.

","Example
To set colors for all element quality parameters:
*createdoublearray 12 59 39 41 56 28 61 19 22 46 57 29 3
*setelemparamscolors 1 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
759,*setelemparamvisualpriority,"Description
This command is related to the element quality view mode. It sets the priority for a
        specified element quality parameter when reviewing multiple criteria.
","Inputs

param_id
Specifies the element quality check parameter ID to update. Valid values are:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation


priority
A value from 0 to 10 specifying the order of the element quality parameter in the
            parameters list, defining the color of elements with multiple parameters violating the
            parameter thresholds for the element. The priority should be unique, as none of the
            parameters should have the same priority number. 

","Example
To set ""warpage"" to priority 6:  
*setelemparamvisualpriority 3 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
760,*setentitytypesupportedbyenggid,"Description
Sets the entity types which will be supported by an engineering ID.
","Inputs

string_array
The string array ID that contains the list of entity types. A value of ALL means all
            entity types.  The string array is created using the
              *createstringarray command. This should always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To set all entity types to be supported by engineering ID:
*createstringarray 1 ""ALL""
*setentitytypesupportedbyenggid 1 1
To set elements and components to be supported by engineering ID:
*createstringarray 2 ""ELEMS"" ""COMPS""
*setentitytypesupportedbyenggid 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
761,*setglobalply ,"Description
Sets the ply name to review. The element ply direction of that ply will be plotted for each
        selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_name
The name of the ply to review.
only_orient


0 - The new x-element directions are shown as continuous gradient lines starting
                and ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the
                element centroid.


normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1 through 64.

","Example
To review the ply directions for the second ply named ""ply45"" for the displayed elements
        with blue vectors of size 3:
*createmark elems 1 displayed
*setglobalply elems 1 ""ply45"" 1 3 7
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
762,*setgraphictranslation,"Description
Graphically translates the specified entity. 
Currently only supported for FE inside of components.
","Inputs

entity_type
The type of entity to graphically translate. Only supported for components.
entity_id
The ID of the entity to graphically translate.
x
The x value of the graphic translation. A value of 0 indicates no translation.
y
The y value of the graphic translation. A value of 0 indicates no translation.
z
The z value of the graphic translation. A value of 0 indicates no translation. 

","Examples
To set the graphic translation of component 100 to 3, 0, 0:
*setgraphictranslation comps 100 3 0 0
To unset the graphic translation of component 100:
*setgraphictranslation comps 100 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
763,*sethistorymemorylimit ,"Description
Sets the maximum amount of memory that history states are allowed to use.
","Inputs

memory
The maximum amount of memory (in MB) that history states are allowed to use. 
0 - Disables all history recording, including potential legacy use cases. 
-1 - Indicates unlimited.



","Example
To set the maximum memory 1000 MB:
*sethistorymemorylimit 1000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
764,*setisosurfaceparameters,"Description
 Sets the display parameters of the isosurface.
","Inputs

on
A boolean value to turn the isosurface on or off.
legendbased
A boolean value to determine if the isosurface is legend based or value based.
value
The value of the value-based isosurface.
addfacesabove
A boolean value to add the ""faces above"" to the isosurface.
transparent
A boolean value to turn on transparency on the ""faces below"" the iso value.
constantcolor
A boolean value to display the isosurface in a user-specified.
color
The color of the isosurface.

","Errors
None.
",
765,*setlightsource ,"Description
Set direction of the global light source.
","Inputs

x
X axis location, horizontal direction of screen.
y
Y axis location, vertical direction of screen.
z
Z axis location, in/out of screen.

","Example
This command may be used in either the hm.cfg file or from a command
        file. 
The default setting is 0.0, 0.0, 1.0 (represents model lighting as you view it).
","Errors
None.
"
766,*setmarkdisplayattributes ,"Description
 Set the display attributes (wireframe/hidden line, color, etc.) for the entities contained
        in a mark.
","Inputs

entitytype
The type of entity contained in the mark; limited to ""components"" and
            ""multibodies"".
mark
ID of the mark whose display attributes you wish to change.
style
The desired rendering style of the entities:
0 wire frame 
1 hidden line 
2 hidden line with mesh 
3 hidden line with features 
4 hidden line, transparent


colortype
Determines how the components are colored.
0 none 
1 component color 
2 assigned plots 
3 contours



","Example
To change the attributes of a component named ""Front Panel"" to hidden line using component
        color
*createmark(components,1) ""Front Panel""
*setmarkdisplayattributes(components,1,1,1)

","Errors
None.
"
767,*setmenustate,"Description
Controls the display of the HyperMesh menus.
","Inputs

state
Boolean value to represent the display state of the menus. 
1 displayed (default) 
0 off

","Example
To display the HyperMesh menus:
*setmenustate(1)
The keyboard shortcut ‘m’ may be used to toggle the menus state.
","Errors
None.
"
768,*setnormalsdisplaytype,"Description
Sets the display type for element normals. 
This is utilized by the commands that turn on element normals display.
","Inputs

type 
0 - Vector display 
1 - Color display

","Example
To set the element normals to color display, and turn on the normals display of elements
        1-10:
*setnormalsdisplaytype 1
*createmark elems 1 1-10
*normalsdisplay elems 1 0
","Errors
None.
"
769,*setoption,"Description
Sets various option values.
","Inputs

<option>=<value>
The name of the option and the corresponding value to assign. Valid options and values
            are as follows:
1d_at_centroid=<value>
Controls whether the 3D representation of 1D elements is relative to the
                  centroid or the shear center. Valid values are:
0 - The 3D representation of 1D elements is relative to the shear center.
1 - The 3D representation of 1D elements is relative to the centroid.
alt_lmb_rmb_binding=<value>
Select action for Alt key and left + right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
alt_mmb_binding=<value>
Select action for Alt key and middle mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
alt_rmb_binding=<value>
Select action for Alt key and right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
anti_alisasing=<value>
Sets the anti-aliasing mode:
0 - Disable anti-aliasing.
1 - Enable anti-aliasing.
auto_cleanuptol=<value>
Sets the geometry cleanup calculation mode. Valid values are:
0 - Manually set the tolerance.
1 - Auto calculate the tolerance.
auto_elementsize=<value>
Sets the element size calculation mode. Valid values are:
0 - Manually set the size.
1 - Auto calculate the size.
auto_nodetol=<value>
Sets the node tolerance calculation mode. Valid values are:
0 - Manually set the tolerance.
1 - Auto calculate the tolerance.
auto_mesh_color_mode=<value>
Sets the auto mesh color mode for mesh lines. Valid values are:
0 - Disable auto mesh line coloring and instead use the color specified by
                    mesh_line_color.
1 - Enable auto mesh line coloring.
axis_drawn_view_cube=<value>
Control axis arrows when show_view_cube=1 or
                    show_view_cube=2. Valid values are:
0 - Arrows are hidden (default)
1 - Arrows are visible
beam_lod_threshold=<value>
The zoom level required to make beams visible, as an integer value from 0-10
                  (default 6.5). 0 means mesh lines are always visible. Smaller values indicate
                  minimal zoom is needed. Higher values mean more zoom is needed.
beam_lod_threshold=<value>
0 - Off/disabled
1 - The number of elements in the frustum (default 4080).
background_colors-<item>={<r> <g> <b>}
The colors for the gradient background. The actual RGB values are not used. The
                  closest of the standard 64 colors are selected based on the RGB values.
The item modifier is required and specifies a specific
                  item:
1 - Background color 1
2 - Background color 2
bitmap_animation=<value>
The bitmap animation graphics mode. Valid values are:
0 - None (default)
1 - Simple
2 - Compressed
block_error_messages=<value>
Controls the display of error messages.
0 - Displays error messages
1 - Blocks error messages. Error messages can still be displayed from Tcl scripts by using hm_errormessage.
block_messages=<value>
Controls the display of info messages.
0 - Displays info messages
1 - Blocks info messages. Info messages can still be displayed from Tcl scripts by using hm_usermessage.
block_redraw=<value>
Controls the graphics redraw. When the redraw operation is blocked, HyperWorks Desktop will not redraw unless the size of its window changes or it
                  is de-iconified or maximized. When the redraw operation is unblocked, HyperWorks Desktop returns to normal.
0 - Allows redraw
1 - Blocks redraw
buffer_command_file=<value>
Controls the command file buffering state.
0 - Disable buffering the command file
1 - Enable buffering the command file
cadupdate_parameter_immediate=<value>
0 - When changing parameters associated to external CAD files, do not update the
                  parameters back in the CAD system automatically
0 - When changing parameters associated to external CAD files, update the
                  parameters back in the CAD system automatically
cleanup_tolerance=<value>
The geometry cleanup tolerance used for geometry creation and editing
                  operations.
clip_boundary_elements=<value>
The boundary element display mode for hidden line, section cut and spherical
                  clipping.
0 - Boundary elements are not clipped and entire elements are shown
1 - Boundary elements are clipped and a smooth boundary is shown
ctrl_lmb_rmb_binding=<value>
Select action for Ctrl key and left + right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
ctrl_mmb_binding=<value>
Select action for Ctrl key and middle mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
ctrl_rmb_binding=<value>
Select action for Ctrl key and right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
coincident_picking=<value>
The state of coicident graphical picking.
0 - Disable coincident picking
1 - Enable coincident picking
command_file_state=<value>
The state of writing to the command file.
0 - Disable writing to the command file
1 - Enable writing to the command file
contact_surface_peak_factor=<value>
The factor for scaling the contact surface graphical height.
contact_surface_percent=<value>
The percent of the element size to use for scaling the contact surface graphical
                  length and width.
contour_type=<value>
The result color mode.
0 - Blended contour
1 - Discrete contour
delete_discrete_topology_mode=<value>
Select a remeshing method for revising modified discrete topology.
Valid values are ""Keep mesh"", Remesh and ""Advanced remesh"".
delete_elements_mode=<value>
The remesh setting for topology revision.
0 - Keep mesh
1 - Delete mesh
2 - Remesh
3 - Advanced remesh
4 - 2D + 3D (tetra) remesh
detailed_elements=<value>
The 3D visualization mode for 1D/2D elements.
0 - Traditional 1D/2D element display.
1 - Detailed 1D/2D element display. 1D elements are viewed as 3D representations
                  with proper cross-section, orientation and offset. 2D elements are views as 3D
                  representations with proper thickness and offset.
2 - Combined traditional and detailed 1D/2D element display.
detailed_elements_beamvis=<value>
The 3D visualization mode for 1D elements.
0 - Traditional 1D element display
1 - Detailed 1D element display. 1D elements are viewed as 3D representations
                  with proper cross-section, orientation and offset.
2 - Combined traditional and detailed 1D element display
detailed_elements_shellvis=<value>
The 3D visualization mode for 2D elements.
0 - Traditional 2D element display.
1 - Detailed 2D element display. 2D elements are views as 3D representations
                  with proper thickness and offset.
2 - Combined traditional and detailed 2D element display.
display_color-<item>=<value>
The color for various objects. Valid values are 1-64. A value of 0 indicates to
                  set the color of that object to the background color value.
The item modifier is required and specifies a specific item:
1 - Free edges
2 - Shared edges
3 - Suppressed edges
4 - Non-manifold edges
5 - Global coordinate axis labels
6 - Fin faces on solids
7 - Bounding faces on solids
8 - Full partition faces on solids
9 - 2D topology faces 
10 - Component edges
12 - Ignored topology faces
13 - Elements no props/mats
14 - Ignored solid mappable
15 - Not solid mappable
16 - 1 directional solid mappable
17 - 3 directional solid mappable
18 - Global X axis
19 - Global Y axis
20 - Global Z axis


display_import_errors=<value>
Defines whether the import process errors/warnings are displayed in a Tcl window in HyperWorks Desktop.
0 - Import process errors/warnings will not be displayed
1 - Import process errors/warnings will be displayed.
domain_handle=<value>
The display of domain handles.
0 - Off
1 - On
duplicate_ids=<value>
Defines whether duplicate entity IDs are allowed for supported solvers.
0 - Duplicate IDs are not allowed
1 - Duplicate IDs are allowed
dynamic_center_of_rotation=<value>
Dynamic center during model rotation. values are 1 or 0.
edge_density_visible=<value>
0 - Disable the visualization of edge density values in the automesh panel
0 - Enable the visualization of edge density values in the automesh panel
edge_lod_threshold=<value>
The zoom level required to make geometry lines visible, as an integer value from
                  0-10. 0 means geometry lines are always visible. Smaller values indicate minimal
                  zoom is needed. Higher values mean more zoom is needed.
edge_lod_width_auto=<value>
Defines whether to enable edge LOD auto mode.
0 - Auto mode disabled
1 - Auto mode enabled
element_color_mode=<value>
The element color mode value:
1 - By component
2 - By property
3 - By material
4 - By thickness
5 - 1D/2D/3D
6 - By config
7 - By assembly
8 - By body
9 - By 2D element quality criteria
10 - By thickness difference
11 - Reserved for future use
12 - Reserved for future use
13 - By domain
14 - Reserved for future use
15 - Reserved for future use
16 - By part
17 - By topology
18 - By 3D topology
19 - By mappable
20 - By 3D element quality criteria
21 - By 2D element quality QI
22 - Reserved for future use
23 - By subsystem
element_connectivity=<value>
Select how newly created elements and any adjacent existing elements are
                  connected.
Valid values are Previous, Break, Keep, and Redo.
element_handle=<value>
The display of element handles.
0 - Off
1 - On
element_internal_edges_mode=<value>
The element internal edges visualization mode. This only applies to the two
                  wireframe modes supported by
                    *setdisplayattributes/*setmarkdisplayattributes.
0 - Do not visualize internal element edges
1 - Visualize internal element edges
element_order=<value>
The order of newly created elements.
1 - First
2 - Second
element_organization=<value>
Select in which component the newly created elements are placed.
Valid values are ""Current component"" and ""Surface component"".
element_size=<value>
The default element size to use when calculating element densities in the
                  auto-meshing module.
element_window_selection_mode=<value>
all - All nodes of an element must be inside the window to be selected
any - Any node of an element must be inside the window to be selected
centroid - The centroid of an element must be inside the window to be
                  selected
entity_highlighting=<value>
The mode for pre-highlighting selected entities.
0 - Do not pre-highlight. This may improve script performance.
1 - Pre-highlight
equation_handle=<value>
The display of equation handles.
0 - Off
1 - On
exponential_display=<value>
The display of floating-point numbers in the menu as standard or
                  exponential.
0 - Standard
1 - Exponential
exponential_display=<value>
The display of floating-point numbers in the menu as standard or
                  exponential.
0 - Standard
1 - Exponential
feature_angle=<value>
The feature angle used for mesh creation and editing operations.
fe_display=<value>
0 - Turns off FE display without changing the state of components.
1 - Turns on FE display without changing the state of components.
feoutput_time_info=<value>
Generates a text file containing export time info for FE entities. The file is
                  written to the same directory as the exported file, with the name
                    <export_file_name>_timing.txt.
0 - Do not write file
1 - Write file
fixed_point_handle=<value>
The display of fixed point handles.
0 - Off
1 - On
force_text_black=<value>
The display of graphical text between black and white. By default, text in
                    HyperWorks Desktop is displayed in white. However white text is not
                  always legible, especially when users change the background color to a lighter
                  color.
0 - White
Non-zero - Black
geom_display=<value>
0 - Turns off geometry display without changing the state of components.
1 - Turns on geometry display without changing the state of components.
geom_feature_angle=<value>
The geometry feature angle used for geometry creation and editing
                  operations.
geom_point_size=<value>
Sets the size of the geometry points, between 1 and 10 (default 4).
geom_refine_level=<value>
The refinement level for geometry graphical faceting. Valid values are 1-5 and
                  11 (which indicates auto refinement). Each level increases the refinement, but
                  also uses more memory and takes more time to compute.
geom_stitching=<value>
The automatic stitching mode when creating surfaces. This applies to all surface
                  creation commands.
0 - Created surfaces are stitched to surfaces from the same component
1 - Created surfaces are stitched to any surfaces that are within geometry
                  cleanup tolerance
2 - Created surfaces are stitched to surfaces attached to selected
                  surfaces/edges
3 - Created surfaces are stitched only to selected surfaces or surfaces that
                  have edges/vertices selected
geometry_parasolid_boolean=<value>
0 - Boolean operations will use the legacy AFC (default)
1 - Boolean operations will use Parasolid (not tested or recommended for use
                  with panels)
graph_plot=<value>
Enable/disable drawing of plots:
0 - Do not draw plots
1 - Draw plots
graphics_file_blank_background=<value>
The graphics file image background color mode.
0 - Use the graphics window background color for the image
Non-zero - Use a blank (white) background color for the image
graphics_optimize_view_control=<value>
0 - Do not remove graphical annotations and entities when you rotate, zoom (via
                  the mouse wheel), or pan the model.
1 - Remove graphical annotations and entities when you rotate, zoom (via the
                  mouse wheel), or pan the model. Graphical annotations and entities are restored
                  once you release the mouse button.
graphics_simplification_component=<value>
The graphics simplification component.
0 - Do not simplify the current component
1 - Simplify the current component
graphics_simplification_mode={<mode> <style>}
The graphics simplification mode. This produces smoother animation when rotating
                  or panning a model by refraining from calculating and rendering some model
                  elements until the model manipulation stops.
mode values:
0 - None
1 - Automatic
2 - Ctrl-Shift


style values:
0 - No simplification
1 - Feature lines (default)
2 - Bounding box
3 - Node cloud
4 - Element centroid
5 - Simplified shading


hide_panels_automatically=<value>
0 - Do not hide panels automatically.
1 - Hide panels automatically.
highlight-<option>=<value>
Sets various highlight options. The option modifier is
                  required and specifies a specific highlight type.
edge_thickness - The thickness of feature edge higlight (default
                      2.0).
face_alpha - A value between 0 and 1 (default 0.5)
face_color - The RGB highlight face color (default #FEB317) .
onoff - The transparent highlight, 0 (off, default) or 1 (on).


history_memory_limit=<value>
The amount of memory to allow for undo-redo.
hv_launch_flag=<value>
Controls the launching of HyperView after an H3D
                  creation.
0 - Disable HyperView launch
1 - Enable HyperView launch
legend_allow_background_transparency=<value>
0 - Do not allow
1 - Allow
legend_beyond_threshold=<value>
The visualization for elements beyond the legend threshold.
0 - Off
1 - Transparent
2 - Feature lines
legend_colormap_divergent=<value>
0 - Disable legend divergent colormap style (use rainbow style)
1 - Enable legend divergent colormap style
legend_ranged_discrete_button=<value>
Controls the legend double button.
0 - Off
1 - On
lighting_mode=<value>
The lighting mode.
0 - 1 light (legacy)
2 - 2 light
line_handle=<value>
The display of line handles.
0 - Off
1 - On
lmb_rmb_binding=<value>
Select action for left + right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
load_base_size=<value>
Change the base size of loads.
load_handle=<value>
The display of load handles.
0 - Off
1 - On
load_label-<config>=<value>
The display of load labels.
0 - Off
1 - On
The config modifier is required and specifies a specific load
                  config. Currently all config values besides 3 are linked together.
1 - Forces
2 - Moments
3 - Constraints
4 - Pressures
5 - Temperatures
6 - Fluxes
8 - Velocities
9 - Accelerations


load_label_color=<value>
The load label color. Valid values are 1-64. A value of 0 indicates to set the
                  color to the background color value.
load_max_size=<value>
Change the maximum size of loads.
load_min_size=<value>
Change the minimum size of loads.
load_new_scaling=<value>
Set new scaling options
Valid values are New and Legacy.
load_scale_type=<value>
Set scale type fixed or limits on load entities.
Valid values are Limits and Fixed.
load_size_magnitude-<config>=<value>
The load display percentage when load_size_type is 1.
The config modifier is required and specifies a specific load
                  config. Currently all config values are linked together.
1 - Forces
2 - Moments
4 - Pressures
5 - Temperatures
6 - Fluxes
8 - Velocities
9 - Accelerations


load_size_type-<config>=<value>
0 - Uniform display
1 - Magnitude display
The config modifier is required and specifies a specific load
                  config. Currently all config values are linked together.
1 - Forces
2 - Moments
4 - Pressures
5 - Temperatures
6 - Fluxes
8 - Velocities
9 - Accelerations


load_size_uniform-<config>=<value>
The load display size in model units when load_size_type is
                  0.
The config modifier is required and specifies a specific load
                  config. Currently all config values besides 3 are linked together.
1 - Forces
2 - Moments
3 - Constraints
4 - Pressures
5 - Temperatures
6 - Fluxes
8 - Velocities
9 - Accelerations


load_solver_label=<value>
The label type for elements and loads.
0 - HyperWorks Desktop labels
1 - Template labels
load_visual_vector=<value>
The location of the vector in relation to the attachment location.
0 - Tip
1 - Tail
locate_view_cube=<value>
The position of the view cube when show_view_cube=1 or
                    show_view_cube=2. Valid values are:
0 - Cube is displayed to the lower left (default)
1 - Cube is displayed to the lower right
2 - Cube is displayed to the upper left
3 - Cube is displayed to the upper right
lod_threshold=<value>
The zoom level required to make element handles visible, as an integer value
                  from 0-10. 0 means element handles are always visible. Smaller values indicate
                  minimal zoom is needed. Higher values mean more zoom is needed.
mesh_line_color=<value>
The mesh line color. Valid values are 1-64.
mesh_lod_threshold=<value>
The zoom level required to make element mesh lines visible, as an integer value
                  from 0-10 (default 6.5). 0 means mesh lines are always visible. Smaller values
                  indicate minimal zoom is needed. Higher values mean more zoom is needed.
mesh_transparency=<value>
The mesh transparency as a double value from 0-10. 0 means no transparency.
                  Smaller values indicate minimal transparency. Higher values mean more
                  transparency.
method_xml_file=<value>
The user defined StressToolMethodDefinition.xml file path to access the user
                  defined design methods.
mixed_property_warning=<value>
The state of the mixed direct/indirect property assignment warning dialog.
0 - Do not show the warning when mixing direct/indirect property
                  assignments.
1 - Show the warning when mixing direct/indirect property assignments.
mmb_binding=<value>
Select action for middle mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
morph_color-<option>=<value>
Sets various morph color options. The option modifier is
                  required and specifies a specific morph color object.
domain - The domain RGB color.
face - The face RGB color.
symmetry - The symmetry RGB color.
volume - The morph volume RGB color.


mouse_append_mode=<value>
Always add to the current selection in idle mode without holding Ctrl.
Valid values are 1 and 0.
mouse_mapping=<value>
Set current mouse controls.
Valid values are HyperWorks and Legacy.
mouse_over_highlighting=<value>
Highlight entities on mouse hover.
Valid values are 1 and 0.
nearby_output_entities=<types>
Sets the nearby output entity types. Valid values are components, elements,
                  equations, loads, systems and vectors.
nearby_radius=<value>
Sets the nearby search radius/tolerance.
nearby_search_method=<value>
Sets the nearby search method. Valid values are sphere and box.
nearby_selected_operation=<value>
Sets the nearby selection operation. Valid values are 0 (show) and 1
                  (isolate).
nodelod=<value>
0 - Disable node level-of-detailing
1 - Enable node level-of-detailing
node_size=<value>
Sets the size of the nodes, between 1 and 10 (default 6).
node_tolerance=<value>
The global node tolerance. Must be greater than
                    cleanup_tolerance/100.
num_history_steps=<value>
The maximum number of undo-redo steps to store in memory.
numeric_legend_force_ranged=<value>
0 - Discrete legend
1 - Ranged legend
numeric_legend_threshold=<value>
The threshold value for automatic switching from discrete to ranged.
numeric_precision=<value>
An integer to define the number of decimal places in numerical values.
numeric_style=<value>
The style of numerical values.
0 - Auto
1 - Fixed
2 - Scientific
number_remesh_layers=<value>
Number of layers for advanced remesh.
performance_normal=<value>
The light setting, based on the direction of element normals.
0 - Flat, each face has a normal
1 - Smooth, vertices have normals
perspective_fov=<value>
The perspective field of view.
perspective_view=<value>
The state of the perspective view.
0 - Off
1 - On
pick_tolerance=<value>
The picking tolerance in pixels which the cursor must be within before an entity
                  is selected.
ply_link_color_and_orientation=<value>
Auto update of colors based on ply orientation.
Valid values are 1 and 0.
ply_thickness_factor=<value>
The ply thickness scale factor for composite layer visualization. This applies
                  for show_composite_layers values 1 and 2.
pr_auto_preserve_connections=<value>
1 - Preserve the internal connections.
0 - Do not preserve the internal connections (default).
pr_box_approach_node_set=<value>
0 - Proximity approach will be used to find the replacement nodes to update the
                  SETS of type NODES. (default).
1 - Bounding box approach will be used to find the replacement nodes to update
                  the SETS of type NODES. All the nodes of an element will be used to update the
                  SETS of type NODES or none of it.
pr_check_log=<value>
0 - Do not allow the user to provide a file path to log replacement details.
                  (default 0)
1 - Allow the user to provide a file path to log replacement details.
pr_custom_bbox_for_equivalence=<value>
Custom tolerance for bounding box can be provided for connecting the 1D elements
                  from incoming file to source components
0 - Use default tolerance.
1 - Use custom tolerance (default).
pr_delete_src_comp=<value>
0 - Delete existing component.
1 - Do not delete existing component. Both existing and incoming component(s)
                  will remain in session after replacement (default).
pr_invoke_model_checker=<value>
0 - Do not invoke a Model Checker browser (default).
1 - Invokes a Model Checker browser after replacement.
This option is not available for single component replacement.
pr_keep_src_comp_cardimage=<value>
0 - Do not copy existing component card image to incoming component.
1 - Copy existing component card image to incoming component (default).
pr_keep_src_comp_id=<value>
0 - Do not assign existing component ID to incoming component.
1 - Assign existing component ID to incoming component (default).
pr_keep_src_comp_name=<value>
0 - Do not assign existing component Name to incoming component.
1 - Assign existing component Name to incoming component (default).
pr_keep_src_ent_type=<value>
0 - Do not assign existing component element type to incoming component element
                  type (default).
1 - Assign existing component element type to incoming component element
                  type.
pr_keep_src_include=<value>
0 - Organize incoming entities to new include.
1 - Organize incoming entities to existing component include (default).
pr_keep_src_mat=<value>
0 - Do not assign existing component material to incoming component.
1 - Assign existing component material to incoming component (default).
pr_keep_src_prop=<value>
0 - Do not assign the existing component material/property to incoming
                  component.
1 - Assign existing the component material/property to incoming component
                  (default).
pr_merge_nodes=<value>
0 - Do not merge the nodes present on the boundaries of incoming component
                  (default).
1 - Merge the nodes present on the boundaries of incoming component.
pr_prefix_basename_suffix_based_name_pairing=<value>
Controls whether component pairing should be done using prefix-basename-suffix
                  matching approach. Valid values are:
0 – Do not use prefix-basename-suffix approach to find the component
                  pairing
1 - Use prefix-basename-suffix approach first to find the component pairing
pr_retain_plotel_elem_nodeIds_from_src_comp=<value>
The node IDs of the source component can be retained if its nodes have
                  comments.
It is available only for OptiStruct and Nastran.
0 - Do not retain the node ids of source component. (default 0)
1 - Retain the node ids of source component.
pr_show_component_pairing=<value>
0 - Do not show component pairing (default ).
1 - Show component pairing.
quick_topo_selection=<value>
Controls holding the ALT key to enable quick advanced selection for faces and
                  edges (elements) and by path (lines and nodes).
0 - Disable
1 - Enable
realize_loads=<value>
Realize loads to their engineering form at the time of model load.
It is available only for OptiStruct and Nastran.
0 - Unrealize (default, classical loads are created)
1 - Realize (engineering loads are created after model load)
retain_element_values=<value>
Keep/delete certain element values upon mesh edit or remesh.
0 - Delete (legacy behavior)
1 - Keep
retain_loads=<value>
Keep/delete loads when associated nodes/elements are deleted.
0 - Delete
1 - Keep
reverse_zoom_direction=<value>
Reverse scroll wheel direction.
Valid values are 1 and 0.
rmb_binding=<value>
Select action for right mouse button drag.
Valid values are Pan Rotate Zoom CircleZoom.
rotation_angle=<value>
The rotation angle used by various view commands.
rotation_center_mode=<value>
The rotation mode.
0 - Rotate about center of model
1 - Rotate about center of screen (legacy behavior)
rotation_center_off_screen=<value>
Defines if the rotation center is allowed to be off screen.
0 - The rotation center is reset to the screen center if a zoom, translation or
                  fit operation causes it to be off the screen (legacy behavior)
1 - The rotation center is not reset to the screen center if a zoom, translation
                  or fit operation causes it to be off the screen
scale_color=<value>
The color of the modeling window model scale. Valid
                  values are 1-64.
scale_height=<value>
The height of the modeling window model scale. Valid
                  values are S (for small), M (for medium) and L (for large).
scale_position=<value>
The position of the modeling window model scale. Valid
                  values are bottomleft, bottom, bottomright, centerleft, center, centerright,
                  topleft, top, topright.
scale_width=<value>
The width of the modeling window model scale. Valid
                  values are S (for small), M (for medium) and L (for large).
shift_lmb_rmb_binding=<value>
Select action for Shift key and left + right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
shift_mmb_binding=<value>
Select action for Shift key and middle mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
shift_rmb_binding=<value>
Select action for Shift key and right mouse button drag.
Valid values are Pan, Rotate, Zoom and CircleZoom.
show_composite_layers=<value>
The composite layers visualization mode.
0 - Composite layers are not visualized.
1 - Composite layers are visualized when defined.
2 - Composite layers are visualized when defined, with overlaid ply orientation
                  vectors.
3 - Composite layers are visualized when defined, showing only edges.
show_global_axes=<value>
The global axes visualization mode.
0 - Off
1 - On
show_line_dir=<value>
Displays symbols indicating geometry lines parametric direction.
0 - Turn off display of line direction symbols
1 - Turn on display of line direction symbols
show_model_title=<value>
Show the file path of the current model in the graphics area.
Valid values are 1 and 0.
show_newly_created_entities=<value>
If new entities are created/updated in a collector that is hidden:
0 - Do not turn the collector on
1 - Turn the collector on
show_plots=<value>
Show plots when loading the model.
Valid values are 1 and 0.
show_scale=<value>
The scale visualization mode.
0 - Off
1 - On
show_view_cube=<value>
The visibility of the view cube.  Valid values are:
0 - Never (default)
1 - On mouse over
2 - Always
shrink_factor=<value>
The element shrink factor, between 0 and 1.
shrink_mode=<value>
The state of the element shrink mode.
0 - Off
1 - On
snap_circle_center=<value>
0 - Off
1 - On
snap_global_xyz=<value>
0 - Off
1 - On
snap_line_end=<value>
0 - Off
1 - On
snap_line_line_intersect=<value>
0 - Off
1 - On
snap_line_middle=<value>
0 - Off
1 - On
snap_mesh_node=<value>
0 - Off
1 - On
snap_on=<value>
0 - Off
1 - On
snap_on_empty_space=<value>
0 - Off
1 - On
snap_on_tangent_extension=<value>
0 - Off
1 - On
snap_perp_from_line=<value>
0 - Off
1 - On
snap_perp_from_surf=<value>
0 - Off
1 - On
snap_perp_to_line=<value>
0 - Off
1 - On
snap_perp_to_surf=<value>
0 - Off
1 - On
snap_surf_center=<value>
0 - Off
1 - On
snap_surf_line_intersect=<value>
0 - Off
1 - On
snap_system_center=<value>
0 - Off
1 - On
snap_tangent_from_line=<value>
0 - Off
1 - On
snap_tangent_to_line=<value>
0 - Off
1 - On
solid_transparency=<value>
The solid geometry transparency value 0-10.
solid_edge_width=<value>
The solid geometry edge width 1.0-10.0. 2.5 is the legacy value.
solvermass_handle=<value>
The display of solvermass handles.
0 - Off
1 - On
specular_intensity=<value>
The specular intensity value.
stereo_display=<value>
The normal (2D) or stereo (3D) display mode.
0 - Normal display mode
1 - Stereo display mode
surface_edge_width=<value>
The solid geometry edge width 1.0-10.0. 1.0 is the legacy value.
surface_uv_lines=<value>
The number of uv lines to draw on surfaces for *settopologydisplaytype
                    3. Must be between 0 and 20.
system_size_uniform=<value>
The size in model units in which systems will be drawn.
tag_display=<value>
The graphical display mode for tag entities.
0 - Show text only at tag locations
1 - Show text and graphics at tag locations
2 - Show graphics only at tag locations
tag_text_display_mode=<value>
The text display mode for tag entities. Valid values are:
0 - Show the label of the tag
1 - Show the body of the tag
2 - Show the name (label:body) of the tag
3 - Show the description of the tag. If no tag exists, the label will be
                  shown.
thick_1d_lines=<value>
The state of 1D element line graphical thickness.
0 - Normal display mode
1 - Thick display mode
thick_mesh_lines=<value>
The state of mesh line graphical thickness.
0 - Normal display mode
1 - Thick display mode
thickness_legend_colors={<color1> <color2> ...
                    <colorN>}
The colors for the thickness legend. A color can be specified for each row.
                  Valid values are 1-64.
thickness_legend_rows=<value>
The number of rows for the thickness legend.
thickness_legend_values={<value1> <value2> ...
                    <valueN>}
The values for the thickness legend. A value can be specified for each row.
                  Values should be specified in order.
topoedgecolor=<value>
The FE topology and geometry topology edge colors:
1 - Automatic
2 - Topology
3 - 3D topology
topofacecolor=<value>
The FE topology and geometry topology face colors:
1 - Automatic
2 - Assembly
3 - Parts
4 - Components
5 - Mixed
6 - Topology
7 - 3D Topology
8 - Mappable
9 - 2D element quality criteria
10 - Property
11 - Material
12 - Thickness
13 - Domain
14 - Configuration
15 - Dimension
16 - Body
22 - Element normal
24 - Include


The element color mode value:
9 - By 2D element quality criteria
10 - By thickness difference
20 - By 3D element quality criteria
23 - By subsystem




topofacemode=<value>
The FE topology and geometry topology face mode:
1 - Wireframe
2 - Shaded
3 - Shaded with edges
4 - Transparent with edges
topology_display_mode=<value>
The geometry color mode.
0 - Automatic. The color switches between topology colors and component colors,
                  based on specific panels.
1 - By component
2 - By topology
3 - By 2D topology. 3D geometry is colored using the ""ignored (topo)""
                  color.
4 - By 3D topology. 2D geometry is colored using the ""ignored (topo)""
                  color.
5 - Mixed. Geometry edges are colored using topology colors, while shaded
                  surfaces use component colors.
6 - Mappable. Solids are colored using the mappable colors (ignored map, not
                  mappable, 1 dir map and 3 dir map). 2D geometry is colored using the ""ignored
                  (topo)"" color.
7 - By assembly
8 - By part
topology_edge_display_color-<type>=<value>
The color of topology edges, from 0-64.
The type modifier is required and specifies a specific edge type:
0 - Free edges
1 - Shared edges
2 - Non-manifold edges
3 - Suppressed edges


topology_edge_display_mode-<type>=<value>
The display state of topology edges.
0 - Off
1 - On
The type modifier is required and specifies a specific edge type:
0 - Free edges
1 - Shared edges
2 - Non-manifold edges
3 - Suppressed edges


topology_solid_display_mode-<type>=<value>
The display state of solid topology faces.
0 - Off
1 - On
The type modifier is required and specifies a specific face type:
0 - Fin faces
1 - Full partition faces
2 - Bounding faces


topology_solid_edge_display_color-<type>=<value>
The color of solid topology edges, from 0-64.
The type modifier is required and specifies a specific edge type:
0 - Free edges
1 - Shared edges
2 - Non-manifold edges
3 - Suppressed edges


topology_solid_edge_display_mode-<type>=<value>
The display state of solid topology edges.
0 - Off
1 - On
The type modifier is required and specifies a specific edge type:
0 - Free edges
1 - Shared edges
2 - Non-manifold edges
3 - Suppressed edges


transparent_with_mesh_lines=<value>
The mesh line display when a component is transparent.
0 - If a component is transparent, do not show mesh lines
1 - If a component is transparent, show mesh lines
vector_auto_scale=<value>
The display of vector auto-scaling.
0 - Off
1 - On
vector_handle=<value>
The display of vector handles.
0 - Off
1 - On
vector_label=<value>
The display of vector labels.
0 - Off
1 - On
vector_size_magnitude=<value>
The vector display percentage when vector_size_type is
                  1.
vector_size_type=<value>
0 - Uniform display
1 - Magnitude display
vector_size_uniform=<value>
The vector display size in model units when vector_size_type
                  is 0.
zoom_factor=<value>
The zoom in/out factor.



","Examples
To set the rotation angle to 10 degrees:
*setoption rotation_angle=10
To set gradient background to the standard colors closest to (100, 200, 100) and (123, 0,
        0):*setoption background_colors-1={100 200 100}
*setoption background_colors-2={123 0 0}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
770,*setparametermark ,"Description
Parameterizes a data name or attribute on a mark of entities. 
","Inputs

name
The name of parameter entity to assign.
entity_type
The type of entity to parameterize.
mark_id
The ID of the mark containing the entities to parameterize. Valid values are 1 and 2.
data_name_or_attribute
The data name or attribute name/ID to parameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.
reserved
Must be set to 0.

","Example
To parameterize attribute LSD_DA1 on entity sets 5, 6 and 7 with the parameter named
        param1:
*createmark sets 1 5 6 7
*setparametermark param1 sets 1 LSD_DA1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
771,*setply_option ,"Description
Sets the ply/layer number to review. The element ply direction of that ply will be plotted
        for each selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_number
The number of the ply to review.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64.
option
Option for review customization. Valid values are: 
1 - Abaqus rebar layer will be reviewed

","Example
To review the ply directions for the ply with ID 2 for the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*setply_option elems 1 2 1 3 7 1
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
772,*setqualitythresholdcolor,"Description
This command is related to the element quality view mode. It sets the color for a specified
        element quality index range.
","Inputs

range_id
Specifies the element quality index range to update. Valid values are:
0 - Ideal (ideal ≤ QI < good) 
1 - Good (good ≤ QI < warn) 
2 - Warn (warn ≤ QI < fail) 
3 - Fail (fail ≤ QI < worst) 
4 - Worst (worst ≤ QI)


color
The color to use. Valid values are 1 through 64.

","Example
To assign the color for the warn range to brown:
*setqualitythresholdcolor 2 28

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
773,*setredoconnectparams,"Description
This command specifies parameters for redo connectivity element remeshing. 
Use of this command implies that it will be followed by a command that performs
        remeshing/meshing by elements with redo option selected.
","Inputs

mesh_side
Flag indicating where the transition from existing element density to selected density
            occurs:
 0 - Transition starts at border formed by selected elements and goes
              num_layers outside (default) 
1 - Transition starts at border formed by selected elements and goes
              num_layers inside
num_layers
The number of layers for transitioning from existing element density to selected
            density. Default value is 2.

","Examples
To remesh elements with IDs 1-40, redo connectivity option selected and transition from
        current element size to element size of 10 occurring in two layers of elements outside the
        border formed by selected elements:
*createmark elems 1 1-40
*setredoconnectparams 0 2
*defaultremeshelems 1 10.0 2 2 0 1 1 1 0 0 0 0 3 30
To remesh elements with IDs 1-40, redo connectivity option selected and transition from
        current element size to element size of 4 occurring in three layers of elements inside the
        border formed by selected elements:
*createmark elems 1 1-40
*setredoconnectparams 1 3
*defaultremeshelems 1 4.0 2 2 0 1 1 1 0 0 0 0 3 30 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
774,*setreviewbymark ,"Description
This command adds entities to the review list based on a mark.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are:
nodes 
elems 
points 
lines 
surfs 
solids 
connectors 
loads 
equations 
systs 
vectors


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
color
The color to use for review of the entity. Valid values are 1-64.

","Example
To review elements 1-100 with color 4, with all other non-reviewed entities having
        transparency and gray color:
*createmark elems 1 1-100
*setreviewbymark elems 1 4
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
775,*setreviewbyname,"Description
Adds entities to the review list based on an entity name.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are: 
blocks 
groups
name
The name of the entity.
color
The color to use for review of the entity. Valid values are 1-64.
review_type
The review type to control.
For blocks: 
1 = nodes 
2 = elems 
For groups:
1 = slave only 
2 = master only 
3 = master & slave

","Example
To review only slave elements from group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
776,*setreviewmode ,"Description
This command turns on/off the review list.
","Inputs

mode
0 - turn off review 
1 - turn on review

","Example
To review slave elements only for group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
 To turn off the review:
*setreviewmode 0
","Errors
None.
"
777,*setsolver,"Description
Sets the solver.
","Inputs

solvername
Can be one of the following: abaqus, ansys, autodv, dytran, hyperopt, ideas, marc,
            masterfile, moldflow, marc,nastran, optistruct, pamcrash, pamcrash2g, patran, phlex,
            pdm, or simex.

","Example
*setsolver(""nastran"")
","Errors
None.
"
778,*setsphereclip,"Description
 Toggles the spherical clipping feature on and off. 
","Inputs

onoff
Determines whether the spherical clipping feature is turned on or off: 
1 on 
0 off

","Example
To turn on spherical clipping:
*setsphereclip(1)

","Errors
None.
"
779,*setsurfacenormalsdisplaytype,"Description
Sets the display type for surface normals. 
This is utilized by the commands that turn on surface normals display.
","Inputs

type
0 - Vector display 
1 - Color display 

","Example
To set the surface normals to color display, and turn on the normals display of surfaces
        1-10:
*setsurfacenormalsdisplaytype 1
*createmark surfs 1 1-10
*surfacedisplaynormals surfs 1 0
","Errors
None.
"
780,*settransparency ,"Description
 Toggles the shaded surface transparency feature on and off.
","Inputs

onoff
Determines whether the shaded surface transparency feature is turned on or off. 
1 on 
0 off

","Example
To make the shaded surfaces in these comps on the mark transparent:
*settransparency(1)
*createmark(components,1) ""middle""
*transparencymark(1)

","Errors
None.
"
781,*settopologydisplaytype,"Description
Sets the various types of geometry display (wireframe, shaded, etc.) 
","Inputs

type 
0 wireframe only 
1 shaded with edges 
2 shaded without edges 
3 wireframe with internal surface lines

","Errors
None.
",
782,*setvalue,"Description
Updates an existing entity/entities with new/modified data. Data names, attributes, and
        metadata are allowed to be modified, assuming the proper card image is also assigned.
","Inputs

entity_type
The type of entity to modify.
<select_type>=<selection>
The entity or entities that are to be modified. There are several ways to provide the
            entities to be modified. Only one option can be used at a time:
id=<id>
The ID of the single entity to modify.
name=<name>
The name of the single entity to modify.
mark=<mark_id>
The ID of the mark containing the entities to modify.
list=<list_id>
The ID of the list containing the entities to modify.
user_ids={<id1> <id2> ... <idN>}
The IDs of one or more entities to modify.
user_names={<name1> <name2> ... <nameN>}
The names of one or more entities to modify.


<name>=<value>
The name=value data name, attribute, and/or metadata pairs that define the relevant
            data for the entity. For attributes, this can be either the attribute name or ID.
For entity attributes, both the entity type and the entity IDs must be provided. For
            example:*setvalue elements id=7 3222={elems 3}
Metadata update is of the form metadata={<name> <value>}.
            Both the name and value must be provided.  For example to update my_metadata_int to 15
            on component
            1:*setvalue comps id=1 metadata={my_metadata_int 15}
column=<column_index> (optional)
Column index for a 2D array. Used together with row_index, it sets
            the value at the specified row_index and
              column_index.
locationunit={<entity_id>, <face_index>}
Valid only for engineering loads. This is required if a non-uniform load is being
            updated. If the load is applied on a regular set, only <entity_id>
            is needed. If the load is applied on solid element faces, then
              <face_index> is also required.


entity_id
The ID of the entity to update.
face_index
The index of the solid element face.




modelname=<name_of_model>
This is the optional model name to update when there are multiple models in the
            database. If not specified, the current model is used.


row=<row_index> (optional)
Thel row index for a 1D or 2D array. For 1D array, it sets the single value at the
            specified index. For a 2D array, it must be used together with
              column_index. This is mandatory for string arrays. For example, to
            update a string array of size 2:
STATUS=<status>
This sets an attribute status value. Valid values are 0, 1 or 2. Notice that STATUS
            must be capitalized.

","Examples
Update the node IDs in a set named node_set:
*setvalue sets name=node_set ids={nodes 1 2 3 4 5 6 7 8}
Update the name of entity set with ID 1:
*setvalue sets id=1 name=new_setnodes
Update the attribute Rho of material ID 1 along with Status to value 1:
*setvalue mats id=1 Rho=1.1 STATUS=1
or
*setvalue mats id=1 183=1.1 STATUS=1
Update materialid to 2 for components on mark 1:
*setvalue comps mark=1 materialid=2
Update node1 to 2 for elements 1 and 2 on list 1:
*setvalue elems list=1 node1=2
Update materialid to 2 for components with IDs 1 and 2:
*setvalue comps user_ids={1 2} materialid=2
Update materialid to 2 for components with names ""mid"" and ""center"":
*setvalue comps user_names={mid center} materialid=2
Update the entire magnitude for non-uniform distributed load
        5:*setvalue loads id=5 magnitude={5 4 10 15 20}
Update the magnitude for non-uniform distributed load 5 for solid element 1654 face
        3:*setvalue loads id=5 magnitude=15 locationunit={1654,3}
Update the metadata value of type integer with name mymeta_int to value 15 for a
        component:*setvalue comps id=1 metadata={mymeta_int 15}
Update the metadata value of type entity with name mymeta_entity to material 3 for a
        component:*setvalue comps id=1 metadata= {mymeta_entity {mats 3}}
Update the metadata value of type entity_array with name mymeta_entityarray to material 1,
        3 for a
        component:*setvalue comps id=1 metadata= {mymeta_entityarray {mats 1 3}}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
783,*shapevarcreate_xproduct ,"Description
Creates a shape variable by using the cross product of two other shape variables.
","Inputs

basenode
The ID of the node where the base of the result is located after it is created.
shape variable A
The ID of the first shape variable in the cross product.
shape variable B
The ID of the second shape variable in the cross product.
magnitude
Magnitude of resulting vector.

","Errors
None.
",
784,*shell_mesh_smoother,"Description
Performs smoothing on the mesh selection with control on local node displacements and
        original mesh shape. This smoothing method is particularly useful for CFD while smoothing
        rough element patches for a wrap mesh.
","Inputs


entity_type
The type of entity to smooth. Valid values are comps and elems.
mark_id
The ID of the mark containing the entities to smooth. Valid values are 1 and 2.
mesh_shape_weight
This is a value between 0 and 1 that defines how much the original mesh shape has to
              be preserved.
node_displacement_weight
This is a value between 0 and 1 that defines how much the neighboring elements of
              the node have an effect on the node displacement itself.
iterations
The number of smoothing iterations.


","Examples
Smooth all elements with 2 iterations, keeping the original mesh shape strictly maintained
        and node displacements respecting the neighboring shape:
*createmark elems 1 ""all""
*shell_mesh_smoother elems 1 0.4 0.4 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
785,*show_new_edge_target_by_number ,"Description
Displays the target for a selected surface edge number in the new target component.
","Inputs

face
Index of the surface to be offset.
e1_edge_number
Number of the surface edge to be offset.
e2_line
Index of a pilot line.
is_opposite
0 - Uses e2_line as the target. 
1 - Uses a midline between the e1_edge_number line and
              e2_line as the target. 

","Example
Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
786,*showall ,"Description
Turns on the display of all entities.
","Example
Turns on the display of all entities.
*showall
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
787,*showentitybymark,"Description
Turns on the display of a mark of entities.
","Inputs

mark_id
The mark ID containing the entities. Valid values are 1 and 2. All entities with a
            display state on the specified mark, regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To show geometry and elements for components
        1-3:*createmark comps 1 1-3
*showentitybymark 1
To show all comps and load collectors, considering only
        elements:*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*showentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
788,*shrinkwrapmesh,"Description
This command generates a shrink wrap mesh of shell elements or its corresponding voxel mesh
        solid elements. This primarily differs from the command *hmshrinkwrap in
        that it can be used to generate solid elements. Furthermore, the tight mesh generated by
        this command better adheres to the input geometry without the need to directly specify
        features. Nevertheless, it is still possible to specify features for cases when it is
        desired to have mesh lines follow non-geometric features.
","Inputs

entity_type
The type of entity to use as input for generating the shrinkwrap mesh. Valid values
            are elems, comps, nodes, points, surfs and solids.
input_mark_id
The ID of the input mark entity mark. Valid values are 1 and 2.
feature_mark_id
The ID of the mark containing 1D feature elements. Valid values are 1 and 2. The mark may be empty, or a value of 0 can be used instead.
mesh_size
The numerical value of the desired element size.
feature_angle
This angle is used to calculate geometric features. If less than 0.0, the model's mesh
            feature is utilized. A standard value is 30.0.
mesh_type
The type of mesh to generate. Valid values are: 
0 - Unsmoothed, unprojected shell elements representing skin of outer voxel mesh. 
1 - Triangle shell mesh. 
2 - Quad shell mesh. 
3 - Predominant quad mesh, with triangles used to split quads with diagonals lying
            near (geometric) feature edges. 
10 - Unsmoothed, unprojected hexa element pure voxel mesh. 
11 - All hexa mesh. 
12 - All hexa mesh with pentas used to best fit the input geometry. 
13 - All tetrahedral mesh.
projection_type
Flag indicating whether to create tight (projected) or smooth (unprojected) mesh.
            Valid values are:
0 - Smooth, unprojected mesh. 
1 - Projected mesh adhering to specified feature angle.
min_checkval 
The minimum allowed value of the corner-node Jacobian for hexa/penta meshes, or
            minimum allowed value of tet-collapse for all tetrahedral meshes.
system_id
ID of system used to orient mesh grid. A value of 0 implies no such mesh
            orientation.
create_hole_elements
Value of 1 denotes to create patch elements, else 0.
hole_patch_size
The input (topological) hole patch size.
gap_patch_size
The input (semantic) gap patch size. 

","Examples
Create a predominantly quad mesh with element size 4.0 that is projected using the model’s
        feature angle and that is aligned with the system with ID of 1. The input is all of the
        elements belonging to all components:
*createmark comps 1 all
*shrinkwrapmesh components 1 0 4.0 0 3 1 0 1 0 0 0
Create a predominantly solid mesh with element size 2.0 that is projected using a feature
        angle of 30.0 degrees and whose elements’ Jacobian is constrained to be greater than 0.3.
        Also, have the surface of the mesh adhere to the features denoted by the feature elements on
        mark 2. The input is all surfaces on mark 1:
*createmark surfs 1 1-10
*shrinkwrapmesh surfaces 1 2 2 30.0 12 1 0.3 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
789,*simulationtitleon,"Description
Controls the display of the simulation title.
","Inputs

on 
1 on 
0 off

","Example
*simulationtitleon(0)
By default, the simulation title is displayed. 
","Errors
None.
"
790,*sl_meshsurfaces ,"Description
Performs feature-based meshing of surfaces using an XML config file. 
","Inputs

mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 1 and 2.
file
The full name and path to the XML config file containing the mesh parameters.
reserved
Reserved for future use. Must be set to 0.

","Example
To mesh all surfaces using the config file c:/temp/config.xml:
*createmark surfs 1 all
*sl_meshsurfaces 1 c:/temp/config.xml 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
791,*smooth3d,"Description
Optimizes node locations of 3D elements aginst user supplied quality criteria.
For nodes on the boundary of the selected elements, tolerances to limit node movement off
        and along boundary may be defined to improve the quality near the boundary. Please note that
        nodes that are adjecent to unselected elements are always fixed and these tolerances have no
        effect.
For practical use, it is better to set the off/along boundary tolerances small and do
        multiple runs.
","
Inputs



entity_type

The type of entities to smooth.  Valid values are comps and elems.

mark_id

The ID of the mark of entities to smooth.  Valid values are 1 and 2.

options

A quoted string of space separated name=value options, which specify the run
            parameters and one or more quality criteria with the corresponding thresholds and
            weights.
The run parameters options the substrings below.  If an option is not given, it takes
            the default value.  Options can be given in any order. Valid options are:

feature_angle=<angle>

The feature angle. Default 60.

niter=<number>

The maximim number of smooth iterations. Default 50.

shell_dev=<off_tol>,<along_tol>

The boundary node move limits for off and along boundary relative to local elems
                  size. Defaults are 0.01,0.1.

show_dim=<flag>

Show before move node locations using temp nodes.
0 - Do not show (default)
1 - Show edge node moves
2 - Show surface node moves


The quality parameters have one or more substrings as shown below. Only specified
            criteria are considered.  Options can be given in any order. Valid options are:

angle2d=<min_tria_angle>,<max_tria_angle>,<min_quad_angle>,<max_quad_angle>,<weight>

The improve face angle for both tria and quad faces.

aspect=<thr>,<weight>

The improve aspect ratio.

jcbr=<thr>,<weight>

The improve jacobian ratio.

size=<min_size>,<max_size>,<weight>

The improve min/max size. The size is not something that is optimized.
                  Iternally, the size is just equalized/smoothed.

skew=<angle>,<weight>

The improve skew.

warp=<angle>,<weight>

The improve warpage of quad faces.



","Examples
*smooth3d elems 1 ""niter=100 shell_dev=0.02,0.1 feature_angle=45 show_dim=2 warp=25,2 size=1.0,5.0,1 angle2d=20,120,40,140,1 aspect=3,1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
792,*solid_cavity_detect_end,"Description
Releases memory from the *solid_cavity_detect_start command.
","
Inputs
None.","Examples
To detect cavities of all geometric types based on default arguments:
*createmark surfaces 1 ""all""
*solid_cavity_detect_start 1 1 0 -1 -1 0.5
*solid_cavity_detect_end
",ErrorsNone.
793,*solid_cavity_detect_local,"Description
Extracts cavity surfaces based on input rims and a face of that cavity.
This command must be followed by a call to *solid_cavity_detect_end.
","
Inputs



mark_id

The ID of the mark containing the surface edges defining the rims of the cavity.

face_id

The ID of a surface within the cavity.

fill_flag

0 - Creates a region entity.
1 - Creates a solid from the cavity.

","Examples
Extracts the cavity and creates a solid representing that cavity, with IDs of rim edges
        1724, 210, 961 and 333, and face ID 73:
*createmark lines 1 1724 210 961 333
*solid_cavity_detect_local 1 73 1
*solid_cavity_detect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
794,*solid_cavity_detect_modify_surfaces,"Description
Modify a partially detected cavity by adding and removing surfaces.
The command *solid_cavity_detect_start must be called before calling
        this command to generate the cavities as region entities.
","
Inputs



mark_id

The ID of the mark containing the surfaces to add or remove.  Valid values are 1 and
            2.

region_id

The ID of the region containing the cavity definition to modify.

add_surfs_flag

1 - The input surfaces are added to the cavity.
0 - The input surfaces are removed from the cavity.

","Examples
Add surfaces 10 and 23 to a cavity attached to region 5:
*createmark surfaces 1 10 23
*solid_cavity_detect_modify_surfaces 1 5 1
Remove surfaces 10 and 23 to a cavity attached to region 5:
*createmark surfaces 1 10 23
*solid_cavity_detect_modify_surfaces 1 5 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
795,*solid_extrude_from_surfs ,"Description
This command creates solids by extruding a set of selected surfaces along a given
        vector.
","Inputs

mark_id
The ID of the mark containing the surfaces that you wish to extrude in order to create
            solids. Valid values are 1 and 2.
vec_x
X-component of the extrusion vector.
vec_y
Y-component of the extrusion vector.
vec_z
Z-component of the extrusion vector.
options
Flags that indicate different modes for the extrusion. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5).
Bit0
0 - Only free edges of surfaces are extruded. 
1 - Both free and internal edges are extruded, thus creating separate solids
                  from surfaces separated by shared edges.
Bit1
0 - Create solid entities. 
1 - Create only boundary surfaces.
Bit2
0 - Surfaces are extruded in one direction (positive or negative based on the
                  surface normal). 
1 - Surfaces are extruded in both directions.
Bit3
0 - Selected surfaces are disconnected from non-selected attached surfaces
                  before creating solids. 
1 - Connectivity between selected and non-selected surfaces is preserved.
Bit4
0 - When extrusion is made in both directions (Bit2=1), delete original
                  surfaces. 
1 - When extrusion is made in both directions (Bit2=1), keep original surfaces
                  and use them as separating surfaces between created solids.
Bit5
0 - Original selected surfaces become part of created solid boundary. 
1 - Copy of original selected surfaces is made before creating solids.


comp_mode
Determines how new solids are distributed into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces (the result
                is not predictable if the surfaces are originally in different components).



","Example
To create a solid by extrusion of the surface with ID 1, using vector (1,2,3), and creating
        the solid in the surface’s component:
*createmark surfaces 1 1
*solid_extrude_from_surfs 1 1.0 2.0 3.0 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
796,*solid_fixedptsmaker,"Description
Used in the solidmap panel to create fixed points on the edges of selected components.
        These points are generated from nodes on the component’s edges that fall within a specified
        tolerance, and are meant to be transitory; use
          *solid_fixedpointssuppressor(1) to remove them.
","Inputs

surf_mark_id
1 or 2, surface mark ID. Fixed points are to be made on the edges of these
            surfaces.
comp_mark_id
1 or 2, component mark ID. Nodes of the elements in the marked components are
            considered for making fixed points.
tol_rel
Tolerance relative to the average element size calculated from the elements in the
            inputed components.

","Example
*solid_fixedptsmaker(1,1)

","Errors
None.
"
797,*solid_offset_from_surfs ,"Description
This command creates solids by normally offsetting a set of selected surfaces.
","Inputs

mark_id
The mark of input surfaces. Valid values are 1 and 2.
offset
The distance to offset along the normal direction.
options
Flags that indicate different modes for the offset. Bit values are used and the value
            is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5).
Bit0
0 - Only free edges of surfaces are offset. 
1 - Both free and internal edges are offset, thus creating separate solids from
                  surfaces separated by shared edges.
Bit1
0 - Create solid entities. 
1 - Create only boundary surfaces.
Bit2
0 - Surfaces are offset in one direction (positive or negative based on the
                  surface normal). 
1 - Surfaces are offset in both directions.
Bit3
0 - Selected surfaces are disconnected from non-selected attached surfaces
                  before creating solids. 
1 - Connectivity between selected and non-selected surfaces is preserved.
Bit4
0 - When extrusion is made in both directions (Bit2=1), delete original
                  surfaces. 
1 - When extrusion is made in both directions (Bit2=1), keep original surfaces
                  and use them as separating surfaces between created solids.
Bit5
0 - Original selected surfaces become part of created solid boundary. 
1 - Copy of original selected surfaces is made before creating solids.


comp_mode
Determines how new solids are distributed into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces (the result
                is not predictable if the surfaces are originally in different components).



","Example
To create a solid by offsetting surface ID 3 a distance of 5.0 along both the positive and
        negative normal directions and to organize the input surface into the same component as the
        solid:
*createmark surfs 1 3
*solid_offset_from_surfs 1 5.0 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
798,*solid_prepare_nodeline ,"Description
This command is used by the solid mapping algorithm to setup an internal node array. It
        must be used within a *solidmap_prepare_usrdataptr data input block. A
        data input block begins with *solidmap_prepare_usrdataptr and ends with
        either a call to *solidmap_end or the start of another data input
        sub-block.
","Inputs

start
A flag that indicates how to handle the nodes on the node list2. A value of 0
            indicates to start a new internal node array. Otherwise, the list is appended to the
            previous internal node array. The later case is required when the node count is more
            than 2000 as this is the current upper limit allowed by a single call to
              *createlist.

","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0
","Errors
Invalid or inconsistent input parameters in *solidmap_prepare_nodeline result in a Tcl
        error. To detect errors, you can use the catch command:
if { [ catch {*solidmap_prepare_nodeline 0} ] } {
# Handle error
}
"
799,*solid_untrim ,"Description
This command creates a full or partial cone or cylindrical solid.
","Inputs

mark_id
The ID of the mark containing the surfaces to untrim. Valid values are 1 and 2.
force
0 - Only surfaces that separate solids (solid on both sides) are removed. 
1 - Surfaces are deleted even if there is no solid on one of the sides. Normally this
            causes solid destruction but it may be useful as a way to remove solid cavities.

","Example
To untrim surface 100:
*createmark surfs 1 100
*solid_untrim 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
800,*solidcone ,"Description
This command creates a full or partial cone or cylindrical solid.
","Inputs

base_x, base_y, base_z
base_x, base_y, base_z
mvec_x, mvec_y, mvec_z
The x, y and z coordinates specifying the major axis vector direction from the base
            location.
nvec_x, nvec_y, nvec_z
The x, y and z coordinates specifying the normal vector (along the length) from the
            base location.
base_radius
The radius of the bottom of the cone/cylinder (at the major axis in case of elliptical
            cone or cylinder).
If the top_radius and base_radius are equal, this creates a cylindrical solid.
top_radius
The radius of the top of the cone/cylinder (at the major axis in case of elliptical
            cone or cylinder). 
If the top_radius and base_radius are equal,
            this creates a cylindrical solid.
aspect_ratio
A value less than 1.0 creates an elliptical cone/cylinder. A value smaller than 1.0
            indicates a more elliptical shape. 
Must be > 0.0.
start_angle
 The angle at which the cone/cylinder starts (0.0 to <
            end_angle). 0.0 starts at major axis.
end_angle
The angle at which the cone/cylinder ends (> start_angle to
            360.0)
height
The height of the cone/cylinder.

","Example
To create a full elliptical cone solid with center at (0,0,0), with major axis vector
        (1,0,0), normal axis vector (0,0,1), base radius of 20, top radius of 10, ratio between
        minor and major axis of 0.5, and a height of 30:
*solidcone 0 0 0 1 0 0 0 0 1 20 10 0.5 0 360 30
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
801,*solidcreateruled,"Description
This command creates solid entities by interpolating linearly or smoothly between input
        surfaces. Optionally, a list of linking points and/or guiding lines and surfaces can be
        provided for better interpolation and shape control.
The link points are given in link_coords_array, using their x-y-z
        coordinates. Link points should be given in pairs since each link between input surfaces is
        specified by its two end points. Furthermore, the pair of points must not skip any surface
        in between. For instance, if we have surfaces 1, 2, 3 and 4 as the input surfaces in this
        order, the link points can link surface 2 to 3 but not 2 to 4, by skipping 3. If such a skip
        is detected, the corresponding pair of points is ignored. One point may be linked to
        multiple points, which results in triangular surfaces.
In the smooth interpolation case, the linking between surfaces may also be given by
        selecting guiding lines and/or guiding surfaces using guide_mark_id.
        Guiding lines are used as part of the boundary of the final interpolating solid. If more
        than one guiding line is selected, the edges of the solid between these lines are obtained
        by smoothly interpolating these lines. If linear interpolation is selected, the guiding
        lines or guiding surfaces are ignored. If a guiding line extends beyond just connecting the
        input surfaces, that part of the line is ignored.
In order for guiding lines to be valid, they must:
Connect the input surfaces at their boundaries. 
Connect to all intermediate input surfaces.


In order for guiding surfaces to be valid, they must:
Link the step surfaces as a single piece surface. In other words, if edge-A of a step
            surface is linked to edge-B of a step surface the linking surface must be a single
            surface.
Be stitched to the edges of step surfaces.
Link all the level surfaces of the solid. For example, if there are 3 step surfaces
            and one wants to use guiding surfaces, it is not enough to link only bottom and middle
            surfaces by a guiding surface. One needs to link the middle and the top surface
            also.
If two or more guiding surfaces are located next to each other, they must be stitched
            together properly.


If any conditions are not met, those guiding lines/surfaces will be ignored.
In the case of a surface with a scratch, if one of the internal points of the scratch is
        not linked to another surface at its boundary, this scratch is treated as if it is not part
        of the boundary, i.e. as if it does not exit. If the scratch is linked upward but not
        downward, then is it considered a part of the boundary while constructing surfaces between
        its level and the level above, but it is ignored while constructing boundary with the
        surface below.
All the surfaces at each level must have the same number of internal loops, if any.
        Currently, only one internal loop at each level is supported. Cases with more than one
        internal loop will generate solids, but the matching between loops may not be desirable.
","Inputs

surf_list
The ID of the list containing the input surfaces. The *createlist
            command is used to create the list. Reserved for future use. Must be set to 0.
link_coords_array
List of coordinates for the points which are supposed to be linked by an edge in the
            solid. The points are given in pairs. The *createdoublearray command
            must be used to create the array. This should always be set to 1.
num_coord_links
The size of the link_coords_array.
guide_mark_id
The ID of the mark containing the guiding lines/surfaces. Reserved for future use. Must be set to 0.
ruled_type
Type of surface interpolation between input surfaces. 
0 - Smooth interpolation. 
1 - Linear interpolation.


options
Flags that indicate different modes for solid creation. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2).
Bit0
Parameter that controls merging of the solid at input surfaces. Valid values are:
0 - Merge solids at shared input surfaces. Creates a single solid. 
1 - Split solid at shared input surfaces. Creates as many as one less than
                      the number of input surfaces.


Bit1
0 - Create an open-ended solid. 
1 - Create a closed ring solid.
Bit2
0 - Create solid entities. 
1 - Create only bounding surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces. The result
                is not predictable if the surfaces are originally in different components.



","Examples
To create a linear ruled solid between surfaces 11 , 23 and 12:
*createlist surfs 1 11 23 12 
*solidcreateruled 1 1 0 1 1 0 2
To create a smooth ring solid in the surfs component component, split at the input
        surfaces, interpolating surfaces 11, 12 and 15, links point P1 = (2.3, 4.5, 6.0) of surface
        11 corresponds to point P2 = (12.3, 2.25, 36.30) of surface 12, uses lines 57 and 68:
*createlist surfs 1 11 12 15
*createdoublearray 6 2.3 4.5 6.0 12.3 2.25 36.30
*createmark lines 2 57 68
*solidcreateruled 1 1 6 2 0 3 2
The following example smoothly interpolates surfaces 9, 1, 3 and 15. Coordinates of 4
        points are given that specify the locations that must be linked together at the boundaries
        of these surfaces. Furthermore, line 416 is given as a guiding line and surfaces 44, 45 and
        4 are given as guiding surfaces. Thus, line 416 will be part of the boundary of the final
        solid as well as surfaces 44-46. All of the other boundary lines connecting surfaces 9, 1, 3
        and 15 will be obtained by smoothly interpolating line 416 and the related boundary lines of
        surface 44-46.
*createlist surfs 1 9 1 3 15
*createdoublearray 12 65.7154694 -45.6232033 0 79.955162 -60.0597343 60 79.955162 -60.0597343 60 39.7798615 -30.2912979 150
*createmark lines 2 416
*createmark surfaces 2 44 45 46
*solidcreateruled 1 1 12 2 0 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
802,*solidmap_begin ,"Description
This command is used by the solid mapping algorithm to indicate the beginning of a solid
        mapping command block. It must be paired with a *solidmap_end command. A
        single solidmap mesh is a result of the block of commands. 
In a solidmap command block, all of the commands before *solidmap_end
        are for preparing input data. *solidmap_end is the command that actually
        performs the solid mapping.
","Inputs

ordered
A flag indicating whether the input nodes will be reordered or not. This is meaningful
            only if nodes will be used as input. Valid values are:
0 - Nodes will be reordered in solidmap. 
1 - Nodes will not be reordered in solidmap.



","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10 
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
803,*solidmap_equivalence,"Description
This command is used by the solid mapping algorithm. It equivalences two sets of nodes,
        based on a given tolerance and, optionally, does a special find_faces
        operation. 
For equivalencing, the first set of nodes are from the elements in the solidmap and ^faces
        components. The second set of nodes consists of all of the nodes not included in the first
        set but falling within the specified tolerance. 
For the find_faces operation, 3D elements in the solidmap component are
        used to find the faces. All pre-existing faces are filtered out and the remaining faces are
        added to the ^faces component. See the command *solid_facesfind. This
        step is useful for continuing with the next solid map operation.
","Inputs

tolerance
The tolerance to use for finding nodes in the equivalence operation.
find_faces
A flag indicating whether to perform the special faces operation. Valid values are: 
0 - Do not perform the find. 
1 - Perform the find.

","Example
To equivalence the solidmap and ^faces nodes using a tolerance of 0.01 and finding the new
        faces:
*solidmap_equivalence 0.01 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
804,*solidmap_prepare_usrdataptr,"Description
This command is used by the solid mapping algorithm to setup the source, destination and
        along inputs. It must be used within a *solidmap_begin and
          *solidmap_end command block. A single solidmap mesh is a result of the
        block of commands.
In a solidmap command block, all of the commands before *solidmap_end
        are for preparing input data. *solidmap_end is the command that actually
        performs the solid mapping.
A data input sub-block starts with this command and ends with either a call to
          *solidmap_end or the start of another data input sub-block. The three
        sub-block types do not all need to be present in a solidmap command block. Not all entity
        types included in options need to be input. For example:
*solidmap_prepare_usrdataptr ""SOURCE"" 10
Means in solidmap, lines and elements are used as the source. However, one could just input
        lines. The required elements would be calculated from these lines inside of the solidmapper.
        This is the auto-completion feature of solidmap.
","Inputs

type
One of the three types of the input data sub block. Valid values are: 
""SOURCE"" - Data input next will be for defining the source. 
""DEST"" - Data input next will be for defining the destination. 
""ALONG"" - Data input next will be for defining the along. 
options


For SOURCE data input blocks, elements (Bit3) are required to be specified even if Bit3 is
        0. Internally, solidmap sets this bit to 1 for SOURCE data input blocks regardless of the
        user setting.
","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
805,*solidmap_solids_begin,"Description
This command is used by the multi-solid mapping algorithm to indicate the beginning of a
        solid mapping command block. It must be paired with a
          *solidmap_solids_end command. 
The commands below can appear in a multi-solids solidmap command block between
          *solidmap_solids_begin and
        *solidmap_solids_end:*solidmap_solids_set_density
*solidmap_solids_set_elemsize
*solidmap_solids_set_face_params
*solidmap_solids_set_mapface
","Inputs

mark_id
ID of the mark containing the solids to mesh. Valid values are 1 and 2.
options
Flags that indicate different options for solid mapping. Bit values are used and the
            value is a sum of all the options. Any bits not listed below are unused or for internal
            use (e.g. called in other commands) and are always internally set to their required
            values. Setting them to 0 is recommended, but not mandatory.
Bit0
0 - Reserved, must be set to 0.
Bit1
0 - New elems are organized to the solid component. 
2 - New elems are organized to the current component.
Bit2
0 - Reserved, must be set to 0.
Bit3
0 - Create elems when calling *solidmap_solids_end .
8 - Do not create elems when calling *solidmap_solids_end
                  (for expert users only).
Bit4
0 - Create layered solid elements. 
16 - Create layered shell elements.
Bit5,6
0 - Auto decide 
32 - Do not use the fast method
64 - Use the fast method
96 - Unused
Bit8
0 - No additional smoothing steps will occur. 
256 - Perform extra smoothing steps.
Bit9,10,11
2D elem type 1 and 2 passing to the internal call to
                    *defaultremesh when per face meshing parameters are not available:
0 - Tria 
512 - Quad 
1024 - Mixed 
1536 - R-tria 
2048 - Quad only


Bit13
0 - Keep shell meshes on input geometry. 
8192 - Remesh shell meshes on input geometry. Note: Solid elems on input solids
                    are always deleted.

Bit14
0 - Normal meshing situations. 
16384 - Create internal meshing sequencing structure only. Do not create mesh
                  and internal meshing structure (for expert users only).
Bit15
0 - Do not use meshing parameters saved to the solid map attributes on the
                  geometry.
32768 - Use meshing parameters saved to the solid map attributes on the
                  geometry.
Bit16
0 - Make the reparameterization of along faces more orthogonal. 
65536 - Make the reparameterization of along faces more like parallelograms
Bit17
0 - Do not use per edge/face saved meshing parameters. 
131062 - Use per edge/face saved meshing parameters.
Bit18
0 - Stop meshing when elems with negative Jacobian are generated. 
262144 - Continue meshing regardless of the elem quality.


elem_size
The default element size used when the per edge/face meshing parameters are not
            available.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem size of 1.0:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
*createmark lines 1 2 4
*solidmap_solids_set_elemsize 1 1.0
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
806,*solidmap_solids_end ,"Description
This command is used by the multi-solid mapping algorithm to indicate the end of a solid
        mapping command block. It must be paired with a *solidmap_solids_begin
        command. 
The commands below can appear in a multi-solids solidmap command block between
          *solidmap_solids_begin and
        *solidmap_solids_end:*solidmap_solids_set_density
*solidmap_solids_set_elemsize
*solidmap_solids_set_face_params
*solidmap_solids_set_mapface
","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem size of 1.0:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
*createmark lines 1 2 4
*solidmap_solids_set_elemsize 1 1.0
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
807,*solidmap_solids_set_elemsize ,"Description
This command is for setting the per edge elem size for solid map meshing. The size value
        specified is only a target value. Depending on solvability, the resulting mesh may take on a
        modified value. This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

mark_id
The ID of the mark containing the lines/edges to set the element size for. Valid values are 1 and 2.
elem_size
The value to set the elem size to for the selected lines/edges.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem density of 10.0:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *createmark lines 1 2 4
   *solidmap_solids_set_elemsize 1 10.0
*solidmap_solid_end

","Errors
None.
"
808,*solidmap_solids_set_mapface ,"Description
This command is used to set the surface shared by the 4 input vertices to the mapped type
        with the input vertices as the corners. The 4 vertices must be distinct. If more than one
        surfaces share the 4 vertices, the resulting surface for type setting is random. The command
        has effect only for surfaces for which the mesh type is free to change (e.g. not an along
        face of a solid). This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

point_id1
The ID of the first corner vertex.
point_id2
The ID of the second corner vertex.
point_id3
The ID of the third corner vertex.
point_id4
The ID of the fourth corner vertex.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on the surface shared by
        points 10, 11, 12 and 13 which is to be of mapped type by these points:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *solidmap_solids_set_mapface 10 11 12 13
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
809,*solidmesh12lines ,"Description
Creates a solid mesh in a volume formed by twelve lines. 
","Inputs

lines
The line list ID which contains lines that define a solid. 
density1
The density of the elements in the first direction. 
density2
The density of the elements in the second direction. 
density3
The density of the elements in the third direction.

","Errors
None.
",
810,*solids_create_from_surfaces,"Description

","Inputs

surfs_markmask
The mark containing the surfaces from which you wish to create solids.
depth_mode
Defines an algorithm of creating solids in closed volumes defined by selected surfaces
            set:
0 - Create solids at levels up to depth_level, with ""level"" defined
            as follows: All volumes that have their boundary with outer space are at level.
1 - All volumes that share their boundary with volumes of the level n, but were not
            themselves marked as level n or n-1, become volumes of the level n+1.
4 - First, all of the selected surfaces that have closed volumes (not already
            containing solid) on exactly one side are found and solids are created for those
            surfaces. 
If after that some of the remaining surfaces from the selected set still do not have a
            solid on their side, but have closed volumes on both sides, then solids are created on
            both sides of those surfaces.
depth_level
The number of levels (as defined by depth_mode 0) used to create
            solids. If the value is -1, then solids are created in all closed volumes defined by the
            input set of surfaces.
comp_mode
0 - Solids are created in the current component and boundary surfaces are moved to the
            same component.
1 - Solids are created in the current component, but surfaces remain in their original
            component.
2 - Solids are created in the surfaces component (the result is not predictable if the
            surfaces were originally in different components).

","Examples
Suppose you have two spheres: a surface with ID 1 being a larger outer sphere and a surface
        with ID 2 being the smaller sphere inside. To create single solid that has the larger sphere
        as its outer boundary and the smaller sphere as the boundary of the cavity inside, and place
        the results in the surfaces component:
*createmark surfaces 1 1 2
*solids_create_from_surfaces 1 4 0 2
or
*solids_create_from_surfaces 1 0 1 2
To create 2 solid spheres--one of them as in previous example, another inside the
        cavity—use:
*solids_create_from_surfaces 1 0 2 2
","Errors
None.
"
811,*solverdeckcleanup ,"Description
Deletes or retains certain solver specific entities, based on their validity in the current
        model. This is useful after a box trim operation.
","Inputs

solver
The source solver name. Currently only LsDyna
            is supported.
mark_id
The ID of the mark containing the entities to consider for cleanup. Valid values are 1 and 2.
Supported entity types include groups, controlvols, and loads.

The following operations are performed:
* AIRBAG_ADVANCED_ALE (control volume): Delete if at least one bag ID is not
            defined.
*AIRBAG_INTERACTION (control volume): Delete if the card image
            does not contain both AB1 and AB2 values. Both have to be present for the entity to be
            retained.
*AIRBAG_PARTICLE (control volume): Delete if the card image does not reference either
            a part set ID or part ID corresponding to variables SID1 and SID2. Only one has to be
            present for the entity to be retained.
*AIRBAG_<option> (control volume): Delete if the slave definition is empty.
*ALE_options (ALE group)
*CONSTRAINED_EULER_IN_EULER (group)
*CONSTRAINED_LAGRANGE_IN_SOLID (ALE group)
*CONSTRAINED_RIGID_BODIES (group)
*CONSTRAINED_TIE-BREAK (group)
*CONTACT (group): Delete if either the master or slave definition is missing or
            empty.
*CONSTRAINED_EXTRA_NODE (group): Delete if no nodes or node set are associated. In its
            card image, remove the keyword if PSID is assigned as blank.


The following keywords, if defined, do not need explicit entity definitions as they
        consider the entire model, and will be retained:
*CONTACT (group): If master or slave type is assigned a value of 5.
*LOAD_BLAST
*LOAD_BODY
*LOAD_BRODE
*INITIAL_VELOCITY_<option>
*RIGIDWALL: If variable NSID is assigned a value of 0.


","Example
To cleanup all relevant entities on mark 1:
*solverdeckcleanup LsDyna 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
812,*spatialrenumbering ,"Description
Renumbers nodes and elements based on spatial locations.
","Inputs

entity_type
The type of entity to renumber. Valid values are nodes and elements.
type=<type>
The type of renumbering, axis or adjacent. 
Adjacent only works with quad4 or quad8 elements and associated nodes.
startid=<startid>
The ID to be assigned to the first entity. The value must be an unsigned integer. This
            option also works with parameters of integer type.
primaryidincrement=<primaryidincrement>
The ID increment in the primary direction. The value must be an unsigned integer. This
            option also works with parameters of integer type. 
secondaryidincrement=<secondaryidincrement>
The ID increment in the secondary direction. The value must be an unsigned integer.
            This option also works with parameters of integer type.

The following options apply to type=axis only:

systemid =<systemid>
The ID of system. For global system, a value of 0 must be used. The system should be
            either Cartesian or cylindrical.
primaryaxis=<primaryaxis>
The primary axis of the system. x=1, y=2 and z=3 for Cartesian systems. r=1, θ=2 and
            z=3 for cylindrical systems.
primarytolerance=<primarytolerance>
The allowed tolerance between entities in the primary direction. The value must be a
            double. This option also works with parameters of double type.
secondaryaxis=<secondaryaxis>
The secondary axis of the system. x=1, y=2 and z=3 for Cartesian systems. r=1, θ=2 and
            z=3 for cylindrical systems. This must not be equal to
            primaryaxis.
secondarytolerance=<secondarytolerance>
The allowed tolerance between entities in the secondary direction. The value must be a
            double. This option also works with parameters of double type.

The following options apply to type=adjacent only:

startentityid=<startentityid>
The ID of the start entity. This entity must be same as
            entity_type.
primaryentityid=<primaryentityid>
The ID of the primary entity. This entity must be same as
              entity_type and must be adjacent to the start entity.
secondaryentityid=<secondaryentityid>
The ID of the secondary entity. This entity must be same as
              entity_type and must be adjacent to the start entity.
A few notes about type=adjacent:
If the entity type for all three options is nodes, all three entities must belong
                to a common element apart from being adjacent to each other. 
For quad8 elements, only provide ids of corner nodes of a common element as start,
                primary and secondary entity ID. Mid nodes as prime inputs are not supported. 
The IDs of non-selected entities will be renumbered if any conflict arises during
                renumbering. 
A single entity cannot be renumbered using this method. 
If a secondary entity is not specified, or set as 0, the row/column containing the
                start and primary entities will be renumbered.



","Examples
Renumber nodes using axis type and local system 1 with primary axis 1 and secondary axis
        2:
*createmark nodes 1 all
*spatialrenumbering nodes mark=1 type=axis systemid=1 startid=100 primaryaxis=1 primarytolerance=0.2 primaryidincrement=1000 secondaryaxis=2 secondarytolerance=0.2 secondaryidincrement=1
Renumber elements using adjacent type and integer parameter named priInc (parameter value
        100) used as primary ID increment by name:
*createmark elems 1 all
*spatialrenumbering elems mark=1 type=adjacent startentityid=555 startid=1 primaryentityid=557 primaryidincrement={parameter name=priInc} secondaryentityid=556 secondaryidincrement=1
Renumber a single column/row of nodes using adjacent type. Only a single column/row of
        entities will be renumbered:
*createmark elems 1 all
*spatialrenumbering elems mark=1 type=adjacent startentityid=41 startid=1 primaryentityid=40 primaryidincrement={parameter id=5} secondaryentityid=0 secondaryidincrement=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
813,*sphereclipautofit ,"Description
Toggles the autofit feature for spherical clipping on or off.
","Inputs

onoff 
Determines whether the autofitting for spherical clipping is turned on or off: 
1 - on 
0 - off

","Example
To turn on autofit for spherical clipping.
* sphereclipautofit (1)
","Errors
None.
"
814,*sphereclipradius,"Description
Set the radius for spherical clipping.
","Inputs

radius
The radius the entities must be within for them to be visible when spherical clipping
            is enabled.

","Example
To enable spherical clipping at the origin with radius 10:
*sphereclipcenter(0,0,0)
*setsphereclip(1)
*sphereclipradius(10)

*sphereclipcenter() is required to view clipping. 
*setsphereclip() is required to view clipping.
","Errors
None.
"
815,*splinesurface ,"Description
Creates a 3D or planar surface defined by a set of lines, and optionally, prepares it for
        immediate use within the automesher. It can also identify a region in the shape of a Coons
        patch surface for the automesher to use under the mesh without surface option. 
","Inputs

entity_type
The type of entities to use as input. Valid values are nodes, points and lines.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
plane_flag
A flag indicating if the lines are planar. 
1 - A plane is calculated from the lines. 
2 - Lines are projected onto the plane defined by plane. 
0 - Lines are not on a plane, and a 3D surface is created. 
plane
The plane used to project lines if plane_flag is set to 2. 
options
Specifies options for creating the surface. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 8*Bit3 + 1024*Bit10).
Bit0
Component mode. Used to determine which component will be used to place created surfaces.
0 - Current component is used. 
1 - Component of input lines is used. If different components are used as
                      input, the component to which the majority of the lines belong is used.


Bit1
Line ends usage mode. Used to control creation of vertices on the constructed
                  spline. Currently works only for planar surfaces.
0 - Vertices are created automatically on constructed surface. 
1 - Vertices are created at input line ends.


Bit3
Surface stitching option. Used to override the default stitching algorithm.
0 - Default stitching algorithm as defined by *setoption
                        geom_stitching command. 
1 - Created surface is not stitched to any of model surfaces.


Bit10
 Mesh stitching option. Used to control the connectivity of the mesh created on
                  the new spline surface in simultaneous meshing modes set by
                    *surfacemode command.
0 - New mesh is not connected. 
1 - In *surfacemode 1, existing mesh nodes on input
                      lines are used if new spline edges are stitched to those lines. In
                        *surfacemode 2, existing mesh nodes on input lines are
                      used to create the mesh on the new spline surface.





","Example
To create a surface from lines 65, 66, 67 and 69, with no elements: 
*surfacemode 4
*createmark lines 1 65 66 67 68
*createplane 1 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000
*splinesurface lines 1 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
816,*split_elements_by_structure_pattern_freeselection,"Description
Creates a refined mesh inside a selected area and makes the transition using structured
        patterns .
","
Inputs



entity_type

The type of entity used as input.  Valid values are nodes and elems.
For nodes, all attached elements are considered.

mark_id

The ID of the mark containing the input entities.  Valid values are 1 and 2.

refine_size

The element size for the refinement zone.

adjacent_layers

The number of adjacent element layers to use for making transitions.

","Examples
To refine all elements attached to node 198 to a size of 25, using 1 layer for
        transtion:
*createmark nodes 1 198
*split_elements_by_structure_pattern_freeselection nodes 1 25 1
To refine elements 175-180 to a size of 0.5, using 2 layers for transtion:
*createmark elems 1 175-180 
*split_elements_by_structure_pattern_freeselection elems 1 0.5 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
817,*split1delements,"Description
Split 1D elements using various options.  Only those 1D elements that have been directly
        assigned a valid 1D property are split. During split, each newly created element will be
        assigned a new property. This new property is of same type as the property of the parent
        element. Parent elements’ attributes like orientation, offset and DOFs are also
        copied/interpolated to new child elements. It also assigns the same ID to newly created
        elements and properties so that it is easy to map the element to its property.
This command works only for OptiStruct and Nastran user profiles.
The match list of elements-to-properties is as follows:
CBAR/PBAR
CBAR/PBARL
CBEAM/PBEAM
CBEAM/PBEAML
CROD/PROD


For PBEAM, the new child properties inherit the intermediate stations of the parent
        property, in case where such station intersects with the new child element.
Limitations:
PBARL/PBAR - The attributes (stations/stress recovery points) associated to CBARAO are
            not supported.
PBEAM - Though the command supports intermediate stations, the beam sections
            (dimensions) are not interpolated for now. Hence the child properties will interpolate
            the attributes associated to beam sections from the parent property, but will not create
            new beam sections.
PBEAML - It is supported, only if there are no intermediate stations.


","
Inputs



enttype=<entity_type>

The type of entity to split. Currently only supported for elements.

mark=<mark_id>

Thd ID of the mark of 1D elements to be split.  Valid values are 1 and 2.

meshingtype=<type>

nodespoints - This option requires to specify list of nodes or points, along with
            reference entity type, to split 1d elements. The elements will split at nodes or points
            provided in the list. The nodes/points not lying on the input element are also
            considered and projected on the input element for split, given the condition, such
            nodes/points are within the tolerance, which is a bounding sphere. The diameter of this
            sphere is the input element length and its center is the element's centroid.
The following options are additionally supported for nodespoints:



refenttype=<entity_type>

The reference entity type. Valid values are nodes and points.

listid=<list_id>

The ID of the list of selected nodes or points, created using
                    *createlist.  Valid values are 1 and 2.


uniform - This option requires to specify number of elements to be created after
            split.
The following options are additionally supported for uniform:



numelems=<number>

The number of elements to be created after split.



delorgelems=<value>

0 - Do not delete original input elements
1 - Delete original input elements

beamstartid=<id>

The start ID for newly created 1D elements. If the specified ID already exists, the
            maximum ID available from elements/properties is considered and incremented by 1 to
            assign as start ID.

","Examples
Split 1D elements using uniform option for meshing type, resulting in creating 3 new
        elements and properties (IDs 300, 301 and 302):
*createmark elements 1 all
*split1delements enttype=elems mark=1 meshingtype=uniform numelems=3 delorgelems=1 beamstartid=300
Split element 100 using nodes 10 and 20, and using nodespoints option for meshing type:
*createmark elements 1 100
*createlist nodes 2 10 20
*split1delements enttype=elems mark=1 meshingtype=nodespoints listid=2 refenttype=nodes delorgelems=1 beamstartid=1000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
818,*splitelementbyedges,"Description
Splits shell element edges that are intersected by a line joining the input points.  The
        user can provide x-coordinate and y-coordinate of the mouse click on the screen. The number
        of input points must be >=2.
","
Inputs


x1
The screen x coordinate of point 1.
y1
The screen y coordinate of point 1.
x2
The screen x coordinate of point 2.
y2
The screen y coordinate of point 2.

","Examples
Example:
*splitelementbyedges 354 379 694 385
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
819,*splitelements,"Description
Splits shell elements using various methods.
","Inputs

method


Defines the method used to split the elements. Valid values are: 
2 - Divide quads, shortest diagonals 
12 - Divide quads, aligned diagonals 
21 - Split all sides 
22 - Divide quads, unionjack diagonals 
23 - Midpoint, to quads 
24 - Midpoint, to trias 
32 - Divide quats, largest angle diagonals 


Add 4 to any method to enable the use of an inferred surface if no geometry exists.
            Add 100 to any of the ""divide quad"" methods to reverse the split direction.
mark_id
The ID of the mark containing the elements to split. Valid values are 1 and 2.

","Examples
To split quad elements 1-10 using unionjack diagonals:
*createmark elems 1 1-10
*splitelements 22 1
To split quad elements 1-10 using unionjack diagonals and using an inferred surface:
*createmark elems 1 1-10
*splitelements 26 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
820,*splitsolidelements,"Description
Divides the given solid elements into hexa or tetra elements. 
","Inputs

markmask
The mark of solid elements to be split.
splittype


A code that indicates the type of split to perform. 
1 - splits a hexa into 8 hexas 
2 - splits a hexa into 5 or 6 tetras 
3 - splits a hexa into 24 tetras



","Example
To split solid elements 100 through 110 into hexas: 
*createmark(elements,1) 100 101 102 103 104 105 106 107 108
   109 110
*splitsolidelements(1, 1)
The *createmark() directive is required for this command. 
","Errors
None.
"
821,*spring ,"Description
Creates a spring element between two nodes using an orientation vector.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
dof
The degree of freedom for the element.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.

","Example
To create a spring element between node 100 and node 101 with DOF 2, property springprop,
        and orientation vector ID 51:
*spring 100 101 2 ""springprop"" 51
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
822,*springos ,"Description
Creates a spring element between two nodes using various orientation methods. 
The orientation may be specified using either vector_id, direction_node_id,
          system_id or individual components (orient_x,
          orient_y, orient_z).
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.
direction_node_id
The ID of the direction node assigned to the element.
orient_x
The x-component of the orientation vector.
orient_y
The y-component of the orientation vector.
orient_z
The z-component of the orientation vector.
orient_comps_flag


0 - Do not use individual components to define the orientation 
1 - Use individual components to define the orientation


system_id
The ID of the orientation system assigned to the element.

","Example
To create a spring element between node 100 and node 101 with property springprop, using
        node 51 as the orientation node:
*springos 100 101 ""springprop"" 0 51 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
823,*springsupdate ,"Description
 Updates the properties of spring elements. 
","Inputs

mark
The ID of the mark which contains the spring elements to be updated. 
dofflag
Set to 1 if the dofs should be updated, otherwise 0.
dof
The degree of freedom which the spring elements should be updated to (one digit of
            1-6). 
propertyflag
Set to 1 if the property should be updated, otherwise 0.
property
The property to which the element should point. 
Vectorflag
Set to 1 if the vector should be updated, otherwise 0.
vectorid
The ID of the orientation vector associated with the spring element.

","Example
To update spring element 16, 17, and 18 to have a degree of freedom of 3 and a property
        reference to sprate, without an orientation vector: 
*createmark(elements,1) 16 17 18
*springsupdate(1,1,3,1,""sprate"",0)
","Errors
None.
"
824,*stackdisplay,"Description
Displays the stack direction of selected entities. Currently only supported for Abaqus continuum shell elements.
","Inputs

entity_type
The type of entity to display. Valid values are elements and components.
mark_id
The ID of the mark containing the entities to display. Valid values are 1 and 2.
size
The size in model units of the stack display.

","Example
To display the stack direction of elements 1-10 using a size of 10.0:
*createmark elems 1 1-10
*stackdisplay elems 1 10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
825,*start_batch_import ,"Description
Initializes a sequence of multi-file batch import/merge operations. This is intended to
        improve performance of importing/merging a series of files. Certain operations that
        generally are run for each import/merge, and queued up and executed just once at then end of
        the import. These operations are different for each type of import/merge operation, and
        therefore cannot be mixed. It is essential to only import/merge valid file types per the
        mode argument. This command must be followed by a corresponding call to
          *end_batch_import. It is potentially dangerous to perform other
        operations within a *start_batch_import/*end_batch_import block, so take
        proper precaution and make sure to always call these commands in pairs.
","Inputs

mode


1 - Merge HyperMesh files using *mergefile
                or *mergefile2

2 - Import FE files using *feinputwithdata2

3 - Import CAD files using *feinputwithdata2



","Example
To execute a sequence of importing multiple CAD files, where the variable
          cad_files contains the list of files:
*start_batch_import 3
foreach cad_file $cad_files {
    *feinputwithdata2 ""#Detect"" ""$cad_file"" 1 0 -0.01 0 0 1 0 1 0
}
*end_batch_import
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
826,*stiffenedpanelmesh,"Description
Creates a stiffened panel mesh between lines or on surfaces.
<option>=<value> options can be provided in any order.
","Inputs

entity_type1
Must be set to lines.
entity_type2
Must be set to surfaces.
BoundCurveU=<value>
The ID of the curve to specify the U direction.  Renumbering will begin where it
            intersects the BoundCurveV.
BoundCurveV=<value>
The ID of the curve to specify the V direction.  Renumbering will begin where it
            intersects the BoundCurveU.
CompName=<value>
The prefix name of the components to create for beams and shells.
DeleteGeom=<value>
The option to keep or delete new geometries.  This is a mandatory option.
0 - Keep new geometries
1 - Delete new geometries
DestinationComp=<value>
The component organization.  This is a mandatory option.
0 - New component
1 - Current component
ElementID=<value>
The start ID for element numbering.
ElementU=<value>
The number of shell elements in each panel in the U direction.
ElementU=<value>
The number of shell elements in each panel in the U direction.
LineMark=<value>
The ID of the mark containing the input lines.  Valid values are 1 and 2.
NodeID=<value>
The start ID for node numbering.
NoIntersectLineMark=<value>
The ID of the mark containing the lines which are non-parallel and non-intersecting to
              LineMark.  Valid values are 1 and 2.
ManifoldSurf=<value>
The option to create mesh in the surfaces:
0 - Do not mesh surfaces
1 - Mesh surfaces
SurfaceMark=<value>
The ID of the mark containing the input surfaces.  Valid values are 1 and 2.
Tolerance=<value>
The tolerance for considering line intersections.

","Example
To create stiffened panel mesh between selected lines:
*createmark lines 1 37 39 41 43 52
*createmark lines 2 21-25
*stiffenedpanelmesh lines surfs LineMark=1 NoIntersectLineMark=2 SurfaceMark=2 BoundCurveU=49 BoundCurveV=25 Tolerance=2.9149397464082 CompName=mypanel DestinationComp=0 DeleteGeom=1 ElementID=2004 NodeID=1138 ManifoldSurf=0 ElementU=2 ElementV=3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
827,*summary,"Description
Prints or displays a summary from a specified template. 
","Inputs

template file
The name of the template file from which the format of the summary file will be
            obtained.
output file
The name of the file that the information will be printed out to (information will
            still be displayed on screen).
print
If set to 0, information will be printed only to screen. 
If set to 1, information will also be sent to printer.
all
0 - Only displayed portions of model will be taken into account when creating the
            summary template. 
1 - Everything will be taken into account regardless of whether it is displayed or
            not.

","Example
To obtain a component by component summary for everything in a Nastran model without printing it:
*summary(""nastran/components"", ""output.txt"", 0, 1)
","Errors
None.
"
828,*surface_rmesh,"Description
 Used by the R-Mesh macro to quickly generate a quad/tria shell mesh for rigid tool
        surfaces. 
","Inputs

min length
The smallest acceptable length of edges in mesh elements.
max length
The maximum acceptable length of mesh element edges.
chordal deviation
The maximum allowable chordal deviation between the edge of an element and the
            adjacent geometry.
fillet angle
The maximum allowable angle between two adjacent elements. Similar to chordal
            deviation, it determines the number of element edges that are used to describe the
            curvature of a given shape.

","Example
To create a mesh wuth a minimum element edge length of 0.5, a maximum element edge length
        of 30, and maximum chordal deviation of 0.1, and a maximum fillet angle of 15 degrees:
*surface_rmesh(0.5,30,0.1,15)
HyperMesh prioritizes these arguments in the same order that
        they are listed above: minimum length is top priority, followed by maximum length, then
        chordal deviation and minimum angle. Note that the final two arguments are given equal
        weight. 
In actual practice, some element edges may still be smaller than the min length parameter,
        because they also depend on the lengths of edges in the model geometry.
","Errors
None.
"
829,*surfaceaddpoint ,"Description
Add a fixed point on a surface at the specified coordinates.
","Inputs

surfptr
The ID of the surface.
x,y,z
The coordinates of the point.

","Example
The coordinates must be within tolerance of the surface. If the coordinates are within the
        geometry tolerance of an edge, a surface vertex is created. Otherwise, an interior fixed
        point is added to the surface. 
","Errors
None.
"
830,*surfacecone,"Description
Creates a full or partial cone, and optionally, prepares it for immediate use in the
        automesher. It also can identify a conical region for the automesher to use under the mesh
        without surface option. 
","Inputs

bottom center
A node specifying the center of the cone.
major vector
A node specifying the major axis. 
normal vector
A node specifying the axis which the cone spins around. The height is applied from the
            bottom center along the normal axis.
base radius
The radius of the bottom of the cone. 
top radius
The radius of the top of the cone. 
aspect ratio
A value less than 1.0 creates an elliptical cone or cylinder.
start angle
Angle at which the cone starts (0.0 to < end angle). 0.0 starts at the major
            vector.
end angle
Angle at which the cone ends (> start angle to 360.0). 
height
Height of the cone. 

","Example
To create an elliptical cone using nodes 1, 2, and 3, with base radius of 10, top radius of
        5, and height of 10, but not create any elements: 
*surfacemode(4)
*surfacecone(1,2,3,10.0,5.0,0.5,0.0, 360.0,10.0)
If the top radius and base radius are equal, a cylinder is created. 
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
831,*surfacecopyedges ,"Description
Create lines from the edges of a surface. 
","Inputs

surface
A surface that contains edges (a full sphere or torus does not contain edges). 
list
The mark ID of the nodes used to select the surface edges (if
              all_edges is 0). 
all_edges
1 - Copy all edges of the surface to new lines. 
0 - Only copy edges that have a node created on them (from list).

","Example
To copy all edges of surface 1 to new lines: 
*createlist(nodes,2)
*surfacecopyedges(1,2,1)
*createmark() is required for this command.
","Errors
None.
"
832,*surfacecreatedraglinealongnormal,"Description
This command creates surface(s) by offsetting the input lines in line_list along their
        curvature direction. The input lines must form a connected line; otherwise an error is
        given. The first line in the line_list determines the direction of the
        combined line, hence the start point, from which the offsetting starts. If the opposite
        direction for the combined line is desired, the corresponding value of
          reverse_dir must be set. 
If the offset value is negative, the direction opposite to curvature direction is used for
        offset. 
In the case where there is a discontinuity in the curvature direction at some point between
        the input lines, a link is inserted if link_type is chosen to be 2.
        However, if the change in the curvature direction is 180 degrees, then no link is inserted
        and the offset continues without any jump. In this case, after the discontinuity point, the
        offset follows the opposite direction of the curvature direction. 
","Inputs

line_list
The list ID of lines to be offset. Input lines must form a connected line when
            combined.
start_offset
The offset distance at the start of the combined line.
end_offset
The offset distance at the end of the combined line.
link_type
The type of link that is inserted between offset lines in the case where there is a
            discontinuity (other that 180 degrees) in the direction of the curvature: 
0 - The offset direction is interpolated on both sides of the discontinuity to allow a
            smooth transition. In this case, along the interpolation region, the offset direction is
            going to be different than the curvature direction. Amplified fluctuations, which would
            occur in the offset because of little ripples in the input curve, are smoothed out with
            this option. 
1 - No link is inserted, if there is a jump in offset direction at points where input
            lines meet. In this case, the offset lines might become disconnected.
comp_mode 
Parameter specifying how entities are organized into components: 
0 - Surfaces are created in the current component. 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.
reverse_dir
0 - The direction of the combined line is the same as the direction of the first line
            in the line_list. 
1 - The direction of the combined line is opposite to the direction of the first line
            in the line_list.

","Example
To create a surface by dragging lines 4 and 5 by an amount of 3.2 units at start and 5.0 at
        end.
*createlist lines 1 4 5
*surfacecreatedraglinealongnormal 1 3.2 5.0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
833,*surfacecreatedragnodesalongline,"Description
This command creates surface(s) by dragging a section line along a line. The section line
        is constructed smoothly from the nodes in sectionnodelist. The direction
        of the drag line is determined by choosing its start point, S, as the closest end of the
        line to the section line vertices. 
node_id and refplane arguments are optional and
        determines how the input lines are transformed before drag. 
The reconfiguration of the geometries before the drag is done as follows. Let P be the
        point referred by the node_id, N be the normal and B be the base point of
        the refplane and T be the tangent vector of drag line at S. First,
        section lines are translated by the direction vector PB. If Bit3 of the
        options is not set, then the section lines are rotated by the rotation from vector N to
        vector T. Also, the drag line is translated by the direction vector SB. The drag is applied
        to along this line L. So, if P is selected on a section line, the new location of P is going
        to be at B. Moreover, if P is one of the vertex points of the section lines, one gets an
        exact geometric copy of the drag line at B, no matter which drag method is chosen. This is
        because, prior to drag, P is moved to B and B moves on drag line since it coincides with the
        start point of the drag line L. 
If node_id is not given, it is chosen as the same point as S, the start
        of the drag line. This means, with the default value of node_id, the drag
        line is not transformed. 
If the reference plane is not given, their default values are B at P and N=T. This means,
        with the default value of transformation plane, the section lines are not transformed prior
        to drag. Note: The location of P is not important if fixed frame method is chosen with no
          transformation plane, since each point on the section surface traces an exact geometric
          copy of the drag line in fixed frame method. 

","Inputs

sectionnodelist 
The list containing the input nodes, forming the section line.
lines_list 
The list ID containing the lines that will be used to from the drag line. 
The first line in this list determines the direction of the drag, which is also shown
            on the screen. If the drag line has corners, then the new surfaces are split at those
            locations.
method
Parameter specifying the method of how the drag is performed. Valid options are: 
0 - Fixed frame 
1 - Follow the drag line only along its tangent direction 
2 - Follow the drag line along its Frenet frame
options
Flags that indicate different modes for the drag. Bit values are used and the value is
            calculated as (Bit0 + 4*Bit2 + 8*Bit3). Note that Bit1
            is not used. 
Bit0
0 - Drag along the direction of the drag line.
1 - Drag along the opposite direction of the drag line. 
Bit2
0 - Use the ref_plane input. 
1 - Do not use the ref_plane input. Instead, use its default
                  values. 
Bit3
0 - Use the whole ref_plane for transformation if it is
                  given. 
1 - Use the only the base point of the reference plane, set the normal as the
                  tangent of the drag line at drag start point.


comp_mode
Parameter specifying how entities are organized into components: 
0 - Surfaces are created in the current component. 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.
?node_id? (optional)
The ID of the node that is used as a reference point while determining how the
            surfaces are transformed prior to drag.
?ref_plane? (optional)
When provided, its value must always be 1. It is used to determine the initial
            reference frame. This plane is created using the *createplane
            command.

","Examples
Assume that you want to drag nodes with IDs 5, 6, 7 and 8 along the line that is formed by
        combining lines with IDs 37 and 25, using the fixed frame method. Assume that you want to
        drag along the direction opposite to the direction of line 37. Moreover, you want the
        resultant surfaces to be organized in the component of the lines. Then,
          options = 1, and comp_mode = 1. If you do not want
        to use any reference plane, use the following commands to create dragged surfaces. As a
        result one edge of the surfaces will be the input section lines, while the opposite edge
        will be an exact translated copy of that section line, and the side edged will be an exact
        translated copy of the drag-lines broken at possible vertex points.
*createlist nodes 1 5 6 7 8 
*createlist lines 1 37 25 
*surfacecreatedraglinealongline 1 1 0 1 1
In addition if you now want to use a reference node with ID 12 with some reference plane,
        then use: 
*createlist nodes 1 5 6 7 8 
*createlist lines 1 37 25
*createplane 1 1.0000 1.0000 1.0000 2678.0 -737.7 548.1 
*surfacecreatedragnodesalongline 1 1 0 3 1 12 1 
The surfaces created will be in such a way that the new location of the point on which node
        12 located, will be at the base point (2678.0, -737.7, 548.1) of the reference plane.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
834,*surfacecreatenurbs,"Description
This command creates generic NURBS type surface using input parameters.
","Inputs

udeg
Polynomial degree of u parameter.
vdeg
Polynomial degree of v parameter.
uk_count
Number of u parameter NURBS knots.
vk_count
Number of v parameter NURBS knots.
up_count
Number of NURBS control points in u parametric direction.
vp_count
Number of NURBS control points in v parametric direction.
ratnl
Parameter that specifies whether weights are used in addition to control points. Valid
            values are: 
0 - Use weights 
1 - Do not use weights
double_array
The ID of the double array that contains the value of the knots, control points and
            weights (if ratnl is 1). The double array is created using the
              *createdoublearray command. This should always be set to 1. 
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.

To reduce input, the usual NURBS convention that for the curve with polynomial degree
        degree first and last degree+1 knots must have the same value is enforced internally. Input
        for this command should only contain one value. For all internal knot values, multiplicity
        should still be provided explicitly. All knot values must be provided in non-decreasing
        order.
Values in double_array array should be arranged as follows: 
First uk_count entries - u parameter knot values. 
Next vk_count entries - v parameter knot values. 
Next up_count×vp_count×3 values are x, y, z values of control points. 
If ratnl is not zero then next up_count×vp_count entries are NURBS
        weights values. 
The poles and weights (if present) are arranged as a sequence of rows of a rectangular grid
        where one row corresponds to a constant v value and increasing u values. 
","Examples
To create a ruled surface connecting two parabolas:
*createdoublearray 22 0 1 0 1 0 0 0 1 0 0 0 1 1 1 1 1 0 2 0 1 2 1
*surfacecreatenurbs 1 2 2 2 2 3 0 1 22
To create a ruled surface connecting two circular arcs:
*createdoublearray 28 0 1 0 1 0 0 0 1 0 0 0 1 1 1 1 1 0 2 0 1 2 1 1 1 0.707 0.707 1 1
*surfacecreatenurbs 1 2 2 2 2 3 1 1 28
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
835,*surfacecreatespinlinewithoffsetangle ,"Description
Spins lines to create surfaces by specifying a start and end angle.
","Inputs

mark_id
The mark ID containing the lines that you wish to spin.
rotation_plane
The axis about which to spin the lines (plane normal is used as axis vector and the
            base point of the plane is used as the rotation center).
start_angle
Degrees value of initial rotation angle: selected lines are rotated by this value
            before surface ""sweeping"" begins.
end_angle
Degrees value of final rotation angle: surface ""sweeping"" stops at this value.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).
Bit0
Line merging mode. Valid values are:
 0 - Do not merge input lines. A surface is created for each input line. 
1 - Merge input lines into smooth lines when possible. A surface is created
                      for each group that forms tangentially continuous line.


Bit1
Specifies how entities are organized into components. Valid values are:
 0 - Surfaces are created in the current component. 
1 - Surfaces are created in the most common input lines component.





","Example
To spin line 2 from 45 to 90 degrees about an axis given by the vector (1 2 3) with
        rotation center at point (4 5 6), creating a surface of revolution in current component:
*createmark lines 1 2
*createplane 1 1 2 3 4 5 6
*surfacecreatespinlinewithoffsetangle 1 1 45 90 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
836,*surfacecreatetangentfromedges,"Description
Create surfaces extending in the tangent direction from the surfaces along selected edges.
        The new surfaces are created by dragging these surface edges along the tangent direction of
        the surfaces to which the master edges belong.  The newly created surfaces and the original
        surfaces are tangent to each other along the input edges.
","Inputs

mark_id
The ID of the mark containing the surface edges to use.  Valid values are 1 and
            2.
distance
The distance to extend the selected lines along the tangent direction.
extend_mode
0 - At the end of a chain of edges, the extension is done in the normal direction from
            the end edge
1 - The direction of the neighbor surface edge is followed to create the edge of the
            extension surface
Consider extending a triangular surface at one of its edges. When 0, the extension
            surface looks like a rectangle. But when 1, a trapezoidal extension surface is created,
            so that together with the original surface they form a bigger triangle.
component
0 - New elements go to current component
1 - New elements go to input line(s) component(s)

","Example
Create surfaces extending tangently from edges 75 and 68 by a distance of 12, with the new
        surfaces created in the same component as the input edges:
*createmark lines 1 75 68
*surfacecreatetangentfromedges 1 12.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
837,*surfacefilletremove ,"Description
Defeatures/removes selected fillet surfaces. 
When a fillet surface is removed, the replacement surface is built by extending the
        surfaces adjacent to the fillet surface and trimming them by mutual intersections. At the
        free edges of the fillet surface, an imaginary surface is built that intersects the fillet
        surface normally having the free edge. The imaginary surfaces are used to trim the
        replacement surfaces to form free edges. 
Sometimes, it may be necessary to change this default interpretation of fillet surface
        edges. For example, suppose that you want to replace a single fillet in a series of
        connected fillet surfaces. It is necessary to disconnect this fillet from the others by
        selecting the connecting edges and passing them as a second argument to the command. 
Another example involves building replacement surfaces for an isolated fillet surface. An
        isolated fillet does not have adjacent surfaces from which to build extensions. You can
        select edges that are connected to an imaginary surface that is to be extended and pass
        those edges as the first argument to the command. The extension surfaces are built as the
        surface tangent to the fillet surface at the selected edges.
","Inputs

surfs_mark_id
The ID of the mark containing the fillet surfaces to remove. Valid values are 1 and 2.
lines_mark_id1
The ID of the mark containing the fillet surface edges at which the extension surface
            replacing the fillet must be built. The extension surface is built by using the fillet
            surface instead of extending the surface that is adjacent to the fillet surface. Valid values are 1 and 2.
lines_mark_id2
The ID of the mark containing the fillet surface edges that are treated as free edges.
              Valid values are 1 and 2.

","Example
To remove fillet surface 241, while using the edge 635 to build a replacement surface as a
        tangent to the fillet surface, and treating edges 746 and 747 as free:
*createmark surfs 1 241
*createmark lines 1 635
*createmark lines 2 746 747
*surfacefilletremove 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
838,*surfaceintersectmark,"Description
Creates lines by intersecting surfaces with a plane or other surfaces. The line segments
        are organized into the current component.
","Inputs

mark_id
The mark ID containing the surfaces to intersect. Valid values are 1 and 2.
plane_flag
0 - Use mark_id2 to define the surfaces to use for the
            intersection. 
1 - Use plane_id to define the plane to use for the
            intersection.
plane_id
The ID of the plane to use for the intersection, if plane_flag is
            1. This is defined using the *createplane command.
mark_id2
The ID of the mark containing the surfaces to use for the intersection, if
              plane_flag is 0. Valid values are 1 and 2.

","Examples
To create intersection lines for the xy-plane with a base node of 0, 10, 0 with the
        displayed
        surfaces:*createmark surfaces 1 displayed
*createplane 1 0 0 1 0 10 0
*surfaceintersectmark 1 0 1 
To create intersection lines for the intersection of surfaces 1 and 2 with surfaces 10 and
        11:*createmark surfaces 1 1 2
*createmark surfaces 2 10 11
*surfaceintersectmark 1 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
839,*surfacemark_duplicate_check,"Description
This command takes surfaces from two different sets and checks if any surface in one set
        has an identical counterpart in another set. Optionally, reflection with respect to an input
        plane is used before checking identity. Only one set of surfaces may also be provided on
        input if mark_id2 is set to 0. If a plane is provided
          (use_plane = 2), then this single set is automatically split into two
        sets by the surfaces’ position with respect to the input plane. As a result of identity
        calculations, surfaces are removed or switched between input sets or returned depending on
        the input options parameter. 
As a result of surface sets symmetry calculation, input surfaces are separated into four
        sets. If there are two input sets provided, the meaning of the output sets is: 
output_set0 - no identical counterpart was found (unmatched) for surfaces of
              mark_id1.
output_set1 - identical counterpart was found (matched) for surfaces of
              mark_id1. 
output_set2 - no identical counterpart was found (unmatched) for surfaces of
              mark_id2.
 output_set3 - identical counterpart was found (matched) for surfaces of
              mark_id2. 


If only one input set is provided (mark_id2 is 0), the meaning of the
        output sets is: 
output_set0 - surfaces that do not have duplicate counterparts. 
output_set1 - ""master"" surfaces that do have duplicate counterparts (in the set of
            several identical surfaces, only one surface is selected as ""master""). 
output_set2 - ""slave"" surfaces that have duplicate counterparts. 
output_set3 - empty set.


","Inputs

mark_id1
The ID of the mark containing the first set of surfaces. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the second set of surfaces. Valid values are 1 and 2.
options
Integer value representing combination of flags used to modify command behavior. This
            parameter is composed of several ""action"" groups, with each group consisting of several
            possible values. The value of this parameter is a sum of the required values: 
Set selection group - bits 0…3: Since there is a limitation that only two mark
                values can be used to designate input sets and respectively the same two values are
                used to mark surfaces in output sets, this means that only two out of four output
                sets can be selected. 
Set selection bits group is used to indicate which of possible four output sets
                are returned on output. If corresponding to output set bit is set to 1, then
                surfaces from corresponding result set are selected. 
Mark inversion group - bits 4…7: If corresponding bit is not set, then output set
                is marked by the same mark as originating input set. If bit is set, the mark of
                another set is used instead. Those bits do not have any effect in case corresponding
                bit in set selection bits group is not set. Also, bits in this group do not have any
                effect in case both sets are the same. 
Highlight group - bits 9 and 10. If bit 9 is set, then surfaces in the output set
                marked by surf_set_mark_id1 are highlighted. If bit 10 is set,
                then surfaces in the output set marked by surf_set_mark_id2 are
                highlighted.


use_plane
0 - Check for identity of surfaces in two sets. 
1 - Use plane specified by plane parameter to reflect on of sets before checking
            identity. 
2 - All surfaces are assumed to be selected in only one set and they are rearranged
            into two sets by their position with respect to input plane before checking for their
            symmetry.
plane
A plane ID defining the symmetry plane.  Must be set to 1.
tol
Tolerance value used to calculate surfaces identity.

","Example
If you want to clean up the model so that it does not contain duplicated surfaces. That is,
        if there exists a set of two or more surfaces that are identical one would like to delete
        all but one of surfaces from this set. A tolerance of 0.1 is going to be used to identify
        surfaces. One puts all input surfaces into one set (mark 1) and selects value 4 for options
        to indicate that surfaces of output_set2 (""slave"" surfaces) have to be
        returned on the input
        mark.*createmark surfs 1 ""all""
*surfacemark_duplicate_check 1 1 4 0 1 0.1
*deletemark surfs 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
840,*surfacemarkaddnodesfixed ,"Description
 Add fixed points to a surface at locations specified by nodes. 
","Inputs

surf_mark_id
ID of the mark containing the input surfaces to add fixed points to. Valid values are 1 and 2.
node_mark_id
ID of the mark containing the nodes to use to define the fixed point locations. Valid values are 1 and 2.
tol
Tolerance value used to determine if a node is close enough to a surface.
reserved_1
Reserved parameter, must be set to 0.

","Example
To add fixed points to the surface with ID 12 at positions specified by nodes with IDs 1
        and 2:
*createmark nodes 1 1 2
*createmark surfs 1 12
*surfacemarkaddnodesfixed 1 1 0.1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
841,*surfacemarkclipwithlines,"Description
Splits a group of surfaces with lines by projecting those lines perpendicularly onto the
        surfaces.
","Inputs

surf_mark
The mark ID containing the surfaces.
line_mark
The mark ID containing the lines. The lines are temporarily combined into a single
            line, and therefore must be contiguous.
tolerance
The maximum distance the line may deviate from the surfaces and still be
            projected.

",,
842,*surfacemarkmerge,"Description
Combines the selected surfaces into one surface, and divides the surface along the internal
        edges that correspond to fillets and feature lines.
","Inputs

mark
The mark ID containing the surfaces.
breakangle
The threshold used to recognize feature lines.
minradius
The lower limit of the radius of curvature used to recognize fillets.
maxradius
The upper limit of the radius of curvature used to recognize fillets.

","Example
To combine a surface with a feature breakangle of 30.0 and fillet radii of 1.0 and
        15.0:*createmark(surfaces,1) 1 31 57 91 93 145 189 190
*surfacemarkmerge(1,30.0,1.0,15.0)
The *createmark() command is required. On the Geom Cleanup panel, this
        command corresponds to the organize by feature tool.
",
843,*surfacemarkremovelinefillets,"Description
Defeatures specific surface edge fillets.
","Inputs

mark_id
The mark ID containing the input surfaces. Valid values are 1 and 2.
min_radius
The minimum value of the fillet radius.
max_radius
The maximum value of the fillet radius.
min_angle
Minimum value of the fillet angle (in degrees).
double_array
The ID of the double array that contains the coordinates of the fillets to defeature.
            The double array is created using the *createdoublearray command.
            This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. 
This should be equal to 3 times the number of fillets being removed (x/y/z coordinates
            for each fillet).

","Example
To delete 3 edge fillets [(112.800768, -97.9869801, 90.4349669) (113.103246, 71.2980238 ,
        87.1212897) and (-118.799245, -97.7195516, 110.804638)] with a radius between 3 and 5, and
        an angle greater than 15
        degrees:*createmark surfs 1 all
*createdoublearray 9 112.800768 -97.9869801 90.4349669 113.103246 71.2980238  87.1212897 -118.799245 -97.7195516 110.804638
*surfacemarkremovelinefillets 1 3 5 15 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
844,*surfacemarksplitwithline,"Description
This command splits a mark of surfaces with a line swept along a vector.
","Inputs

mark_id
The mark ID containing the surfaces to split. Valid values are 1 and 2.
line_id
The line ID to use for splitting.
vector_id
The vector ID to use for the split direction. This is defined using the
              *createvector command.
trim_flag
0 - The line is swept using the distance value. 
1 - The line is swept through the entire surface.
distance
The distance to sweep, if trim_flag is 0.

","Example
To split surfaces 10 and 20 by sweeping line 11 along the
        z-axis:*createmark surfaces 1 10 20
*createvector 1 0.0000 0.0000 1.0000
*surfacemarksplitwithline 1 11 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
845,*surfacemarksplitwithnodes,"Description
Splits a group of surfaces with a smooth line defined by the nodes. 
","Inputs

mark
The ID of the mark containing the surfaces
node_list
The list ID of the node to be used.

","Errors
None.
",
846,*surfacemarksplitwithsurface ,"Description
 Splits a group of surfaces with another surface 
","Inputs

mark
The ID of the mark containing the surfaces to be split.
surface
The surface used to split the other surfaces.

","Example
To split surfaces 10 and 20 with surface 5:
*createmark(surfaces,1) 10 20
*surfacemarksplitwithsurface(1,5)

","Errors
None.
"
847,*surfacemode,"Description
Sets the mode for automesh surface and shell mesh generation.
","Inputs

mode
1 - Mesh, keep surface 
2 - Mesh, delete surface 
3 - Mesh without surface 
4 - Surface only 

","Example
To set the mode to mesh, delete surf:
*surfacemode 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
848,*surfaceprimitivefromlines ,"Description
This command takes input lines and uses them as targets to construct surface of specified
        primitive type. Optionally, tolerance value can be specified to reject surface that does not
        fit input lines. 
","Inputs

mark_id
The mark of input lines.
surf_type
The type of primitive surface to create. Valid values are: 
1 - plane 
2 - sphere 
3 - cylinder 
4 - cone 
5 - general quadric surface 
For surf_type 4, if a cylinder can be fit to the input entities, it
            will be created instead of a cone.
tol_mode
0 - Tolerance is not used, best possible surface is found for any input set of points. 
1 - Tolerance specified by tol parameter is used to reject surface
            that does not fit input points.
tol
Tolerance value used to accept generated surface. Not used if
              tol_mode is 0. Negative value can be set to specify that the global
            value of the geometry cleanup tolerance set using *setoption
              cleanup_tolerance should be used.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1). 
Bit0
Trimming mode. Valid values are:
0 - An untrimmed surface is created. 
1 - Created surface is trimmed by input lines and automatically stitched to
                      adjacent surfaces. 
In this case, the value of tol_mode should be set to 1.
                    


Bit1
Specifies how entities are organized into components. Valid values are: 
0 - Surface is created in the current component.
1 - Surface is created in the most common input lines component.





","Examples
To create a cone surface that fits all displayed lines in the best possible way:
*createmark lines 1 ""displayed""
*surfaceprimitivefromlines 1 4
To try to create a sphere that fits lines 1 through 8 with a deviation not larger than
        0.02, and trim the resulted surface with the input lines:
*createmark lines 1 1-8
*surfaceprimitivefromlines 1 2 1 0.02 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
849,*surfacereversenormals2 ,"Description
Reverses the normals of surfaces, and optionally any associated FE. 
The minimum set of surfaces to maintain overall normal direction consistency, without
        affecting other surfaces, is automatically adjusted based on the input selection.
","Inputs

entity_type
The type of entity to reverse normals for. Valid values are surfaces, solids and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn, if vector normal display is
            set. If set to zero, the vector is drawn at 10% of the screen size.
adjust_fe
If non zero, normals for elements associated with selected surfaces will be
            automatically adjusted to match the normals of their surfaces.

","Example
 To reverse the normals for surfaces 1-10 along with the associated FE, and to display the
        adjusted element normals with a size of 5.0:
*createmark surfs 1 1-10
*surfacereversenormals2 surfs 1 5.0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
850,*surfacespherefromfournodes ,"Description
Creates a sphere which passes through the four specified nodes, and optionally, prepares it
        for immediate use within the automesher. It can also identify a region in the shape of such
        a sphere for the automesher to use under the mesh without surface option.
","Inputs

list
The list of the four nodes through which the surface will pass. 

","Example
To create a sphere which passes through nodes 1, 2, 3, and 4, but not create any elements
        on the sphere: 
*surfacemode(4)
*createlist(nodes,1) 1 2 3 4
*surfacespherefromfournodes(1)
*createlist() is required for this command. The
          *surfacemode(4) directive tells HyperMesh
        not to pass the information on to the automesher for element creation. 
","Errors
None.
"
851,*surfacespherefull,"Description
Creates a sphere with a specified center and radius, and optionally, prepares it for
        immediate use within the automesher. It can also identify a region in the shape of such a
        sphere for the automesher to use under the mesh without surface option. 
","Inputs

center
A node specifying the center of the sphere. 
radius
The radius of the sphere. 

","Example
To create a sphere with center at node 1 and a radius of 45, but not create any elements on
        the sphere: 
*surfacemode(4)
*surfacespherefull(1,45.0)

The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
852,*surfacesplinefillholes2 ,"Description
Creates spline surfaces on all loops of selected lines. 
Both topological and free lines can be used for the loop for spline creation.  If lines are
        not connected into a closed loop, it will create connecting lines. If the selected lines are
        topological lines connected to some other surfaces, the tangency of the lines created to
        close the gaps in the loop should match the tangency of the connected surfaces.  The
        tangencies of the created splines match the tangencies of connected surfaces (if any). 
        Created splines are placed into the same components that selected lines belong to.
","Inputs

mark_id
The ID of the mark containing the input lines. Valid values are 1 and 2.
options
If set to 1, the edges of the new surface are suppressed. Otherwise the edges are not
            suppressed.

","Example
To create spline surfaces for lines 1-10, and suppress the edges between the new and
        existing surface:
*createmark lines 1 1-10
*surfacesplinefillholes2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
853,*surfacesplinefrompoints ,"Description
Creates a spline surface using selected nodes or points as boundary conditions.
","Inputs

entity_type
The type of entity to use as input. Valid values are nodes and points.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
options
Specifies options for creating the surface. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2)
Bit0
 Surface trim mode
0 - Trim by parametric rectangle. 
1 - Trim by points boundary.


Bit2
Mesh stitching. Used to control the connectivity of the mesh created on the new
                  spline surface in simultaneous meshing modes.
0 - New mesh is not connected. 
1 - If *surfacemode is set to 1, existing mesh nodes are
                      used if new spline edges are stitched to those lines.





","Example
To build a spline from the displayed points and do not connect mesh:
*surfacemode 1
*createmark points 1 ""displayed""
*surfacesplinefrompoints points 1 0
To build a spline from the displayed points and do not connect mesh:
*surfacemode 1
*createmark points 1 ""displayed""
*surfacesplinefrompoints points 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
854,*surfacesplineonnodesloop2 ,"Description
Creates a spline surface using a node list as boundary conditions. 
","Inputs

list_id
The ID of the list containing the input nodes. Valid values are 1 and 2.
The nodes should be selected in an order consistent with the intended trimming
            boundary of the constructed surface. No attempt is made to correct the input by
            rearranging the order of the nodes.
options
If set to 0, input nodes that were not already associated to any geometry get
            associated to the new surface. In addition, in simultaneous meshing modes set by
              *surfacemode, input nodes are taken into account to create
            connections between the new surface mesh and an already existing mesh. 
If set to 1, input nodes are not associated to the new surface and are not taken into
            account in simultaneous meshing modes.

","Example
To build a spline from the nodes 1, 2, 3 and 4:
*surfacemode 1
*createlist nodes 1 1 2 3 4
*surfacesplineonnodesloop2 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
855,*surfacesplitwithline ,"Description
Splits a surface with a line by sweeping the line along a vector. 
","Inputs

surface
The ID of surface to be split. 
line
The ID of the line used to split the surface. 
vector
The vector used to sweep the line.
entire_surf_flag
1 - The line is swept throughout the entire surface.
0 - The line is swept for a distance of distance
distance
The distance to sweep line, if entire_surf_flag is set to 0.

","Example
To split surface 1 by sweeping line 2 along the x-axis for a distance of 100: 
*createvector(3,1.0,0.0,0.0)
*surfacesplitwithline(1,2,3,0,100.0)

","Errors
None.
"
856,*surfacesplitwithsurface ,"Description
Splits one surface with another. 
","Inputs

surface1
The surface to be split
surface2
The surface used to split surface1. 

","Example
To split surface 1 with surface 2: 
*surfacesplitwithsurface(1,2)

","Errors
None.
"
857,*surfacetorus ,"Description
Creates a full or partial torus, and optionally, prepares it for immediate use in the
        automesher. It also can identify a toroidal region for the automesher to use with the mesh
        without surface option. 
","Inputs

center
A node specifying the major center of the torus.
major vector
A node specifying the major axis of the torus.
normal vector
A node specifying the normal axis of the torus.
minor radius
The minor radius of the torus.
major radius
The major radius of the torus.
major start angle
Angle at which the major radius of the torus starts (0.0 to < major end angle).
          
major end angle
Angle at which the major radius of the torus ends (> major start angle to 360.0).
minor start angle
Angle at which the minor radius of the torus starts (0.0 to < minor end
            angle).
minor end angle
Angle at which the minor radius of the torus ends (> minor start angle to 360.0).

","Example
This example creates the bottom half of a torus with center at node 1, normal vector at
        node 12, major vector at node 4, and a major radius of 10 and a minor radius of 2.5, but
        does not continue to the automesher for element creation: 
*surfacemode(4)
*surfacetorus(1,12,4,2.5,10.0,0.0000,360.0000,180.0000,
   360.0000)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
858,*surfacetorusfull,"Description
Creates a torus with specified radii, and optionally, prepares it for immediate use in the
        automesher. It also can identify a toroidal region for the automesher to use with the mesh
        without surface option.
","Inputs

center
A node specifying the center of the torus. 
normal vector
A node specifying the normal axis of the torus. 
minor radius
The minor radius of the torus. 
major radius
The major radius of the torus. 

","Example
To create a torus with center at node 1, normal at node 2, a minor radius of 5, and a major
        radius of 10, but not create any elements: 
*surfacemode(4)
*surfacetorusfull(1,2,5.0,10.0)

The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
859,*surfmark_trim_by_surfmark ,"Description
Trims surfaces along the intersection(s) with other surfaces.
","Inputs

mark_id1
The ID of the mark containing the selection of surfaces to be trimmed. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the selection of surfaces to use as the trim tool. Valid values are 1 and 2.
mode


0 - Surfaces on mark_id1 are trimmed by the surfaces on
                  mark_id2

1 - Surfaces on both marks trim each other 
2 - Surfaces on mark_id1 are trimmed by virtually extending
                surfaces of mark_id2



","Example
To trim all surfaces on mark 1 by those on mark 2:
*createmark surfs 1 1-100
*createmark surfs 2 101-200
*surfmark_trim_by_surfmark 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
860,*swapcontactmasterslave,"Description
Swaps the master and slave entities of groups.Note:

In OptiStruct, if slave is a set of nodes, on swapping
              it is converted to set of elements.
In Samcef, it is used to swap master-slave entities of
              groups MCT and STI. New master and slave entities are created on swapping based on the
              entity types supported specific to element type and contact type.



","Inputs

mark_id
The ID of the mark containing the groups to update. Valid values are 1 and 2.

","Example
Swap master and slave entities of groups with IDs 1 and 2:
*createmark groups 1 1 2
*swapcontactmasterslave 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
861,*system,"Description
Creates and updates coordinate systems.
<option>=<value> options can be provided in any order.
","
Inputs



entity_type

The type of input entity. Must be set to nodes.

axisname=<value>

The name of the axis to define. This is required. Valid values are:
x-axis
y-axis
z-axis

axisnode=<value>

The axis node ID.  This is required if coordinate values axisx,
              axisy and axisz are not given.

axisx=<value>

The axis x coordinate value.  This is required if axisnode is not
            given.

axisy=<value>

The axis y coordinate value.  This is required if axisnode is not
            given.

axisz=<value>

The axis z coordinate value.  This is required if axisnode is not
            given.

NodeMark=<value>

The ID of the mark containing origin nodes at which to create systems.  This is
            required if originx, originy and
              originz or originnode are not given.

planename=<value>

The name of the plane to define.  This is required.  Valid values are:
xy-plane
xz-plane

originnode=<value>

The origin node ID.  This is required if originx,
              originy and originz or
              NodeMark are not given.

originx=<value>

The origin x coordinate value.  This is required if originnode and
              NodeMark are not given.

originy=<value>

The origin y coordinate value.  This is required if originnode and
              NodeMark are not given.

originz=<value>

The origin z coordinate value.  This is required if originnode and
              NodeMark are not given.

planenode=<value>

The plane node ID.  This is required if planex,
              planey and planez are not given.

planex=<value>

The plane x direction coordinate value.  This is required if
              planenode is not given.

planey=<value>

The plane y direction coordinate value.  This is required if
              planenode is not given.

planez=<value>

The plane z direction coordinate value.  This is required if
              planenode is not given.

system=<value>

The system ID to be edited.

type=<value>

The type of system to create.  This is required.  Valid values are:
0 - Rectangular
1 - Cylindrical
2 - Spherical

","Examples
To create a new rectangular system:
*system nodes type=0 originx=0.01 originy=0.2 originz=0.3 axisname=z-axis axisx=0.3 axisy=0.4  axisz=0.2  planename=xz-plane  planex=0.4  planey=0.6 planez=0.7
To update a system:
*system nodes type=RECTANGULAR originx=0.01 originy=0.2 originz=0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
862,*systemconvertnodetoaxis,"Description
Converts systems from nodal reference to axis reference.
Supported only for OptiStruct and Nastran profiles.
","Inputs

mark_id
The ID of the mark of systems to conver.  Valid values are 1 and 2.

","Example
Convert systems 2-5:
*createmark systems 1 2-5
*systemconvertnodetoaxis 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
863,*systemorthobound,"Description
 Makes sure that a child system lies within the specified euler angle bounds with respect
        to the parent child system. If it does not, it moves the child system in the most direct
        path so that it does. 
","Inputs

child system id
The ID of the child system - the system that will be moved if it is not within the
            bounds of the parent.
parent system id
The ID of the parent system.
xmin
The minimum x euler angle.
xmax
The maximum x euler angle.
ymin
The minimum y euler angle.
ymax
The maximum y euler angle.
zmin
The minimum z euler angle.
zmax
The maximum z euler angle.

","Examples
Two systems, system 1 and system 2, are slightly misaligned and need to be reset. We want
        system 2 to be aligned exactly with system 1. Use the following command:
*systemorthobound(2, 1, 0, 0, 0, 0, 0, 0)
System 2 should be no more than +/-10 euler degrees on the x axis from System 1. If it is,
        it should be aligned to fall within those bounds. Use the following command:
*systemorthobound(2, 1, -10, 10, 0, 0, 0, 0)
When it is determined that the child system does not lie within the bounds of the parent
        system, the three euler angles are first independently set so that they lie within the min
        and max parameters. The child system is then reset and rotated to its new position.
        Therefore, for the following case:
*systemorthobound(2, 1, -10, -10, -10, 10, 10, 10)
Where system 2’s euler difference (with respect to system 1) is 20, -30, 5, system 2 will
        be rotated so that it goes to 10, -10, 5. 
Because there are many euler angles for different system positions, unpredictable results
        may occur if the systems are not already closely aligned and when there is a great
        difference between the min and max parameters. 
","Errors
None.
"
864,*tableaddrow,"Description
Adds a row of data to the bottom of a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the row data to add. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.

","Example
To add a row of data to ""table1"" which has 7 columns with data types (integer, string,
        double, elements, integer, double, properties):
*createstringarray 7 1 abc 4.567 500 10 3.14159 100
*tableaddrow ""table1"" 1 7
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
865,*tablecreate ,"Description
Adds a row of data to the bottom of a table.
","Inputs

name
The name of the table to create.
color
The color of the table. Valid values are 1-64.
config
Currently reserved for future use. Must be set to 1.
string_array
The ID of the string array that contains the data type of each column. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid column data types are:
bool 
string 
int 
unsignedint 
float 
double 
triple 
HM 
entity 
types (e.g. elements, plies, components, etc...)


number_of_columns
Integer indicating the size (number of strings) in the string array created
              using *createstringarray. This must equal the number of columns in
            the table.
number_of_rows
Integer indicating the number of rows to pre-reserve in the table.

","Example
To create a table named ""table1"" with color 3, 4 columns of data (integer, double, string,
        elements), and no pre-reserved rows:
*createstringarray 4 INT DOUBLE STRING elements
*tablecreate table1 3 1 1 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
866,*tabledeleterow,"Description
Deletes a row of data from a table.
","Inputs

name
The name of the table to update.
row_index
The index of the row to delete. Tables are indexed starting from 1 (1 to n rows). If
            specified as 0, the last row in the table is deleted.

","Examples
To delete the last row from table1, which has 11 rows:
*tabledeleterow table1 0
or
*tabledeleterow table1 11
To delete row 3 from table1:
*tabledeleterow table1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
867,*tableinsertcolumn ,"Description
 Inserts a column of data into a table.
","Inputs

name
The name of the table to update.
data_type
The data type of the column. See *tablecreate for valid
            values.
column_label
The label of the column.
string_array
The ID of the string array that contains the column data to add. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of rows in the
            table.
column_index
The index of the column to insert. Tables are indexed starting from 1 (1 to n
            columns).

","Example
To insert column 4 of type integer and label INTEGERS to ""table1"" which has 7 rows:
*createstringarray 7 1 2 3 4 5 6 7
*tableinsertcolumn ""table1"" int INTEGER 1 7 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
868,*tablepopulate ,"Description
Populates an existing table with data from a delimited file. The data in the file must
        match the format of the columns defined in the table. Additional rows are appended to the
        table and existing data remains.
","Inputs

name
The name of the table to populate. The table will be overwritten with the data from
            the file.
filename
The full path and filename of the file to use to populate the table.
delimiter
The character or string to use as the delimiter. The value must be enclosed in quotes.
            If not specified, the default is a comma (CSV).

","Examples
To populate table1 with C:/table1.csv, which is a comma delimited
        file:
*tablepopulate table1 C:/table1.csv "",""
or
*tablepopulate table1 C:/table1.csv
To populate table1 with C:/table1.txt, which is a space delimited
        file:
*tablepopulate table1 C:/table1.txt "" ""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
869,*tableupdatecolumn ,"Description
Updates the values in a column of a table.
","Inputs

name
The name of the table to update.
data_flag
A flag defining if the data_type and column data contained in
              string_array should be updated (1) or ignored (0).
data_type
The data type of the column. See *tablecreate for valid values.
            Ignored if data_flag=0.
column_label_flag
A flag defining if the column_label should be updated (1) or
            ignored (0).
column_label
The label of the column. Ignored if column_label_flag=0
string_array
The ID of the string array that contains the column data to update. The string array
            is created using the *createstringarray command. This should always
            be set to 1. Ignored if data_flag=0.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table. Ignored if data_flag=0.
column_index
The index of the column to update. Tables are indexed starting from 1 (1 to n
            columns).

","Example
To update the data of column 3 of ""table1"" which has 7 rows of integers, but ignore the
        label:
*createstringarray 7 1 2 3 4 5 6 7
*tableupdatecolumn table1 1 int 0 """" 1 7 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
870,*tableupdaterow ,"Description
Updates the values in a row of a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the row data to update. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.
row_index
The index of the row to update. Tables are indexed starting from 1 (1 to n rows).

","Example
To update row 3 of ""table1"" which has 7 columns with data types (integer, string, double,
        elements, integer, double, properties):
*createstringarray 7 1 abc 4.567 500 10 3.14159 100
*tableupdaterow table1 1 7 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
871,*tangentbetweennodeandline,"Description
Creates a tangent line between a node and a line. 
","Inputs

node id
The ID of the node to which the tangent line is to be created. 
line id
The ID of the line to which the tangent line is to be created. 
checkpoints
The number of points to check in each line segment for tangency. 
lineselected
The tangent line selected, if more than one exists. 

","Example
To create a tangent between node 1 and line 10: 
*tangentbetweennodeandline(1,10,10,0)
If more than one tangent line is found, you must select the necessary tangent line. The
        number of this line (based on the order in which the tangents were found) is then used in
        the command string as lineselected. 
","Errors
None.
"
872,*tetmesh,"Description
A general single tetra mesh operation can involve a command block consisting of zero or
        more calls to *tetmesh_set_input followed by one call to
          *tetmesh. *tetmesh can take up to two different
        entity input/selections and *tetmesh_set_input supplies additional entity
        selections (up to four more) to *tetmesh. 
The following discussion applies to the entire tetra mesh command block. 
In the command argument list each triplet entity_type
mark_id mode specifies a set of entity input that either define a part of
        the boundary of the meshing volumes or the element size control boxes. 
An entity input with mark_id as 0 or mode as -1 is
        considered an inactive input. Inactive inputs are ignored inside the commands. However, for
        an inactive input, entity_type still must be a valid entity name. An
        input can be empty and still active. An empty active input with mode 6 will be auto filled
        internally. 
If there are inputs with mode 2 or 3, the resulting mesh is called a CFD mesh. Otherwise,
        it is called a non-CFD mesh. 
Also, note that not all combinations of the triplet values are valid. The general rules for
        all active entity inputs and the internal handling of these inputs are as follows and all
        must be satisfied: 
Must have at least one active input. 
Up to 7 inputs can be used but, each active mode value can appear no more than once. 
Modes 0, 1, 2, 3 and 6 are for boundary inputs of the meshing volumes. For these
            modes, inputs with entity_type as elems or comps are boundary inputs
            by elems; inputs with entity_type as solids or surfs are boundary
            inputs by geoms. All boundary inputs must be either all by elems or all by geoms. 
For an input by elems with modes 0, 2 and 3, all elems other than 2D elems are
                ignored.
For an input with mode 1, both 1D (plotel) and 2D elems are acceptable. In this
                case, 1D elems specify the elem edges that must appear in the final mesh. 
For an input with mode 6, all elems other than 3D elems are ignored. 


For inputs by geoms, all surfs without a pre-existing mesh are treated as float
            regardless of the mode of input. Internally, these surfs are auto-meshed with the 2D
            meshing parameters passed in through the string_array argument. 
There can be no more than one input with entity_type as solids.
            That is, if there is one solids input, all other boundary inputs must have
              entity_type as surfs. It is further required that all these surfs
            selections are on the selected solids (other surfs are silently ignored). 
For mode 4, entity_type must be comps. The selected entities must
            be the specially constructed components for size control boxes (others are silently
            ignored). 
For mode 5, entity_type must be nodes. The nodes that are too close
            to other anchor nodes or that are outside of the meshing volumes or too close to the
            boundary of the meshing volumes are ignored. 
For an input with mode 6, all boundary inputs must be by elems. All other boundary
            inputs are considered as 2D baffles (and 1D constraints). An empty input with mode 6
            will be auto filled internally by the inputs of baffles (modes 0, 1, 2 and 3), size
            control boxes (mode 4) and anchor nodes (mode 5). Otherwise, all entities with input
            modes 0-5 that fall outside of the 3D selection or too close to the boundary of the 3D
            selection are ignored. 
If a single command has two active entity inputs, the mark_ids must
            be different. 
Inputs with different modes are allowed to have overlapping selections. The overlaps
            are resolved inside the command. The general rule is that the input in an earlier
            command has the higher priority; while within a command the later input has the
            priority. If an input has ent=solids, it always has the lowest priority regardless its
            position in the input order.


","Inputs

entity_type1
The first entity type. Valid values are nodes, elems, comps, surfs, and solids.
mark_id1
The mark ID containing the first entities. Valid values are 0 (inactive input), 1 and
            2.
mode1


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer 
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL,
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.



Note: If one of the float inputs is set to remeshable by either a mode listed above or
              by the ""shell_remesh"" parameter in the ""pars:…"" string, all float inputs are set to
              remeshable. Otherwise, all floats are swappable only except for the non-BL input that
              receives BL imprinting. 

entity_type2
The second entity type. Valid values are nodes, elems, comps, surfs, and solids. 
mark_id2
The mark ID containing the second entities. Valid values are 0 (inactive input), 1 and
            2.
mode2


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer 
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL, 
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.


string_array
The ID of the string array that contains the array of meshing parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each argument can be either space or comma separated.
There are 6 types of strings which can be passed, as indicated below. Different
            combinations of these strings can be passed, based on the specific meshing
            requirements.

Options for checking the validity of the input
        mesh:""shchk: mode prox_tol angle_tol""At least one
        of the two entity inputs needs to be filled. The check functionality takes only elems or
        comps as input and only shell elems are considered. If only one input is filled, the check
        is a ""self"" check, that is, all elements causing interference are collected. If both inputs
        are non-empty, the check is a ""mutual"" check, that is, an interference pair is collected
        only if it involves both inputs.
The message bar provides a brief view of what is detected. For example:
32790 elems:x=34698 pairs, prx=168@0.001/min1.91e-7, angle=3@0.5, dups=0 on 0
32790 elems - Input has 32790 shell elements
x=34698 pairs - Found 34689 self-intersecting element pairs
prx=168@0.001/min1.91e-7 - Found 168 proximiy element pairs for threshold distance
            0.001 with the worst being 1.91e-7
angle=3@0.5,min0.01 - Found 3 elem pairs having dihedral angle < 0.5 degrees, with
            the worst being 0.01 degrees
dups=45 on 10 - Found 45 duplicated shell element pairs involving a total of 10 shell
            elements




mode
Tetra mesh options. Bit values are used and the value is calculated as
                (Bit0_Bit1 + 16*Bit4 + 32*Bit5).
Bit0_Bit1: Volume analysis:
0 - Reserved
1 - Do per-volume check after analyzing volumes using inward-positive
                  orientation (inside is positive). It is an error if the input does not form
                  volumes. For proximity, proximities on the positive side are collected. For
                  dihedral angle, as orientation is used, an angle ""A"" is distinct from ""360-A"" ( as
                  opposed to without orientation value=3, ""A"" is equivalent to ""360-A""). 
2 - Do not analyze volumes, but element normal is used. To have the orientation
                  meaningful, user needs to adjust the input to a consistent normal before doing the
                  check here (for orientation effect, see the per-volume check above).
3 - Do not analyze volumes and do not use orientation . Two sides of each
                  element are treated equally.


Bit4: Collection options.  The specially names are:
^err_x_elems - Elements having self-intersections
 ^err_prx_elems - Elements having failing proximity (no
                  self-intersection)
^err_agl_elems - Elements having failing dihedral angle

Note: Each comp or set can only collect the same element once. That is, all pair
                info are lost.

0 - Detected elements are duplicated in specially named comps (red color) 
1 - Detected elements are pladed in specially named sets


Bit5: Group-by cluster options:
0 - Do not further classify detections by cluster
1 - Further classify detections by clusters. A cluster is a set of elements
                  related by adjacency and interference pairing. With this option, each cluster has
                  its own comp or set having the name appended with _<cluster_id> (e.g.
                  ^err_x_elems_2.


prox_tol
A threshold value for proximity detection. Input elements having a distance to other
              input elements less than this value are collected in comps or sets depending on
                mode. Two elems may have proximity only if they do not share an
              edge, and at least one is in the forward (or backward) cone of the other. The shape of
              the cone is defined internally.
< 0.0 - Proximity detection is disabled
= 0.0 - Detect only self-intersection
> 0.0 - Detect both self-intersection and proximity
angle_tol
A threshold value for dihedral angle detection. Input elements having a diheral
              angle to other adjacent input elements less than this value are collected in comps or
              sets depending on mode.
< 0.0 - Angle detection is disabled


Tetra meshing parameters that control the tetra core part of the mesh. This is required for
        all meshing types:""tet: tet_opts growth_rate uniform_layers max_size qt_ratio min_size min_height""
tet_opts
Tetra mesh options. Bit values are used and the value is calculated as
                (Bit0_Bit1_Bit2 + Bit5_Bit6_Bit7 + 256*Bit8).
Bit0_Bit1_Bit2: Core tetra mesh and optimization method.
0 - Unused. 
1 - Normal. 
2 - Optimize for performance. 
3 - Optimize for quality. 
4 - Generate boundary layer only. Valid only if there are boundary layer
                  inputs.


Bit5_Bit6_Bit7: Quad transition settings. Used only if there are
              fixed quad inputs.
0 - Keep quads as-is. Only valid for BL only mode. 
32 - Build a layer of 1 pyramid per quad transition. 
64 - Build a layer of 5 pyramids and 2 tetras per quad transition. 
96 - BL hexas are split into prisms for all layers. 
128 - BL elems are split into tetras for all layers.


Bit8: Elems-to-geometry flag. Effective only for non-CFD meshes
              with inputs by geoms. For CFD mesh, the elems are always placed in fixed comps with
              special names. For all other cases, elems go to the current comp. 
0 - Elements to current component. 
256 - Elements to geometry component.


Bit10: Fix midnodes flag. The method of optimazing the midnode of
              2nd order tets that are on surfaces. 
0 - Surface midnodes are allowed to move to an optimazed location.
1024 - Surface midnodes will be made fixed (no relocation).


growth_rate
The tetra mesh elem size growth rate for the boundary (typical 1.2, range
              >1.0).
uniform_layers
The number of tetra layers that are to have uniform elem sizes (typical 2.0, range
              >0).
max_size
The limit on the max elem size. A value of 0.0 means no limit (typical 0.0).
qt_ratio
Affect only the quad transition layer. This determines the layer height as a
              fraction of the local 2D elem size (typical 0.8).
min_size
The nominal lower bound for the element size. A value of 0.0 means not bounded
              (typical 0.0).
min_height
The minimal element height. A value of 0.0 means not bounded (typical 0.0).
If not specified, the command behaves as if this capability was not
              implemented.


CFD boundary layer meshing parameters. This is only required if one or more boundary
        selections are of mode=2 or mode=3:""cfd: cfd_opts bl_thick0 bl_thicktotal bl_growthrate size_trans_flag""
cfd_opts
Flags for smooth/native boundary layer meshes.
Bit0: Split mode. Effective only for native boundary layers or when size_trans_flag=1.
0 - All 3D non-tetra elems are split into tetras. 
1 - Prism and pyramid elems in the boundary layer are not split into
                  tetras.


Bit1: The main boundary layer mode.
0 - Native boundary layer method is used. 
2 - Smooth boundary layer method is used.


Bit2-Bit3: Boundary layer total thickness mode. Effective only for smooth boundary
              layer method.
0 - bl_thicktotal specifies the total boundary layer
                  thickness.
4 - bl_thicktotal specifies the total number of boundary
                  layers.
8 - bl_thicktotal specifies the ratio of the total boundary
                  layer thickness over the average input elem size.


Bit4: Non-boundary layer remesh mode. Effective only for smooth boundary layer method.
0 - The float non-boundary layer inputs that intersect the boundary layer elems
                  are morphed to accommodate the boundary layers.
32 - The float non-boundary layer inputs that intersect the boundary layer
                  elems are imprint-remeshed to accommodate the boundary layers.


Bit5: Distribute boundary layer thickness mode. Effective only for smooth boundary
              layer method.
0 - No special boundary layer thickness distribution.
64 - The special load comp ^CFD_BL_Thickness is used to extract the boundary
                  layer thickness reduction ratio distribution. Note that this component needs to be
                  pre-constructed with either the auto or manual boundary layer thickness generation
                  utilities.


Bit7: Special comp cleanup mode. Effective only for smooth boundary layer method.
0 - Do not delete elements in special CFD_boundary_layer and CFD_tetramesh_core
                  components first.
128 - Delete elements in special CFD_boundary_layer and CFD_tetramesh_core
                  components first.


Bit8: Determines if multiple normals should be used for baffle edges or inward sharp
              edges that are sharper than a given threshold angle. This threshold angle is 1.5
              degrees by default and can be reset byunoffsettable_angle in the
              ""pars:…"" string below.
0 - Collapse BL for nodes on the baffle edges and inward-sharp edges.
256 - Use multiple normals (currently 2) per node on the baffle edges and
                  inward-sharp edges so to generate a wrapping BL around them.


bl_thick0
The first layer thickness.
bl_thicktotal
Either the total boundary layer thickness, or the number of layers, depending on
                cfd_opts. Effective only for the smooth boundary layer
              method.
bl_growthrate
The boundary layer growth rate (typical 1.1, range >1.0).
size_trans_flag
The boundary layer to tetra core elem size transition mode. Effective only for
              smooth boundary layer method. If set to 1, the boundary layer heights are smoothly
              transitioned to the core elem size whenever possible. In rare situations where the
              smooth boundary layer is unable to be built for some baffle elems, activation of this
              mode may cause meshing failures.


For elem size control box:""size_ctrl: x1 y1 z1 x2 y2 z2 … x8 y8 z8""

This string contains 25 double numbers and inputs a single size control box. Note, a
              size control box can be input also using components that are specially pre-constructed
              for size control boxes (see *tetmesh_create_size_ctrl). The first 24 numbers above
              consist of 8 triplets that each defines the 3d coordinates of a corner of the control
              box. The corners are ordered the same as an hm hex element. The last number is the
              target element size for elems inside and near the box.


For the 2D auto meshing parameters, which are used for meshing unmeshed input surfaces.
        This is required only for meshing by geometries:""2d: elem_order elem_type mesh_type elem_size min_size max_angle use_existing_mesh""
elem_order
The element order. Should be the same as the global elem order setting. Valid values
              are 1 and 2.
elem_type
The element type. Valid values are:
0 - trias
1 - quads
2 - mixed
3 - R-trias
4 - quads only


mesh_type
The mesh type. Valid values are:
1 - No chordal and no curvature and no proximity
2 - Chordal and no curvature and no proximity
3 - No chordal and no curvature and proximity
4 - Chordal and curvature and proximity
5 - Chordal and curvature and no proximity


elem_size
The 2D element size.
min_size
The minimum element size.
max_angle
The feature angle in degrees (typically 30).
elem_size


0 - Recreate 2D mesh on input surfaces even if there is an existing mesh
1 - Create 2D mesh only on the input surfaces that do not have an existing mesh
                  (default)




Other meshing parameters that either aren't categorized, or are less used. Pairs are
        separated by either a space or a comma. In general a key may have a default off-value and a
        default on-value. When a key is not present in the ""pars..."" string, it assumes the default
        off-value; while when the key is in the ""pars:…"" string without the ""=value"" part, it
        assumes the default on-value. Note also, not all keys have default on-values. In this case
        the ""=value"" part is mandatory.

""pars: key1=value1 key2=value2 …""

aft/delauney/octree


aft - Node insertion based on the legacy advancing front method.
delauney - Node insertion based on the Delauney method (default if not
                  specified).
octree - Node insertion based on the octree method.




Integer value parameters:
auto_cfd_bc
If on, the floating input shell elements will be updated by the corresponding faces
              of resulting solid elements.
0 - Do not reclassify interfacial input elements (default off)
1 - All interfacial input elements between meshing fluid volumes are auto
                  reclassified as float non-BL input regardless of how they are specified on input
                  (default on)


bdr_iso_lyrs


0 - Do not create isotropic layered mesh (default off)
1 - Create isotropic layered mesh (default on)


feature_angle
Valid only if skip_aflr3 is on. The feature angle to use for tet
              mesh optimization.
fill_void
Determines if auto-detected voids are to be meshed.
0 - No fill (default off)
1 - Fill (default on)


fix_comp_bdr
Preserves the boundary between input components.
0 - Do not preserve (default off)
1 - Preserve (default on)


fix_top_bdr
Valid only if skip_aflr3 is on.
0 - Node-wide (as opposed to topologically) preserve the surface boundary while
                  doing tet mesh optimization (default off)
1 - Topologically (as opposed to node-wise) preserve the surface boundary while
                  doing tet mesh optimization (default on)


niter
Valid only if skip_aflr3 is on. The max iterations to use for tet
              mesh optimization. Must be a value >= 0. The default off is 0 and there is no default
              on value.
nlayer_tet
The minimum number of tetra mesh layers, >= 1 (default 1).
no_tetra_has_2btri


0 - Do not prevent any resulting tetra from having more than one face on a
                  boundary (default off)
1 - Prevent any resulting tetra from having more than one face on a boundary
                  (default on)


post_cln
If on, if tet meshing fails, the shell elements are checked and cleaned before tet
              meshing is retried.
0 - Do not clean after tet failure (default off)
1 - Clean after tet failure (default on)


pre_cln
If on, input shell elements are checked and cleaned before tet meshing.
0 - Do not clean (default off)
1 - Clean (default on)


shell_remesh


0 - Swap only (default off)
1 - Float input can be remeshed (default on)


shell_swap
Valid only if skip_aflr3 is on. The input triangles are swappable
              only while doing tet mesh optimization.
shell_validation


0 - Do not check shell validity before tet meshing (default off)
1 - Check shell validity before tet meshing (default on)


skip_aflr3


0 - Do not skip AFLR3 (default off)
1 - Skip AFLR3 (default on)


upd_shell
If on, the floating input shell elements will be updated by the corresponding faces
              of resulting solid elements.
0 - Do not update float shells (default off)
1 - Update float shells (default on)


task


0 - Normal run (default off)
1 - Initial tetra Delaunay, only an initial tetra Delaunay mesh with minimum
                  insertion of nodes will be created. The inserted nodes are only for the purpose of
                  a successful recovery of the boundary shell.
64 - Generate a convex hull of inputs.




Double value parameters:
bl_core_r
The dynamic BL thickness reduction parameter for avoiding BL collisions. Valid
              values are:
1.0 - Disabled (default off value).
> 0.0 - Enabled with the specified value as the thickness ration of the tetcore
                  thickness vs the BL thickness.


bl_corer_r
The dynamic BL thickness reduction parameter for sharp corners for avoiding BL
              collisions. Valid values are 1.0 >= value > 0.0. The default off value is 0.3.
1.0 - Disabled (default off value).
> 0.0 - Enabled with the specified value as the thickness ration of the tetcore
                  thickness vs the BL thickness.


bl_int_lyrs
The initial number of BL layers that are to be interpolated, instead of done by
              smoothing layer-by-layer. A value >= 0.0, with a default off value of 0.0.
bl_iter_max
The max BL per layer smooth interations, between 0.0 and 3000. 0.0 means
              auto-calculate. The default off value is 0.0.
bl_res_thr
The BL smooth relative residue convergence criteria, between 0.0 and 1.0. At any
              smooth iteration, if the worst relative residue is below this value, smoothing is
              performed. 0.0 means auto-calculate. The default off value is 0.002.
unoffsettable_angle
A threshold angle in degrees, between 0.0 and 45.0. An element edge is classified as
              inward-sharp if the inward-dihedral angle is sharper than this threshold. Baffle edges
              are always considered as sharp edges. BL on a sharp edge is handled either by BL node
              collapsing or BL wrapping by multiple normals per node depending on bit 8 of
                cfd_flags options in the ""cfd:…"" string. The default off value is
              1.5.
shell_dev=<off geom>,<along geom>
Defines the optional allowed deviation off and along the ""geometry"" while improving
              tet quality.  A typical value might be shell_dev=0.01,0.1.


Quality parameters, any combination can be used:
aspect
Aspect ratio. Range > 1.0, typical is 8.0.
cell_squ
Cell squish. Range [0-1.0], typical is 0.9.
skew
Skew. Range > 0.0, typical is 60.
stretch
SimLab stretch criteria=sqrt(R/Lmax) where R is the radius of the inscribed sphere
              and Lmax is the longest tet edge. For an equilateral tet, stretch is 1. Range [0-1.0],
              typical is 0.1.
tet_clps
Tet collapse. Range [0-1.0], typical is 0.1.
vol_ar
Volumetric aspect ratio. Range > 1.22, typical is 8.0.
vol_skew
Volumetric skewness. Range [0-1.0], typical is 0.95.


For saving mesh to file. This string is optional and it is mainly for large model handling.
        When this string exists, the resulting mesh will not be created on the HM database. Instead,
        it will be written directly to the indicated file in Nastran format.""save_as: file_path""
file_path
The file path to save the mesh. If the path has spaces, it should be double quoted
              by \"" pairs (e.g. ""save_as: \""C:\Program Files\mesh.dat\"""").


For advanced control of tetra meshing core. These parameter values take precedence over
        those defined by the tetra meshing string. Each name/value pair must be a proper parameter
        string name/value pair as defined in
        AFLR3.""aflr3_int: str_name1 int1 …""
""aflr3_dble: str_name1 double1 …""
""aflr3_str: str_name1 str_value1 …""

number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
Tetra
        mesh:*createstringarray 1 ""tet: 579 1.2 2 0 0.8 0 0""
*createmark comps 2 ""inlet"" ""outlets"" ""wall"" ""wall_cyl""
*tetmesh comps 2 0 elems 0 -1 1 1
Tetra re-mesh with fixed
        baffles:*createstringarray 1 ""tet: 579 1.2 2 0 0.8 0 0""
*createmark comps 2 ""some_3d_elems""
*createmark comps 1 ""some_baffle_elems""
*tetmesh comps 2 6 comps 2 0 1 1
Tetra mesh by
        geometries:*createstringarray 2 ""tet: 547 1.2 2 0 0.8 0 0"" ""2d: 1 0 1 4 0.8 30""
*createmark solids 1 4 5
*tetmesh solids 1 1 elems 0 -1 1 2
CFD
        mesh:*createstringarray 2 ""tet: 579 1.2 2 0 0.8 0 0"" ""cfd: 86 0.2 1 1.2 0""
*createmark comps 2 ""inlet"" ""outlets""
*createmark comps 1 ""wall"" ""wall_cyl""
*tetmesh comps 2 0 comps 1 2 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
873,*tetmesh_set_input ,"Description
Supplies additional input to *tetmesh. 
For the special case that both inputs are inactive, this command clears selections from all
        previous calls to *tetmesh_set_input and *tetmesh.
        This is normally not necessary since such cleanup is normally done at the end of each call
        to *tetmesh.
","Inputs

entity_type1
The first entity type. Valid values are nodes, elems, comps, surfs and solids.
mark_id1
The ID of the mark containing the first entities. Valid values are 0 (inactive input),
            1 and 2.
mode1


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer 
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL, 
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.


entity_type2
The second entity type. Valid values are nodes, elems, comps, surfs and solids.
mark_id2
The ID of the mark containing the second entities. Valid values are 0 (inactive
            input), 1 and 2.
mode2


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL 
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.



","Example
*createstringarray 1 ""tet: 579 1.2 2 0 0.8 0 0""
*createmark comps 1 ""^elem_size_ctrl_0.1"" ""^elem_size_ctrl_0.5""
*tetmesh_set_input comps 1 4 elems 0 -1
*createmark comps 2 ""float_shells""
*createmark comps 1 ""fixed_shells""
*tetmesh comps 2 0 comps 1 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
874,*titlecreate ,"Description
Creates a title. 
","Inputs

name
The name of the title. 
entities
The type of entity to which the title should be attached.
id
The ID of the entity.
pointindex
The point index.
color
The color of the title. 
font
The font to be used to display the title. 
anchorpoint
The anchor point of the title. 
x
The x location of the anchor point (0.0 - 1.0). 
y
The y location of the anchor point (0.0 - 1.0). 

","Errors
None.
",
875,*titlemodify,"Description
Modifies a title entity.
","Inputs

titlename
The name of the title. 
itemname
The name of the item to be modified. itemname can be one of the
            following options:
titlecolor - Title color, 0 through 64.


titlefont - Font used to display text (1-4, with 1 being the smallest font and 4 being
            the largest).
titleanchor - Anchor corner of the title.
0 - lower left
1 - upper left
2 - upper right
3 - lower right


border on - Turns the border on and off.
1 - turn border on
0 - turn border off


borderwidth - Width of the border.
borderxmin - Minimum x value of the border.
borderxmax - Maximum x value of the border.
borderymin - Minimum y value of the border.
borderymax - Maximum y value of the border.
titletext - Set the title text to string.
string
The string value to which the modified item should be set. When itemname is
              titletext, the title displays a string.
value
The value to which the modified item should be set. Used for all
              itemnames, except titletext.
plot
Designates whether the title will be plotted after modification. 
1 - Plot the title after modification. 
0 - Do not plot the title after modification.

","Example
*titlemodify(""test"",""borderon"","""",1,0)
*titlemodify(""test"",""bordercolor"","""",4,0)
*titlemodify(""test"",""titletext"",""This is test"",0,1)
*titlemodify(""test"",""titlefont"","""",3,1)
*titlemodify(""test"",""titleanchor"","""",1,1)
*titlemodify(""test"",""borderxmin"","""",0.469273743,0)
*titlemodify(""test"",""borderymin"","""",0.120287253,0)

","Errors
None.
"
876,*titlepush ,"Description
Pushes a title to the background. 
","Inputs

titlename
The name of the title which should be made current. 

","Errors
None.
",
877,*toggleincludefromdisplay ,"Description
This command un-displays/masks any entities in the specified include file that are
        currently displayed and displays/unmasks any entities in the specified include file that are
        currently hidden. The display of entities not in the specified include is not affected.
","Inputs

id
The ID of the include file. An ID of 0 selects the master file. If not specified,
            should be blank """".
shortname
The shortname of the include file. This value can be blank when id
            is specified. If not specified, should be blank """".

","Examples
To toggle the entities in the include with ID 3:
*toggleincludefromdisplay 3 """"
To toggle the entities in the include with shortname elems.fem:
*toggleincludefromdisplay """" elems.fem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
878,*transformmark ,"Description
This command translates a selection of entities along a vector.
","Inputs

entity_type
The type of entity to transform.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
r1c1-r4c4
The 4x4 transformation matrix, in row-column order. This matrix defines the
            reflection, rotation, scaling and translation applied to the entities. 
The scaling is in r1c1(x), r2c2(y), and r3r3(z). 
The translation is in r4c1 (x), r4c2 (y), and r4c3 (z). 
The rotation is in the upper 3x3 matrix. 
The last column is for reflection. 
The steps to use to calculate the matrix are as follows:
Calculate the angle in radians. 
Construct a matrix to translate from the rotation point to (0,0,0). 
Construct a second matrix to handle the actual rotation. 
Multiply matrix(step2) X matrix(step3). 
Construct a third matrix to translate back to the rotation point. 
Multiply matrix(step4) X matrix(step5).



","Example
To rotate all displayed nodes 30 degrees about the x-axis through the point (0,0,0):


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


0
0
0
1




*createmark nodes 1 displayed
*transformmark nodes 1 1 0 0 0 0 0.86603 0.5 0 0 -0.5 0.86603 0 0 0 0 1
To rotate all elements 30 degrees about the x-axis through the point (5,10,6):


1
0
0
0


0
1
0
0


0
0
1
0


-5
-10
6
1




x


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


0
0
0
1




=


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


-5
-5.6603
-10.1962
1




x


1
0
0
0


0
1
0
0


0
0
1
0


5
10
6
1




=


1
0
0
0


0
1
0
0


0
0
1
0


5
10
6
1




*createmark elems 1 all
*transformmark elems 1 1 0 0 0 0 0.86603 0.5 0 0 -0.5 0.86603 0 0 4.3397 -4.1962 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
879,*translatemarkwithsystem,"Description
This command translates a selection of entities along a vector of the specified system.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
vector_id
The ID of the vector to use for the translation. This is defined using the
              *createvector command. The vector is relative to the specified
            system.
distance
The distance to translate.
system_id
The ID of the system which the vector is relative to. Note that the type of system
            affects the meaning of vector. For example, the vector (1, 0, 0), x-axis, in a
            cylindrical coordinate system translates the mark radially out from the origin.
origin
If zero, the vector is based at the origin of the system. Otherwise, it specifies a
            node ID whose coordinates define the base point of the vector.

","Example
To translate node 1 5 units along the y-axis of system 13 with node 2 being the origin:
*createvector 1 0.0 1.0 0.0
*createmark nodes 1 1
*translatemarkwithsystem nodes 1 1 5.0 13 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
880,*transparencyvalue,"Description
Sets the level of transparency for the shaded surface in components that are set to be
        transparent. 
","Inputs

value
A value from 0 to 10, 0 being the most transparent and 10 being opaque.

","Example
To set the transparency level to completely transparent:
*transparencyvalue (0
","Errors
None.
"
881,*trim_by_offset_edges ,"Description
Offset selected surface edges and trim attached surfaces.
","Inputs

surfs
Selection markmask for the set of surfaces to perform the operation. If zero, all
            surfaces attached to selected lines are trimmed.
lines
Selection markmask for the lines to be offset and used for trimming. If 0, all lines
            on selected surfaces are offset and used for trimming selected surfaces.
offset
Offset distance value.
break_mode
Controls connection of lines connected on convex vertex (see comments). Used together
            with break_angle. 
0 - Connect breaks by the straight segments (default). 
1 - Connect breaks by the arcs. 
2 - Do not connect breaks.
mode
Bitwise operation mode: 
Bit 0
Trim mode
0 - Trim selected surfaces by offset lines.
1 - Do not trim surfaces but create offset lines and put them in the lines
                      selection markmask. 


Bit 1
Shrink mode
0 - Trim surfaces and keep all trimmed pieces
1 - Trim surfaces and remove parts between original and offset lines 




Other Bits are reserved for future use and must be 0.
break_angle
Angle value to control extension of offset edges. Setting to 0.0 corresponds to
            default value of 30 degrees. See comments.

","Example
To create a ""generic washer"" of width 5, select lines on the free loop
          (lines=1) and call
*trim_by_offset_edges (0,1, 5.0, 0, 0, 0.0)
To ""shrink"" surfaces (selected in the surface mark surfs = 1)
*trim_by_offset_edges (1,0, 5.0, 0, 2, 0.0)

For break_angle and break_mode, normal offset of
        lines connected at convex vertex creates a break between line ends. In order to maintain
        connectivity between lines, the ends must be connected. If the vertex angle is larger than
          break_angle, connect ends by extending and intersecting them. If the
        angle is smaller than break_angle, connect ends either by a straight line
          (break_mode = 0) or by a circular arc (break_mode =
        1). 
","Errors
None.
"
882,*trim_elems_by_multi_circular_hole,"Description
This command is used to trim elements with circular holes. Washer elements can optionally
        be added to the hole. Multiple holes can be handled at the same time.
","Inputs

node_mark_id
The mark ID containing the nodes to use as the center of the holes. Valid values are 1 and 2.
feature_angle
This parameter is used to define mesh feature lines around holes and washer elements.
            The range should be (0, 180). It is usually set to 30.
string_array
The ID of the string array that contains the washer element information. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
The first string in quotations should contain the following parameters as keywords
            followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
layer_number <layers>
The number of washer element layers, > 0.
uniform_layers <flag>
The value is 1 or 0. 1 means that all layer widths are uniform..
 hole_density <value>
The washer element density on the hole.


All other strings define layer width parameter groups.
              If uniform_layers is set to 1, only one layer width parameter group
            is needed. Otherwise, the number of groups should be the same as the layer number. Each
            group contains 2 quoted values:
width_flag <flag>
1 - Means that width_value defines the width of the layer,
                  otherwise it is defined as the ratio of the layer width over the hole radius.


width_value <value>
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
periphery_node_mark_id
The output mark of periphery nodes generated on the hole. Valid values are 0, 1 and 2.
            If the value is set to 0, no periphery nodes are placed on the mark.
background_elem_mark_id
The output mark of background elements to be deleted in order to update the
            connectivity of the newly created elements and their neighbors. Valid values are 0, 1
            and 2. If the value is set to 0, background elements are deleted and element
            connectivity is updated. Otherwise, the background elements are kept and placed on the
            mark.
rigid_spider
Valid values are 0, 1 and 2. If the value is set to 0, no rigid elements will be
            created inside the hole. If the value is set to 1, a single spider will be created
            inside the hole. If the value is set to 2, individual rigid elements will be created for
            periphery nodes.

","Example
To create a hole around node 60 with a radius of 5, and 2 layers of uniform washer elements
        using a density of 8 and a width of 5.0:
*createmark nodes 1 60
*createstringarray 2 "" hole_radius = 5.0 layer_number = 2 uniform_layers = 1 hole_density = 8""  ""1 5.0""
*trim_elems_by_multi_circular_hole 1 30 1 2 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
883,*trim_shell_elems_by_shell_elems ,"Description
Trim 2D elements with 2D elements along their intersection lines, and remove small
        penetrating parts of elements between the intersection lines and free element edges. If some
        elements get trimmed, the elements along the cutting lines are re-generated.
","Inputs

entity_type
The type of entity taking part in the mesh trimming. Valid values are elems and
            comps.
mark_id
The ID of the mark containing the entities taking part in the mesh trimming. Valid values are 1 and 2.
trimmer_entity_type
The type of entity to use as the trimmer. Valid values are elems and comps. 
If specified, these elements are only used in the intersection calculation and are not
            trimmed themselves. Entities belonging to mark_id, but not
              trimmer_mark_id, may be trimmed, if required. 
If not specified, all entities on mark_id are mutually trimmed as
            required.
trimmer_mark_id.
The ID of the mark containing the entities to use as the trimmer. Valid values are 1 and 2.
param_string.
This string contain keyword/value pairs, separated by whitespace. Valid keywords are:
angle
Defines the mesh feature angle to use. If not specified, a default of 30.0 is
                  used.
break_shell_along_component_boundaries
Input elements are distributed into groups based on their connectivity. Only are
                  different groups taken as counterparts of the intersection calculation.
0 - Do not break element groups at component boundaries (default). 
1 - Break element groups at component boundaries.


min_elem_size_rate
Defines the minimum element size locally. The valid value range is between 0.0
                  and 1.0. 
The minimum element size is calculated locally on the mesh area being re-meshed.
                  The element size is computed for the mesh area and the minimum element size is
                  then the product of this value and the element size of the area. 
If min_elem_size_value is also defined,
                    min_elem_size_value is ignored. If neither
                    min_elem_size_rate nor min_elem_size_value
                  are defined, min_elem_size_rate 0.4 is used.
min_elem_size_value
Defines the minimum element size globally. 
If min_elem_size_rate is also defined,
                    min_elem_size_value is ignored. If neither
                    min_elem_size_rate nor min_elem_size_value
                  are defined, min_elem_size_rate 0.4 is used.
remove_internal_shell


0 - Do not remove internal elements when selected elements form two or more
                      watertight shells. 
1 - Remove internal elements when selected elements form two or more
                      watertight shells (default).


trim_removal_limit
Defines the maximum distance between the intersection lines and free element
                  edges in the isolated parts to be removed. A penetration part consists of a group
                  of connected elements with only intersecting or free edges as boundaries.



","Example
To trim all displayed components with each other, using a maximum trim value of 50.0, along
        with other basic options:
*createmark comps 1 displayed
*createmark comps 2 """"
*trim_shell_elems_by_shell_elems comps 1 comps 2 ""remove_internal_shell 1 min_elem_size_rate 0.4 trim_removal_limit 50.0 
break_shell_along_component_boundaries 0 angle 30.000000""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
884,*undohistorystate,"Description
Undoes one or more history states.
","Inputs

count
The number of history states to undo.

","Example
To undo two history states:
*undohistorystate 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
885,*unlockentities ,"Description
This command removes entity locks for a selection of entities.
","Inputs

entity_type
The type of entity to lock.
mark_id
The ID of the mark containing the entities to unlock. Valid values are 1 and 2.
dataname
The dataname to unlock. Currently only supported for ""id"".

","Example
To unlock the displayed element IDs:
*createmark elems 1 displayed
*unlockentities elems 1 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
886,*unmaskall,"Description
 Unmasks all supported entities. For collected entities, only entities in displayed
        collectors are affected. This includes: points
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
To unmask all supported entities in the displayed collectors:
*unmaskall
","Errors
None.
",
887,*unmaskentitiesincollector ,"Description
This command unmasks the entities contained within the collectors of
          entity_type that are on mark_id. Valid
          mark_ids are 1 and 2. Only entities in displayed collectors may be
        unmasked. 
The six flag arguments indicate the type of entities to unmask within
        the specified collectors. If the flag is set to 1, that entity is unmasked. If the flag is
        set to 0, that entity is not modified. Currently supported entity_types
        and flags are:
","Inputs

comps
flag_1- elements
flag_2- points
flag_3- lines
flag_4- surfaces
flag_5- solids
flag_6- connectors
groups
flag_1 - master elements
flag_2- slave elements
flag_3through flag_6 are not used.
loadcols
flag_1- loads
flag_2- equations
flag_3through flag_6 are not used.
multibodies
flag_1- ellipsoids
flag_2- mbjoints
flag_2 - mbplanes
flag_4 through flag_6 are not used

","Examples
To unmask all of the points and surfaces in the displayed components:
*createmark components 1 displayed
*unmaskentitiesincollector comps 1 0 1 0 1 0 0
 To unmask all ellipsoids and mbjoints in all multibodies:
*createmark multibodies 2 all
*unmaskentitiesincollector multibodies 2 1 1 0 0 0 0
","Errors
Incorrect usage of *unmaskentitiesincollector results in a Tcl error. To detect errors, you can use the catch command:
if { [ catch {*unmaskentitiesincollector comps 3 1 1 1 1 1 1} ] } {
# Handle error
}
"
888,*unmaskshown ,"Description
Unmasks all supported entities in the current view window. For collected entities, only
        entities in displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
 To unmask all supported entities in the displayed collectors that are in the current view
        window:
*unmaskshown
","Errors
None.
",
889,*unrealizeengineeringentities,"Description
Unealize engineering entities.
","Inputs

entity_type
The type of engineering entities to unrealize.
mark_id
The ID of the mark containing the engineering entities to unrealize.  Valid values are
            1 and 2.
unrealize_mode
0 - Delete entities from realization.  Only current solver/profile is affected.
1 - Maintain entities from realization.  Only current solver/profile is affected.
10 - Delete entities from realization.  All entities including other solvers/profiles
            are affected.
11 - Maintain entities from realization.  All entities including other
            solvers/profiles are affected.

","Example
Unrealize masses with IDs 10 and 20:
*createmark masses 1 10 20
*unrealizeengineeringentities masses 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
890,*unsetparameter,"Description
Unparameterizes a data name or attribute on a single entity.
","Inputs

entity_type
The type of entity to unparameterize.
entity_id
The ID of the entity to unparameterize.
data_name_or_attribute
The data name or attribute name/ID to unparameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.

","Example
To unparameterize attribute LSD_DA1 on entity set 5:
*unsetparameter sets 5 LSD_DA1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
891,*unsmoothelements ,"Description
From within the automeshing module, undoes the last operation of the
          *smoothelements() command for the specified face. 
","Inputs

faceindex
The index of the face into the particular surface under consideration. 

","Errors
None.
",
892,*update1delements,"Description
Updates 1D beams, bars and rods, and optionally assigns properties.
","
Inputs


adjustoffset=<value>
Adjust the offset when offsetflag=1.  Valid values are all, reset
            and vert.
allshells=<value>
Flag to consider all neighboring shells.  For orientation, use
              usereference=1, orientflag=1 and
              orientmethod=auto.  For offset, use
              usereference=0 and offsetflag=1.
0 - Do not consider
1 - Consider.

createpropfromdata=<flag>

Used to create property from metadata.  Used only when propflag=1,
              usereference=1 and propmethod=bydata.
0 - Do not create (default)
1 - Create

inputentitytype=<entity_type>

The type of input entity.  Valid value is elems.  Used only when
              usereference=0.

inputmark=<mark_id>

The ID of the mark of input entities.  Valid values are 1 and 2.  Used only when
              usereference=0.

offsetends=<method>

The method of offsetting element ends.  Used only when
            offsetflag=1.  Valid values are start (offset at start/end A), end
            (offset at end/end B), and startend (offset at both ends).

offsetflag=<flag>

0 - Do not update element offset values
1 - Update element offset values

offsetlateral=<value>

The lateral offset direction.  Valid values are pos or neg.  Used when
              offsetflag=1.

offsetmethod=<method>

The element offset method.  Valid values are auto (when
              adjustoffset=auto) and reset (when
              adjustoffset=reset).  Used only when
              offsetflag=1.

offsetnormal=<value>

The normal offset direction.  Valid values are pos or neg.  Used when
              offsetflag=1.

orient=<value>

0 - Do not update element orientation using autoupdate1delements
1 - Update element orientation using autoupdate1delements.  Used only when
              orientflag=1 and orientmethod=auto.

orientdatatype=<method>

Provide a label as metadata, which uses inclination information stored as metadata.
            Used only when orientflag=1, usereference=1 and
              orientmethod=bydata.

orientflag=<flag>

0 - Do not update element orientation
1 - Update element orientation, use orientmethod

orientmetadataent=<entity_type>

The entity type to use for metadata.  Valid value is lines.  Used only when
              orientflag=1, usereference=1 and
              orientmethod=bydata.

orientmetadatamark=<mark_id>

The ID of the mark for orientmetadataent.  Used only when
              orientflag=1, usereference=1 and
              orientmethod=bydata.

orientmetadataname=<label>

Provide a label as metadata name where orientation inclination exists.  Used only when
              orientflag=1, usereference=1 and
              orientmethod=bydata.

orientmetadatatype=<label>

Provide a label as byentity, to use metadata from the entity.  Used only when
              orientflag=1, usereference=1 and
              orientmethod=bydata.

orientmethod=<method>

The element orientation method.  Valid values are auto (normal to plates), bydata,
            bynodeid, and bysystem.  Used only when orientflag=1.

orientnodeid=<id>

The ID of the orientation node.  Used only when orientflag=1 and
              orientmethod=bynodeid

orientsysid=<id>

The ID of the orientation system.  Used only when orientflag=1 and
              orientmethod=bysystem

orientvector=<id>

The ID of the orientation vector.  Used only when orientflag=1 and
              orientmethod=bysystem

propdatalabel=<label>

Provide a label as metadata, which uses property information stored as metadata.  If
            beam section exists, then a beam property is created.  If thickness exists, then a shell
            property is created.  Used only when propflag=1,
              usereference=1 and propmethod=bydata.
0 - Do not update
1 - Update

propflag=<flag>

Used to update the property on the elements or components.
0 - Do not update
1 - Update

propid=<id>

The ID of the property to apply to elements or components.  Used only when
              propflag=1 and propmethod=byid.

propmetadataentitytype=<entity_type>

The entity type to use for metadata.  Valid value is lines.  Used only when
              propflag=1, usereference=1 and
              propmethod=bydata.

propmetadatamark=<mark_id>

The ID of the mark for propmetadataentitytype.  Used only when
              propflag=1, usereference=1 and
              propmethod=bydata.

propmetadatatype=<label>

Provide a label as byentity, to use metadata from the entity.  Used only when
              propflag=1, usereference=1 and
              propmethod=bydata.

propmethod=<method>

The method of updating the property.  Valid values are bydata and byid.  Used only
            when propflag=1.

refentmark=<mark_id>

The ID of the mark of reference entities.  Valid values are 1 and 2.  Used only when
              usereference=1.

refentsearchtol=<tolerance>

The search tolerance used by the reference entity (default -1).  Used only when
              usereference=1.

refenttype=<entity_type>

The type of reference entity.  Valid value is lines.  Used only when
              usereference=1.

refmethod=<method>

Use metadata from the input entity.  Valid value is byentity.  Used only when
              usereference=1.

thickness=<method>

The method of assigning shell thickness in case multiple neighboring shells have
            different thickness values.  Used only when offsetflag=1.  Valid
            values are avg, max and min.

usercompsbydata=<flag>

Used only when propflag=1 and either
              propmethod=bymethod and usereference=1, or
              propmethod=byid.
0 - Do not apply property to components (default)
1 - Apply property to components

usereference=<flag>

0 - Update elements from user input (default)
1 - Update elements by using metadata from entities

","Examples
Update 1D elements using lines, assign properties to elements which exist along the lines,
        update the orientation using metadata, and offset these elements using neighboring
        shells:*createmark lines 1 1 2 3 4
*update1delements usereference=1 refmethod=byentity refenttype=lines refentmark=1 refentsearchtol=-1.0 orientflag=1 orientmethod=bydata orientdatatype=metadata orientmetadatatype=byentity orientmetadataent=lines orientmetadatamark=1 orientmetadataname=Inclination offsetflag=1 offsetnormal=pos adjustoffset=vert offsetlateral=pos offsetends=startend thickness=avg offsetmethod=auto allshells=1 propflag=1 propmethod=bydata propdatatype=metadata propmetadatatype=byentity propmetadataentitytype=lines propmetadatamark=1 usecompsbydata=1 createpropfromdata=1
Update 1D elements orientation, offset and property using
        usereference=0:*createmark lines 1 1 2 3 4
*update1delements inputenttype=elems inputmark=1 orientflag=1 orientmethod=auto offsetflag=1 offsetnormal=pos adjustoffset=vert offsetlateral=pos offsetends=startend thickness=avg offsetmethod=auto allshells=1 propflag=1 propmethod=byid propid=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
893,*updatefeatures ,"Description
This command specifies for element remesh with feature edges, if 1D elements selected as
        features are also refined. 
Use of this command implies that it will be followed by a command that performs
        remeshing/meshing by elements with redo option selected.
","Inputs

flag
0 - 1D elements selected as feature edges are not refined (default). 
1 - 1D elements selected as feature edges are refined. New 1D elements, connected to a
            new mesh, will be created

","Example
To remesh elements 1-40 with element size 10 using 1D elements with IDs 100-110 as feature
        edges and create along these feature edges new, connected to created mesh, 1D elements with
        same properties:
*createmark elems 1 100-110
*elementsaddelemsfixed 1
*updatefeatures 1
*setusefeatures 1
*createmark elems 2 1-40
*defaultremeshelems 2 10.0 2 2 1 1 1 1 0 0 0 0 2 30
*setusefeatures 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
894,*updateidrange ,"Description
This command updates an ID range for a submodel.
","Inputs

submodel_type
The type of submodel to update the ID range for. Valid values are includes and
            submodel. Submodel is recommended. 
id
The ID of the submodel. Not required if shortname is used.
shortname
The shortname of the submodel. Not required if id is used.
entity_type
The type of entity to update the ID range for.
min_id
The minimum ID for the range.
max_id
The maximum ID for the range.
pool_id
The ID of the solver pool.
integer_array
The ID of the integer array that contains the locked IDs. The integer array is created
            using the *createarray command. This should always be set to 1.
number_of_integers
Integer indicating the size (number of integers) in the integer array created using
              *createarray.

","Examples
To update an ID range for include 1 with min ID 1,000 and max ID 100,000 for
        components:
*updateidrange includes 1 """" comps 1000 100000 0 1 0
To update an ID range for include 1 with min ID 1,000 and max ID 100,000 for components,
        with locked IDs 2000 and 5000:
*createarray 2 2000 5000
*updateidrange includes 1 """" comps 1000 100000 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
895,*updateincludedata2,"Description
Updates include file solver specific information. 
The two solver values are for the convenience of template authors. They function in a
        manner analogous to ""config"" and ""type"" for elements, in that they can be used to screen out
        categories of include files from inappropriate sections in the template. 
As an example, in Nastran, there are three sections in the
        output file, call them A, B, and C. Some include files need to appear in the A section,
        others in the B section, and the rest in the C section. In this case, solver1 is used to
        segregate them, with A files having the value 1, B files having the value 2, and C files
        having the value 3.
","Inputs

id
The ID of the include file to update. If 0, shortname is used
            instead.
shortname
The short name to use to select the file if ID is 0. Ignored otherwise.
do_not_export_flag
0 - Do not update the export state 
1 - Update the export state
do_not_export
0 - Set the include to export 
1 - Set the include to not export
solver1_flag
0 - Do not update solver value 1 
1 - Update solver value 1
solver1
 The new value of solver value 1.
solver2_flag
0 - Do not update solver value 2 
1 - Update solver value 2
solver2
The new value of solver value 2.
merge_flag
0 - Do not update the merge value 
1 - Update the merge value
merge
0 - Do not merge include file with master file 
1 - Merge include file with master file. 
This option is valid, if  you have selected the ‘Preserve Merge’ export option.

","Example
To change the include file with ID 1 to not export, and update solver1 to a value of 3:
*updateincludedata2 1 """" 1 0 1 3 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
896,*updateoffset,"Description
Update the definition of offset.
","
Inputs



type

Must be set to includefiles.

include_id

The include file ID, if shortname is not used.

shortname

The shortname of the include file, if include_id is not used.

entity_type

The type of entity to update. 0 for all entities under the include file.

pool_id

The pool ID for the entities to update. 0 for all of pools.

offset

The offset value to assign.

","Examples
To assign offset 1000 to all entities in include file 1:
*updateoffset includefiles 1 """" 0 0 1000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
897,*updatepropertyidforfejoints,"Description
Updates the property ID for the given FE joint elements.
","
Inputs



mark_id

The ID of the mark containing the joint elements to update.

property_id

The ID of the PJOINTG property.

","Examples
To update joint elements 9 and 10 with property ID 2:
*createmark elements 1 9 10
*updatepropertyidforfejoints 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
898,*usercheck,"Description
 Runs a template that can be used to check element quality
","Inputs

template file
The name of the template file.
output file
The name of the output file.
all
Determines the entities the template scans. 
1 - Specifies all entities. 
0 - Specifies only visible entities.

","Example
The template file can use the *markfailed() template command to mark
        elements that do not pass any user-specified test. *markfailed()
        highlights the element on the screen and also puts the element on the user mark. 
","Errors
None.
"
899,*vectorplot ,"Description
Creates a vector plot from results data. The results file must be loaded before executing
        this command. The *freesimulation command clears the plot.
","Inputs

title
The title to use for the plot.
vector_size
The size of the vectors. If constant_size is set to 0, this defines
            a scale factor for the vectors. If constant_size is set to 1, this
            defines the size in model units
mesh_color
The color used to plot the mesh. Valid values are 1 through 64. 
-1 - Uses the elements color. 
0 - Uses the background color.


full_size
Determines whether the contour plot fills the entire screen. Valid values are: 
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return.
constant_size
Set to 1 to plot all vectors with a constant length, otherwise set to 0.

","Example
To load the result file named C:/my_results/test.res and generate a
        vector plot for Subcase 1 with Displacements data type, a vector model size of 2.5, a mesh
        color of black, and normal plot size:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*vectorplot """" 2.5 0 0 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
900,*vectorupdate_xproduct ,"Description
Updates a vector entity created from the cross product of two other vectors.
","Inputs

markid
The ID of the mark that contains the vectors to update.
basenode
The ID of the node where the base of the result is located after it is updated.
vector A 
The ID of the first vector entity in the cross product.
vector B
The ID of the 2nd vector entity in the cross product.
magnitude
Magnitude of vectors.
baseflag
A flag (0,1) to update the base node of the vector.
directionflag
A flag (0,1) to update the direction and magnitude of the vector

","Errors
None.
",
901,*verticescombine ,"Description
Given one surface fixed point to retain, and one or more additional fixed points, combines
        all of the points into the first point. Some surface edges or entire surfaces may be deleted
        in the process. 
","Inputs

retained_point
The ID of the point to keep.
mark
The ID of the mark containing the points that are to be adjusted.

","Example
To combine points 7, 8, and 9 into point 21:
*createmark(points,2) 7 8 9
*verticescombine(21,2)
Typically, the points to be combined must be very close to each other.
","Errors
None.
"
902,*verticesrelease ,"Description
This command is applied to a selection of points given by the points mark. All selected
        fixed points are released.  All the suppressed (blue), shared (green), and nonmanifold
        (yellow) edges that share fixed points are released, generating free (red) edges.
","Inputs

markmask
Selection markmask for points to be released (1 or 2).

","Example
*verticesrelease (1)
Unstitches selected vertices selected by markmask 1.  
","Errors
The command returns error code for no points selected.
"
903,*view_restoreprevious,"Description
 Return to previous view state.
","Errors
None.
",,
904,*visualizemode ,"Description
 Sets the parameters for visualization mode. 
","Inputs

hiddenline
 Set to 1 for hidden line, 0 for wire frame. 
fillmode
Set to -2 for contours, -1 for element color, or 0-15 for constant color. 
meshmode
Set to -2 for contours, -1 for element color, or 0-15 for constant color. 
plot
Set to 1 to replot the screen after this command has executed, otherwise 0. 

","Example
This command is valid only after the system has entered into visualization mode.
","Errors
None.
"
905,*voxel_lattice_hex_mesh_add_buffer_layers,"Description
Adds buffer layers to all include entities in the voxel domain.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

num_buffer_layers
The number of buffer layers.

","Example
To create voxels of size 10 for include components 100-110 and exclude components 200-203,
        with a buffer of 2 layers around the include components:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*voxel_lattice_hex_mesh_add_buffer_layers 2
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
906,*voxel_lattice_hex_mesh_add_entities_with_buffer,"Description
Adds entities to the voxel domain with a number of buffer layers.  Voxel gridding is done
        along the intersection profile of the entities as well as the buffer layer.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

entity_type
The type of entity to add to the domain.  Valid values are comps, elems, surfs, solids
            and lines.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
num_buffer_layers
The number of buffer layers.

","Example
To create voxels of size 10 for include components 100-110 with 3 buffer layers around comp
        110, and exclude components 200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-109
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities_with_buffer comps 1 3
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
907,*voxel_lattice_hex_mesh_add_volume,"Description
Adds a volume surrounding a given point to the voxel domain.  The volume is determined by
        the elements that are part of the domain when this command is run.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

x
The x-coordinate of the point inside the volume.
y
The y-coordinate of the point inside the volume.
z
The z-coordinate of the point inside the volume.

","Example
To create voxels of size 10 for include components 100-110 and volume surrounding
        (50,50,50):
*voxel_lattice_hex_mesh_init 10
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*voxel_lattice_hex_mesh_add_volume 50 50 50
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
908,*voxel_lattice_hex_mesh_drag_faces,"Description
Drags faces of existing voxels to create new voxels.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        either a call to *voxel_lattice_hex_mesh_import or
          *voxel_lattice_hex_mesh_create. It must be followed by a call to
          *voxel_lattice_hex_mesh_create to create the voxels.
","Inputs

voxel_mark_id
The ID of the mark containing the voxel elements to drag.
face_node_mark_id
The ID of the mark containing the nodes of the voxel elements defining the face to
            drag.
dx
The value to drag in the x direction.
dy
The value to drag in the y direction.
dz
The value to drag in the z direction.

","Example
To register voxels in comps 100 and 101 and drag elements 500-600 using the face with nodes
        100-110 by (50,0,0):
*voxel_lattice_hex_mesh_init 10
*createmark comps 1 100 101
*voxel_lattice_hex_mesh_import comps 1
*createmark elems 1 500-600
*createmark nodes 1 100-110
*voxel_lattice_hex_mesh_drag_faces 1 1 50 0 0
*voxel_lattice_mesh_mesh_create
*voxel_lattice_hex_mesh_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
909,*voxel_lattice_hex_mesh_fill_voids,"Description
Sets the mode for filling closed volumes during voxel creation.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

mode
0 - Only intersected voxels are considered for computing the volumes.
1 - All the voxels are considered for computing the volumes.

","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
910,*voxel_lattice_hex_mesh_init,"Description
Initializes the voxel hex mesh module. This must precede any calls to other
          *voxel_lattice_hex_mesh... APIs, and must be followed by a call to
          *voxel_lattice_hex_mesh_end.
Unrelated ""major"" database changes made while inside of the voxel module will cause it to
        terminate.
","Inputs

voxel_size
The size of the voxel hex elements to be created/registered.  Only a uniform size is
            supported within a single voxel session.

","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
911,*voxel_lattice_hex_mesh_remove_constraints,"Description
Removes all planar constraints for the current voxel session.
This must be preceeded by a call to
          *voxel_lattice_hex_mesh_add_constraints and must be followed by a call
        to *voxel_lattice_hex_mesh_create.
","Example
To create voxels of size 10 for include components 100-110 and exclude components 200-203,
        with a planar constraint at 500,0,0 along the positive x-direction, and the remove the
        constraint and regenerate:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_add_constraints 500 0 0 501 0 0 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh_remove_constraints
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
912,*voxel_lattice_hex_mesh_remove_volume,"Description
Removes a volume surrounding a given point from the voxel domain.  The volume is determined
        by the elements that are part of the domain when this command is run.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

x
The x-coordinate of the point inside the volume.
y
The y-coordinate of the point inside the volume.
z
The z-coordinate of the point inside the volume.

","Example
To create voxels of size 10 for include components 100-110, removing the volume surrounding
        (50,50,50):
*voxel_lattice_hex_mesh_init 10
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*voxel_lattice_hex_mesh_remove_volume 50 50 50
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
913,*wadlines_createlines,"Description
Creates multiple wadlines.
","
Inputs


number_of_integers
The number of integers in integer_array.
integer_array
The ID of the integer array that contains the number of vertices for each polyline.
            The integer array must be created using the *createarray command.
            This should always be set to 1.
double_array
The ID of the double array that contains the 3D coordinates of the vertices for each
            polyline. The double array must be created using the
              *createdoublearray command. This should always be set to 1.
number_of_integers
The number of doubles in double_array.  This should be equal to 3
            times the number of vertices.
line_type
0 - Standard line
1 - Smooth line

","Examples
Create 2 wadlines, one with 4 vertices and the other with 3:
*createarray 2 4 3
*createdoublearray 21 0.0 0.0 0.0 1.0 1.0 1.1 2.0 2.0 2.0 0.0 3.0 3.0 0.0 3.0 3.0 4.0 0.0 4.0 5.0 5.0 0.0
*wadlines_createlines 1 2 1 21 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
914,*wadlines_hardpartzone,"Description
Creates the hard part zone by duplicating and trimming the vehicle outer components with
        test zone boundaries.
","
Inputs


entity_type
The type of entity for the vehicle outer.  Must be set to comps.
mark_id
The ID of the mark of vehicle outer components.  Valid values are 1 and 2.
double_array
The double array ID that contains the 3D coordinates of the vertices defining the test
            zone. The double array is created using the *createdoublearray
            command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. This should be 3 times the number of
            spheres.
vector_id
The ID of a vector created using the *createvector commend. This
            vector defines the perpendicular direction of the test zone, used to search elements
            within the test zone up to the search_distance.  Valid values are 1
            and 2.
search_distance
The perpendicular distance from the test zone boundary used to select elements from
            the vehicle outer components.

","Examples
To create a hard part zone around the displayed components with a tolerance of 10:
*createvector 1 0 0 1
*createdoublearray 12 1343.514343661 709.91761797527 973.43251742578 1334.7036682323 703.07456401521 973.15886027621 1327.8482379749 697.4142871779 972.93366355648 1323.86674249 694.00118686161 972.79787178914 
*createmark comps 1 displayed
*wadlines_hardpartzone comps 1 1 12 1 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
915,*weld ,"Description
Creates a weld element between two nodes. 
","Inputs

independent
The independent node. 
dependent
The dependent node.
length
The length of the weld. 
systems
Determines if systems should be built at the end of the node (1 for yes, 0 for no).
          
movenode
Set to 1 to move the node perpendicular to the surface of the elements, otherwise 0. 

","Example
To build a weld element between nodes 100 and 101 with length 1.0 and without systems being
        built at the ends of the weld element: 
*weld(100,101,1.0,0,0)
","Errors
None.
"
916,*window ,"Description
Modifies the current window.
","Inputs

function
Defines the function being performed: 
0 - The window is redefined so that all of the current model is inside the
                window. All of the other parameters are ignored. 
1 - The window is recalculated. All of the other parameters are ignored. This
                function is only used internally.
2 - Zooming is performed on the current window based on the value passed in xmin.
                If xmin is positive, the current window is multiplied by xmin,
                and the result is zooming in. If xmin is negative, the current
                window is divided by xmin, and the result is zooming out. This is defined each time
                the + and - zooming options are used.
3 - The window is set to the values passed in xmin,
                  ymin, xmax, and ymax. The
                parameters are specified in model units. This is defined each time the z zooming
                option is used. 
4 - The window is centered at the point specified by xmin and
                  ymin. The parameters are specified in model units. This is
                defined each time the c paning option is used.


xmin
The minimum x value of the window.
ymin
The minimum y value of the window.
xmax
The maximum x value of the window. 
ymax
The maximum y value of the window. 

","Errors
None.
",
917,*writecurrentqualitycriteria,"Description
Writes the current quality criteria to the specified file. 
The current quality criteria must be previously set. If the quality criteria is not set,
        the command writes the criteria from the quality index panel (interactive mode) or the
        default quality criteria adjusted to the current element size (batch mode).
","Inputs

file_name
The path to the destination criteria (a quoted string).

","Example
*writecurrentqualitycriteria ""c:/demos/my_criteria.txt""
","Errors
None.
"
918,*writeh3dwithoptions,"Description
Writes an H3D file using various options to control the exported data.
","Inputs

filename
Full name and path of the H3D file to save.
string_array
The ID of the string array that contains the additional output parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
Arguments can be provided in any order and must be space separated.
model=<value>
1 - Write FE data only (default) 
2 - Write geometry (STL) data only 
3 - Write both geometry (STL) and FE data
result=<value>
0 - Do not write results (default). 
1 - For supported entities and result contours, this writes the displayed
                  results to the H3D file. If no supported result contour is displayed, this option
                  is ignored.
title=<value>
0 - Do not write HyperMesh titles as HyperView notes (default). 
1 - Write HyperMesh titles as HyperView notes.
orient=""n1x ny1 n1z n2x n2y n2z n3x n3y n3z""
The x, y, z coordinates of the 3 orientation nodes. The default is to not write
                  orientation nodes.
overwrite=<value>
0 - Do not overwrite file if it exists (default) 
1 - Overwrite file if it exists


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To save an H3D as C:/test.h3d:
*writeh3dwithoptions C:/test.h3d 1 0
To save an H3D as C:/test.h3d with both geometry and FE data, along
        with titles:
*createstringarray 2 model=3 title=1
*writeh3dwithoptions C:/test.h3d 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
919,*writepart,"Description
Exports part information.
","
Inputs


file_path
The directory to write to.
mark_id
The ID of the mark of the modules/parts to export.

","Examples
To export all part information to
        C:/temp:*createmark parts 1 all
*writepart ""C:/temp"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
920,*writequalitysummary ,"Description
Collects a summary of the mesh quality, including details such as the number of quads which
        fail the Jacobian test or trias with angles exceeding the acceptable number, and writes the
        results to a formatted text file.
","Errors
None.
",,
921,*xelem_bysetid,"Description
Creates a new element(/XELEM) of config 27 and type 1 using a node list..  This is
        currently only supported for Radioss.
","
Inputs



node_set_id

The ID of the node set to create the element from.  The set must be an ordered node
            set of type /GRNOD/NODENS, and must contain at least two nodes.

","Examples
Create a xelem element with ordered node set of ID 5:
*xelem_bysetid 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
922,*xyplotcoloroverride ,"Description
Sets the override color for xy plots. 
","Inputs

color 
Set to the color which should be used to plot all of the xy plot information on the
            screen (1-15). 

","Example
If the color is set with this command, all of the entities on an xy plot are plotted in
        that color. If color is set to zero, then the color of each of the entities on the xy plot
        is used. 
","Errors
None.
"
923,*xyplotcreateandsize,"Description
Creates an xy plot with the indicated position and dimensions. 
","Inputs

plot name
The name of the plot to be created.
like plot
The name of the plot from which the new plot should get its default values.
xmin
The leftmost boundary of the plot on the screen, expressed as a fraction of the window
            dimensions.
xmax
The rightmost boundary of the plot on the screen.
ymin
The top boundary of the plot on the screen.
ymax
The bottom boundary of the plot on the screen

","Example
To create a plot situated in the upper left corner of the screen, and spanning 1/3rd of the
        width and 1/3rd of the height of the screen:
*xyplotcreateandsize(""myplot"", """", 0.0, 0.33333, 0.0, 0.33333)

","Errors
None.
"
924,*xyplotcurvecreate,"Description
Creates a curve. 
","Inputs

curve name
The name of the curve being created. 

","Errors
None.
",
925,*xyplotcurvepermute ,"Description
Permutes a curve. 
","Inputs

curve name
The name of the curve to be permuted. 

","Errors
None.
",
926,*xyplotexpand,"Description
Expands a plot to cover the entire graphics region of the screen.
","Inputs

plot name
The name of the xy plot to be expanded.

","Errors
None.
",
927,*xyplotmodify ,"Description
Modifies an xy plot. 
","Inputs

plot name
The name of the plot to be modified
item name
The name of the data item associated with the xy plot which should be modified.
string
The string value of the data item.
value
The value of the data item.
plot
A logical which determines if the xy plot should be redrawn after modification.

","Errors
None.
",
928,*xyplotorganize ,"Description
Organizes the active plots so that they are fully visible on the screen. 
","Errors
None.
",,
929,*xyplotpop ,"Description
Pops an xy plot to the top level. 
","Inputs

plot name
The name of the plot to be popped. 

","Errors
None.
",
930,*xyplotreadcurve ,"Description
Reads a curve(s) from an ASCII file. 
","Inputs

filename 
The name of the file which contains the curve data.

","Errors
None.
",
931,*xyplotregisterexternalreader,"Description
 Registers a translator for use in the Edit Curves panel.
","Inputs

path
path of the executable for the reader.

","Example
*xyplotregisterexternalreader(daisy.exe).
External readers allow you to expand the file reading capabilities of the edit curves panel
        through the addition of custom readers. Custom readers can be written in C or Fortran. 
","Errors
None.
"
932,*xyplotsetcurrent ,"Description
Sets the current xy plot 
","Inputs

plot name
 The name of the plot to be made current. 

","Errors
None.
",
933,*xyplotsetcurves,"Description
Sets the curve pointers on a plot. 
","Inputs

plotname
The name of the plot whose curve pointers should be set.
mark
The ID of the mark which contains the curves to be drawn on the plot.

","Errors
None.
",
934,*xyplotstack ,"Description
Stacks the active xy plots. 
","Errors
None.
",,
935,*xyplotwindow,"Description
 Sets the minimum and maximum values for the plot window. 
","Inputs

plotname
The name of the plot. 
xmin
The minimum value which the window should be set to along the x axis
xmax
The maximum value which the window should be set to along the x axis. 
ymin
The minimum value which the window should be set to along the y axis. 
ymax
The maximum value which the window should be set to along the y axis

","Errors
None.
",
936,*accepteditedsurface_with_user_tolerance,"Description
Moves surfaces from the midsurface to edit component into the middle surface component and
        stitches surfaces according to a specified tolerance.
","Inputs

auto_stitch
= 0 - Auto-stitch is disabled.
≠ 0 - Auto-stitch combines surfaces using the specified
            tolerance.
tolerance
Surfaces within this decimal-value tolerance are stitched together if
              auto_stitch is enabled.
If auto_stitch is enabled but tolerance is less
            than zero, then the result is stitched with a tolerance of 1/5 the midsurface
            thickness.

","Example
To move midsurfaces from midsurface to edit into middle surface with a stitching tolerance
        equal to ¼ of the midsurface thickness:
*accepteditedsurface_with_user_tolerance(1,0.25)
",
937,*createpositionformech,"Description
Creates a new position for a mechanism. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the position to be created. If the provided name already exists, an
            incremental name will be used.

","Example
To create a new position with name newposition:
*createpositionformech newposition
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
938,*hideentity,"Description
Turns off the display of an entity.
","Inputs

entity_type
The type of entity to display.
search_type
The method used to specify the entity. The entity is specified using the
              id_name argument. Valid values are: 
""by name"" - Entity is specified using the entity name.
""by id"" - Entity is specified using the entity ID.
id_name
The ID or name of the entity, depending on search_type.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To hide geometry and elements for component with ID 3:
*hideentity comps ""by id"" 3
To hide elements only for component with ID 3:
*createstringarray 2 geometry_off
*hideentity comps ""by id"" 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
939,*hm_batchmesh2,"Description
Performs interactive BatchMeshing. 
","Inputs

entity_type
The entity type to perform the BatchMeshing for. Valid values are surfs and
            comps.
mark_id
The ID of the mark containing the entities to mesh. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each string must be space and/or = separated between the name and value. Strings can
            be grouped in any manner, and can appear in any order. 
Valid strings are:

","Examples
BatchMesh surfaces 36 and 79 using the criteria file
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param, with all other default
        parameters:*createmark surfs 1 36 79
*hm_batchmesh2 surfs 1 1 0 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
BatchMesh surfaces 36 and 79 using the criteria file
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param, breaking mesh connectivity, with all other
        default
        parameters:*createmark surfs 1 36 79
*createstringarray 1 ""breakconnectivity = 1""
*hm_batchmesh2 surfs 1 1 0 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
 BatchMesh surfaces 36 and 79 with element size 8.0 and minimum size 3.75. Use
        auto-generated shell criteria and parameters. Allow internal reject steps via temp
        files:*createmark surfs 1 36 79
*createstringarray 2 ""elem_size = 8 min_elem_size = 3.75 params_generate_mode = shell"" ""batchtempfilesmode = 1""
*hm_batchmesh2 surfs 1 1 2 ""dummy"" ""dummy""
BatchMesh surfaces 36 and 79 with element size 7.0, using scaling of the criteria
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param::*createmark surfs 1  36 79
*createstringarray 2 ""elem_size = 7.0 params_generate_mode = scale""
*hm_batchmesh2 surfs 1 1 2 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
940,*hm_meshutils_cutelements_2points,"Description
Cut elements with a box defined by 2 diagonal points. 
","Inputs

element_mark
The mark of the elements that needs to be cut.
c1x, c1y, c1z
The coordinates of the point 1.
c1x, c1y, c1z
The coordinates of the point 2.
spc_collector_name
The name of the collector in which the spcs will be created for constraining cut
            elements. 
No entities will be created if the name is an empty string.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox. 
No entities will be created if the name is an empty string.

","Example
Only linear shell elements will be cut properly. For any other type of element, it will
        simply be deleted if it is completely or partially inside the cut box.
","Errors
None.
"
941,*hm_trim_elements_with_two_point_box,"Description
Trims shell elements using a box defined by two diagonal points. Shell elements inside the
        box are kept with the elements along any cuts re-meshed. Solid elements with all nodes
        inside the box are kept, while all others are deleted.
","Inputs

mark_id
The ID of the mark containing the elements to cut. Valid values are 1 and 2.
x1 y1 z1
The coordinates of the first corner point.
x2 y2 z2
The coordinates of the second corner point.
spc_collector_name
The name of the collector in which the SPCs will be created for constraining cut
            elements.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox.
remesh_params
The parameters of re-meshing along the cut, defined as ""keyword value"" format. 
For example: ""angle 30.0 min_elem_size_rate 0.6 comp_remainder_area_rate 1.0"" 
Valid keywords and values are:
angle
Values used to define feature edges on mesh. Default if not specified is
                  30.0.
min_elem_size_rate
Defines the minimum element size locally. The valid range is between 0.0 and
                  1.0. The minimum element size is calculated locally on the mesh area being
                  re-meshed. The element size is computed for the mesh area and the minimum element
                  size is then the product of min_elem_size_rate and the element
                  size of the area. 
min_elem_size_value
Defines the minimum element size globally.
comp_remainder_elem_numb
Defines the minimum number of elements in a component. After box trimming, any
                  component with an element count less than this value is deleted.
comp_remainder_area_rate
Define the limit of shell element area of components. After box trimming, any
                  component with element areas less than this percent of its original area is
                  deleted. The valid range of the value is between 0.0 and 100.0. 



","Example
 To trim displayed elements using a box with corner points (0,0,0) and (100,100,100):
*createmark elements 1 ""displayed""
*hm_trim_elements_with_two_point_box 1 0.0 0.0 0.0 100.0 100.0 100.0 ""abc"" ""efg"" ""min_elem_size_rate 0.6 comp_remainder_elem_rate 0.01 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
942,*hmmeshsurfacesphere,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *surfacesphere... commands.
","Inputs

quads 
If nonzero, specifies that the created elements should be quads.

","Example
This example identifies a spherical region passing through the given four nodes, and,
        without actually building a surface, creates 150 elements with a density of 15 along a
        longitude and 10 around the equator: 
*surfacemode 3
*createlist nodes 1 159 141 178 228
*surfacespherefromfournodes 1
*set_meshedgeparams 0 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 15.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshsurfacesphere 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
943,*icelementcreate,"Description
Creates an IC element. *addicconnectivity and
          *modifyicelement can be used to add additional details or modify the
        element.
","Example
Create an IC element and update the independent node to 15, and dependent nodes to 16, 17,
        18, 19 with DOF’s 123, 345, 1234, 123456:
*icelementcreate
*createintarray2d 2 4 16 17 18 19 123 345 1234 123456
*addicconnectivity 1 15 1 2 4
","Errors
None.
",
944,*includesuppressoutput,"Description
This command sets the export/do not export state of all supported entities contained within
        the include file (but not the include file itself) with include_id and
          include_shortname. Only one of these two options need to be specified,
          however include_id will take precedence if specified. Double quotes """"
        must be used for an argument that is not specified. 
The state argument indicates the export/do not export status for the
        supported entities contained in the include. A state of 0 indicates to
        set the entities to ""export"". A state of 1 indicates to set the entities
        to ""do not export"". 
Include files do not have an export/do not export state that is controlled by this command.
        Instead use the command *updateincludedata2.
","Example
To set all supported entities contained within include file ID 5 to ""export"":
*includesuppressoutput 5 """" 0
To set all supported entities contained within include file shortname include.txt to ""do
        not export"":
*includesuppressoutput """" include.txt 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
945,*interactivemeshelems,"Description
Brings all marked elements into the automeshing module and prepares them for processing,
        enabling the use of all restricted module commands.
","Inputs

markmask
The elements to be meshed. 
elementsize
The default element edge size used to calculate element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created.
1 = yes 
0 = no


break_connect
Determines if connectivity will be broken along shared edges between elements when a
            different element size is chosen. 
1 = yes 
0 = no


Element size along shared edges cannot be changed.
angle
Determines the angle between two edge segments when the vertex is created.

","Example
In this example, the automeshing module processes two separate groups with four and six
        elements each (each group forms a quad with four edges). To generate a mesh for each group,
        the automeshing module sets up values for the element densities and biasing with the
          *set_meshedgeparams command. Automeshing parameters for each group are
        specified with the *set_meshfaceparams command. Prior to meshing,
        parameters for the first group were changed. This required additional setedgeparams calls
        for four edges. Each group of elements is sent to the *automesh command
        so it can determine the appropriate meshing algorithm and create an all-quads mesh. Two
        meshes are then saved to theHyperMesh database. The automeshing
        module clears from its memory any information regarding the current group so that a new
        group can be processed. 
*surfacemode 1
*createmark elements 1 11 12 19 20 79 80 82 84 86 90
*interactivemeshelems 1 10 1 1 1 1 0 30
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0 5 0
*set_meshedgeparams 4 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 2 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
946,*isolateelementswithinradius,"Description
Isolates entities within the radius specified.  Other entities in the model should be
        hidden first.
","Inputs

entity_type
The type of entity to isolate.  Valid values are masses and elements.
mark_id
The ID of the mark containing the entities to isolate.  Valid values are 1 and 2.
radius
The radius of interest from all locations.

","Example
Show elements from all locations of mass1 and mass2 within radius 50.0:
*createmark masses 1 mass1 mass2
*isolateelementswithinradius masses 1 50.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
947,*jointelement_fournoded,"Description
 Creates a four-noded joint element.
","Inputs

type
The type of the element (2,3,4,5 ONLY)
n1,n2,n3,n4
The four nodes of the element.
orientation
Orientation option for the element. Use:
0 - None 
1 - Systems


system1,2
The orientation systems IDs for the element.
property 
The property to which the element points.

","Example
To create a four-noded joint element:
*jointelement_fournoded(5,467,466,459,291,1,1595,0, ""stiffness"")
","Errors
None.
"
948,*jpegfile,"Description
Captures the graphics area to a JPEG image in the current working directory. Each image is
        automatically assigned a unique name and number starting from 0 (e.g.
          image0.jpg, image1.jpg, etc...). 
The color and background settings can be specified using the
          *graphicsfilecolor and *graphicscolorblankbackground
        commands.
","Example
To capture the graphics area to a JPEG image:
*jpegfile
","Errors
None.
",
949,*lastsimulation,"Description
Sets the last simulation and data type for transient animations. The results file must be
        loaded before executing this command.
","Inputs

simulation
The name of the simulation contained in the results file.
data_type
The name of the data type for the simulation.

","Example
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 through Subcase 4 with Displacements data type, using a
        10.0 model unit scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*lastsimulation ""Subcase 4"" ""Displacements""
*animatetransient """" 10.0 4 1 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
950,*legenddisplay,"Description
This command controls the display of the legend.
","Inputs

state
The legend display state: 
0 - Off 
1 - On

","Example
To set the legend off:*legenddisplay 0
","Errors
None.
"
951,*legendmove,"Description
 Moves the legend. 
","Inputs

x
The new x location for the legend. 
y
The new y location for the legend. 

","Errors
None.
",
952,*legendsavecolors,"Description
Saves the colors of a legend to a file. 
","Inputs

filename
Save the color information to this file name. 

","Errors
None.
",
953,*legendsetcolors,"Description
 Sets the number of colors which will be used in the legend. 
","Inputs

number
The number of colors. 

","Errors
None.
",
954,*linearsurfacebetweenlines,"Description
Creates a ruled surface between two trimmed line lists, and optionally, prepares it for
        immediate use within the automesher. It can also identify a region in the shape of a ruled
        surface for the automesher to use under the mesh without surface option. 
","Inputs

linelist1
The ID of the first list of lines forming one side of the surface. 
endpoints1
The list ID of the list of zero or two nodes which lie on the lines in the first line
            list which will be used to trim the line during surface creation. 
linelist2
The ID of the second list of lines forming the other side of the surface. 
endpoints2
The list ID of the list of zero or two nodes which lie on the lines in the second line
            list which will be used to trim the line during surface creation. 
reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
To create a surface where lines 7 and 11 form one side, and line 5 trimmed by nodes 37 and
        38 forms the other, and not immediately bring the surface into the automesher: 
*surfacemode(4)
*createlist(lines,1) 7 11
*createlist(nodes,1)
*createlist(lines,2) 5
*createlist(nodes,2) 37 38
*linearsurfacebetweenlines(1,1,2,2,1)
All four *createlist() directives are required for this command. 
A case in which the surface is brought into the automesher is slightly more complicated. 
A case in which a region in the shape of a ruled surface is brought into the automesher to
        generate a mesh without using a surface is slightly more complicated.
","Errors
None.
"
955,*linecreateconic,"Description
This command creates a conic section curve segment (hyperbola, parabola, ellipse or
        circular arc) for given segment endpoints, given endpoint tangent lines intersection point,
        and a parameter that defines the curve type.
","Inputs

sx sy sz
Coordinates of conic curve segment start point.
ex ey ez
Coordinates of conic curve segment end point.
tx ty tz
Coordinates of a point at intersection between straight lines tangent to created conic
            curve segment at start and end points.
ratio
Parameter that defines the created conic curve segment ""altitude"". Consider the
            segment that connects the tangents’ intersection point with the midpoint between the
            start and end points of the curve. If the length of this segment is used as the unit
            length, then the ratio is defined as the length of the portion of the segment that
            connects the midpoint with the point where the segment is intersected by created curve
            (see figure below). Valid values for ratio are in the range 0 to 1. For the value of
            0.5, the conic curve is a parabolic segment. For the values between 0 and 0.5, the conic
            curve is an ellipse. For the values between 0.5 and 1, the conic curve is a hyperbolic
            segment.
A ratio of -1 can also be used to invoke automatic circle calculation. A circular arc
            is then created, provided the length of the tangent segments are equal.

Figure 1. 


","Examples
To create a parabolic segment with the start point at (1,2,3), the end point at (4,2,3) and
        the endpoint tangent lines intersection point at (3,10,3):
*linecreateconic 1 2 3 4 2 3 3 10 3 0.5
To create a 90 degree circular arc that lies in the plane z=0 and connects points (0,0,0)
        and (1,0,0):
*linecreateconic 0 0 0 1 0 0 0.5 0.5 0 -1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
956,*linecreatefromnodesandprojecttobinder,"Description
 Create a specific type of line from a list of nodes and project it along a direction onto
        a surface. 
","Inputs

list id
The ID of the list containing the nodes.
type
The type of line being generated.
1 linear 
2 standard 
3 smooth 
4 user-controlled


break angle
Specifies the minimum angle allowed between three points in a line. If the angle
            between a point and the two adjacent points is less than the angle specified, HyperMeshconsiders this point to be a point of discontinuity in the
            line and places a joint (starts a new NURBS) at this location. 
aspect
Specifies the maximum ratio allowed for the distance between a point and the previous
            point in the line and the distance between the same point and the next point in the
            line. If the ratio of the distance between the two adjacent segments exceeds the aspect
            ratio defined, HyperMesh places a joint between the
            segments.
linear angle
Defines the angle at which HyperMesh should consider a
            line straight. For example, if the line angle between three consecutive points along the
            line is greater than the linear angle specified, HyperMesh
            removes the center point from the line. 
pro_dir
The vector of direction along which the line is projected after it is created from the
            node list.
binder_surf
The surface onto which the line is projected.

","Example
*createlist(nodes, 1) 1 2 3 4
*createvector(1, 0.0, 0.0, 1.0)
*linecreatefromnodesandprojecttobinder(0, 1, 179.0, 5, 179.0, 1, 24)

*linecreatefromnodesandprojecttobinder() has two more parameters than *linecreatefromnodes().
","Errors
None.
"
957,*linecreatenormalfromgeom,"Description
This command creates straight segment lines of a user defined length from a given set of
        points or nodes normally to a given set of geometry entities. The segment is created for
        each pair of point and geometry. The input nodes/points must be attached or associated with
        their respective geometry.
","Inputs

point_type
Type of entities representing input points. Valid values are nodes or points.
point_mark_id
The mark of input points or nodes.
geom_type
Type of geometry entities. Valid values are lines, surfs, faces or solids.
geom_mark_id
The mark of input geometry entities.
length
The length of the normal line.
?mode?(optional)
Indicates different modes. Bit values are used and the value is calculated as (Bit0 + 2*Bit1).
Bit0
 0 - the normal direction is used, which is the default case 
1 - The direction opposite to the normal direction is used to create the
                  segment
Bit1
Specifies how entities are organized into components. Valid values are:
0 - Line is created in the current component, which is the default valule. 
1 - Line is created in the input geometry component.





","Example
To create a straight segment normally from node ID 10 to surface ID 21, with length 18:
*createmark nodes 1 10
*createmark surfs 1 21
*linecreatenormalfromgeom  nodes 1 surfs 1 18
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
958,*linecreatespline,"Description
This command creates a cubic spline curve that interpolates input points. Various
        conditions can be used to specify the spline behavior at the endpoints.
","Inputs

point_type
Type of entities representing input points. Valid values are nodes or points.
point_list
List ID of the input points or nodes. Minimum of 2 points or nodes must be
            selected.
scond, econd
Parameter specifying the constructed spline behavior at curve start
              (scond) or end (econd). Valid values are:
0 - Spline direction at endpoint is not constrained 
1 - Spline is closed. In this case any other end condition is ignored. Closed
                smooth cubic spline is constructed. 
2 - Spline direction at endpoint is tangent to direction of input vector
                  svector (for scond) or
                  evector (for econd). 
3 - Spline direction at endpoint is normal to direction of input vector
                  svector (for scond) or
                  evector (for econd). 
4 - Spline parametric derivative at endpoint equals to input vector
                  svector (for scond) or
                  evector (for econd). Normalized spline
                parameterization of 0 to 1 is implied.


svector
Vector used to apply boundary condition specified by parameter
              scond. Only required when scond is 2, 3 or
            4.
evector
Vector used to apply boundary condition specified by parameter
              econd. Only required when econd is 2, 3 or
            4.

","Examples
To create a closed spline that interpolates nodes 11, 12 and 13:
*createlist nodes 1 11 12 13
*linecreatespline nodes 1 1
 To create a spline that interpolates the same nodes, is tangent at its start to vector
        (0,0,1) and is normal at its end to vector (1,0,0):
*createlist nodes 1 11 12 13
*createvector 1 0 0 1
*createvector 2 1 0 0
*linecreatespline nodes 1 2 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
959,*linedraglinetoformsurface,"Description
Drags a trimmed line along a trimmed line to create a surface, and optionally, prepares it
        for immediate use within the automesher. It can also identify a region in the shape of a
        line-dragged surface for the automesher to use under the mesh without surface option. 
","Inputs

sectionlinelist
The ID of the list of lines to be dragged.
sectionnodelist
The list ID of the list of zero or two nodes which lie on the lines in the
            sectionlinelist which will be used to trim the line during surface creation. 
draglinelist
The ID of the list of lines to drag along. 
dragnodelist
The list ID of the list of zero or two nodes which lie on the lines in the
            draglinelist which will be used to trim the line during surface creation. 
refplane
The orientation plane used to orient the section lines to the drag lines. 
using_default_vector
0 - Use plane normal vector 
1 - Use default normal vector

","Example
To drag lines 3 and 4 along lines 2 and 1 using the given plane, creating a surface but no
        elements: 
*surfacemode(4)
*createlist(lines,1) 3 4
*createlist(nodes,1)
*createlist(lines,2) 2 1
*createlist(nodes,2)
*createplane(1,0.0000,1.0000,0.0000,0.0000,0.0000,100.0000)
*linedraglinetoformsurface(1,1,2,2,1)

The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
*createlist() and *createplane() are required for
        this command. 
","Errors
None.
"
960,*lineextendtoline,"Description
 Extends line1 to line2.
","Inputs

line1
The ID of the line to extend.
line2
The ID of the line to which line1 is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of line2, then force the end
            point to be on line2.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
961,*linelistbypath,"Description
Creates a line path from the starting line to the ending line.
","Inputs

line_id1
The ID of the first line.
line_id2
The ID of the second line.
list_id
The ID of the line list to populate. Valid values are 1 and 2.
flag
0 - If both line_id1 and line_id2 lie are free
            edges, the path will follow free edges where possible. Otherwise, the shortest path is
            returned. 
1 - Always return the shortest path.

","Example
To determine the path between lines 100 and 110 using the shortest path:
*linelistbypath 100 110 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
962,*linemesh_savedata1,"Description
Creates 1D elements and cleans up memory. 
Each call to this command must be paired with a previous call to
          *linemesh_preparedata1 or
          *linemesh_preparenodeslist1.
","Inputs

create_flag
0 - Do not generate elements. 
1 - Generate elements.
config
The 1D element config ID of the elements to create. If creating bar2 elements (config
            60) the command *linemesh_savedata_bar1 should be used.
property_id
The ID of the property to assign to the 1D elements.
organize
0 - Organize new 1D elements to current component. 
1 - Organize new 1D elements to input lines component(s).

","Examples
To mesh lines 15 and 18 with a 30 degree break angle, creating rigid elements with no
        property:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
To mesh between nodes 16, 17, and 2 with 3 rigid elements between nodes 16 and 17 and with
        2 rigid elements between nodes 17 and 2, with no property assignment, organizing to the
        input line component(s):
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 1
To mesh between nodes 16, 17, and 2 without creating elements:
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1 5
*linemesh_savedata1 0 5 0 0
","Errors
None.
"
963,*linereverse,"Description
This command reverses the direction for a given input line. Works for free lines only.
","Inputs

 line_id
Input line ID.

","Example
To reverse line 12:
*linereverse 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
964,*linescombine,"Description
Combines two free surface edges to create one unsuppressed common edge.
","Inputs

edge1, edge2
Two free surface edges (face edges which are attached to a surface only once).
edge_tolerance
The edges must be within this tolerance.

","Example
To combine edges 101 and 39, using a tolerance of 0.1:
*linescombine(101,39,0.1)
","Errors
None.
"
965,*linesplitatjoint,"Description
Splits a line at a joint. 
","Inputs

line
The line which should be split. 
node
The node which represents a position close to the joint where the line should be
            split. 

","Example
To split line 10 at node 3: 
*linesplitatjoint(10,3)

","Errors
None.
"
966,*loadcreatewithsystem,"Description
Creates a load (force, moment, pressure, or constraint) at a node or element defined in a
        local coordinate system.
","Inputs

mark
The ID of the mark containing the nodes or elements that will bear the load.
config
The load configuration.
type
Solver dependent types of the referenced load config.
1 - Force 
2 - Moment 
3 - Constraint 
4 - Pressure 
5 - Temperature 
6 - Nodal flux 
8 - Velocity 
9 - Acceleration


component 1-6
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            999999.0. All of the other components of the constraints are active in the respective
            directions. 
Finally, for pressures the active components are 1, 2, and 3, which represent the x,
            y, and z axes respectively. To create a pressure that is normal to the element, set all
            components to zero.
system
ID of the coordinate system to use.
transformflag
 Indicates which system supplies component values.
0 - If the component values are supplied in the global coordinate system. 
1 - If the component values are supplied in the local coordinate system.



","Example
To apply a force of magnitude 10.0 along the x axis of local system 4 to nodes 5 and 25: 
*createmark(nodes,1) 5 25
*loadcreatewithsystem(1,1,1,10.0,0.0,0.0,0.0,0.0,0.0, 4,1)
To apply a constraint of zero in the global 1, 3, 5 directions to nodes 12, 13, and 14, but
        have the constraint communicated to the solver in the local coordinate system with ID 4:
*createmark(nodes,1) 12 13 14
*loadcreatewithsystem(1,1,3,0.0,999999.0,0.0,999999.0,0.0,-999999.0, 4,0)

","Errors
None.
"
967,*loadcreatewithsystemonentitywithvars,"Description
Create loads on nodes using Tcl variables for the load components, using a local
        system.
","Inputs

entity_type
The type of entity the load is applied to. Currently only nodes are supported.
mark_id
The ID of the mark containing the entities.
config
The config of the load to create: 
1 - force 
2 - moment 
3 - contraint 
5 - temperature 
6 - nodal flux 
8 - velocity 
9 - acceleration
type
Solver-dependent type of the specified config.
comp1_var - comp6_var
Tcl variables containing the components of the load for each node. Each variable is an
            array with its indices as node IDs and its value the component for that direction. If
            the variable or index does not exist, the component will be set to zero. These variables
            must be fully qualified when passed in (e.g. ::data::comp1).
system_id
The ID of a system that will transform the first three components before creating the
            load. An ID of zero indicates use of the global system.

","Example
To create a force on node 50 with a value of 100 in the x-direction and on node 51 with a
        value of 200 in the y-direction, relative to system 5:
set ::comp1(50) 100
set ::comp2(51) 200
*createmark nodes 1 50 51
*loadcreatewithsystemonentitywithvars nodes 1 1 1 ::comp1 ::comp2 ::comp3 ::comp4 ::comp5 ::comp6 5
","Errors
None.
"
968,*loadsupdate,"Description
Updates the magnitude, direction, and coordinate system of selected loads. 
","Inputs

markmask
ID of the mark containing the loads to update.
config
The configuration of the load: 
1 - Force 
2 - Moment 
3 - Constraints 
5 - Temperature 
6 - Flux 
8 - Velocity 
9 - Acceleration
type
The type assigned to the load (as defined on the Load Types panel).
updatevector
A variable that controls if the direction of the load should be updated.
component[1-6]
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z-axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z-axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            -999999.0. 
All of the other components of the constraints are active in the respective
            directions. For pressures, the active components are 1, 2, and 3, which represent the x,
            y, and z-axis, respectively. To create a pressure that is normal to the element, set all
            components to zero.
updatemag
An integer variable that controls if the magnitude is updated.
magnitude
The new value of magnitude of the load.
update_system
A variable that controls if the system is updated.
system_id
The ID of the local system.
transform_flag
A simple integer variable that controls if the load is created in the local system. 

","Example
To update a force of 10 N along the y axis to a force of 20 N along the y axis:
*createmark(loads,1) 4
*loadsupdate(1,1,1,0,0,1,0,0,0,0,1,20,0,0,1)

*loadsupdate() is the update command for all loads.
","Errors
None.
"
969,*loadsupdatefixedvalue,"Description
Updates the fixed constraint value on SPC and SPCD constraint loads forOptiStruct.
","Inputs

mark_id
The ID of the mark containing the SPC and SPCD constraints to update. Valid values are 1 and 2.
fixed_value
0 - Do not retain the deformed boundary resulting from a preceding nonlinear subcase 
1 - Retain the deformed boundary resulting from a preceding nonlinear subcase 

","Example
To update a fixed value for SPC load 4:
*createmark loads 1 4
*loadsupdatefixedvalue 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
970,*maketempfrompreservednodes,"Description
This command converts nodes from preserved nodes to temp nodes.
","Inputs

mark_id
The ID of the mark containing the nodes to convert. Valid values are 1 and 2.

","Example
To convert nodes 1-4 from temp to preserved:
*createmark nodes 1-4
*maketempfrompreservednodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
971,*markcombineelements,"Description
Combines selected plate and shell elements into one quad or tria element. 
","Inputs

mark
The ID of the mark containing the elements to be combined. 
tolerance
The maximum tolerance allowed before a node within the group of selected elements is
            considered to be not on the plane formed by any three nodes attached to the group of
            selected elements. 
quad or tria
A flag designating the type of element you want to create. 
0 - tria 
1 - quad

","Example
To combine elements 10, 13, and 15 into a tria, using an off-plane tolerance of 0.1:
*createmark(elements, 1) 10 13 15
*markcombineelements(1, 0.1, 0)
This command works with two-dimensional elements only. 
","Errors
None.
"
972,*markercreate,"Description
This command creates an MBD analysis marker.
","Inputs

name
The name of the marker.
node_id
The ID of the node that defines the location of the marker.
syst_id
The ID of the orientation coordinate system.
syst_flag
A flag for the coordinate system. A value of 0 indicates that the coordinate system
            will be blank.
color
The color of the marker.

","Example
To create a marker m1 at node ID 100 using coordinate system ID 10:
*markercreate ""m1"" 100 10 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
973,*markintersectplane,"Description
Selects a chain of elements and nodes cut by a given section plane.
","Inputs

EntityMark
The mark containing the elements or components to be intersected.
Plane
The ID of the plane to use for intersection calculations.
ElemOutMark
The mark to contain the intersected elements
NodeOutMark
The mark to contain one row of nodes along the intersected elements.

","Example
To find the nodes and elements inside of the components mark cut by a user-defined plane,
        and place these nodes/elems into mark 2:
*createmark elements 1 displayed
*createplane 1 0.0002 -0.3832 0.0004 850.3620 237.5095 349.0000
*markintersectplane components 1 1 2 2

","Errors
None.
"
974,*markmovetomodule,"Description
This command organizes entities into a module.
","Inputs

entity_type
The type of entity to organize.
mark_id
The ID of the mark containing the entities to organize. Valid values are 1 and 2.
module_name
The name of the module to organize the entities into.

","Example
To move comps 1-4 into module ""Test"":
*createmark comps 1 1-4
*markmovetomodule comps 1 ""Test""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
975,*maskall,"Description
Masks all supported entities. This includes: 
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors
tags
domains
handles
morphconstraints
morphvolumes
shapes
symmetries


","Example
To mask all supported entities:
*maskall
","Errors
None.
",
976,*maskreverse,"Description
Reverses the masking state of a specific entity type. For collected entities, only entities
        in displayed collectors are affected. This includes: 
components (points, lines, surfaces, solids, elements, connectors)
points
lines
surfaces
solids
elements (both in components and groups)
connectors
groups (elements)
multibodies (ellipsoids, mbjoints, mbplanes)
ellipsoids
mbjoints 
mbplanes 
loadcols (loads) 
loads 
equations 
systemcols (systems) 
systems 
vectorcols (vectors) 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
To reverse the masking of all vectors in the displayed vector collectors:
*maskreverse vectorcols

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
977,*maskreverseall2,"Description
Reverses the masking state of supported entities. Only entities in displayed collectors are
        affected. This includes: 
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors


","Example
To reverse the masking of all supported entities in the displayed collectors:
*maskreverseall2
","Errors
None.
",
978,*ME_CoreBehaviorAdjust,"Description
Adjusts part and part assembly related behaviors based on certain aspects and policies.
","Inputs
Valid aspects and their policy values are:

allow_automatic_occurrence_splitting
Every occurrence has an associated base prototype.  A single prototype may provide the
            base for multiple occurrences (e.g. a prototype of a wheel might have four occurrences
            in a vehicle).  Once automatic splitting is enabled, any modification that may happen in
            an occurrence will cause it to be separated (split) from its original prototype to a new
            prototype of its own, containing all the modifications made.  In the wheel/vehicle
            example, changes made to the front left wheel will cause it to be separated in a
            different prototype, while all the rest of the wheels remain based on the original
            prototype, thus having now two prototypes instead of just one. Possible values are: 
yes - Enable automatic splitting.
no - Disable automatic slitting (default).
allowable_actions_policy
Defines the availability of various actions that operate on parts and part assemblies.
            Possible values are: 
default - Allows all actions. 
TC - TeamCenter policy. Prevents renaming, re-parenting and deleting. 
TC_lite - TeamCenter lite policy. Prevents renaming and re-parenting.

","Example
To set the allowable actions policy to TC lite:
*ME_CoreBehaviorAdjust ""allowable_actions_policy=TC_lite""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
979,*ME_ModuleOccurrenceConvert,"Description
Converts a module from part to part assembly and vice-versa, assuming it’s allowed from the
        current hierarchy status and entity containment rules. To check if the conversion is
        allowed, use hm_me_moduleoccurrenceconvert_isallowed.
","Inputs

id
The ID of the module to convert. The module must be an occurrence.
type
part - Converts the module to a part. That means it will become a leaf in module
            hierarchy and cannot contain other parts or part assemblies, only other entity types. A
            module explicitly created as part assembly cannot be converted to part. 
assembly - Converts the module to a part assembly. That means it will be able to hold
            other parts and part assemblies, as well as other entity types based on entity
            containment rules.
reserved
Reserved for future use. Must be set as """".

","Example
Convert module ID 168 from a part assembly to a part:
*ME_ModuleOccurrenceConvert 168 part """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
980,*ME_ModuleOccurrenceMoveContents,"Description
 Move the contents from one module part to another.
","Inputs

source_id
The ID of the source module part whose contents are being moved.
target_id
The ID of the target module part receiving the contents.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
purge_target=<flag>
0 - Keep the original destination part contents alongside the moved contents. 
1 - Default. Purge/delete the target module’s contents before starting the move
                  operation. 



","Example
Delete the contents in part 40, and then move the contents of part 30 to part 40:
*ME_ModuleOccurrenceMoveContents 30 40 ""purge_target=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
981,*ME_TransformationMatrixSet,"Description
Sets the transformation matrix for a module.
","Inputs

id
The ID of the module to set the transformation for.
rXcY
The row (X) and the column (Y) for the 4 x 4 transformation matrix.
is_relative
0 - An absolute matrix is passed, so internally derive the local relative matrix. 
1 - A relative (to the parent module) matrix is passed in, so use it directly. 

","Example
Translate the passed 4 x 4 absolute matrix to a relative matrix, and store this in the
        hierarchy for module 168:
*ME_TransformationMatrixSet 168 0.994123 -0.058675 0.090977 0 0.058296 0.998276 0.006823 0 -0.09122 -0.001479 0.99583 0 3171.78 508.679 1582.44 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
982,*mechapplybodymovements,"Description
Moves the bodies of a mechanism to the specified matrix orientation. 
The mechanism must have the enabled flag set to true for this to be possible. 
This is used internally for solver operations and is not recommended for end-users.
","Inputs

bodies_array
The ID of the string array that contains the names of the bodies to update. The array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_bodies
Integer indicating the size (number of bodies) in the array created using
              *createstringarray. This must be the same as
              number_of_matrices.
matrices_array
The ID of the double 2D array that contains the 4x3 matrices. The array is created
            using the *createdoublearray2d command. This should always be set to
            1. 
The matrix elements are given in the following order:
xaxis1 xaxis2 xaxis3 yaxis1 yaxis2 yaxis3 zaxis1 zaxis2 zaxis3 position1 position2
            position3
number_of_matrices
Integer indicating the rows (number of matrices) in the array created using
              *createdoublearray2d. This must be the same as
              number_of_bodies.
number_of_matrix_elements
Integer indicating the columns (number of elements per matrix) in the array created
              using *createdoublearray2d. This must be set to 12.

","Examples
To apply position with ID 3 on mechanism with ID 1:
*mechconstructfromedi 2 3
*mechapplybodymovements 1 0
To move 7 bodies with a matrix orientation:
*createstringarray 7 ""Fix_Rail"" ""Move_Rail"" ""Roller"" ""Front_Lever"" ""Rear_Lever""   ""Seat_Cushion"" ""Back_Seat""
*createdoublearray2d 7 12 \
1 0 0 0 1 0 0 0 1 -1905.69155 354.020211 364.071702 \
0.999999114 -0.000727765047 -0.00111450131 0.000727161917 0.999999589 -0.000541475532 0.00111489492 0.000540664629 0.999999232 -1831.77992 339.826305 396.010172 \
0.999999996 -8.52472731e-005 6.68843529e-006 8.52472333e-005 0.999999996 5.95670407e-006 -6.68894306e-006 -5.95613387e-006 1 -1906.86575 353.204386 367.817282 \
0.78961924 -0.00116572455 -0.613596038 0.00088450914 0.999999319 -0.000761573242 0.613596507 5.86215809e-005 0.789619733 -1678.57592 327.008703 476.854454 \
0.581245504 -0.00107812242 -0.813727535 0.000811882833 0.999999393 -0.000744989557 0.813727844 -0.000227629586 0.581246027 -2000.582 334.362031 476.908588 \
0.994393674 -0.0008628871 -0.105737772 0.000748529572 0.999999091 -0.00112120052 0.105738643 0.00103576685 0.994393416 -1782.50488 333.097311 547.540308 \
0.994393672 -0.000863464035 -0.105737788 0.000749102696 0.999999091 -0.00112126678 0.10573866 0.00103577213 0.994393415 -2112.46025 320.887101 909.524211
*mechapplybodymovements 1 7 1 7 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
983,*mechapplyediposition,"Description
Applies a position to a mechanism. This will be always used in conjunction with
          *mechcontructfromedi. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

mode
The mode for the position: 
0 - Initial position 
1 - Active position
run_solver
0 - Directly apply the position to bodies without considering constraints and joints. 
1 - Run the solver to apply the position along with constraints and joints.

","Examples
To apply position with ID 3 on mechanism with ID 1:
*mechconstructfromedi 2 3
*mechapplyediposition 1 0
To apply the initial position on a mechanism:
To apply the initial position on a mechanism:
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
984,*mechjointlimits,"Description
Sets the type of limits to use on joints for the current dummy. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

limits
0 - Hard limits (default) 
1 - Soft limits

","Example
To activate soft limits on the current dummy:
*mechjointlimits 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
985,*menufilterenable,"Description
Enables filtering.
","Errors
None.
",,
986,*meshline_delete,"Description
This command deletes meshlines.
","Inputs

mark_id
The ID of the mark containing the meshlines. Valid values are 1 and 2.

","Example
To delete meshlines 100-200:
*createmark lines 1 100-200
*meshline_delete 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
987,*meshline_mark_entity_inside_class,"Description
This command marks entities as being inside a meshline class.
","Inputs

entity_type
The type of entity to mark. Valid values are nodes and elements.
mark_id1
The ID of the mark containing the new entities to add. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the previous entities. Valid values are 1 and 2.

","Example
To add element 500 inside a meshline class:
*createmark elems 1 500
*meshline_mark_entity_inside_class elems 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
988,*meshline_set_approximate_tol_factor,"Description
Sets the tolerance factor for approximating meshlines with NURBs curves. 
","Inputs

tol
The tolerance factor to use. Must be > 0.0.

","Example
To set the meshline tolerance factor to 0.5:
*meshline_set_approximate_tol_factor 0.5

","Errors
None.
"
989,*meshtopologyadjust,"Description
This command is intended to work with 2D meshes created by QI meshing, batchmeshing,
        element remeshing and manual editing tools. Very often such meshes have multiple elements
        intersected by the surfaces selection boundary edges. This command attempts to adjust the
        mesh on selected surfaces to its boundary by moving nodes to the boundary, splitting
        elements or suppressing geometry edges or vertices.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
flags
A flag that controls the level of mesh adjustment to topology. Valid values are: 
0 - Adjustment ensures that all elements within the selection are not intersected by
            the selection boundary edges. It’s not guaranteed that there are no geometry vertices in
            the middle of boundary element edges. There are no topology changes for this value. 
1 - Adjustment ensures that all elements within the selection are not intersected by
            the selection boundary edges. All boundary element edges shared with any adjacent mesh
            do not have any geometry vertices in the middle. Some topology changes may occur for
            this case such as the suppression of geometry edges and vertices. 
3 - Adjustment provides that all elements within the selection are not intersected by
            the selection boundary edges. All boundary element edges (both those shared and not
            shared with any adjacent mesh) do not have any geometry vertices in the middle. Some
            topology changes may occur for this case such as the suppression of geometry edges and
            vertices.

","Example
To adjust the elements for surface 143 with full adjustment to topology edges of elements
        edges shared with adjacent mesh:
*createmark surfaces 1 143
*meshtopologyadjust 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
990,*metadatamarkdate,"Description
Creates date metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The date value assigned to the metadata. This is the number of seconds since the epoch
            (i.e., January 1st 00:00:00 1970).

","Example
To add metadata named Date with the current time in seconds since the epoch:
*createmark undef 1 
*metadatamarkdate undef 1 ""Date"" [clock seconds]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
991,*metadatamarkentityidtype,"Description
Creates entity ID type metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
entity_type_2
The type of entity which the metadata references.
value
The entity ID value assigned to the metadata.

","Example
To add metadata named Surface with surface 100 to elements 1-100:
*createmark elems 1 1-100
*metadatamarkentityidtype elems 1 ""Surface"" surfs 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
992,*metadatamarkint,"Description
Creates integer metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The integer value assigned to the metadata. 

","Example
To add metadata named Int_Val with the value 5 to elements 1-100:
*createmark elems 1 1-100
*metadatamarkint elems 1 ""Int_Val"" 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
993,*midsurface_collapse_lines,"Description
Sets the selection of lines to be collapsed during mid-surface extraction when performing a
        rerun operation. 
","Inputs

mark_id
The ID of the mark containing the lines to collapse. Valid values are 1 and 2.

","Example
To set the lines with IDs 5-7 to collapse during the mid-surface extraction when performing
        a rerun operation:
*createmark lines 1 5 6 7
*midsurface_collapse_lines 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
994,*midsurface_offset_by_targets_11,"Description
Offsets a surface according to the targets that are attached to its vertices and edges.
","Inputs

surface
The ID of the surface to offset.
mode
The mode for the selected surfaces. Valid values are: 
1 - Preserves the planarity of the surfaces that were planar before the offset 
Any other value - A planar surface might become curved if the targets set to offset
            the surface are not in one plane.

","Example
To offset the mid-surface from a surface with ID 109:
*midsurface_offset_by_targets_11 109 1
","Errors
None.
"
995,*midsurface_remove_display_plates,"Description
The command deletes components that show the plate information present in the model. The
        command can also be used to delete all the plate and thickness information present in the
        model.
","Inputs

delete_plate_info
This specifies whether, besides deleting the plate information components, the plate
            information itself should be deleted. Valid values are: 
0 - Delete all components showing plate information, and retain the plate and
            thickness information present on relevant surfaces. 
1 - Delete all components showing plate information, and delete the plate and
            thickness information present on relevant surfaces.
remove_from_all_comps
Specifies whether to delete the plate information from the entire model or just from
            specific components where the plate edit is performed. Valid values are: 
0 - Delete display plates from all components for which temporary comps are drawn.
            This was the default behavior pre-14.0. 
1 - Delete display plates from all components (even inactive).
reserved1
Reserved for future use. Must be set to 0.

","Examples
To delete the components showing plate information, as well as the plate and thickness
        information:
*midsurface_remove_display_plates 1 0 0

To delete the components showing the plate information, as well as the plate information
        itself, from all components:
*midsurface_remove_display_plates 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
996,*midsurface_remove_edit_bodies,"Description
No arguments are required for this command.
","Errors
None.
",,
997,*midsurface_update_from_plate_edit,"Description
The command removes relevant pre-existing midsurfaces and plate display components,
        extracts mid-surfaces corresponding to the existing plate edit information, and re-draws the
        plate display components. This command replicates and expands upon the functionality
        available in the *midsurface_extract_10 command, and all parameters have
        the same meaning as for *midsurface_extract_10.
","Inputs

entity_type
The type of entity selected for mid-surface extraction. Valid values are surfaces and
            solids.
mark_id
The ID of the mark containing the input entities.
outbound_normals
If entity_type is surfaces:
 -1 - If surfaces selected on mark_id form a closed solid (but
                  entity_type parameter is not set to solid). In this case the
                surfaces will be re-oriented, if needed, to have the normals go outside the solid
                they form. 
0 - If the normals go inside the selected surfaces 
1 - If the normals go outside the selected surfaces


If entity_type is solids:
3 - The parameter must be set to this value.


thickness_bound
Limits on midsurface thickness: 
0 - No limit. Max ratio set using max_thickness_ratio. 
1 - User-defined thickness limits. Limits set using min_thickness
            and max_thickness.
align_steps
Determines how steps are aligned for solids with discrete sections. This parameter
            also determines whether any specified base surfaces are taken into account when
            constructing the middle surface. If the values are 0, 1, or 2, the base surfaces are not
            used. In order to take the base surfaces into account, the value should be increased by 3.
0 - Steps are not aligned at the thickness jumps (jumps maintained). Base
                surfaces will not be used. 
1 - Steps aligned at the thickness jumps. Mid-surface position set automatically.
                Base surfaces will not be used. 
2 - Steps aligned at the thickness jumps. Mid-surface position set using
                  mid_position. Base surfaces will not be used. 
3 - Steps are not aligned at the thickness jumps (jumps maintained). Base
                surfaces specified by you will be taken into account. 
4 - Steps aligned at the thickness jumps. Mid-surface position set automatically.
                Base surfaces specified by you will be taken into account. 
5 - Steps aligned at the thickness jumps. Mid-surface position set using
                  mid_position. Base surfaces specified by you will be taken into
                account.


extract_by_comp


0 - Extraction of the mid-surfaces can occur between any matching pair of the
                surfaces. 
1 - Extraction of the mid-surfaces can occur only between the surfaces that
                belong to the same component.


rerun_type
Used to specify one of the midsurface extraction methods: offset, offset+planes and
            offset+planes+sweeps. If the value is 0, 1, or 2 the extraction method is ""offset"". If
            you want to use extraction method ""offset+planes"" instead, the value should be increased
            by 3. If you want to use the extraction method ""offset+planes+sweeps"", the value should
            be increased by 6.
0 - Simply extracts the mid-surface. Midsurface extraction method is ""offset"". 
1 - Extracts the mid-surface and at the same time copies the lines that collapsed
                into ""Collapsed Lines"" component. Midsurface extraction method is ""offset"". 
2 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset"". 
3 - Simply extracts the mid-surface. Midsurface extraction method is
                ""offset+planes"". 
4 - Extracts the mid-surface and at the same time copies the lines that collapsed
                into ""Collapsed Lines"" component. Midsurface extraction method is ""offset+planes"". 
5 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset+planes"". 
9 - Simply extracts the mid-surface. Midsurface extraction method is
                ""offset+planes+sweeps"". 
10 - Extracts the mid-surface and at the same time copies the lines that
                collapsed into ""Collapsed Lines"" component. Midsurface extraction method is
                ""offset+planes+sweeps"". 
11 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset+planes+sweeps"".


stitch_tol_mode
Defines the mode for performing mid-surface stitching. Valid values are:
0 - Final stitching of the mid-surfaces is performed using a local tolerance of
                1/5 of the local surface thickness (default in prior versions). 
1 - Final stitching of the mid-surfaces is performed using the geometry cleanup
                tolerance. This is recommended when extensive manual editing of the auto
                mid-surfacing result is expected, because having ""far"" stitching may misrepresent
                the geometry of the model and affect subsequent geometry operations.


max_R_t_ratio 
This is a ratio between the fillet radius and plate thickness analyzed at T, X and
            similar junctions. If the calculated ratio is greater than this parameter, the fillet
            does not collapse. In previous releases the ratio was a default value of 2 and could not
            be changed
reserved_1
Reserved for future use. Must be set to 0.
reserved_2
Reserved for future use. Must be set to 0.
max_thickness_ratio
This is a ratio between a plate thickness found during the midsurfacing and the
            minimum plate thickness found during the midsurfacing.  If the ratio is exceeded the
            corresponding midsurface will be ignored. The parameter is used  when
              thickness_bound is 0. It can be any real number > 1.
min_thickness
Sets the minimum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number ≥ 0.
max_thickness
Sets the maximum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number >
              min_thickness.
mid_position
Sets the midsurface position for step alignment case when
              align_steps is set to 2. This can be any number between 0 and
            1.
reserved_3
Reserved for future development. Value = undefined.
reserved_4
Reserved for future use. Must be set to 0.
reserved_5
Reserved for future use. Must be set to 0.
new_or_curr_comp


0 - Midsurface will be created in the current component. 
1 - Midsurface will be created in a new component named ""Middle Surface"".



","Example
To extract the midsurface of solids ID 5 through 7, no thickness bounds, align the steps at
        0.39, only extract surfaces between the same component, max thickness ratio of 10, and
        organize them into the ""Middle Surface"" component:
*createmark solids 1 5 6 7
*midsurface_update_from_plate_edit solids 1 3 0 2 1 0 0 2 10 0 0 0.39 undefined 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
998,*minmaxtitlesetfont,"Description
Sets the font of a minimum or maximum title.
","Inputs

font
The font number for the descriptor (1-4).
type
0 - Node title (contour plot) 
1 - Element title (assigned plot)
minmax
0 - Minimum title 
1 - Maximum title

","Errors
None.
",
999,*modifyicelement,"Description
Modifies a dependent node of an IC element.
","Inputs

id
The ID of the IC element to modify.
mode
1 - Move up in the order 
2 - Move down in the order 
3 - Delete
node_id
The ID of the node to modify.

","Example
Create an IC element with independent node 15, and dependent nodes to 16, 17, 18, 19 with
        DOF’s 123, 345, 1234, 123456, then remove node 18:
*icelementcreate
*createintarray2d 2 4 16 17 18 19 123 345 1234 123456
*addicconnectivity 1 15 1 2 4
*modifyicelement 1 3 18
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1000,*morphalteranglevec,"Description
Alters the angle for three nodes using morphing and measuring perpendicular to a
        vector.
","Inputs

h1type
Handles
h1mark
Handle mark number - end a
h2type
Handles
h2mark
Handle mark number - end b
n1
ID of node - end a
n2
ID of node - vertex
n3
ID of node - end b
hold
Determines which of the three nodes should be held: 
0 - Hold end a 
1 - Hold end b 
2 - Hold middle
ang
New angle between n1 and n3 with
              n2 as the vertex
sym
Flag to determine whether or not to use symmetry: d 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag to determine whether or not to use constraints: 
0 - Do not use constraints 
1 - Use constraints
vec
Vector mark number

","Example
*morphalteranglevec (HANDLES,0,HANDLES,1,132,783,171,0,45.0,1,1,1)
The handles on the marks will be moved based on hold through an angle
        based on the current angle and ang, measured perpendicular to vector
          vec, and using n1, n2, and n3 to
        determine the perturbations. If symmetry is used all handles linked to marked handles by
        symmetry will also be perturbed. If constraints are used they will be applied to the
        perturbations. 
","Errors
None.
"
1001,*morphalterdistancevec,"Description
Alter the distance between two nodes using morphing and measuring along a vector.
","Inputs

h1type
Handles
h1mark
Handle mark number - end a
h2type
Handles
h2mark
Handle mark number - end b
n1
ID of node - end a
n2
ID of node - end b
hold
Specify which part of the 2-node system to anchor: 
0 - Hold end a 
1 - Hold end b 
2 - Hold middle
dist
New distance between n1 and n2
sym
Flag for use of symmetry: 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag for use of constraints: 
0 - Do not use constraints 
1 - Use constraints
vec
Vector mark number

","Example
*morphalterdistancevec (HANDLES,0,HANDLES,1,132,783,0,100.0,1,1,1)
The handles on the marks will be moved based on hold to create the new
        distance dist between n1 and n2 as
        measured along vector vec. If symmetry is used, all handles linked to
        marked handles by symmetry will also be perturbed. If constraints are used, they will be
        applied to the perturbations.
","Errors
None.
"
1002,*morphapplylargedomains,"Description
Applies current morphing to large domains.
","Example
*morphapplylargedomains
This command applies any current morphing that affects any large domains to those large
        domains. 
This command is only needed when the bigdomainsolve parameter is set to
        manual (0.0). For other values the large domain solver will be applied automatically.
","Errors
None.
",
1003,*morphbiasstyle,"Description
Applies updated bias style retroactively to existing perturbations.
","Inputs

style
The biasing style to use: 
0 - Exponential 
1 - Sinusoidal
con
Use/do not use symmetry: 
0 - Do not use symmetry 
1 - use symmetry

","Example
*morphbiasstyle (1,1)
Recalculates and reapplies all morphs on the morph list in terms of the updated biasing
        factors.
","Errors
None.
"
1004,*morphbiasupdatemulti,"Description
Updates the bias factor for the handles on the mark.
","Inputs

htype
HANDLES
hmark
Handle mark number
bias
New bias value

","Example
*morphbiasupdatemulti(HANDLES,1,2.0)

Updates the handles on the mark to the given bias factor.
","Errors
None.
"
1005,*morphconnstodoms,"Description
This command will create a general domain for each of the connectors on the mark. Each
        general domain will contain all of the elements of the associated connector regardless of
        their type.
","Inputs

entity_type
Valid value is connectors.
mark_id
Mark of connectors. Valid values are 1 and 2.
retain_handles
0 - Do not retain handles 
1 - Retain handles
create_type
0 - Create as normal general domain 
1 - Create as independent domain 
2 - Create as slave domain 
3 - Create as master domain 
4 - Create as cluster domain
If 0 is specified, the domain is created as a general domain, which means that no
            handles will be created for it and it will not share the same behavior as any 1D domains
            in the model. If one of the other options is selected, the general domain will have
            handles created for it in the same way that handles are created for 1D domains of the
            selected type. The general domain will also have the same behavior as 1D domains of the
            selected type (independent, master, slave, cluster).

","Example
To create cluster type domains for all connectors in the model:
*createmark connectors 1 ""all""
*morphconnstodoms connectors 1 0 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1006,*morphconstraintcreateangle,"Description
Creates a model type constraint based on the angle between three nodes.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
type
0 - Measure angle node to node 
1 - Measure angle using vector
name
Name of morph constraint
n1
First end of angle
n2
Vertex of angle
n3
Second end of angle
vec
Mark number of vector
angle
Constrained angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
color
The color of the constraint. Valid values are 1 through 64.

","Example

*morphconstraintcreateangle (SHAPES,1,0,""angle"",21,22,23,1,45.0,0,32)
This command creates a model type constraint for the three selected nodes with the option
        of having those nodes measured in the plane that they lie in or perpendicular to a vector
        and the option of having the angle forced to be greater than, less than, or equal to the
        specified angle. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
1007,*morphconstraintcreateedge,"Description
This command creates a tangency type constraint either between two edge domains or 2D
        domains or at the end of one edge domain. For the master type, dptr1 is
        the master and dptr2 is the slave. For the slave type,
          dptr2 is the master and dptr1 is the slave. For the
        attached type, dptr1 follows dptr2.
","Inputs

name
The name of morph constraint.
dptr1
The ID of the edge or 2D domain.
dptr2
The ID of the edge or 2D domain.
end
The ID of node at fixed end (for fixed type).
type
1 - Fixed (edge domains only) 
2 - Master (edge domains only) 
3 - Slave (edge domains only) 
4 - Continuous 
5 - Attached (edge domains only)
vec
The ID of the vector created using *createvector. Must be set to
            1.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a continuous tangency constraint named ""tang"" between domains 12 and 14:
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateedge ""tang"" 12 14 1 4 1 44
 To create a master tangency constraint named ""master"" where domain 14 is forced tangent to
        domain 12:
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateedge ""master"" 12 14 1 2 1 44
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1008,*morphconstraintcreateeq,"Description
This command will create a constraint for the nodes on the mark which positions the nodes
        on or a specified distance away from the surface of the function. The
          function can contain x, y, and z variables but should not contain an
        equals sign. The surface of the function is located where the value of the function equals
        zero. The function will be positioned at the global origin if meth is set
        to 0. If meth is set to 1, oid will specify the origin
        node and the global system will be used for the x, y, and z directions. If
          meth is set to 2, oid will specify the local system
        to be used for the origin and x, y, and z.
type determines if the nodes move along the surface of the function, are
        bounded by the surface of the function, remain a set distance from the surface of the
        function, or maintain their original distance from the surface of the function.
To enable mesh stretching, add 32 to the type (thus 1, 3, and 5 become
        33, 35, and 37).
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark containing the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface of the function 
1 - Bounded by the surface of the function 
3 - Remains a set distance from the surface of the function 
5 - Maintains its original distance from the surface of the function 
+32 - Enables mesh stretching around constrained nodes
name
The name of the morph constraint to create.
vec
The ID of the vector created using *createvector. Must be set to
            1.
function
String containing a surface definition function f(x,y,z)
distance
Distance nodes must remain away from the surface of the function
              (type 1 and 3 only).
ivec
0 - Project normal to function 
1 - Project along vector vector
meth
0 - Use global origin and system 
1 - Use global system with node ID oid as the origin 
2 - Use local system with ID oid as the origin and system
oid
ID of node or system specified in meth.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To create a constraint where all nodes move along the surface of a sphere and are projected
        normal to the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateeq nodes 1 0 ""sph"" 1 ""x*x+y*y+z*z-100.0"" 0.0 0 0 0 11
To create a constraint where all nodes are bounded by the sphere by a distance of 2.0,
        projected along a vector, and use a local system to orient the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateeq nodes 1 1 ""sph"" 1 ""x*x+y*y+z*z-100.0"" 2.0 1 2 1 11
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1009,*morphconstraintcreatelength,"Description
Creates a model type constraint based on the length of a list of nodes.
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure length node to node 
1 - Measure length using vector
name
Name of morph constraint
nodes
Mark number of node list
vec
The ID of the vector created using *createvector. Must be set to
            1.
length
Constrained length of node list
bound
-1 - Greater than specified length 
0 - Equal to specified length 
1 - Less than specified length
color
The color of the constraint. Valid values are 1 through 64.

","Example
*morphconstraintcreatelength (SHAPES,1,0,""length"",1,1,43.5,0,32)
This command creates a model type constraint for the selected node list with the option of
        having those nodes measured node to node or along a vector and the option of having the node
        list forced to be greater than, less than, or equal to the specified length. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
1010,*morphconstraintcreatesmooth,"Description
This command creates a smooth type morphconstraint for the selected nodes. During morphing,
        the perturbations of the nodes or dependent handles will be modified using a spline based
        approximation so that edge domains running along the selected entities will have smooth
        contours.
","Inputs

nlist
The ID of the list containing the nodes. Valid values are 1 and 2.
type
0 - Apply to nodes. All handles on the node list serve as anchors for the spline curve
            and nodes are adjusted to the curve based on influences 
1 - Apply to dependent handles. Only the independent handles on the node list serve as
            anchors and the dependent handles are adjusted to the curve based on influences
closed
0 - Open ended 
1 - Loop. The first node on the list will be added to the end to form a loop.
name
The name of the morph constraint.
color
The color of the constraint. Valid values are 1 through 64. 

","Example
To create a smooth morphconstraint for nodes 1-5 with a closed loop:
*createlist nodes 1 1 2 3 4 5
*morphconstraintcreatesmooth 1 0 1 ""smooth"" 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1011,*morphconstraintcreatevec,"Description
This command creates a vector type morphconstraint for the selected nodes with the option
        of having those nodes bounded to move no closer than a given distance from the specified
        plane.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the vector 
1 - Moves along the vector and is bounded by the plane 
3 - Moves along the vector, at a set distance from the plane 
5 - Moves along the vector and remains its original distance from the plane 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
plane
The ID of the plane created using *createplane. Must be set to
            1.
dist
The minimum distance from the bounding plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a vector and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*morphconstraintcreatevec nodes 1 0 ""vec"" 1 1 0.0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1012,*morphconstraintupdatearcrad,"Description
Updates a model type constraint based on the radius or arc length of an edge domain.
","Inputs

stype
SHAPES
smark
Mark number of shapes
atype
NODES or LINES
amark
Mark number of node or line used for radius measurement
type
0 - Measure radius or arc angle using domain 
1 - Measure radius or arc angle using axis 
2 - Measure radius or arc angle using line 
3 - Measure radius or arc angle using node
mcon
ID of morph constraint
plane
mark number of plane for axis
dptr
ID of edge domain
radius
Constrained radius or arc angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
arc
0 - Radius 
1 - Arc angle
color
The color of the constraint. Valid values are 1 through  64.

","Example
This command updates a model type constraint for the selected domain with the option of
        updating the radius or arc angle to be measured in the plane of the domain, about an axis,
        about a line or about a node, and the option of having the radius or arc angle forced to be
        greater than, less than, or equal to the specified value. 
If arc is 0, the radius will be constrained. If arc
        is 1, the arc angle will be constrained. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
*morphconstraintupdatearcrad (SHAPES,1,NODES,1,0,5,1,21,5.0,0,0,32)
","Errors
None.
"
1013,*morphconstraintupdateedge,"Description
This command updates a tangency type constraint either between two edge domains or 2D
        domains or at the end of one edge domain. For the master type, dptr1 is
        the master and dptr2 is the slave. For the slave type,
          dptr2 is the master and dptr1 is the slave. For the
        attached type, dptr1 follows dptr2.
","Inputs

mcon
The ID of morph constraint to update.
dptr1
The ID of the edge or 2D domain.
dptr2
The ID of the edge or 2D domain.
end
The ID of node at fixed end (for fixed type).
type
1 - Fixed (edge domains only) 
2 - Master (edge domains only) 
3 - Slave (edge domains only) 
4 - Continuous 
5 - Attached (edge domains only)
vec
The ID of the vector created using *createvector. Must be set to
            1.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a continuous tangency constraint with ID 5 between domains 12 and 14:
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateedge 5 12 14 1 4 1 44
To update a master tangency constraint with ID 12 where domain 14 is forced tangent to
        domain 12:
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateedge 12 12 14 1 2 1 44
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1014,*morphconstraintupdatefc,"Description
This command updates either a fixed type morphconstraint or a cluster type morphconstraint
        for the selected nodes with the option of having mesh stretching around those nodes.
        Rotation options are also available for cluster type morphconstraints.
There are three options for rotation: in-plane, out-of-plane, and full rotation. In-plane
        will limit rotation of the cluster to the plane in which the cluster lies (spinning) while
        out-of-plane limits the rotation of the cluster to take place normal to the plane of the
        cluster (tilting). Full rotation allows both in-plane and out-of-plane rotation. For cluster
        constraints where the nodes do not lie in a discernable plane any rotation option results in
        full rotation.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Fixed type constraint without mesh stretching 
6 - Fixed type constraint with mesh stretching 
7 - Cluster type constraint with mesh stretching (no rotation) 
9 - Cluster type constraint without mesh stretching (no rotation) 
+10 - (type 17 and 19) enables out-of-plane rotation for clusters 
+20 - (type 27 and 29) enables in-plane rotation for clusters 
+30 - (type 37 and 39) enables full rotation for clusters
mcon
The ID of the morph constraint to update.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a cluster morphconstraint with mesh stretching and full rotation:
*createmark nodes 1 ""all""
*morphconstraintupdatefc nodes 1 37 ""rivet"" 12
To update a cluster morphconstraint without mesh stretching and with in-plane rotation:
*createmark nodes 1 ""all""
*morphconstraintupdatefc nodes 1 29 ""rivet"" 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1015,*morphconstraintupdatelength,"Description
Updates a model type constraint based on the length of a list of nodes.
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure length node to node 
1 - Measure length using vector
mcon
The ID of the morph constraint to update.
nodes
Mark number of node list
vec
Mark number of vector
length
constrained length of node list
bound
-1 - Greater than specified length 
0 - Equal to specified length 
1 - Less than specified length
color
Color (1 through 64 inclusive)

","Example
*morphconstraintupdatelength (SHAPES,1,0,5,1,1,43.5,0,32)
This command updates a model type constraint for the selected node list with the option of
        updating those nodes to be measured node to node or along a vector and the option of
        updating the node list to be forced to be greater than, less than, or equal to the specified
        length. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
","Errors
None.
"
1016,*morphconstraintupdatematch,"Description
This command will update a match type morphconstraint between two marks of elements such
        that they maintain a similar shape if the elements of either one mark or both marks are
        morphed. The two meshes do not have to be identical but the more similar they are the better
        the constraint will work. 
This type of constraint can be used multiple times on the same set of elements in order to
        make three or more meshes match each other. Note that only shell elements can be matched
        using this constraint.
","Inputs

a_entity_type
Must be set to elems.
a_mark_id
The ID of the mark containing the first set of elems. Valid values are 1 and 2.
b_entity_type
Must be set to elems.
b_mark_id
The ID of the mark containing the second set of elems. Valid values are 1 and 2.
type
0 - Allow to slide normal to the mesh 
1 - Allow sliding normal to the specified vector vec

2 - Match the shape between the two meshes 
+4 - Stretch mesh around the constrained elements
morphconstraint_id
The ID of the morphconstraint to update.
vec
The ID of the projection vector created using *createvector. Must
            be set to 1. Only used for type 1 and 5.
dist
The distance to be maintained between the meshes. Not used for type
            2 and 6.
node_basea
ID of the base node of a local system oriented to the mesh specified by
              a_mark_id. Only used for type 2 and 6.
node_xa
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by a_mark_id. Only used for type 2 and
            6.
node_xya
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
            by b_mark_id. Only used for type 2 and 6.
node_baseb
ID of the base node of a local system oriented to the mesh specified by
              b_mark_id. Only used for type 2 and 6.
node_xb
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by b_mark_id. Only used for type 2 and
            6.
node_xyb
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
            by a_mark_id. Only used for type 2 and 6.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a match constraint which matches the shape between two meshes
          (type = 2) and uses mesh stretching (type +4 for a
        total of 6):
*createmark elements 1 83 84 86-90 93 95 96 98-102 105 107 *createmark elements 2 50-54 57 62-66 69 74-78 81
*createvector 1 1 0 0
*morphconstraintupdatematch elements 1 elements 2 6 1 1 0 133 135 110 60 62 86 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1017,*morphconvertmv,"Description
Converts the morph volumes on the mark to hexa elements or vice-versa. 
","Inputs

ctype
HYPERCUBES or ELEMS
cmark
Mark number of morph volumes or elements
han
0 - Do not create handles for morph volumes 
1 - Create handles for morph volumes
ord
Order of morph volumes
tan
0 - No tangency 
1 - Make neighboring morph volume edges continuously tangent
mode
0 - Morph volumes to hexas 
1 - Hexas to morph volumes
nauto
0 - Do not register all nodes found inside morph volumes 
1 - Register all nodes found inside morph volumes

","Example
*morphconvertmv (HYPERCUBES,1,1,1,1,0,1)
This command will either convert the morph volumes on the mark to hexa elements or convert
        the hexa elements on the mark to hypercubes with the given options for handles, order,
        tangency, and node registration. 
Morph volumes will always get converted to second order hexa elements.
","Errors
None.
"
1018,*morphdisplayconstraints,"Description
This command will draw or undraw vectors to the screen for the various constraints
        specified on the mark. This command is used when reviewing constraints from the Morph
        constraints panel.
","Inputs

entity_type
Must be set to morph constraints.
mark_id
The ID of the mark containing the morph constraints. Valid values are 1 and 2.

","Examples
To display vectors for all morph constraints in the model:
*createmark morphconstraints 1 ""all""
*morphdisplayconstraints morphconstraints 1
To turn off the vector display:
*createmark morphconstraints 1
*morphdisplayconstraints morphconstraints 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1019,*morphentitydelete,"Description
Deletes entities on a mark.
","Inputs

etype
Entity type
emark
Mark number of entities

","Example
*morphentitydelete (HANDLES,1)
Deletes the entities of the specified type on the mark. 
","Errors
None.
"
1020,*morphhandlecreatenodes,"Description
Creates handles at nodes on mark on domain.
","Inputs

nodetype
Nodes
marknode
Node mark number.
dhandletype
Handles
dmarkhandle
Dependent handle mark number.
domainptr
ID of domain.
name
Name of handle(s) to be created.

","Example
*morphhandlecreatenodes (NODES,1,HANDLES,1,1,""bob"")
Handles are created on the specified domain at the nodes on the mark with dependencies on
        the handles on the mark. The handle mark may be empty. 
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
1021,*morphhandlecreatexyz,"Description
Creates handle at x,y,z, location for the given system. 
","Inputs

dhandletype
Handles
dmarkhandle
Dependent handle mark number.
domainptr
ID of domain.
name
Name of handle(s) to be created.
xx
X coordinate of handle to be created.
yy
Y coordinate of handle to be created.
zz
Z coordinate of handle to be created.
sys
System to create handle in (default = global).

","Example
*morphhandlecreatexyz (HANDLES,1,1,""bob"",1.0,2.0,3.0,3)
 Handle is created on the specified domain at the x, y, and z coordinates for the given
        system with dependencies on the handles on the mark. The handle mark may be empty. 
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
1022,*morphhandleprojectentity,"Description
This command will move each of the selected handles onto the selected surfaces or elements
        along a direction defined by the projection type. Applying symmetry links and constraints is
        optional. All domains influenced by the selected handles will be morphed accordingly. 
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions. 
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to other lines in the model. 
Constraints may move the perturbed handles off of the selected line after the handles are
        moved to the line.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
e_entity_type
Must be set to surfs or elems.
e_mark_id
The mark ID containing the target surfaces or elements. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
nproj
0 - Project along vector proj

1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
 Temporary projection vector ID
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a surface along a vector:
*createmark handles 1 ""all""
*createmark surfs 1 12
*createmark elems 2
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 surfs 1 elems 2 0 1 1 1
To project handles to a mesh normal to the mesh:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createmark elems 2
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 elems 1 elems 2 1 1 1 1
To project handles to a surface normal to the selected elements:
*createmark handles 1 ""all""
*createmark surfs 1 12
*createmark elems 2 7 8 9 10 11 12
*createvector 1 1.0 0.0 0.0
*morphhandleprojectentity handles 1 surfs 1 elems 2 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Unable to create tacit surface from elements."" - occurs if the selected target elements
        cannot be assembled into a useable tacit surface. Selected elements should be shells,
        connected to each other, and of relatively good quality. 
"
1023,*morphhandleprojectplane,"Description
This command will move each of the selected handles on to the defined plane along a
        direction defined by the projection type. Applying symmetry links and constraints is
        optional. All domains influenced by the selected handles will be morphed accordingly.
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions.
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to the specified plane.
Constraints may move the perturbed handles off of the specified plane after the handles are
        moved to the plane.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
plan
Temporary target plane ID.
nproj
0 - Project along vector proj 
1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
Temporary projection vector ID.
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a plane along a vector:
*createmark handles 1 ""all""
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 0 1 1 1
To project handles to a plane normal to the plane:
*createmark handles 1 ""all""
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 1 1 1 1
To project handles to a plane normal to the elements:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphhandleprojectplane handles 1 elems 1 1 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1024,*morphhandleupdatemulti,"Description
Updates dependencies for handles on mark. 
","Inputs

handletype
Handles
markhandle
Handle mark number.
dhandletype
Handles
dmarkhandle
Dependent handle mark number.

","Example
*morphhandleupdatemulti (HANDLES,1,HANDLES,2)
Handles on the first mark are updated to be dependent on the handles on the second
        mark.
","Errors
None.
"
1025,*morphinterpolatesurf,"Description
This command will morph the elements on e_mark_id, or those of an
        internally generated mesh, to a surface interpolated from the nodes or lines on
          n_mark_id. The mode specifies the general shape of the interpolated
        surface (and internally generated mesh) and requires either a specified plane, line, node,
        node list, or system to orient the shape. This command may also be used to generate a
        surface using the interpolated surface but is limited to support only a plane as the general
        shape of the interpolated surface.
For a generated mesh the sizbld option can be used to specify the number
        of elements per side (for a rectangular mesh) or per 45 degree section (for a
        non-rectangular mesh), or it can be used to specify the average element size. For an
        existing mesh (e_mark_id) sizbld is the blend factor %
        which allows you to blend the difference between the shape of the existing mesh and the
        shape of the interpolated surface. A higher blend factor means that the mesh will match
        closer to the interpolated surface.
Covariance, drift, nugget, and nugget value are parameters sent to the Kriging algorithm
        which calculates the interpolated surface. Good default values are ""h"" for covariance,
        ""linear"" for drift, and ""off"" for the nugget.
","Inputs

n_entity_type
Valid values are nodes and lines.
n_mark_id
The mark ID of the nodes or lines. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The mark ID of the elements. Valid values are 1 and 2.
sizbld
If the element mark is empty: 
< 0 - Element density of generated mesh (or surface for mode 8) 
> 0 - Average element size of generated mesh 
If the element mark contains elements: 
blend factor % (0.0 - 100.0)
buffer
% increase in the size of the generated mesh before morphing to interpolated surface
            (0.0 - 100.0) - intended mainly for planar meshes (modes 0 and
            8)
ndens
Number of nodes created on lines for interpolated surface.
mode
Shape of generated mesh and general shape of interpolated surface:
0 - plane 
1 - cylinder 
2 - sphere 
3 - ellipse 
4 - cylinder about node list 
5 - cylinder about line 
6 - enclosed cylinder about nodelist 
7 - enclosed cylinder about line 
8 - plane - create a surface instead of a mesh
plane
Temporary plane ID for orientation or cylinder axis (modes 0, 1 and
            8)
node_id
ID of center node of sphere or ellipse (modes 2 and 3)
system_id
ID of local system for ellipse (mode 3)
line_list
Line list ID (modes 5 and 7)
node_list
Node list ID (modes 4, 5, 6, and 7)
sym
0 - Do not use symmetry links 
1 - Use symmetry links
con
0 - Do not use constraints 
1 - Use constraints
covar
Covariance for Kriging algorithm: 
0 - h 
1 - h^2log(h) 
2 - h^3 
3 - exp(-1/x)
drift
Drift type for Kriging algorithm: 
0 - no drift 
1 - constant 
2 - linear 
3 - quadratic 
4 - cubic 
5 - trigonometric
nugget
0 - off 
1 - on
nugval
The value of nugget for Kriging algorithm.
symm
0 - No symmetric surface is created (mode 8 only) 
1 - Symmetric surface is created (mode 8 only)
type
0 - Smooth surface is created (mode 8 only) 
1 - Developable surface is created (mode 8 only)
draw
Draw depth used to position the surface below the part (mode 8
            only)
offset
Used to increase the size of the surface while maintaining tangency
              (mode 8 only)
sym_plane
Temporary symmetry plane ID (mode 8 only)
model_shape
0 - The surface is created using the half model given by symplane
              (mode 8 only) 
1 - The surface is created using the complete model (mode 8
            only)
node1_id
Base point of vector defining the developable direction (mode 8
            only). Can be set to zero for other modes.
node2_id
End point of vector defining the developable direction (mode 8
            only). Can be set to zero for other modes.

","Examples
To morph a mesh to a surface interpolated from nodes which is roughly planar:
*createmark nodes 1 1 2 3 4 5 6 7 8
*createmark elems 1 ""all""
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createlist lines 1
*createlist nodes 1
*createplane 2,1.0 0.0 0.0 1.0 0.0 0.0
*morphinterpolatesurf nodes 1 elems 1 100.0 10.0 0 0 1 0 0 1 1 1 1 0 2 0 0.0 0 0 0.0 0.0 2 0 0 0
To generate a mesh, with 10 elements per 45 degree spherical section, and morph it to a
        surface interpolated from lines which is roughly spherical and oriented with a given system
        with a node as the origin:
*createmark lines 1 1 2 3 4 5 6 7 8
*createmark elems 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createlist lines 1
*createlist nodes 1
*createplane 2,1.0 0.0 0.0 1.0 0.0 0.0
*morphinterpolatesurf nodes 1 elems 1 -10.0 10.0 10 2 1 45 3 1 1 1 1 0 2 0 0.0 0 0 0.0 0.0 2 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1026,*morphloadshape,"Description
A shape stored as either grid perturbations (filetype 0) or as a local
        shape (filetype 1) is read in to HyperMesh
        and optionally applied to the model. 
filetype 1 gives you the option of reading the local shapes into
          HyperMesh as elements with the shapes acting on those
        elements. Your can then use *morphtranslateshapemark,
          *morphpositionshapemark, or *morphreflectshapemark
        to apply the shape to the rest of the model. 
filetype 1 requires a value for tolerance, the envelope for shapes to be
        applied to the model if the apply flag is on.
","Inputs

filename
Full name and path of the file containing the shapes.
apply_shapes
0 - Do not apply shapes to model 
1 - Apply shapes to model
filetype
0 - OptiStruct/Radioss
.fem or .grid format, or
              *morphsaveshape ""as grids"" 
1 - *morphsaveshape ""as shapes""
create_elems
0 - Do not re-create elements from file (filetype 1 only) 
1 - Recreate elements from file (filetype 1 only)
tolerance
Envelope for application of local shapes. The envelope is the range of influence that
            an imported shape will have on the new mesh. Since the original mesh (where the shape
            was when the shape file was saved) and target mesh may not match exactly, the envelope
            must be large enough to include nodes that may lie outside the bounds of the original
            mesh were it to be positioned on to the target mesh. Nodes inside the envelope will be
            perturbed proportional to how close they are to the bounds of the original mesh. Set the
            tolerance to -1.0 to use the default value, which is equal to the average length of the
            sides of the elements in the shape. Type in a larger value to capture more nodes within
            the envelope. Similarly, if too many nodes are being affected, try using a smaller
            envelope. You may also use a very large envelope (a million times the size of an average
            element) to make sure that the shape is applied to nearby nodes at full value.

","Example
To load and apply the shapes found in file C:/Temp/save.shp in file
        format 1 using the default tolerance:
*morphloadshape ""C:/Temp/save.shp"" 1 1 0 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1027,*morphmanualapplyenvelope,"Description
This command can only be used after *morphmanualinit.
If mode is 0, no other information is required, the difference in
        positions of the nodes between the *morphmanualinit command and the
          *morphmanualapplyenvelope is converted into a morph.
If mode is 1, then temporary handles are created for all moving and
        fixed nodes to determine the stretching of the affected elements. If
          integ is 0, a general domain is temporarily created for the affected
        elements. If integ is 1, the domains currently in the model are used. If
          integ is 2, 1D, 2D, 3D, and edge domains are temporarily created for
        the affected elements but the 2D domains are not partitioned. If integ is
        3, then handle influences are applied using a spatial relationship rather than through a
        domain. If integ is 4, only the selected moving nodes are moved and all
        others are held fixed. If integ is 5, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements and the 2D domains are partitioned. Any
        handles created due to partitioning are moved based on their distance from the moving and
        fixed nodes. If integ is 6, then handle influences are applied using the
        Kriging algorithm. If integ is 7, then handle influences extend only up
        to a given distance (if envelope is positive) or a given multiple of the
        applied perturbations (if envelope is negative) away from the moving
        nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If mode is set to 2, then the previous
          *morphmanualapplyenvelope command is rejected and the nodes are left in their
        manually perturbed positions. The model is still 'initialized' and thus another
          *morphmanualapplyenvelope command can be called after a reject. To
        restore the model to the way it was, call *morphmanualrestore.
If mode is set to 3 then the memory set aside by
          *morphmanualinit is freed, and
          *morphmanualapplyenvelope can no longer be used until another
          *morphmanualinit command is called. It is good practice to use this
        mode to free memory which is no longer needed.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value sent in for
          undisplayed.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
mode
0 - Apply as node perturbations 
1 - Apply as handles 
2 - Reject last *morphmanualapplyenvelope command 
3 - Clear memory set aside by *morphmanualinit
mbias
Bias factor for moving nodes on affected elements.
fbias
Bias factor for fixed nodes on affected elements. 
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing

","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1028,*morphmanualrestore,"Description
Restores the positions of nodes after a *morphmanualinit command.
","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
None.
",
1029,*morphmapedgestoequationoffset,"Description
This command maps the handles on the marked morph volume edges to a function along the
        specified vector, equation surface normal, or normal to any attached shell elements (unusual
        for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
equation
String containing an equation f(x,y,z). The equation can contain x, y, and z variables
            but should not contain an equals sign. The surface of the function is located where the
            value of the function equals zero.
origin
0 - Use global origin and system 
1 - Use global system with node ID = origin_id as the origin 
2 - Use local system with ID = origin_id as the origin and
            system
origin_id
The ID of node or system specified in origin. Ignored if origin is
            0.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to surface of equation 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the equation for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Examples
To map edges on mark 0 to an equation (sphere of radius 10) with an offset of 1.2 using the
        global system along a vector leaving the handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestoequationoffset 0 ""x*x+y*y+z*z-100.0"" 0 0 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to an equation (sphere of radius 10) using a local system along the
        line normal with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestoequationoffset 1 ""x*x+y*y+z*z-100.0"" 2 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1030,*morphmapedgestotacitoffset,"Description
This command will project the handles on the marked morph volume edges to the elements on
        the specified mark along the specified vector, target element normal, or normal to any
        attached shell elements (unusual for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
entity_type
Must be set to elems.
mark_id
 The ID of the mark containing the input elements. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to target elements 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces for values of
            project of 0, 1, and 2. The offset will be measured along the projection vector normal
            for values of project of 10, 11, and 12.

","Examples
To map edges on mark 0 to a mark of elements along a vector with offset of 1.2 and leaving
        the handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createmark elems 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestotacitoffset 0 elems 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3

To map edges on mark 1 to a mesh along the element normals with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createmark elems 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestotacitoffset 1 elems 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1031,*morphmapsections,"Description
Map elements on mark to section lines.
","Inputs

typeelem
Elems
markelem
Mark number of elements to map
typenode
Nodes
marknode
Mark number of follower nodes
typeline
Lines
markline
Mark number of section lines
typefix
Nodes
markfix
Mark number of fixed nodes
plane
Plane mark number
rotate
0 - L point to point mapping between lines 
1 - Rotate nodes along with curvature difference between lines
blend
0 - Do no blend unselected nodes 
1 - Blend nodes between mapped and fixed nodes
axis
0 - Apply mapping in x, y, z coordinates 
1 - Apply mapping about axis defined by plane
sym
0 - Do not use symmetry (only option)
con
0 - Do not use constraints 
1 - Use constraints

","Example
*morphmapsections (ELEMS,1,NODES,1,LINES,1,NODES,2,1,0,0,0,0,1)
This command maps selected elements to an interpolated cross section given the section
        lines optionally following the curvature differences (rotate) or mapping about an axis (axis
        and plane). 
This command interpolates a number of *morphmapdifference() calls
        between line pairs. The initial lines are found by intersecting a plane normal to each
        section line with the selected elements. Thus, the selected elements should match up closely
        with the selected lines. 
If blend is on, no fixed nodes have been selected, and no mapped nodes
        are a part of any domain, this command will automatically assign all non-mapped nodes as
        fixed nodes. 
","Errors
None.
"
1032,*morphmaptolinenodesoffset,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

list_id_nodes
The ID of the list containing the input nodes. Valid values are 1 and 2.
entity_type_handles
 Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
line_list
The ID of the list containing the input lines. Valid values are 1 and 2.
node_list
The ID of the list containing any nodes to define input lines. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 -  Project along vector defined by vector_id

1 to 11 - Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
offset
The distance to offset nodes from the target. Not used if
              project is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on list 1 normal to lines and points on list 2 with an offset of 1.2:
*morphmaptolinenodesoffset 1 handles 1 2 2 0 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1033,*morphmaptonodelistvecoffset,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the input nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
node_list_id
The ID of the list containing the target nodes. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11- Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target. Not used if project
            is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on mark 1 normal to a line with ID 23 with an offset of 1.2 when not using
          *morphmaprecalc:
*morphmaptonodelistvecoffset nodes 1 handles 1 23 0 1 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1034,*morphmaptotacitvecoffset,"Description
Maps nodes to, or offset from, a mark of elements using the temporary shape created
          by *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the target elements along a vector, normal to the target
        elements, or projected normal to the elements touching the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
entity_type_elems
Must be set to elems.
mark_id_elems
The ID of the mark containing the elems to map to. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to the elements on the mark 
2 or 12 - Project normal to shell elements touching nodes
If offset is non-zero, the offset will be measured from the closest
            point on the elements for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10, 11 and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the elements for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Example
To map all nodes to elements 1-100 with an offset of 1.2 when not using
          *morphmaprecalc:
*createmark nodes 1 ""all""
*createmark elems 1 1-100
*morphmaptotacitvecoffset nodes 1 handles 1 elems 1 0 1 2 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1035,*morphnodesequaoffset,"Description
This command will move the selected nodes to the surface of the function either normal to
        the surface of the function, along a vector, or normal to the elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3, 6 or 7) are stretched according to the value of
          integ.
The function can contain x, y, and z variables but should not contain an equals sign. The
        surface of the function is located where the value of the function equals zero. The function
        will be positioned at the global origin if ori is set to 0. If
          ori is set to 1, oid will specify the origin node
        and the global system will be used for the x, y, and z directions. If ori
        is set to 2, oid will specify the local system to be used for the origin
        and x, y, and z. 
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6, all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes willb e offset from the surface
        of the equation by the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The ID of the mark containing the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID of the fixed nodes. Valid values are 1 and 2.
equation
String containing an equation f(x,y,z).
ori
0 - Use global origin and system 
1 - Use global system with node ID = oid as the origin 
2 - Use local system with ID = oid as the origin and system
oid
ID of node or system specified in ori.
nproj
0 - Project along vector given by c_vec

1 - Project normal to surface of function. 
2 - Project normal to attached shell elements 
5 - Project normal to attached elements using smoothed normals 
6 - Project normal to elements using CFD corners
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor for moving nodes on affected elements.
fbias
Bias factor for fixed nodes on affected elements.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.

","Example
To morph nodes to be offset 1.2 from the surface of a sphere of radius 10.0 normal to the
        surface of the sphere using partitioned edges:
*createmark nodes 1 ""all""
*createmark elems 1 ""all""
*createmark nodes 2 ""all""
*createvector 1 1.0 0.0 0.0
*morphnodesequaoffset nodes 1 elems 1 nodes 2 ""x*x+y*y+z*z-100.0"" 0 0 1 1 4 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1036,*morphnodesmeshoffset,"Description
This command will move the selected nodes to a mesh. The moving nodes may be projected to
        the mesh along a vector, normal to the mesh, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6 all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_entity_type
Must be set to elems.
t_mark_id
The mark ID of the target elems. Valid values are 1 and 2.
nproj
0 or 10 - Project normal to vector 
1 or 11 - Project along c_vec

2 or 12 - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 to 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the mesh for values of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the target mesh for values of
              nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes to be offset 1.2 from a mesh normal to the mesh and stretch all the
        elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 1-100
*createmark nodes 2 21 22 23
*createmark elems 2 101-200
*createvector 1 1.0 0.0 0.0
*morphnodesmeshoffset nodes 1 elems 1 nodes 2 elems 2 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1037,*morphnodesshapeenvelope,"Description
This command will apply the specified shape to the mesh be a factor specified by
          mult. The fixed nodes are held in place and the affected elements (or
        all unfixed nodes in the model if integ is 3 or 6) are stretched
        according to the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are temporarily created
        for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
a_shape
The ID of the shape to be applied.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
mult
The multiplication factor for the shape.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.

","Example
To apply a shape 3 times the original perturbation and stretch all the elements in the
        model using the existing domains:
*createmark elems 1 ""all""
*createmark nodes 1 21 22 23
*morphnodesshapeenvelope elems 1 nodes 1 14 1 1.0 1.0 3.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1038,*morphorganizedomain,"Description
Organizes elements on mark into specified domain.
","Inputs

elemtype
Nodes (for global domains) 
Elems (for non-global domains)
elemmark
Node or element mark number
dptr
ID of domain
type
0 global domain 
11 D domain 
22 D domain 
33 D domain 
7 general domain
rethand
0 do not retain handles 
1 retain handles

","Example
*morphorganizedomain (ELEMS,1,32,2,0)
Nodes or elements on the mark are removed from the domains that they are in and placed into
        the specified domain. Nodes or elements not in the selection are removed from the specified
        domain. Thus the specified domain will retain only the selected elements. 
The type specified notes which nodes or elements in the mark will be retained. If no
        elements of the correct type are on the mark for non-global domains the command will exit. 
","Errors
None.
"
1039,*morphpartition,"Description
Organizes elements on mark into specified domain.
","Inputs

dtype
DOMAINS
dmark
Domain mark number.

","Example
*morphpartition(DOMAIN,1)

Only 2D domains on the mark will be partitioned. 
","Errors
None.
"
1040,*morphreflectshapemark,"Description
This command will reflect each shape on s_mark_id and reflect them
        according to each symmetry on sym_mark_id and affect only the nodes on
          a_mark_id. The shapes may be applied to the mesh, created as new
        shapes, added to existing shapes, or may replace existing shapes.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The mark ID of the shapes. Valid values are 1 and 2.
sym_entity_type
Must be set to symmetries.
sym_mark_id
The mark ID for symmetries. Valid values are 1 and 2.
a_entity_type
Must be set to nodes.
a_mark_id
The mark ID for target nodes. Valid values are 1 and 2.
mode
0 - Apply each shape to the mesh 
1 - Apply each shape and add the perturbations to the original shape 
2 - Apply each shape and overwrite the original shape 
3 - Apply each shape and create a new shape or shapes 
4 - Create a new shape or shapes but do not apply them to the mesh
tol
The ""envelope"" or distance around the translated shape inside which nodes are
            affected.
con
0 - Do not use constraints 
1 - Use constraints

","Examples
To reflect a shape using a symmetry and apply it to the mesh:
*createmark shapes 1 1
*createmark symmetrys 1 1
*createmark nodes 2 ""all""
*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1
To reflect all shapes using all symmetries and create new shapes, but only on selected
        nodes:
*createmark shapes 1 ""all""
*createmark symmetrys 1 ""all""
*createmark nodes 2 1 2 3 4 5 6 7 8 9 10 11 12
*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 4 3.0 1
","Errors
Incorrect usage of *morphreflectshapemark results in a Tcl error. To detect errors, you can
        use the catch
        command:if { [ catch {*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1} ] } {
# Handle error
}
""Symmetries must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if none of the
        symmetries on the mark are of a reflective type. Non-reflective symmetries are allowed on
        the mark but will be
        ignored.if { [ catch {*morphreflectshapemark shapes 1 symmetrys 1 nodes 2 0 3.0 1} ] } {
# Handle error
}
""Symmetries must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if none of the
        symmetries on the mark are of a reflective type. Non-reflective symmetries are allowed on
        the mark but will be ignored.
"
1041,*morphreparam,"Description
Reparameterizes domains on the mark.
","Inputs

domaintype
Domains
markdomain
Domain mark number.

","Example
*morphreparam (DOMAINS,1)
Domains on the mark are reparameterized, which means that the influence coefficients for
        the nodes within that domain are recalculated for the handles on the domain. 
This command will trigger the update of any existing shapes which are affected by the
        recalculation.
","Errors
None.
"
1042,*morphsavemvols,"Description
Saves morph volume, handle, and shape data to a file.
","Inputs

stype
Hypercubes
smark
Mark number of morph volumes.
savefile
Name of data file.
shapes
0 - Do not save shapes for morph volumes on mark 
1 - Save shapes for morph volumes on mark

","Example
*morphsavemvols (HYPERCUBES,1,""mvols.dat"",1)
This command will save the morph volumes on the mark to the specified file along with any
        handles on those morph volumes and any shapes which affect the morph volumes. 
","Errors
None.
"
1043,*morphsetactive,"Description
Sets an active parameter for either morph constraints or symmetries.
","Inputs

etype
Symmetries or morphconstraints 
emark
Mark number.

","Example
*morphsetactive (SYMMETRYS,1)
All entities of the type selected on the mark will be set to active. Non-selected entities
        will be set to inactive. 
","Errors
None.
"
1044,*morphshapeapply,"Description
Applies the shapes on the mark to the model. 
","Inputs

shtype
Shapes
shmark
Shape mark number.
mult
Multiplier to applied shapes.

","Example
*morphshapeapply (SHAPES,1,2.0)
Shapes on the mark are applied to the model consecutively and scaled up or down by the
        multiplier. 
For HyperMesh versions 8.0 and higher, active constraints will
        be applied to the shapes. For previous versions of HyperMesh,
        constraints were not applied.
","Errors
None.
"
1045,*morphshapecreateorthogonal,"Description
This command will convert all the shapes on the first mark into shapes, design variables,
        equations, and dlink2 entities when using the constraint and system
          methods. For the mid-shape v, only one shape may be
        converted at a time and each mark should contain one and only one unique shape.
For the constraint method, a non-linear shape will be deduced by applying each shape on
          the s_mark_id by a number of factors from 0.0 to 1.0 equal to the value
        of prec, enforcing any active constraints, and fitting a curve through
        the intermediate positions for each node.
For the mid-shape method, a non-linear shape will be deduced by fitting a shape through a
        curve beginning at the unperturbed position, traveling through the position attained when
        the shape on the md_mark_id is applied, and ending at the position
        attained when the shape on the s_mark_id is applied.
For the system method, each shape on s_mark_id will be assumed to rotate
        about the z-axis of the selected system instead of moving linearly in the xy plane. A
        non-linear shape will be deduced from the circular node paths.
For all methods, the non-linear paths of the nodes are represented by a
        pair of linear shape variables, plus a corrective shape variable, which are linked together
        via equations and dlink2 entities. The result is a single design variable which, when
        changed, applies the linear shape variables in such a way that the nodes move along
        non-linear paths.
For the constraint and system methods, if multiple shapes are selected,
        conflicts between each pair of shapes (such as when the application of one shape causes
        another to violate constraints) are detected and resolved by adding a corrective shape which
        is linked to those two shapes through an equation and a dlink2 entity.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The ID of the mark containing the shapes. Valid values are 1 and 2.
md_entity_type
Must be set to shapes.
mdmark
The ID of the mark containing the mid-shapes (for mid-shape method). Valid values are 1 and 2.
system_id
The ID of the system about which shapes are defined (for system method).
method
0 - non-linearity is due to constraints 
1 - non-linearity is deduced from mid-shape 
2 - non-linearity is due to rotation about a system
prec
Number of intermediate positions for non-linear approximation.
tol
Tolerance for establishing linear versus non-linear.

","Examples
To create non-linear shapes, equations, etc., for all the shapes in the model using the
        constraint method:
*createmark shapes 1 ""all""
*morphshapecreateorthogonal shapes 1 shapes 1 0 0 10 0.001
To create non-linear shapes, equations, etc., for shape ""full"" using shape ""mid"" as the
        mid-shape:
*createmark shapes 1 ""full""
*createmark shapes 2 ""mid""
*morphshapecreateorthogonal shapes 1 shapes 2 0 1 10 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1046,*morphshapelinkedapply,"Description
This command will apply all the shapes on an internal list (generated by using the
          *morphshapelinkedpush command) at their stored multiplier values. It will also
        apply any shapes linked to the applied shapes via desvar, deqatn, and dlink2 cards, such as
        those created during non-linear design variable generation. The shapes will be applied to
        only the nodes on the specified mark. This command will clear the internal list of shapes
        and multipliers created using the *morphshapelinkedpush command.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the affected nodes. Valid values are 1 and 2.

","Example
To apply the stored shapes and linked shapes to all of the nodes in the model:
*createmark nodes 1 ""all""
*morphshapelinkedapply nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1047,*morphshapeupdatecolor,"Description
Updates the color of a shape.
","Inputs

shape
ID of shape.
color
Integer between 0 and 63 inclusive.

","Example
*morphshapeupdatecolor (1,15)

 The color of the specified shape will be set to the new color. 
","Errors
None.
"
1048,*morphsplitmorphvolumes,"Description
Splits the morph volumes in the model given the specified morph volume edge.
","Inputs

n1
ID of first end node of morph volume edge.
n2
ID of second end node of morph volume edge.
split
If > 1.0: number of splits 
If < 1.0: position along edge for split
hand
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
tangent
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent.

","Example
*morphsplitmorphvolumes (21,22,2.0,1,1)

 This command will propagate one or more splits along the specified morph volume edge
        through the entire morph volume ""matrix"" so that it remains consistent. 
Newly formed morph volumes can optionally have handles and tangency automatically applied. 
The higher the value of 'split' (if less than 1.0), the closer to n2 the split will
        occur.
","Errors
None.
"
1049,*morphstorematch,"Description
This command allows you to predetermine which domains match with which surfaces when using
        the *morphfittosurface command and the one to one mapping option. There
        are two ways to use this command, one is to call it for each pair of domains and surfaces,
        passing in the IDs to store as matches; the other is to call it once and automatically match
        all the overlapping domains and surfaces in pairs. In the case of matching domains to
        surfaces automatically, a domain’s nodes must be associated to a surface for a match to be
        registered.
","Inputs

domain_id
ID of a 2D domain to map to a surface.
surface_id
ID of a surface to map to a 2D domain.
mode
0 - Clear the current list of matching domains and surfaces 
1 - Add the given domain and surface pair to the current list 
2 - Clear the list and fill it with all overlapping domain and surface pairs

","Example
To set the fitting list to have three pairs of domains and surfaces:
*morphstorematch 0 0 0
*morphstorematch 2 4 1
*morphstorematch 3 5 1
*morphstorematch 4 11 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1050,*morphsurfaces,"Description
Calls surface morphing function. 
","Inputs

surftype
Surfs
marksurf
Surface mark number

","Example
*morphsurfaces (SURFS,1)
This command morphs the surfaces for a given model. Any surface that is associated with a
        node that has been morphed will be morphed when this command is used.
","Errors
None.
"
1051,*morphsymmetryrefresh,"Description
none.
","Example
*morphsymmetryrefresh()
All symmetries in the model will be refreshed and all symmetric relationships between
        handles will be updated. Note that handles which are linked through symmetry may become
        unlinked if they are no longer symmetric. Similarly, new links may be created between
        previously unlinked handles. 
Whenever handles and symmetries are created, updated, or deleted, the symmetries are
        refreshed automatically. This command is intended for situations where the user wishes to
        refresh the symmetries manually.
","Errors
None.
",
1052,*morphupdatedatabase,"Description
Updates morph volume database.
","Example
*morphupdatedatabase ()
This command updates the database for morph volumes based on the current value of the
        ""cubestat"" parameter. This command is called when necessary inside other commands and
        shouldn't need to be called by the user. 
","Errors
None.
",
1053,*morphupdatedomains,"Description
Updates global domains.
","Inputs

mode
Always 0 global domains.

","Example
*morphupdatedomains (0)
This command updates any global domains which are not assigned any nodes (those created
        with versions of HyperMesh prior to 8.0) to be assigned all the
        nodes in the model. 
","Errors
None.
"
1054,*morphupdateendcondition,"Description
Updates the end condition of one or two morph volume edges.
","Inputs

n1
Node at end of first edge.
n2
Node between first edge and second edge.
n3
Node at end of second edge (if necessary).
x
X component of vector for end direction
y
Y component of vector for end direction
z
Z component of vector for end direction
mode
0 = free 
1 = set to vector 
2 = master-slave tangency 
3 = slave-master tangency 
4 = continuous tangency

","Example
*morphupdateendcondition (21,22,23,1.0,0.0,0.0,1)
This command either frees the specified edge end, sets the direction of the edge end equal
        to the given vector, or enforces a tangency condition between two edges. The end of an edge
        which is affected by this command is marked by n1. 
","Errors
None.
"
1055,*morphupdatemvols,"Description
Updates morph volumes on mark.
","Inputs

ctype
 Hypercubes
cmark
Mark number of morph volumes.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent

","Example
*morphupdatemvols (HYPERCUBES,1,1,1,1)
This command updates the order, handles, and tangency of the morph volumes on the mark. 
The order of the morph volumes (ord) refers to the number of mid-nodes along each edge with
        an order of one meaning there will be no mid-nodes, an order of two meaning that there will
        be one mid-node, and so forth.
","Errors
None.
"
1056,*morphvolumeconnect,"Description
Joins the specified morph volumes. 
","Inputs

hcube1
ID of first morph volume.
hcube2
ID of second morph volume.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
mode
0 = join hcube2 to hcube1

1 = join hcube1 to hcube2

2 = join at midpoint
nauto
0 = do not register all nodes found inside morph volumes 
1 = register all nodes found inside morph volumes

","Example
*morphvolumeconnect (21,22,1,1,1)
This command will join the specified morph volumes provided that the process does not make
        the morph volume ""matrix"" inconsistent. Newly combined morph volumes can optionally have
        tangency automatically applied.
","Errors
None.
"
1057,*morphvolumecreateplus,"Description
This command creates a matrix of morph volumes xd by
          yd by zd in number aligned with the specified
        coordinate system (or the global system if zero) and enclosing the elements on the mark.
","Inputs

etype
elems
emark
Mark ID of elements.Valid values are 1 and 2.
xd
Density of matrix in x direction.
yd
Density of matrix in y direction.
zd
Density of matrix in z direction.
buff
Percentage buffer zone around matrix.
sysid
ID of system used to orient matrix.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
 options
0 = do not apply shrinking 
1 = apply eight iterations of shrinking without internal face movement 
3 = apply eight iterations of shrinking with internal face movement

","Example
To create a morph volume matrix with three morph volumes on a side, a buffer zone of 10%,
        with handles at the corners only, continuously tangent, and shrink the matrix for eight
        iterations with internal face movement:
*createmark elems 1 ""all""
*morphvolumecreateplus elems 1 3 3 3 10.0 0 1 1 1 3
","Errors
None.
"
1058,*morphvolumereflect,"Description
This command will create morph volumes by reflecting the morph volumes on the mark using
        the specified reflective symmetries (1-plane, 2-plane, 3-plane, cyclical). Optionally the
        nodes inside the reflected morph volumes can be automatically registered.
","Inputs

c_entity_type
Must be set to hypercubes.
c_mark_id
The ID of the mark containing the hypercubes. Valid values are 1 and 2.
s_entity_type
Must be set to symmetries.
s_mark_id
The ID of the mark containing any symmetries. Valid values are 1 and 2.
nauto
0 - Do not register new nodes 
1 - Register new nodes

","Example
To reflect all morph volumes using a symmetry:
*createmark hypercubes 1 ""all""
*createmark symmetries 1 4
*morphvolumereflect hypercubes 1 symmetrys 1 1

","Errors
Incorrect usage of *morphvolumereflect results in a Tcl error. To detect errors, you can
        use the catch command:
if { [ catch {*morphvolumereflect hypercubes 1 symmetrys 1 1} ] } {
# Handle error
}
""Symmetrys must be reflective type (1, 2, 3-plane, or cyclical)."" - occurs if all of the
        selected symmetries are not reflective type symmetries. If only some of them are
        non-reflective, those will be ignored.
"
1059,*moveinclude,"Description
 Moves an include file to a new location in the include hierarchy.
","Inputs

filebeingmoved
The name of the file to be moved in the tree.
newparent
The name of the new parent file.

","Errors
None.
",
1060,*movemark,"Description
Moves entities from one collector to another.
","Inputs

entity_type
The type of entity to move. Any collected entity type (aside from master/slave
            elements) is valid.
mark_id
The ID of the mark containing the entities to move. Valid values are 1 and 2.
name
The name of the collector to move the entities to. The collector type is determined by
            the entity_type.

","Example
To move all elements from comp1 to comp2:
*createmark elems 1 ""by collector name"" comp1
*movemark elems 1 comp2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1061,*multi_surfs_lines_merge,"Description
This command takes surfaces from an input set specified by the selection mark
          surf_mark_id, finds intersections between them, creates trimming lines
        at the intersections, and equivalences the resulting surface edges; thus creating a
        topologically valid body from possibly overlapping surfaces. 
Optionally, a set of lines specified by selection mark line_mark_id can
        be used to create additional edges on selected surfaces within proximity of those lines.
        This command uses the tolerance value specified as the cleanup tool in the
        Modeling Options panel (which also can be set using the *setoption
          cleanup_tolerance command) to calculate proximity and equivalence between edges.
        The options Parameter is reserved for future extensions of the command and must be set to 0.
        The surface selection mark (surf_mark_id) can have values 1 or 2. The
        Line selection mark (line_mark_id) can have values 0 (no lines used),
          1 or 2.
","Example
To find intersections and merge surfaces with IDs 30 and 31 into a single body:
*createmark surfs 1 30 31
*multi_surfs_lines_merge 1 0 0
To find intersections and merge all displayed surfaces into a single body.
*createmark surfs 1 ""displayed""
*multi_surfs_lines_merge 1 0 0
To trim surface with ID 31 by free line with ID 9 using the value of 0.1 as a proximity
        tolerance:
*createmark surfs 1 31
*createmark lines 1 9
*setoption cleanup_tolerance=0.1
*multi_surfs_lines_merge 1 1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1062,*newidoption,"Description
This command now new IDs are assigned for a submodel.
","Inputs

id
The ID of the submodel.
option
0 - Minimum available 
1 - Maximum available (default)

","Example
To set the new ID option as using minimum available for include 1:
*newidoption 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1063,*nodecleartempmark,"Description
Clears all of the nodes from the temporary node mark.  If a node is selected at the time
        this command is run, it will not be removed, but its graphic will be cleared.
","Errors
None.
",,
1064,*nodecreateatlineparams,"Description
This command creates nodes or points at points on given line for given parametric
        values.
","Inputs

line_id
Input line ID.
double_array
The ID of the double array that contains the parametric location values in the range 0
            to 1. The double array is created using the *createdoublearray
            command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
insert_count
Number of additional parametric values inserted between the values specified by the
            array in double_array.
mode
Specifies how parameters specified in double_array are used. Valid values are: 
0 - Line arc length parameterization is used. 
1 - Internal line parameterization is used.
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes (default) 
1 - Create points

","Examples
To create nodes on line 12 at arc length parametric values 0.2, 0.8 and 0.85:
*createdoublearray 3 0.2 0.8 0.85
*nodecreateatlineparams 12 1 3

To create 10 points on line 12 using the line’s internal parameterization with parameters
        equally distributed between 0 and 1:
*createdoublearray 2 0 1
*nodecreateatlineparams 12 1 2 8 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1065,*nodecreateatvectorplaneintersection,"Description
This command creates node or point at location of intersection between two vectors or a
        vector and a plane. 
","Inputs

vector
Input temporary vector ID. Plane is used to define vector such as base point of the
            plane is used as the base point of the vector and normal of the plane is used as vector
            direction.
plane_or_vector
Input temporary plane ID (if plane_use is 0) or vector ID
              (plane_use is 1, 2 or 3). In case of vector plane base point is
            used as vector base point and plane normal is used as vector direction.
vector_use
Parameter specifying whether input data specified by vector parameter is interpreted
            as a plane of vector. Valid values are:
0, 1 - Input data specified by vector parameter is used as undirected vector
                (straight line that passes through the base point specified by vector parameter in
                the direction of the normalspecified by vector parameter). 
2 - Input data specified by vector parameter is used as directed vector (ray that
                starts at base point specified by vector parameter and continues in the direction of
                normal specified by vector parameter). 
3 - Input data specified by vector parameter is used as finite length vector
                (segment that starts at base point specified by vector parameter and ends at the end
                of normal vector specified by vector parameter).


plane_use
Parameter specifying whether input data specified by
              plane_or_vector parameter is interpreted as a plane of vector.
            Valid values are:
0 - Input data specified by plane_or_vector parameter is used
                as plane. 
1 - Input data specified by plane_or_vector parameter is used
                as undirected vector (straight line that passes through the base point specified by
                  plane_or_vector parameter in the direction of the normal
                specified byplane_or_vector parameter). 
2 - Input data specified by plane_or_vector parameter is used
                as directed vector (ray that starts at base point specified by
                  plane_or_vector parameter and continues in the direction of
                normal specified by plane_or_vector parameter). 
3 - Input data specified by plane_or_vector parameter is used
                as finite length vector (segment that starts at base point specified
                  byplane_or_vector parameter and ends at the end of normal
                vector specified by plane_or_vector parameter).


point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes (default) 
1 - Create points

","Examples
To create nodes at the intersections between straight line (x=1, y=2) and the plane
        z=2:
*createplane 1 0.0 0.0 1.0 1.0 2.0 0.0
*createplane 2 0.0 0.0 1.0 0.0 0.0 2.0
*nodecreateatvectorplaneintersection 1 2
To create points at the intersection between ray that starts at point (1,2,4) and
        propagates in the direction of y axis and a ray that starts at point (1, 4, 0) and
        propagates in the direction of z axis:
*createplane 1 0.0 1.0 0.0 1.0 2.0 4.0
*createplane 2 0.0 0.0 4.0 1.0 4.0 0.0
*nodecreateatvectorplaneintersection 1 2 2 2 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1066,*nodecreateonlines,"Description
This command creates nodes or points at locations of intersection between two sets of input
        geometries. Only intersections between entities from different sets are calculated and are
        used to create nodes or points. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a surface edge to a parent surface is
        undefined and can return unexpected or varied results.
","Inputs

entity_type
Must be set to lines.
mark_id
The ID of the mark containing the input lines. Valid values are 1 and 2.
number
The number of nodes to create.
bias_style
0 - Linear 
1 - Exponential 
2 - Bell curve
bias_intensity
The bias intensity value. A positive value indicates biasing along the line direction,
            while a negative value indicates biasing along the opposite direction. A value of 0
            indicates no biasing.

","Example
To create 5 nodes on lines 10, 11, 12, and 13 with linear biasing of 2.0:
*createmark lines1 10 11 12 13
*nodecreateonlines lines 1 5 1 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1067,*nodemodify,"Description
Modifies the location of a node in space. 
","Inputs

nodeid
The ID of the node to be modified. 
x
The new x coordinate of the node. 
y
The new y coordinate of the node. 
z
The new z coordinate of the node. 

","Example
To modify the location of node 1 to be x = 10.0, y = 20.0, z = 30.0: 
*nodemodify(1,10.0,20.0,30.0)

","Errors
None.
"
1068,*nodesandelemsclear,"Description
This command will remove all numbers from the modeling window for
        all nodes and elements.
","Example
*nodesandelemsclear
","Errors
None.
",
1069,*nonstructuralmasscreateall,"Description
Creates a group with non-structural mass configuration for all properties of a specified
          card image.
","Inputs

name
The name of the non-structural mass group to create.
color
The color of the non-structural mass group. Valid values are 1 through 64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
card_image
The card image of the properties to create the non-structural
            mass for. Valid values are:
ELEMENT 
PBAR 
PBARL 
PBEAM 
PBEAML 
PCOMP 
PROD 
PSHEAR 
PSHELL 
PTUBE 
PSHELL



","Examples
To create a non-structural mass named nsm1 of type 1 (NSM1) for properties with PSHELL
          card image with mass value 2.4:
*nonstructuralmasscreateall ""nsm1"" 8 1 2.4 PSHELL
To create a non-structural mass named nsml1 of type 2 (NSML1) for properties with PBAR
          card image with mass value 3.5:
*nonstructuralmasscreateall ""nsml1"" 8 2 3.5 PBAR
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1070,*normalsdisplay,"Description
Turns on the display of surface normals.
","Inputs

entity_type
The type of entity to turn on normals for. Valid values are elements and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn. If set to zero, the vector is
            drawn at 10% of the screen size.

","Example
To turn on the display of normals for elements 1-10 at 10% screen size:
*createmark elems 1 1-10
*normalsdisplay elems 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1071,*normalsreverse,"Description
Reverses the normals of 2D and 3D elements.
","Inputs

entity_type
The type of entity to reverse. Valid values are elements and components.
mark_id
The ID of the mark containing the entities to reverse. Valid values are 1 and 2.
size
The size in model units of the normal display, if displayed as vectors.

","Example
To reverse the normal of element 15 using a display size of 10.0:
*createmark elements 1 15
*normalsreverse elements 1 10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1072,*offset_surfaces_and_modify,"Description
This command offsets selected surfaces or solids normally to their surface by the distance
        specified by you. It has two main modes, disjoint offset and continuous offset, and several
        modifications. 
With the disjoint offset only the surfaces selected by you will be offset. This mode cannot
        be applied to the surfaces that belong to a solid, if the selection is made ""by surfaces""
          (entity_type is not solid), because this could
        disrupt the solid. 
With the continuous offset the surfaces adjacent to the surfaces selected by you also will
        be modified, to keep continuity of the created model. The modification of the adjacent
        surfaces will be such that their edges that are shared with the selected surfaces will be
        moved together with the selected surfaces, while their edges that do not touch the selected
        surfaces will be locked (stay where they were). 
Both disjoint and continuous modes have a modification, remove degenerations. A
        degeneration is a surface (or several adjacent surfaces) that will self intersect after the
        offset. (e.g., this will occur if a cylinder or a sphere is offset inside by a distance that
        is bigger than its radius.) If the ‘remove degenerations’ modification is on, the offset
        tool will try to clean out the self-intersections automatically. It is recommended to have
        this mode ""on"" only if the degenerations are really happening and there is a need to remove
        them, because having this mode ""on"" all the time increasing the time of the command
        execution (to analyze for the degenerations) and increases the risk of a failure. 
The continuous offset can be modified by the user-selected lines, separators. If you select
        a separator line between the selected and not the offset surfaces, the non-selected surface
        will not be modified (pulled) to keep the result continuous. Instead, a new surface will be
        inserted between the separator line and the new position of the offsetted edge, to create
        the result continuity. 
If you select the separators inconsistently, it can dramatically break the result.
        Therefore, an automatic completion of the separator lines is possible, by selecting the
        ""auto-complete separators"" modification. If this mode is selected, additional separators
        will be added automatically to get a reasonable result (or, at least, to try to get the
        reasonable result). Note: The additional separators might be added not the way you would
          want them to go. This is why, if the ""auto-complete"" modification is used, a review of the
          actually used separators is recommended.

","Inputs

entity_type
The type of entity selected for the offset. Surfaces, splines and solids are
            supported.
mark_id
The mark of surfaces, splines or solids selected for the offset.
surf_mark_id 
Reserved and must be set to 0, or to a mark ID that is empty.
line_mark 
Mark of the separator lines.
offset_type 
Flag to specify the offset mode and modifications:
-13 - Continuous offset. Remove degenerations. Auto-complete separators. Update
                eccentricity. 
-11 - Continuous offset. Do not remove degenerations. Auto-complete separators.
                Update eccentricity. 
-4 - Do not offset, only display how the separators will be auto-completed, to
                review. 
-3 - Continuous offset. Remove degenerations. Auto-complete separators. Do not
                update eccentricity. 
-1 - Continuous offset. Do not remove degenerations. Auto-complete separators. Do
                not update eccentricity. 
0 - Disjoint offset. Do not remove degenerations. Do not update eccentricity. 
1 - Continuous offset. Do not remove degenerations. Do not auto-complete
                separators. Do not update eccentricity. 
2 - Disjoint offset. Remove degenerations. Do not update eccentricity. 
3 - Continuous offset. Remove degenerations. Do not update eccentricity. 
10 - Disjoint offset. Do not remove degenerations. Update eccentricity. 
11 - Continuous offset. Do not remove degenerations. Do not auto-complete
                separators. Update eccentricity. 
12 - Disjoint offset. Remove degenerations. Update eccentricity. 
13 - Continuous offset. Remove degenerations. Do not auto-complete separators.
                Update eccentricity.


offset 
The value of the offset (offset distance with a sign). The offset will occur in the
            direction of the surfaces normals, if offset > 0, and in the opposite to the normals
            direction otherwise.

","Example
To offset by -0.5 surface ID 105 using continuous offset with removal of degenerated
        surfaces, separator line ID 2471 and auto-completion of the separators:
*createmark surfaces 1 105
*createmark lines 1 2471
*offset_surfaces_and_modify surfaces 1 0 1 -3 -0.5
","Errors
None.
"
1073,*optimized_elements_remesh2,"Description
Remeshes elements with the selection of the best meshing algorithm and optimization of node
        positions.
","Inputs

mark_id
The ID mark that contains the elements to remesh. Valid values are 1 and 2.
criteria_file
The path and file name of the criteria file. Use double quotes if no file is
            specified.
elem_size
The default element size used to calculate element densities along edges, when
            necessary. Element sizes along shared edges cannot be changed.
elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


feature_angle
The angle, in degrees, specifying the feature lines. This is approximately the minimal
            internal angle between the elements adjacent to a feature line. Valid values are between
            18-90 degrees.
vertex_angle
The angle between two edge segments when a vertex is created.
comp_mode
A flag that specifies how the elements are organized. Valid values are:
0 - Elements are created in the current component. 
1 - Elements are created in the same component as their parent surface(s).


break
Determines if connectivity will be broken along shared edges between elements when a
            different element size is chosen.
0 - Do not break connectivity. 
1 - Break connectivity.


algorithm
Determines the algorithm for meshing. Valid values are:
0 - Standard meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control



","Example
To remesh the displayed elements with element size 10, mixed elements type and optimize
        node positions using default criteria file, feature and vertex angle of 30 degrees, and mesh
        flow with align and size control
*createmark elements 1 ""displayed""
*optimized_elements_remesh2 1 ""dummy"" 10 2 30 30 1 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1074,*optimsmooth,"Description
One or more nodes may be specified as being anchored in place and not movable. The command
        optimizes nodes location to reach the specified target Q.I. of the selected elements
        aggregate according to a given quality criteria. It moves nodes through the surface
        boundaries unless the boundaries are strong feature lines or component boundaries. The
        optimization process may be interrupted if the target Q.I. has been reached or a time limit
        is specified. The optimization may be applied recurrently with a given maximum number of
        iterations.
","Inputs

smoothmark
The mark of elements to be smoothed. Does not need to be a contiguous block.
anchormark
The mark of nodes on elements that are not adjustable.
criteria_filename
The path of the file containing quality criteria or ""dummy"" for pre-set criteria.
feature_angle
The angle in degrees specifying the feature lines (18-90 degrees). This is
            approximately the minimal angle between the elements adjacent to a feature line. 
If a negative value is used, this enables the option to maintain nodes on geometry
            edges and the absolute value is used for the feature angle.
target_QI
The target Q.I. for optimization.
max_iterations
The maximum number of recursive applications of the optimization procedure.
time_limit
Time limit in minutes for the optimization. 
If = 0, the time constraint is not applied. 

","Example
To smooth elements 100 through 110 with fixed nodes 15, 17, and 14 using the quality
        criteria file, c:/mycriteria/durability.txt, the feature angle = 30
        degrees, the target Q.I = 0.2, recursive optimization with maximum five iterations and with
        no time limit applied:
*createmark elements 1 100 101 102 103 104 105 106 107 108 109 110
*createmark nodes 2  15 17 14
*optimsmooth 1 2 c:/mycriteria/durability.txt 30 0.2 5 0
To smooth all plate elements with fixed nodes 257 and 678 using the quality criteria
        specified in the example with the feature angle = 40 degrees, target Q.I. = 0.3, no
        recursive optimization, time limit 60 minutes:
*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
*createmark elements 1 ""all""
*createmark nodes 1 257 678
*optimsmooth 1 1 dummy 40 0.3 1 60

","Errors
None.
"
1075,*ossmooth_reanalysis,"Description
Extract the final geometry from OptiStruct topology
        optimization results and inherit the boundary conditions for reanalysis.
","Inputs

sh_filename
The full name and path to the OptiStruct
.sh results file generated from the optimization.
mode
Iso-surface mode indicating how to process non-design elements. Valid values are:
0 - keep all non-design elements with a half layer around 
1 - split only intersected non-design elements 
2 - split overlapping non-design elements with a half layer around 
3 - split overlapping non-design elements


density_threshold
Threshold value for topology optimization (0 ≤ density threshold ≤ 1).

","Example
Execute OSSmooth on the C:/test/os.sh files, loading the geometry back
        to HyperMesh, splitting all quads on non-design/design
        interface, with a density threshold of 0.3:
*ossmooth_reanalysis ""C:/test/os1.sh"" 3 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1076,*penetrationcheck,"Description
Checks the given components for contact surface penetrations. To release the memory after
        completion, use the command *penetrationcheckend. 
A valid template must be loaded for the check to occur.
","Inputs

entity_type
The type of entity to check for penetration. Valid values are groups and elems.
mark_id
The ID of the mark containing the entities to check. Valid values are 1 and 2.
check_type
The type of penetration check to perform. Valid values are:
0 - groups 
3 - elems only



","Example
To check the elements in group E2E for penetration:
*createmark groups 1 E2E
*penetrationcheck groups 1 0
*penetrationcheckend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1077,*PenetrationCheckSummary,"Description
Command is used to generate a summary log file for last run penetration check. This file
        contains a flat list of intersected and penetrated components, followed by more detailed
        lists of each component-component pair data. If the last check’s input was specified by
        groups, then the above data is organized by groups, as well. 
","Inputs

filename
The name of the file, including its full path, to which the summary is written. The
            file is appended to if it already exists.
sort_intersections
A flag that indicates how to sort intersection data. Valid values are:
0 - No sorting 
1 - Ascending component ID 
-1 - Descending component ID 
2 - Ascending element count 
-2 - Descending element count 
3 - Ascending number of interfered components 
-3 - Descending number of interfered components


sort_penetrations
A flag that indicates how to sort penetration data. Valid values are:
0 - No sorting 
1 - Ascending component ID 
-1 - Descending component ID 
2 - Ascending element count 
-2 - Descending element count 
3 - Ascending number of interfered components 
-3 - Descending number of interfered components 
4 - Ascending maximum penetration depth 
-4 - Descending maximum penetration depth



","Example
Output results of the last penetration check (run using the command
          *checkpenetration) to the file
          C:\results\check.txt, with intersections sorted by ascending
        component ID and penetrations by descending maximum penetration depth:
*PenetrationCheckSummary ""C:/results/check.txt"" 1 -4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1078,*penetrationdisplay,"Description
Displays the amount of penetration through nodes, vectors, or contour.
","Inputs

contact_thickness
Supplied value of the contact thickness.
part_thickness_scale
Supplied value of the part thickness scale.
display_mode
Type of mode used to display penetration.
0 - Nodes 
1 - Normal 
2 - Contour


normal_scale
Greater than zero - uniform size or % of magnitude of vectors.
label
The vector label option.
0 - Vector labels off 
1 - Vector labels on


segment_orientation
Flag for taking element normal into consideration for checking penetration.
0 - Elements normal will not be considered 
1 - Elements normal will be considered


magnitude_mode


0 - Uniform size 
1 - Percentage of magnitude



","Example
For displaying the amount of penetration if a contact thickness supplied is 1.5, part
        thickness scale supplied is 1.0, display mode is normal, percentage of magnitude used is 50,
        vector labels are on, and segment orientation and percentage of magnitude are used:
*penetrationdisplay(1.5, 1, 1, 0.5, 1, 1, 1) 
The *penetrationcheck(), penetrationchecktwo(), or
          penetrationrecheck() command is required.
","Errors
None.
"
1079,*perturbationshapecreate,"Description
Creates a perturbation shape.
","Inputs

name
The name of the shape.
vectorcolid
The ID of the vector collector that contains the perturbation vectors.

","Example
To create a shape ""sh1"" that has its perturbation vectors in a vector collector of ID 5: 
*perturbationshapecreate(""sh1"",1)
","Errors
None.
"
1080,*plotinfotitlesetcolor,"Description
Sets the color of the plot information title.
","Inputs

color 
Set the title to this color.

","Errors
None.
",
1081,*plottitlemove,"Description
 Moves the plot title. 
","Inputs

xmin
The x value of the upper left corner of the plot title (0.0 - 1.0). 
ymin
The y value of the upper left corner of the plot title (0.0 - 1.0). 
xmax
The x value of the lower right corner of the plot title (0.0 - 1.0). 
ymax
The y value of the lower right corner of the plot title (0.0 - 1.0). 

","Errors
None.
",
1082,*plottitlesettext,"Description
Sets the text for the plot title. 
","Inputs

text
The text which should be displayed in the plot title. 

","Errors
None.
",
1083,*pointmodify,"Description
Specifies new coordinates for the point.
","Inputs

point_id
ID of the point to be modified.
x/y/z
New point coordinates.

","Example
*createpoint(0,0,0,0)
*createpoint(10,0,0,0)
*window(0,0,0,0,0)
*pointmodify(2,5,0,0)
*createpointsbetweenpoints(1,2,1)

This command is called from the distance panel.
","Errors
None.
"
1084,*projectmarktoplane,"Description
 Projects a group of entities to a plane. 
","Inputs

entity type
The type of entities contained on the mark. 
mark
The ID of the mark containing the entities to be projected. 
plane
The ID of the plane to which the entities will be projected. 
vector
The vector along which the entities will be projected. 
toplane
A flag indicating if the entities should be projected to the plane or to the normal of
            the plane (1 for plane, 0 for normal).

","Example
To project elements 10, 11, 12, 13 to the plane with a normal of (1.0, 0.0, 0.0) based at
        the origin along the vector (1.0, 1.0, 1.0): 
*createmark(element,1) 10 11 12 13
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*createvector(1.0,1.0,1.0)
*projectmarktoplane(element,1,1,1,1)

*createmark() , *createplane() , and
          *createvector() are required. 
","Errors
None.
"
1085,*projectsystem,"Description
References a vector that is projected on the element plane. Re-orients and visualizes the
        element (material) coordinate system for selected elements.
","Inputs

entities
Determines the selected entity, which can only be elements.
markmask
Determines the selected elements.
vectorptr
Determines the vector to be projected on the element plane to define the element
            orientation.
onlyorient
1 - The new x-element directions are shown as vectors starting from the element
            center. 
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges.
normal_size
If onlyorient = 1, it determines the size of the vectors to be
            shown.
color
Determines the color of the vector or line. The color ID numbers range from 1 to
              64.

","Example
To project the created vector on the element plane of four selected elements and show the
        projection as blue vectors (color = 7) with size = 3:
*createmark(elements,2) 376 377 389 418
*createvector(1,2.4482,-0.7894,0.9774)
*projectsystem(elements,2,1,1,3,7)
*vectorsoff()

The *createmark() and *vectorsoff() commands are
        required.
","Errors
None.
"
1086,*qismoothfixfailed,"Description
This command is applied to a selection of elements given by the elements mark. It changes
        positions of nodes of elements violating the quality index threshold and possibly of
        adjacent elements. Maximum displacements of nodes on feature edges are limited by the
        user-specified values.
The command parameters have the following meaning:
","Inputs

smoothmark
The elements selection mark (1 or 2).
anchormark
The mark of additional (to welds) nodes not allowed to move (1 or 2).
criteria_file
The path to the criteria file. If the criteria are set by a preceding command, ""dummy""
            can be used as a criteria file name.
feature_angle
Elements feature angle for defining of features in degrees (30 degrees is a commonly
            used value).
ignore_features
The flag defining permissions of node movement across the feature edges:
0 - Nodes are not allowed to move across feature edges. 
1 - Nodes are allowed to be moved across shared edges; free edges nodes, marked
                edges, edges of features (beads, washers, dimples, birdbeaks, fillets), all fixed
                nodes are forbidden for movement across. 
2 - The same as ""1"", but nodes on some of the features surfaces (beads, vertices)
                are unfixed + end vertices of fillet edge are unfixed. 
3 - The same as ""2"", but fillet edges are released and some curves sharp break
                vertices are unfixed. 
4 - All shared edges nodes,including recognized features boundary edges, all
                non-user marked edges and fixed vertices are released for movement across; 
5 - The same as ""4"" but free edges nodes are also released, those nodes are not
                allowed to move off the surfaces; 
6 - The same as ""5"" but free edges nodes are allowed now to move off surfaces
                breaking associativity with geometry.


freenodesmovelimit
Maximum absolute movement for free edges nodes. If negative value - no constraints are
            applied.
breaknodesmovelimit
Maximum absolute movement for shared feature edges nodes. If negative value - no
            constraints are applied.
smoothedgenodesmovelimit
Maximum absolute movement for smooth (non feature) shared edges nodes. If negative
            value - no contsraints applied.
flgs
Flags controlling internal algorithms. The default is 0. flgs = 256
            should be used to mark moved free edges by plot elements placed in the predefined
            component - to account for the moved edges on the future steps.
max_iterations
Maximum number attempts to fix the failed elements. Usually 3-5 can be used.

","Example
To fix the displayed failed elements with no anchor nodes, using the quality criteria file
          C:/Altair/hw8.0/hm/batchmesh/10mm criteria, feature angle 30 degrees,
        with maximum allowed ignore_features option 6 (the free edges' nodes are
        allowed to be moved across with breaking of associativity with geometry), maximum allowed
        movement of free edges nodes is 0.5, maximum allowed movement of shared feature edges nodes
        is 1.0, no constraints applied to movement across of non-feature shared edges (-1), no
        marking of moved feature edges (flgs = 0), 5 iterations applied:
*createmark elements 1 ""displayed""
*createmark nodes 1  
*qismoothfixfailed 1 1 ""C:/temp/10mm.criteria"" 30 6 0.5 1.0 -1 0 5
To do the same, except that node IDs 2342 and 131 are not allowed to move, free edges'
        nodes are not allowed to move across edges (ignore_features =4), and the
        quality criteria are preset directly by the preceding
        command:*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0 
*createmark elements 1 ""displayed""	
*createmark nodes 1 2342 131  
*qismoothfixfailed 1 1 ""dummy"" 30 4 0.5 1.0 -1 0 5
","Errors
The command returns error codes for wrong quality criteria, no elements selected and
        internal optimization errors.
"
1087,*rbe3,"Description
Creates an RBE3 element.
","Inputs

mark_id
The ID of the mark containing the independent nodes. Valid values are 1 and 2.
independent_dofs
The ID of the integer array containing the degrees of freedom for which each
            respective independent node of the element is active (any of the digits 1-6), created
            using *createarray. Must be set to 1.
dof_size
The size of the independent_dofs array.
independent_weights
The ID of the double array containing the weight for each respective independent node,
            created using *createdoublearray. Must be set to 1.
weight_size
The size of the independent_weights array.
dependent_node
The dependent node of the element. If set to 0, the dependent node will be
            auto-created at the centroid of the independent nodes.
dof
The degree of freedom code for which the dependent node of the element is active (any
            of the digits 1-6).
weight
The weight assigned to the dependent node.

","Example
To create an RBE3 element with dependent node 100 and independent nodes 101, 102, and 103
        with all of the nodes having all six degrees of freedom and a weight of 1.23:
*createmark nodes 1 101 102 103
*createarray 3 123456 123456 123456
*createdoublearray 3 1.230000 1.230000 1.230000
*rbe3 1 1 3 1 3 100 123456 1.23
","Errors
None.
"
1088,*readqiviewsettings,"Description
This command is related to the element quality view mode. It loads settings from a text
        file created by *writeqiviewsettings, and resets the current settings
        used in this view mode.
","Inputs

flag
The full name and path of the file to load containing the QI view settings.

","Example
To load the current settings from the file C:/settings/qiview.txt:
*readqiviewsettings ""C:/settings/qiview.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1089,*redohistorystate,"Description
Redoes one or more history states.
","Inputs

count
The number of history states to redo.

","Example
To redo two history states:
*redohistorystate 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1090,*refineelementsbydeviation,"Description
Refine elements to chordal deviation.
","Inputs

mark
The ID of the mark which contains the elements to be refined. 
deviation
The maximum chordal deviation.
minlength
The minimum element edge size.

","Example
To refine the elements to chordal deviation:
*createmark(elements,1) 86 88 113
*refineelementsbydeviation(1,0.01,0.1)

*createmark() is required.
","Errors
None.
"
1091,*rejectmark,"Description
Rejects the entities held on the reject mark. 
","Errors
None.
",,
1092,*remesh_master_slave_boolean,"Description
Performs intersection and Boolean operations of 2D elements. Elements are distributed into
        groups based on their connectivity and component membership. The elements belonging to
        different components can be in a single group by parameter input. Only different groups are
        taken as counterparts for the intersection and Boolean operations. Moreover, elements
        sharing a node are not counterparts of intersection calculations for element/element
        intersection.
","Inputs

selected_entity_type
The type of selected entities. Valid values are elems and comps.
selected_mark_id
The ID of the mark that contains the selected entities. Valid values are 1 and 2.
master_entity_type
The type of master entities. Valid values are elems and comps. 
Master entities are those with no elements (internal shell elements) deleted after
            conformal elements are generated for intersecting elements. Selected entities which are
            not also selected as master, are known as slave elements. After conformal elements are
            generated for intersecting elements, the slave elements inside any closed watertight
            element groups are deleted.
master_mark_id
The ID of the mark that contains the master entities. Valid values are 1 and 2.
strings
Character string containing name/value pairs. Names and values are space separated.
angle <value>
This is used to define feature edges on the mesh utilized for remeshing. If not
                  defined, its default is 30.0.
break_shell_along_component_boundaries <value>
0 - All elements connected to each other are classified as a group. 
1 - Element group building stops at component boundaries. All elements in each
                  group belong to a single component (default).
do_boolean_difference <value>
If set to 1, perform a Boolean difference to subtract slave entities from the
                  master. Default is 0.
generate_intersect_segments_only <value>
If set to 1, the command only calculates and creates the intersection segments,
                  but does not perform the intersection and remeshing. Default is 0.
keep_intersected_edges <value>
If set to 1, create 1D elements at mesh intersection locations. Default is
                  0.
num_remesh_layers <value>
The number of layers attached to intersecting elements to consider for
                  remeshing. 
-1 - Intersecting elements are split and stitched to obtain a conformal element
                  connectivity without remeshing. 
0 - Remesh only the intersecting elements 
> 0 - Remesh using the specified number of layers in addition to the intersected
                  elements.



","Example
To create intersections between the displayed comps and comps brown and blue:
*createmark components 1 ""displayed""
*createmark components 2 ""brown"" ""blue""
*remesh_master_slave_boolean components 1 components 2 ""do_boolean_difference 1 keep_intersect_edges 0 break_shell_along_component_boundaries 0 num_remesh_layers -1 angle 30.000000 ""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1093,*removecrbrelation,"Description
Removes a master-slave relationship for LS-DYNA
        *CONSTRAINED_RIGID_BODIES keyword.
 If a master component is removed, then the constrainedrigidbodies entity is deleted. If
        all slave components are removed, the constrainedrigidbodies entity is deleted.
","Inputs

mark_id
The ID of the mark containing the components.

","Example
To remove slave rigid component 200:
*createmark comps 1 200
*removecrbrelation 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1094,*removeelemsfromcontactsurfusingnodes,"Description
Removes elements from a contactsurf using face nodes. If all elements are removed the empty
        contactsurf still exists.
","Inputs

name
The name of the contactsurf.
elem_mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes defining the face nodes of the elements to
            remove. Valid values are 1 and 2.

","Example
To remove elements 100 and 101 from the contactsurf ""test"" for the specified face defined
        by the nodes on mark 2:
*createmark elems 1 100 101
*createmark nodes 2 201 202
*removeelemsfromcontactsurfusingnodes  ""test"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1095,*removeinclude,"Description
Deletes the include file from the database, optionally removing all of its contents as
        well. 
","Inputs

id
Use an id of 0 to have HyperMesh to use the
              shortname to select the file.
shortname
The shortname to use to select the file. This can be left empty if the id is
            specified.
removecontents
If nonzero, and either the id or the shortname selects a single
            file, then all of the contents of that include file will be deleted from the
            database.

","Example
To remove the include file mat1.dyn from the database, and delete its contents as well:
*removeinclude(0,mat1.dyn,1)
If both id and shortname are empty, this command removes all include files from the
        database (but does not delete the files’ contents). If the contents are not deleted, they
        move to the file's parent include file.
","Errors
None.
"
1096,*renamecollectorbyid,"Description
Renames a collector to its ID. 
","Inputs

entity type
The type of collector being renamed. 
prefix
A prefix which will be inserted before the ID of the collector. 

","Errors
None.
",
1097,*renumberall,"Description
This command renumbers the internal HyperMesh IDs for all
        entities in the model. 
This command only renumbers HyperMesh internal IDs, even if the
        selected entities have solver IDs (see *renumbersolveridall).
","Inputs

start_id
Integer value > 0 specifying the starting value.
incr_val
Integer value > 0 specifying the renumbering increment.
offset_val
Integer value to use for offsetting. Can be positive or negative as long as after
            renumbering all entities will have a positive ID.
offset_flag
Flag to specify whether to use offsetting: 
0 Use start_id and incr_val and ignore
              offset_val. 
1 Use offset_val and ignore start_id
              and incr_val.

","Example
To renumber the internal HyperMesh IDs of all entities starting
        from 100 with an increment of 1:
*renumberall 100 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1098,*reparammark,"Description
Reparameterizes the lines on a mark. 
","Inputs

mark_id
The ID of the mark containing the lines to be reparameterized.  Valid values are 1 and
            2.

","Examples
To reparameterize lines 1 and
        2:*createmark lines 1 2
*reparammark 1
","Errors
None.
"
1099,*resetreview,"Description
Resets the entity review of the *reviewentity command.
","Example
To reset the review:
*resetreview
","Errors
None.
",
1100,*restoreviewmask,"Description
Restores a view saved using *saveviewmask. The orientation and visible
        entities can be restored.
","Inputs

view_name
The name of the view to restore.
visible
A flag indicating whether to restore the visible entities or not. Valid values are: 
0 - Restore the visible entities and view orientation. 
1 - Restore the view orientation only. 
2 - Restore the visible entities only.

","Example
To restore the view with the name ""my_view"", including the orientation and visible
        entities:
*restoreviewmask ""my_view"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1101,*reversecontactsurfnormals,"Description
Change normals (inward to outward, vice versa) of contactsurf.
","Inputs

Name
Name of the contactsurf being created.
Elemmark
Elements whose normal need to be reversed.
Indelems
Flag for reversing normals of all or individual elements of a contactsurf (0 = all
            elements and 1 = individual elements).

","Example
Reverse normals of contactsurf ""test"" for the elements on mark 1 
*reversecontactnormals(""test"", 1, 0)
If indelems flag = 0 then the mark is empty as all elements in contactsurf are
        selected.
","Errors
None.
"
1102,*reviewclearbyid,"Description
This command removes/clears entities from the review list based on an entity ID.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are blocks and groups. 
id
The ID of the entity.
review_type
The review type to control.
For blocks: 
1 = nodes 
2 = elems


For groups: 
1 = slave only 
2 = master only 
3 = master & slave



","Example
To remove master and slave review of group 5 from the review list:
*reviewclearbyid groups 5 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1103,*reviewmaterialorientation_option,"Description
Reads and plots the first axis of the element (material) coordinate system for selected
        elements. When review is complete, the command *vectorsoff must be
        run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64.
option
Option for review customization. Valid values are: 
1 - Abaqus rebar layer will be reviewed

","Example
To review the element (material) coordinate system of the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*reviewsystem_option elems 1 1 3 7 1
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1104,*reviewtwomark,"Description
Graphically reviews two mark of nodes with different colors.
","Inputs

mark_id1
The first mark of nodes.
mark_id2
The second mark of nodes.
color1
The color used to review the nodes on mark 1. Valid values are 1-64. 
If specified as 0, the entity will be reviewed with its respective entity color (not
            yet available).
color2
The color used to review the nodes on mark 2. Valid values are 1-64. 
If specified as 0, the entity will be reviewed with its respective entity color (not
            yet available).

","Example
To review nodes 1-100 with color 4 and nodes 201-300 with color 6:
*createmark nodes 1 1-100
*createmark nodes 2 201-300
*reviewtwomark 1 2 4 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1105,*rigidlinkinodecalandcreate,"Description
Creates a rigidlink elem by calculating the independent node based on selection of
        dependent nodes. Location of independent nodes will be at the geometric center of dependent
        nodes.
","Inputs

node_mark1
Mark for multiple dependent nodes. 
set_id
Set that contains dependent nodes. Set type should be of nodes.
attach_set_option
Options for attaching set to rigidlink: 
0- set will not be created when multiple dependent nodes are selected. 
1- set will be created when multiple dependent nodes are selected and then assigned to
            rigidlink.
dof
Degrees of freedom. This is a six digit number.

","Example
For creating a rigidlink elem by selecting only dependent nodes without the attach set
        option: 
*rigidlinkinodecalandcreate(2,0,0,123456)

For creating a rigidlink elem by selecting only dependent nodes with the attach set
        option:
*rigidlinkinodecalandcreate(2,0,1,123456)

For creating a rigidlink elem by selecting only dependent node set with the attach set
        option:
*rigidlinkinodecalandcreate(0,2,1,123456)
*createmark() for nodes is required if a dependent node set is not
        selected.
","Errors
None.
"
1106,*rigidlinkwithset,"Description
 Create a rigid link element with dependent nodes attached as a node set connected to the
        element. The attached node set may exist before or may be created from a given mark of
        dependent nodes while the rigid link element is created. 
","Inputs

independent
The independent node of the element. 
mark
The ID of the mark containing the dependent nodes if the dependent nodes set is
            created for the rigid link element; 
0 - if an existing nodes set is being attached to the rigid link. 
dependent_set
The ID of an existing nodes set being attached to the rigid link; 0 - if the rigid
            link and an attached nodes set are being created using a mark of dependent nodes. 
dof
The degrees of freedom for which the element is active (any of the digits 1-6).

","Example
To create a rigid link element with independent node 100 and dependent nodes 101, 102, and
        103 with nodes having all six degrees of freedom:
*createmark(nodes,2) 101 102 103
*rigidlinkwithset(100,2,0,123456)
A new nodes set with an autogenerated name is created for the rigid link element, the
        dependent nodes 101,102,103 being placed to this nodes set. 
To create a rigid link element with independent node 100 and node set 25 attached as a
        dependent node set, with nodes having all six degrees of freedom:
*rigidlinkwithset(100,0,25,123456)
The *createmark() command is required to create a rigid link element
        with an attached independent node set. 
","Errors
None.
"
1107,*rigidwallsize,"Description
Sets the size for axis and motion arrow plotting.
","Inputs

size 
The size in model units in which the arrows should be plotted.

","Errors
None.
",
1108,*rotatedummy,"Description
Rotates the dummy by an arbitrary axis that is specified by the
          *createplane() command.
","Inputs

entities
The entity type selected that recognizes the dummy. Currently, only components is
            supported.
collectorid
The id of the entity recognizing the dummy.
plane
The plane defining the arbitrary axis that the dummy rotates about.
increment
The number of degrees to rotate the dummy.

","Example
To rotate about the x axis by 90 degrees, specify a component that exists within the dummy
        (and is included in the parent/child system): 
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*rotatedummy(components,1,1,90)

","Errors
None.
"
1109,*saveviewmask,"Description
Saves the currently view orientation and visible entities. Views are stored in the
        database.
","Inputs

view_name
The name of the view to save. The numbers 1-5 are reserved and cannot be used.
visible
A flag indicating whether to save the visible entities or not. Valid values are:
0 - Save the visible entities and view orientation. 
1 - Save only the view orientation.



","Example
To save a view with the visible entities, with the name ""my_view"":
*saveviewmask ""my_view"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1110,*scalemark,"Description
This command scales a selection of entities by multiplying the coordinates.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
scale_x
The multiplication factor for the x-coordinate.
scale_y
The multiplication factor for the y-coordinate.
scale_z
The multiplication factor for the z-coordinate.
origin
The node ID defining the origin of the scaling. If set to 0, the global origin is
            used. 

","Example
To scale component top uniformly 10 times about node 3:
*createmark comps 1 top
*scalemark comps 1 10.0 10.0 10.0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1111,*screendump,"Description
 Generates a PostScript output file from a Macro menu macro.
","Inputs

pathName
The file name and path to which the PostScript file will be output.

","Example
This command is not available through Tcl/Tk.
* screendump (c:\postscriptdumps\output1.ps)

","Errors
None.
"
1112,*section_plane_mesh,"Description
Generates a shell mesh from a selection of planar boundary elements.
","Inputs

entity_type
The type of entity to use as input for the boundary. Valid values are comps and
            elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
mesh_type
Flag indicating the type of mesh to generate. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_size
The target element size.
connectivity
Manage the connection with input boundary/overlay elements. Valid values are:
0 - Generate mesh using given element size. Ignore
                  elem_mark_id.

1 - Manage connection with the user given boundary elements. Ignore
                  elem_mark_id. 
2 - Manage connection with elements specified with elem_mark_id. Elements on
                  elem_mark_id should be part of mark_id as
                well. 
3 - Manage connection with boundary elements which are not on
                  elem_mark_id. 
4 - Manage connection with overlapped elements on
                elem_mark_id. Overlapped elements should not be tagged as
                boundary elements on mark_id. 
5 - Manage connection with boundary elements which do not overlap
                  elem_mark_id elements. Overlapped elements should not be tagged
                as boundary elements on mark_id.


elem_mark_id
The ID of the mark containing the boundary/overlay elements used to manage the
            connectivity. Valid values are 1 and 2.

Ignored if connectivity is set to 0 or 1.
tol
The tolerance to use for overlay check. If set as 0, the tolerance will attempt to be
            automatically detected.

","Example
To create a section plane quad mesh of size 2.0, using elements 10-30 as boundary input,
        and elements 1-5 as overlapped:
*createmark elems 1 10-30
*createmark elems 2 1-5
*section_plane_mesh elems 1 1 2.0 4 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1113,*selfstitchcombine,"Description
This command performs equivalencing of edges within surfaces or/and between surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to operate on. Valid values are 1 and 2.
mode
The mode options for performing the stitching. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 64*StitchOption).
Bit0
0 - Do not consider self-stitching. 
1 - Consider self-stitching (same surface edges).
Bit1
0 - Do not stitch edges between different surfaces. 
1 - Stitch edges between different surfaces.
Bit2
0 - Consider free edges only. 
1 - Consider all edges.
Bit3
0 - Equivalence between components. 
1 - Do not equivalence between components.
Bit4
0 - Do not collapse small edges. 
1 - Collapse small edges.
StitchOption
0 - Honor the value set by Bit3. 
1 - Do not equivalence between components (same as Bit3=1). Bit3 is ignored. 
2 - Equivalence between components (same as Bit3=0). Bit3 is ignored. 
3 - Equivalence between selected surfaces and surfaces connected to selection.
                  Bit3 is ignored. 
4 - Equivalence only within the subset of selected surfaces. Bit3 is
                  ignored.


tolerance1
Equivalencing tolerance for edges of different surfaces.
tolerance2
Equivalencing tolerance for edges within one surface. 

","Example
To equivalence edges between all displayed surfaces using a tolerance of 0.2:
*selfstitchcombine 1 2 0.2 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1114,*set_acousticmesh_options,"Description
Assigns certain options used during acoustic cavity meshing.
","Inputs

string_array
The ID of the string array that contains the option parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Valild strings are:
DisplayCavities:
Option to control the number of cavities displayed during the preview.
NumElemPerWaveLength:
Specifies the element per wave length which is used to decide the target element
                  size. The target size is computed as
                  (WaveSpeed/MaxFrequency)/NumElemPerWaveLen
WaveSpeed:
Specifies the wave length which is used to decide the target element size.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
TBD
*createstringarray 3 ""NumElemPerWaveLength: 6"" ""WaveSpeed: 31000"" ""DisplayCavities: 10""
*set_acousticmesh_options 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1115,*set_preserved_edges,"Description
Marks edge geometry to be preserved during batch meshing, or clears the ""preserved"" flag
        from preserved edges.
","Inputs

hmlinesmark
The mark containing the lines that you wish to flag as preserved or not preserved. 0
            indicates all lines.
new_stat
1 - The lines are marked as preserved. 
0 - The preservation flag is cleared from the lines.

","Example
To preserve the lines in mark 2:
*set_preserved_edges(2,1)
","Errors
None.
"
1116,*setcomptopologydisplay,"Description
Sets the various types of geometry display at the component level.
","Inputs

compid
The ID of the component for which you wish to set the topology display mode.
display_type
The type of topology display:
0 - Wireframe only 
1 - Shaded with edges 
2 - Shaded without edges 
3 - Wireframe with internal surface lines



","Errors
None.
",
1117,*setcuttingplanesbase,"Description
Sets the origin coordinates for all cutting planes.
","Inputs

x
The x coordinate of the origin.
y
The y coordinate of the origin.
z
The z coordinate of the origin.

","Example
 To set the cutting plane origin to (5,0,7):
*setcuttingplanesbase 5.0 0.0 7.0
","Errors
None.
"
1118,*setelemparamscolors,"Description
This command is related to the element quality view mode. It sets the color for all element
        quality parameters for elements violating the threshold.
","Inputs

double_array
The ID of the double array containing the color values for each quality parameter.
            Must always be set to 1. 
There are currently 12 quality parameters. The colors for each parameter must be
            specified, using a value of 1-64 for each. The order of the parameters is:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation 
11 - quality index


number_of_doubles
Must currently be set to 12.

","Example
To set colors for all element quality parameters:
*createdoublearray 12 59 39 41 56 28 61 19 22 46 57 29 3
*setelemparamscolors 1 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1119,*sethistorymemorylimit,"Description
Sets the maximum amount of memory that history states are allowed to use.
","Inputs

memory
The maximum amount of memory (in MB) that history states are allowed to use. 
0 - Disables all history recording, including potential legacy use cases. 
-1 - Indicates unlimited.



","Example
To set the maximum memory 1000 MB:
*sethistorymemorylimit 1000
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1120,*setlightsource,"Description
Set direction of the global light source.
","Inputs

x
X axis location, horizontal direction of screen.
y
Y axis location, vertical direction of screen.
z
Z axis location, in/out of screen.

","Example
This command may be used in either the hm.cfg file or from a command
        file. 
The default setting is 0.0, 0.0, 1.0 (represents model lighting as you view it).
","Errors
None.
"
1121,*setmarkdisplayattributes,"Description
 Set the display attributes (wireframe/hidden line, color, etc.) for the entities contained
        in a mark.
","Inputs

entitytype
The type of entity contained in the mark; limited to ""components"" and
            ""multibodies"".
mark
ID of the mark whose display attributes you wish to change.
style
The desired rendering style of the entities:
0 wire frame 
1 hidden line 
2 hidden line with mesh 
3 hidden line with features 
4 hidden line, transparent


colortype
Determines how the components are colored.
0 none 
1 component color 
2 assigned plots 
3 contours



","Example
To change the attributes of a component named ""Front Panel"" to hidden line using component
        color
*createmark(components,1) ""Front Panel""
*setmarkdisplayattributes(components,1,1,1)

","Errors
None.
"
1122,*setparametermark,"Description
Parameterizes a data name or attribute on a mark of entities. 
","Inputs

name
The name of parameter entity to assign.
entity_type
The type of entity to parameterize.
mark_id
The ID of the mark containing the entities to parameterize. Valid values are 1 and 2.
data_name_or_attribute
The data name or attribute name/ID to parameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.
reserved
Must be set to 0.

","Example
To parameterize attribute LSD_DA1 on entity sets 5, 6 and 7 with the parameter named
        param1:
*createmark sets 1 5 6 7
*setparametermark param1 sets 1 LSD_DA1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1123,*setply_option,"Description
Sets the ply/layer number to review. The element ply direction of that ply will be plotted
        for each selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_number
The number of the ply to review.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64.
option
Option for review customization. Valid values are: 
1 - Abaqus rebar layer will be reviewed

","Example
To review the ply directions for the ply with ID 2 for the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*setply_option elems 1 2 1 3 7 1
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1124,*setreviewbymark,"Description
This command adds entities to the review list based on a mark.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are:
nodes 
elems 
points 
lines 
surfs 
solids 
connectors 
loads 
equations 
systs 
vectors


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
color
The color to use for review of the entity. Valid values are 1-64.

","Example
To review elements 1-100 with color 4, with all other non-reviewed entities having
        transparency and gray color:
*createmark elems 1 1-100
*setreviewbymark elems 1 4
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1125,*setreviewtransparentmode,"Description
This command sets the transparency mode for non-review list entities.
","Inputs

mode
0 - Normal 
1 - Transparent (polystipple)

","Example
To review slave elements only for group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
None.
"
1126,*settrimcuttingplanes,"Description
Turns the cutting plane trim option on/off.
","Inputs

state
Specifies the trim plane option for all cutting planes. Valid values are: 
0 - off 
1 - on

","Example
To turn off the trim cutting plane option:
*settrimcuttingplanes 0
","Errors
None.
"
1127,*shapevarcreate_xproduct,"Description
Creates a shape variable by using the cross product of two other shape variables.
","Inputs

basenode
The ID of the node where the base of the result is located after it is created.
shape variable A
The ID of the first shape variable in the cross product.
shape variable B
The ID of the second shape variable in the cross product.
magnitude
Magnitude of resulting vector.

","Errors
None.
",
1128,*show_new_edge_target_by_number,"Description
Displays the target for a selected surface edge number in the new target component.
","Inputs

face
Index of the surface to be offset.
e1_edge_number
Number of the surface edge to be offset.
e2_line
Index of a pilot line.
is_opposite
0 - Uses e2_line as the target. 
1 - Uses a midline between the e1_edge_number line and
              e2_line as the target. 

","Example
Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
1129,*showall,"Description
Turns on the display of all entities.
","Example
Turns on the display of all entities.
*showall
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1130,*sl_meshsurfaces,"Description
Performs feature-based meshing of surfaces using an XML config file. 
","Inputs

mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 1 and 2.
file
The full name and path to the XML config file containing the mesh parameters.
reserved
Reserved for future use. Must be set to 0.

","Example
To mesh all surfaces using the config file c:/temp/config.xml:
*createmark surfs 1 all
*sl_meshsurfaces 1 c:/temp/config.xml 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1131,*solid_offset_from_surfs,"Description
This command creates solids by normally offsetting a set of selected surfaces.
","Inputs

mark_id
The mark of input surfaces. Valid values are 1 and 2.
offset
The distance to offset along the normal direction.
options
Flags that indicate different modes for the offset. Bit values are used and the value
            is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5).
Bit0
0 - Only free edges of surfaces are offset. 
1 - Both free and internal edges are offset, thus creating separate solids from
                  surfaces separated by shared edges.
Bit1
0 - Create solid entities. 
1 - Create only boundary surfaces.
Bit2
0 - Surfaces are offset in one direction (positive or negative based on the
                  surface normal). 
1 - Surfaces are offset in both directions.
Bit3
0 - Selected surfaces are disconnected from non-selected attached surfaces
                  before creating solids. 
1 - Connectivity between selected and non-selected surfaces is preserved.
Bit4
0 - When extrusion is made in both directions (Bit2=1), delete original
                  surfaces. 
1 - When extrusion is made in both directions (Bit2=1), keep original surfaces
                  and use them as separating surfaces between created solids.
Bit5
0 - Original selected surfaces become part of created solid boundary. 
1 - Copy of original selected surfaces is made before creating solids.


comp_mode
Determines how new solids are distributed into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces (the result
                is not predictable if the surfaces are originally in different components).



","Example
To create a solid by offsetting surface ID 3 a distance of 5.0 along both the positive and
        negative normal directions and to organize the input surface into the same component as the
        solid:
*createmark surfs 1 3
*solid_offset_from_surfs 1 5.0 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1132,*solid_prepare_nodeline,"Description
This command is used by the solid mapping algorithm to setup an internal node array. It
        must be used within a *solidmap_prepare_usrdataptr data input block. A
        data input block begins with *solidmap_prepare_usrdataptr and ends with
        either a call to *solidmap_end or the start of another data input
        sub-block.
","Inputs

start
A flag that indicates how to handle the nodes on the node list2. A value of 0
            indicates to start a new internal node array. Otherwise, the list is appended to the
            previous internal node array. The later case is required when the node count is more
            than 2000 as this is the current upper limit allowed by a single call to
              *createlist.

","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0
","Errors
Invalid or inconsistent input parameters in *solidmap_prepare_nodeline result in a Tcl
        error. To detect errors, you can use the catch command:
if { [ catch {*solidmap_prepare_nodeline 0} ] } {
# Handle error
}
"
1133,*solidcone,"Description
This command creates a full or partial cone or cylindrical solid.
","Inputs

base_x, base_y, base_z
base_x, base_y, base_z
mvec_x, mvec_y, mvec_z
The x, y and z coordinates specifying the major axis vector direction from the base
            location.
nvec_x, nvec_y, nvec_z
The x, y and z coordinates specifying the normal vector (along the length) from the
            base location.
base_radius
The radius of the bottom of the cone/cylinder (at the major axis in case of elliptical
            cone or cylinder).
If the top_radius and base_radius are equal, this creates a cylindrical solid.
top_radius
The radius of the top of the cone/cylinder (at the major axis in case of elliptical
            cone or cylinder). 
If the top_radius and base_radius are equal,
            this creates a cylindrical solid.
aspect_ratio
A value less than 1.0 creates an elliptical cone/cylinder. A value smaller than 1.0
            indicates a more elliptical shape. 
Must be > 0.0.
start_angle
 The angle at which the cone/cylinder starts (0.0 to <
            end_angle). 0.0 starts at major axis.
end_angle
The angle at which the cone/cylinder ends (> start_angle to
            360.0)
height
The height of the cone/cylinder.

","Example
To create a full elliptical cone solid with center at (0,0,0), with major axis vector
        (1,0,0), normal axis vector (0,0,1), base radius of 20, top radius of 10, ratio between
        minor and major axis of 0.5, and a height of 30:
*solidcone 0 0 0 1 0 0 0 0 1 20 10 0.5 0 360 30
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1134,*solidmap_begin,"Description
This command is used by the solid mapping algorithm to indicate the beginning of a solid
        mapping command block. It must be paired with a *solidmap_end command. A
        single solidmap mesh is a result of the block of commands. 
In a solidmap command block, all of the commands before *solidmap_end
        are for preparing input data. *solidmap_end is the command that actually
        performs the solid mapping.
","Inputs

ordered
A flag indicating whether the input nodes will be reordered or not. This is meaningful
            only if nodes will be used as input. Valid values are:
0 - Nodes will be reordered in solidmap. 
1 - Nodes will not be reordered in solidmap.



","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10 
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1135,*solidmap_solids_end,"Description
This command is used by the multi-solid mapping algorithm to indicate the end of a solid
        mapping command block. It must be paired with a *solidmap_solids_begin
        command. 
The commands below can appear in a multi-solids solidmap command block between
          *solidmap_solids_begin and
        *solidmap_solids_end:*solidmap_solids_set_density
*solidmap_solids_set_elemsize
*solidmap_solids_set_face_params
*solidmap_solids_set_mapface
","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem size of 1.0:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
*createmark lines 1 2 4
*solidmap_solids_set_elemsize 1 1.0
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1136,*solidmap_solids_set_elemsize,"Description
This command is for setting the per edge elem size for solid map meshing. The size value
        specified is only a target value. Depending on solvability, the resulting mesh may take on a
        modified value. This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

mark_id
The ID of the mark containing the lines/edges to set the element size for. Valid values are 1 and 2.
elem_size
The value to set the elem size to for the selected lines/edges.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem density of 10.0:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *createmark lines 1 2 4
   *solidmap_solids_set_elemsize 1 10.0
*solidmap_solid_end

","Errors
None.
"
1137,*solidmap_solids_set_mapface,"Description
This command is used to set the surface shared by the 4 input vertices to the mapped type
        with the input vertices as the corners. The 4 vertices must be distinct. If more than one
        surfaces share the 4 vertices, the resulting surface for type setting is random. The command
        has effect only for surfaces for which the mesh type is free to change (e.g. not an along
        face of a solid). This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

point_id1
The ID of the first corner vertex.
point_id2
The ID of the second corner vertex.
point_id3
The ID of the third corner vertex.
point_id4
The ID of the fourth corner vertex.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on the surface shared by
        points 10, 11, 12 and 13 which is to be of mapped type by these points:
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *solidmap_solids_set_mapface 10 11 12 13
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1138,*solidmeshwithsurfaces,"Description
Creates a mesh of solid elements by first extruding an existing 2D finite element mesh, and
        then mapping the extruded mesh into a volume. 
","Inputs

type
Identifies which type of geometry is being supplied.
0 - Source and destination
1 - Source and along
2 - Source, destination, and along


sourcetype
Set to nodes, lines, or surfaces, this parameter identifies the geometry used to
            define the source face. 
source
The mark ID which contains the data of the source face.
desttype
Set to nodes, lines, or surfaces, this parameter identifies the geometry used to
            define the destination face.
dest
The mark ID which contains the data of the destination face. 
alongtype
Set to lines or surfaces, this parameter identifies the geometry used to define the
            along faces. 
along
The mark ID which contains the data of the along faces. 
genelems
Currently not used. 
elements
The mark which contains the elements which are to be mapped into the volume. 
density
The number of elements to be created between the source and destination faces.
biasstyle
The type of biasing to use.
biasing
The biasing intensity value.

","Errors
None.
",
1139,*spatialrenumbering,"Description
Renumbers nodes and elements based on spatial locations.
","Inputs

entity_type
The type of entity to renumber. Valid values are nodes and elements.
type=<type>
The type of renumbering, axis or adjacent. 
Adjacent only works with quad4 or quad8 elements and associated nodes.
startid=<startid>
The ID to be assigned to the first entity. The value must be an unsigned integer. This
            option also works with parameters of integer type.
primaryidincrement=<primaryidincrement>
The ID increment in the primary direction. The value must be an unsigned integer. This
            option also works with parameters of integer type. 
secondaryidincrement=<secondaryidincrement>
The ID increment in the secondary direction. The value must be an unsigned integer.
            This option also works with parameters of integer type.

The following options apply to type=axis only:

systemid =<systemid>
The ID of system. For global system, a value of 0 must be used. The system should be
            either Cartesian or cylindrical.
primaryaxis=<primaryaxis>
The primary axis of the system. x=1, y=2 and z=3 for Cartesian systems. r=1, θ=2 and
            z=3 for cylindrical systems.
primarytolerance=<primarytolerance>
The allowed tolerance between entities in the primary direction. The value must be a
            double. This option also works with parameters of double type.
secondaryaxis=<secondaryaxis>
The secondary axis of the system. x=1, y=2 and z=3 for Cartesian systems. r=1, θ=2 and
            z=3 for cylindrical systems. This must not be equal to
            primaryaxis.
secondarytolerance=<secondarytolerance>
The allowed tolerance between entities in the secondary direction. The value must be a
            double. This option also works with parameters of double type.

The following options apply to type=adjacent only:

startentityid=<startentityid>
The ID of the start entity. This entity must be same as
            entity_type.
primaryentityid=<primaryentityid>
The ID of the primary entity. This entity must be same as
              entity_type and must be adjacent to the start entity.
secondaryentityid=<secondaryentityid>
The ID of the secondary entity. This entity must be same as
              entity_type and must be adjacent to the start entity.
A few notes about type=adjacent:
If the entity type for all three options is nodes, all three entities must belong
                to a common element apart from being adjacent to each other. 
For quad8 elements, only provide ids of corner nodes of a common element as start,
                primary and secondary entity ID. Mid nodes as prime inputs are not supported. 
The IDs of non-selected entities will be renumbered if any conflict arises during
                renumbering. 
A single entity cannot be renumbered using this method. 
If a secondary entity is not specified, or set as 0, the row/column containing the
                start and primary entities will be renumbered.



","Examples
Renumber nodes using axis type and local system 1 with primary axis 1 and secondary axis
        2:
*createmark nodes 1 all
*spatialrenumbering nodes mark=1 type=axis systemid=1 startid=100 primaryaxis=1 primarytolerance=0.2 primaryidincrement=1000 secondaryaxis=2 secondarytolerance=0.2 secondaryidincrement=1
Renumber elements using adjacent type and integer parameter named priInc (parameter value
        100) used as primary ID increment by name:
*createmark elems 1 all
*spatialrenumbering elems mark=1 type=adjacent startentityid=555 startid=1 primaryentityid=557 primaryidincrement={parameter name=priInc} secondaryentityid=556 secondaryidincrement=1
Renumber a single column/row of nodes using adjacent type. Only a single column/row of
        entities will be renumbered:
*createmark elems 1 all
*spatialrenumbering elems mark=1 type=adjacent startentityid=41 startid=1 primaryentityid=40 primaryidincrement={parameter id=5} secondaryentityid=0 secondaryidincrement=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1140,*splinesurface,"Description
Creates a 3D or planar surface defined by a set of lines, and optionally, prepares it for
        immediate use within the automesher. It can also identify a region in the shape of a Coons
        patch surface for the automesher to use under the mesh without surface option. 
","Inputs

entity_type
The type of entities to use as input. Valid values are nodes, points and lines.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
plane_flag
A flag indicating if the lines are planar. 
1 - A plane is calculated from the lines. 
2 - Lines are projected onto the plane defined by plane. 
0 - Lines are not on a plane, and a 3D surface is created. 
plane
The plane used to project lines if plane_flag is set to 2. 
options
Specifies options for creating the surface. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 8*Bit3 + 1024*Bit10).
Bit0
Component mode. Used to determine which component will be used to place created surfaces.
0 - Current component is used. 
1 - Component of input lines is used. If different components are used as
                      input, the component to which the majority of the lines belong is used.


Bit1
Line ends usage mode. Used to control creation of vertices on the constructed
                  spline. Currently works only for planar surfaces.
0 - Vertices are created automatically on constructed surface. 
1 - Vertices are created at input line ends.


Bit3
Surface stitching option. Used to override the default stitching algorithm.
0 - Default stitching algorithm as defined by *setoption
                        geom_stitching command. 
1 - Created surface is not stitched to any of model surfaces.


Bit10
 Mesh stitching option. Used to control the connectivity of the mesh created on
                  the new spline surface in simultaneous meshing modes set by
                    *surfacemode command.
0 - New mesh is not connected. 
1 - In *surfacemode 1, existing mesh nodes on input
                      lines are used if new spline edges are stitched to those lines. In
                        *surfacemode 2, existing mesh nodes on input lines are
                      used to create the mesh on the new spline surface.





","Example
To create a surface from lines 65, 66, 67 and 69, with no elements: 
*surfacemode 4
*createmark lines 1 65 66 67 68
*createplane 1 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000
*splinesurface lines 1 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1141,*spring,"Description
Creates a spring element between two nodes using an orientation vector.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
dof
The degree of freedom for the element.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.

","Example
To create a spring element between node 100 and node 101 with DOF 2, property springprop,
        and orientation vector ID 51:
*spring 100 101 2 ""springprop"" 51
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1142,*springsosupdate,"Description
Updates a spring element using various orientation methods. 
The orientation may be specified using either vector_id, direction_node_id,
          system_id or individual components (orient_x, orient_y, orient_z).
","Inputs

mark_id
The ID of the mark containing the spring elements to update.
property_flag


0 - Do not update property_name

1 - Update property_name


property_name
The name of the property to assign to the element.
vector_flag


0 - Do not update the orientation vector 
1 - Update the orientation vector


vector_id
The ID of the orientation vector assigned to the element.
direction_node_id
The ID of the direction node assigned to the element.
orient_x
The x-component of the orientation vector.
orient_y
The y-component of the orientation vector.
orient_z
The z-component of the orientation vector.
orient_comps_flag


0 - Do not use individual components to define the orientation 
1 - Use individual components to define the orientation


system_id
The ID of the orientation system assigned to the element.
update_orient_flag


0 - Do not update the orientation vector's component or system 
1 - Update the orientation vector's component or system



","Example
To update spring element s16, 17, and 18 to have property sprate, and an orientation vector
        with components 10,11,12:
*createmark elements 1 16 17 18
*springsosupdate 1 1 ""sprate"" 1 0 0 10 11 12 1 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1143,*start_batch_import,"Description
Initializes a sequence of multi-file batch import/merge operations. This is intended to
        improve performance of importing/merging a series of files. Certain operations that
        generally are run for each import/merge, and queued up and executed just once at then end of
        the import. These operations are different for each type of import/merge operation, and
        therefore cannot be mixed. It is essential to only import/merge valid file types per the
        mode argument. This command must be followed by a corresponding call to
          *end_batch_import. It is potentially dangerous to perform other
        operations within a *start_batch_import/*end_batch_import block, so take
        proper precaution and make sure to always call these commands in pairs.
","Inputs

mode


1 - Merge HyperMesh files using *mergefile
                or *mergefile2

2 - Import FE files using *feinputwithdata2

3 - Import CAD files using *feinputwithdata2



","Example
To execute a sequence of importing multiple CAD files, where the variable
          cad_files contains the list of files:
*start_batch_import 3
foreach cad_file $cad_files {
    *feinputwithdata2 ""#Detect"" ""$cad_file"" 1 0 -0.01 0 0 1 0 1 0
}
*end_batch_import
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1144,*surfaceaddpoint,"Description
Add a fixed point on a surface at the specified coordinates.
","Inputs

surfptr
The ID of the surface.
x,y,z
The coordinates of the point.

","Example
The coordinates must be within tolerance of the surface. If the coordinates are within the
        geometry tolerance of an edge, a surface vertex is created. Otherwise, an interior fixed
        point is added to the surface. 
","Errors
None.
"
1145,*surfaceconefull,"Description
Creates a cone with a specified center and radius, and optionally, prepares it for
        immediate use in the automesher. It also can identify a conical region for the automesher to
        use under the mesh without surface option.
","Inputs

top center
A node specifying the top center of the cone. 
bottom center
A node specifying the bottom center of the cone. 
base radius
The radius of the bottom of the cone. 
top radius
The radius of the top of the cone.
aspect ratio
A value less than 1.0 creates an elliptical cone or cylinder. 
height
Height of the cone. 

","Example
To create a circular cone with the top center at node 1, the bottom center at node 2, a
        base radius of 100, top radius of 0, and a radius of 50, but not create any elements:
*surfacemode (4)
*surfaceconefull(1,2,100.0,0.0,1.0,50.0)
If the top radius and base radius are equal, a cylinder is created. 
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
1146,*surfacecreatedraglinealongline,"Description
This command creates surface(s) by dragging section lines(s) along a drag line. Lines in
        the line list are combined into a single line L, called the drag line. The direction of the
        drag line is determined by choosing its start point, S, as the closest end of the line to
        the section line vertices. 
node_id and refplane arguments are optional and
        determines how the input lines are transformed before drag.
The reconfiguration of the geometries before the drag is done as follows. Let P be the
        point referred by the node_id, N be the normal and B be the base point of
        the refplane and T be the tangent vector of drag line at S. First,
        section lines are translated by the direction vector PB. If Bit3 of the
        options is not set, then, the section lines are rotated by the rotation from vector N to
        vector T. Also, the drag line is translated by the direction vector SB. The drag is applied
        to along this line L. So, if P is selected on a section line, the new location of P is going
        to be at B. Moreover, if P is one of the vertex points of the section lines, one gets an
        exact geometric copy of the drag line at B, no matter which drag method is chosen. This is
        because, prior to drag, P is moved to B and B moves on drag line since it coincides with the
        start point of the drag line L. 
If node_id is not given, it is chosen as the same point as S, the start
        of the drag line. This means, with the default value of node_id, the drag
        line is not transformed.
If the reference plane is not given, their default values are B at P and N=T. This means,
        with the default value of transformation plane, the section lines are not transformed prior
        to drag.
Note that, the location of P is not important if fixed frame method is chosen with no
        transformation plane, since each point on the section surface traces an exact geometric copy
        of the drag line in fixed frame method. 
","Inputs

lines_mark_id 
The mark ID containing the lines that you wish to drag.
lines_list 
The list ID containing the lines that will be used to from the drag line. 
The first line in this list determines the direction of the drag, which is also shown
            to the user on the screen. If the drag line has corners, then the new surfaces are split
            at those locations.
method
Parameter specifying the method of how the drag is performed. Valid options are: 
0 - Fixed frame 
1 - Follow the drag line only along its tangent direction 
2 - Follow the drag line along its Frenet frame
options
Flags that indicate different modes for the drag. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3). 
Bit0
0 - Drag along the direction of the drag line. 
1 - Drag along the opposite direction of the drag line.
Bit1
0 - Do not merge input lines. A surface is created for each input line. 
1 - Merge input lines into smooth lines when possible. A surface is created for
                  each group that forms tangentially continuous lines.
Bit2
0 - Use the ref_plane input. 
1 - Do not use the ref_plane input. Instead, use its default
                  values.
Bit3
0 - Use the whole ref_plane for transformation if it is
                  given. 
1 - Use the only the base point of the reference plane, set the normal as the
                  tangent of the drag line at drag start point.


comp_mode
Parameter specifying how entities are organized into components: 
0 - Surfaces are created in the current component. 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.
?node_id? (optional)
The ID of the node that is used as a reference point while determining how the
            surfaces are transformed prior to drag.
?ref_plane? (optional)
When provided, its value must always be 1. It is used to determine the initial
            reference frame. This plane is created using the *createplane
            command.

","Examples
Assume that you want to drag section-lines with IDs 39, 401 and 388 along the line that is
        formed by combining lines with IDs 37 and 25, using the fixed frame method. Assume that you
        want to drag along the direction opposite to the direction of line 37 and want to merge the
        input section lines into smooth line groups when possible. Moreover, you want the resultant
        surfaces to be organized in the component of the lines. Then, options = 1+2 = 3, and
        comp_mode = 1. If you do not want to use any reference plane, use the following commands to
        create dragged surfaces. As a result one edge of the surfaces will be the input section
        lines, while the opposite edge will be an exact translated copy of that section line, and
        the side edged will be an exact translated copy of the drag-lines broken at possible vertex
        points.
*createmark lines 1 39 401 388 
*createlist lines 1 37 25 
*surfacecreatedraglinealongline 1 1 0 3 1
In addition if you now want to use a reference node with ID 12, which happen to lie on one
        of the section lines, and a reference plane, use:
*createmark lines 1 39 401 388 
*createlist lines 1 37 25
*createplane 1 1.0000 1.0000 1.0000 2678.0 -737.7 548.1 
*surfacecreatedraglinealongline 1 1 0 3 1 12 1 
The surfaces created will be in such a way that the new location of the point on which node
        12 located, will be at the base point (2678.0 -737.7 548.1) of the reference plane.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1147,*surfacecreatespinnodeswithoffsetangle,"Description
Spins a list of nodes to create a surface, and optionally, prepares it for immediate use
        within the automesher. It can also identify a region in the shape of a surface of revolution
        for the automesher to use under the mesh without surface option.
","Inputs

nodelist
The ID of the list of nodes to be spun.
rotplane
The axis about which to spin the lines made from nodes (plane normal is used as axis
            vector and the base point of the plane is used as the rotation center).
start_angle
Degrees value of initial rotation angle: lines made from selected nodes are rotated by
            this value before surface ""sweeping"" begins.
end_angle
Degrees value of final rotation angle: surface ""sweeping"" stops at this value.

","Example
To a line made through nodes 8, 9, 10 and 11 from 45 to 90 degrees about an axis given by
        the vector (1 2 3) with rotation center at point (4 5 6), creating a surface of revolution
        but not creating any elements on it:
*surfacemode 4
*createlist nodes 1 8 9 10 11
*createplane 1 1 2 3 4 5 6
*surfacecreatespinnodeswithoffsetangle 1 1 45 90
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1148,*surfaceintersectmark2,"Description
Creates lines by intersecting surfaces with a plane or other surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to intersect. Valid values are 1 and 2.
plane_flag


0 - Use mark_id2 to define the surfaces to use for the
                intersection. 
1 - Use plane_id to define the plane to use for the
                intersection.


plane_id
The ID of the plane to use for the intersection, if plane_flag is
            1. This is defined using the *createplane command.
mark_id2
The ID of the mark containing the surfaces to use for the intersection, if
              plane_flag is 0. Valid values are 1 and 2.
comp_mode


Parameter specifying how lines are organized into components: 
0 - Lines are created in the current component. 
1 - All created intersection lines will be placed in the original surface
                component(s), splitting the lines where necessary if the surfaces selected are
                connected and in different components.



","Examples
To create intersection lines for the xy-plane with a base node of 0,10,0 with the displayed
        surfaces:
*createmark surfaces 1 displayed
*createplane 1 0 0 1 0 10 0
*surfaceintersectmark2 1 0 1 0
To create intersection lines for the intersection of surfaces 1 and 2 with surfaces 10 and
        11:
*createmark surfaces 1 1 2
*createmark surfaces 2 10 11
*surfaceintersectmark2 1 1 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1149,*surfacemarkaddnodesfixed,"Description
 Add fixed points to a surface at locations specified by nodes. 
","Inputs

surf_mark_id
ID of the mark containing the input surfaces to add fixed points to. Valid values are 1 and 2.
node_mark_id
ID of the mark containing the nodes to use to define the fixed point locations. Valid values are 1 and 2.
tol
Tolerance value used to determine if a node is close enough to a surface.
reserved_1
Reserved parameter, must be set to 0.

","Example
To add fixed points to the surface with ID 12 at positions specified by nodes with IDs 1
        and 2:
*createmark nodes 1 1 2
*createmark surfs 1 12
*surfacemarkaddnodesfixed 1 1 0.1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1150,*surfacemarksplitwithsurface,"Description
 Splits a group of surfaces with another surface 
","Inputs

mark
The ID of the mark containing the surfaces to be split.
surface
The surface used to split the other surfaces.

","Example
To split surfaces 10 and 20 with surface 5:
*createmark(surfaces,1) 10 20
*surfacemarksplitwithsurface(1,5)

","Errors
None.
"
1151,*surfacereversenormals2,"Description
Reverses the normals of surfaces, and optionally any associated FE. 
The minimum set of surfaces to maintain overall normal direction consistency, without
        affecting other surfaces, is automatically adjusted based on the input selection.
","Inputs

entity_type
The type of entity to reverse normals for. Valid values are surfaces, solids and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn, if vector normal display is
            set. If set to zero, the vector is drawn at 10% of the screen size.
adjust_fe
If non zero, normals for elements associated with selected surfaces will be
            automatically adjusted to match the normals of their surfaces.

","Example
 To reverse the normals for surfaces 1-10 along with the associated FE, and to display the
        adjusted element normals with a size of 5.0:
*createmark surfs 1 1-10
*surfacereversenormals2 surfs 1 5.0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1152,*surfacespherefromfournodes,"Description
Creates a sphere which passes through the four specified nodes, and optionally, prepares it
        for immediate use within the automesher. It can also identify a region in the shape of such
        a sphere for the automesher to use under the mesh without surface option.
","Inputs

list
The list of the four nodes through which the surface will pass. 

","Example
To create a sphere which passes through nodes 1, 2, 3, and 4, but not create any elements
        on the sphere: 
*surfacemode(4)
*createlist(nodes,1) 1 2 3 4
*surfacespherefromfournodes(1)
*createlist() is required for this command. The
          *surfacemode(4) directive tells HyperMesh
        not to pass the information on to the automesher for element creation. 
","Errors
None.
"
1153,*surfacesplinefillholes2,"Description
Creates spline surfaces on all loops of selected lines. 
Both topological and free lines can be used for the loop for spline creation.  If lines are
        not connected into a closed loop, it will create connecting lines. If the selected lines are
        topological lines connected to some other surfaces, the tangency of the lines created to
        close the gaps in the loop should match the tangency of the connected surfaces.  The
        tangencies of the created splines match the tangencies of connected surfaces (if any). 
        Created splines are placed into the same components that selected lines belong to.
","Inputs

mark_id
The ID of the mark containing the input lines. Valid values are 1 and 2.
options
If set to 1, the edges of the new surface are suppressed. Otherwise the edges are not
            suppressed.

","Example
To create spline surfaces for lines 1-10, and suppress the edges between the new and
        existing surface:
*createmark lines 1 1-10
*surfacesplinefillholes2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1154,*surfacesplinefrompoints,"Description
Creates a spline surface using selected nodes or points as boundary conditions.
","Inputs

entity_type
The type of entity to use as input. Valid values are nodes and points.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
options
Specifies options for creating the surface. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2)
Bit0
 Surface trim mode
0 - Trim by parametric rectangle. 
1 - Trim by points boundary.


Bit2
Mesh stitching. Used to control the connectivity of the mesh created on the new
                  spline surface in simultaneous meshing modes.
0 - New mesh is not connected. 
1 - If *surfacemode is set to 1, existing mesh nodes are
                      used if new spline edges are stitched to those lines.





","Example
To build a spline from the displayed points and do not connect mesh:
*surfacemode 1
*createmark points 1 ""displayed""
*surfacesplinefrompoints points 1 0
To build a spline from the displayed points and do not connect mesh:
*surfacemode 1
*createmark points 1 ""displayed""
*surfacesplinefrompoints points 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1155,*surfacesplitwithline,"Description
Splits a surface with a line by sweeping the line along a vector. 
","Inputs

surface
The ID of surface to be split. 
line
The ID of the line used to split the surface. 
vector
The vector used to sweep the line.
entire_surf_flag
1 - The line is swept throughout the entire surface.
0 - The line is swept for a distance of distance
distance
The distance to sweep line, if entire_surf_flag is set to 0.

","Example
To split surface 1 by sweeping line 2 along the x-axis for a distance of 100: 
*createvector(3,1.0,0.0,0.0)
*surfacesplitwithline(1,2,3,0,100.0)

","Errors
None.
"
1156,*surfacesplitwithsurface,"Description
Splits one surface with another. 
","Inputs

surface1
The surface to be split
surface2
The surface used to split surface1. 

","Example
To split surface 1 with surface 2: 
*surfacesplitwithsurface(1,2)

","Errors
None.
"
1157,*surfmark_trim_by_surfmark,"Description
Trims surfaces along the intersection(s) with other surfaces.
","Inputs

mark_id1
The ID of the mark containing the selection of surfaces to be trimmed. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the selection of surfaces to use as the trim tool. Valid values are 1 and 2.
mode


0 - Surfaces on mark_id1 are trimmed by the surfaces on
                  mark_id2

1 - Surfaces on both marks trim each other 
2 - Surfaces on mark_id1 are trimmed by virtually extending
                surfaces of mark_id2



","Example
To trim all surfaces on mark 1 by those on mark 2:
*createmark surfs 1 1-100
*createmark surfs 2 101-200
*surfmark_trim_by_surfmark 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1158,*tablecontour,"Description
Contours node/element data from a table.
","Inputs

table_name
The name of the table containing the data to contour.
table_id_column
The title of the column in the table that contains the IDs of the entities to contour. 
If the column is an integer column, the integers are assumed to be element IDs. If the
            column is an entity type column with type element or node, the values are taken as IDs
            of elements or nodes respectively.
table_value_column
The title of the column in the table that contains the values to use for the contour. 
Currently only double or float values are supported.
legend_title
The title to use for the contour legend.

","Example
To create a contour of data in table ""contour_table"", with the column labeled ""IDs"" as the
        ID column, the column labeled ""Values"" as the value column, and a legend title of ""My
        Values"":
*tablecontour contour_table IDs Values ""My Values""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1159,*tabledeletecolumn,"Description
Deletes a column of data from a table.
","Inputs

name
The name of the table to update.
column_index
The index of the column to delete. Tables are indexed starting from 1 (1 to n
            columns). If specified as 0, the last column in the table is deleted.

","Examples
To delete the last column from table1, which has 11 columns:
*tabledeletecolumn table1 0
or
*tabledeletecolumn table1 11
To delete column 3 from table1:
*tabledeletecolumn table1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1160,*tableinsertcolumn,"Description
 Inserts a column of data into a table.
","Inputs

name
The name of the table to update.
data_type
The data type of the column. See *tablecreate for valid
            values.
column_label
The label of the column.
string_array
The ID of the string array that contains the column data to add. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of rows in the
            table.
column_index
The index of the column to insert. Tables are indexed starting from 1 (1 to n
            columns).

","Example
To insert column 4 of type integer and label INTEGERS to ""table1"" which has 7 rows:
*createstringarray 7 1 2 3 4 5 6 7
*tableinsertcolumn ""table1"" int INTEGER 1 7 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1161,*tableupdatecell,"Description
Updates the value of a cell in a table.
","Inputs

name
The name of the table to update.
row_index
The index of the row to edit. Tables are indexed starting from 1 (1 to n rows).
column_index
The index of the column to edit. Tables are indexed starting from 1 (1 to n
            columns).
value
The value to update.

","Example
To update cell (3.4) of table1:
*tableupdatecell table1 3 4 100.2345
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1162,*tableupdatelabels,"Description
 Updates the column labels of a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the column labels to update. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.

","Example
To update the labels for table1 with 3 columns:
*createstringarray 3 ""Name"" ""ID"" ""Thickness""
*tableupdatelabels table1 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1163,*tangentbetweenlines,"Description
 Creates a tangent line between two lines. 
","Inputs

line1 id
The ID of the first line to which the tangent line is to be created.
line2 id
The ID of the second line to which the tangent line is to be created. 
checkpoints
The number of points to check in each line segment for tangency. 
lineselected
The tangent line selected, if more than one exists. 

","Example
To create a tangent between lines 1 and 2: 
*tangentbetweenlines(1,2,10,0)
If more than one tangent line is found, you must select the necessary tangent line. The
        number of this line (based on the order in which the tangents were found) is then used in
        the command string. 
","Errors
None.
"
1164,*time,"Description
 Prints the current time to the command file. 
","Errors
None.
",,
1165,*titlepush,"Description
Pushes a title to the background. 
","Inputs

titlename
The name of the title which should be made current. 

","Errors
None.
",
1166,*toggleincludefromdisplay,"Description
This command un-displays/masks any entities in the specified include file that are
        currently displayed and displays/unmasks any entities in the specified include file that are
        currently hidden. The display of entities not in the specified include is not affected.
","Inputs

id
The ID of the include file. An ID of 0 selects the master file. If not specified,
            should be blank """".
shortname
The shortname of the include file. This value can be blank when id
            is specified. If not specified, should be blank """".

","Examples
To toggle the entities in the include with ID 3:
*toggleincludefromdisplay 3 """"
To toggle the entities in the include with shortname elems.fem:
*toggleincludefromdisplay """" elems.fem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1167,*transformmark,"Description
This command translates a selection of entities along a vector.
","Inputs

entity_type
The type of entity to transform.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
r1c1-r4c4
The 4x4 transformation matrix, in row-column order. This matrix defines the
            reflection, rotation, scaling and translation applied to the entities. 
The scaling is in r1c1(x), r2c2(y), and r3r3(z). 
The translation is in r4c1 (x), r4c2 (y), and r4c3 (z). 
The rotation is in the upper 3x3 matrix. 
The last column is for reflection. 
The steps to use to calculate the matrix are as follows:
Calculate the angle in radians. 
Construct a matrix to translate from the rotation point to (0,0,0). 
Construct a second matrix to handle the actual rotation. 
Multiply matrix(step2) X matrix(step3). 
Construct a third matrix to translate back to the rotation point. 
Multiply matrix(step4) X matrix(step5).



","Example
To rotate all displayed nodes 30 degrees about the x-axis through the point (0,0,0):


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


0
0
0
1




*createmark nodes 1 displayed
*transformmark nodes 1 1 0 0 0 0 0.86603 0.5 0 0 -0.5 0.86603 0 0 0 0 1
To rotate all elements 30 degrees about the x-axis through the point (5,10,6):


1
0
0
0


0
1
0
0


0
0
1
0


-5
-10
6
1




x


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


0
0
0
1




=


1
0
0
0


0
0.86603
0.5
0


0
-0.5
0.86603
0


-5
-5.6603
-10.1962
1




x


1
0
0
0


0
1
0
0


0
0
1
0


5
10
6
1




=


1
0
0
0


0
1
0
0


0
0
1
0


5
10
6
1




*createmark elems 1 all
*transformmark elems 1 1 0 0 0 0 0.86603 0.5 0 0 -0.5 0.86603 0 0 4.3397 -4.1962 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1168,*trim_by_offset_edges,"Description
Offset selected surface edges and trim attached surfaces.
","Inputs

surfs
Selection markmask for the set of surfaces to perform the operation. If zero, all
            surfaces attached to selected lines are trimmed.
lines
Selection markmask for the lines to be offset and used for trimming. If 0, all lines
            on selected surfaces are offset and used for trimming selected surfaces.
offset
Offset distance value.
break_mode
Controls connection of lines connected on convex vertex (see comments). Used together
            with break_angle. 
0 - Connect breaks by the straight segments (default). 
1 - Connect breaks by the arcs. 
2 - Do not connect breaks.
mode
Bitwise operation mode: 
Bit 0
Trim mode
0 - Trim selected surfaces by offset lines.
1 - Do not trim surfaces but create offset lines and put them in the lines
                      selection markmask. 


Bit 1
Shrink mode
0 - Trim surfaces and keep all trimmed pieces
1 - Trim surfaces and remove parts between original and offset lines 




Other Bits are reserved for future use and must be 0.
break_angle
Angle value to control extension of offset edges. Setting to 0.0 corresponds to
            default value of 30 degrees. See comments.

","Example
To create a ""generic washer"" of width 5, select lines on the free loop
          (lines=1) and call
*trim_by_offset_edges (0,1, 5.0, 0, 0, 0.0)
To ""shrink"" surfaces (selected in the surface mark surfs = 1)
*trim_by_offset_edges (1,0, 5.0, 0, 2, 0.0)

For break_angle and break_mode, normal offset of
        lines connected at convex vertex creates a break between line ends. In order to maintain
        connectivity between lines, the ends must be connected. If the vertex angle is larger than
          break_angle, connect ends by extending and intersecting them. If the
        angle is smaller than break_angle, connect ends either by a straight line
          (break_mode = 0) or by a circular arc (break_mode =
        1). 
","Errors
None.
"
1169,*trim_shell_elems_by_shell_elems,"Description
Trim 2D elements with 2D elements along their intersection lines, and remove small
        penetrating parts of elements between the intersection lines and free element edges. If some
        elements get trimmed, the elements along the cutting lines are re-generated.
","Inputs

entity_type
The type of entity taking part in the mesh trimming. Valid values are elems and
            comps.
mark_id
The ID of the mark containing the entities taking part in the mesh trimming. Valid values are 1 and 2.
trimmer_entity_type
The type of entity to use as the trimmer. Valid values are elems and comps. 
If specified, these elements are only used in the intersection calculation and are not
            trimmed themselves. Entities belonging to mark_id, but not
              trimmer_mark_id, may be trimmed, if required. 
If not specified, all entities on mark_id are mutually trimmed as
            required.
trimmer_mark_id.
The ID of the mark containing the entities to use as the trimmer. Valid values are 1 and 2.
param_string.
This string contain keyword/value pairs, separated by whitespace. Valid keywords are:
angle
Defines the mesh feature angle to use. If not specified, a default of 30.0 is
                  used.
break_shell_along_component_boundaries
Input elements are distributed into groups based on their connectivity. Only are
                  different groups taken as counterparts of the intersection calculation.
0 - Do not break element groups at component boundaries (default). 
1 - Break element groups at component boundaries.


min_elem_size_rate
Defines the minimum element size locally. The valid value range is between 0.0
                  and 1.0. 
The minimum element size is calculated locally on the mesh area being re-meshed.
                  The element size is computed for the mesh area and the minimum element size is
                  then the product of this value and the element size of the area. 
If min_elem_size_value is also defined,
                    min_elem_size_value is ignored. If neither
                    min_elem_size_rate nor min_elem_size_value
                  are defined, min_elem_size_rate 0.4 is used.
min_elem_size_value
Defines the minimum element size globally. 
If min_elem_size_rate is also defined,
                    min_elem_size_value is ignored. If neither
                    min_elem_size_rate nor min_elem_size_value
                  are defined, min_elem_size_rate 0.4 is used.
remove_internal_shell


0 - Do not remove internal elements when selected elements form two or more
                      watertight shells. 
1 - Remove internal elements when selected elements form two or more
                      watertight shells (default).


trim_removal_limit
Defines the maximum distance between the intersection lines and free element
                  edges in the isolated parts to be removed. A penetration part consists of a group
                  of connected elements with only intersecting or free edges as boundaries.



","Example
To trim all displayed components with each other, using a maximum trim value of 50.0, along
        with other basic options:
*createmark comps 1 displayed
*createmark comps 2 """"
*trim_shell_elems_by_shell_elems comps 1 comps 2 ""remove_internal_shell 1 min_elem_size_rate 0.4 trim_removal_limit 50.0 
break_shell_along_component_boundaries 0 angle 30.000000""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1170,*unlockentities,"Description
This command removes entity locks for a selection of entities.
","Inputs

entity_type
The type of entity to lock.
mark_id
The ID of the mark containing the entities to unlock. Valid values are 1 and 2.
dataname
The dataname to unlock. Currently only supported for ""id"".

","Example
To unlock the displayed element IDs:
*createmark elems 1 displayed
*unlockentities elems 1 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1171,*unmaskshown,"Description
Unmasks all supported entities in the current view window. For collected entities, only
        entities in displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
 To unmask all supported entities in the displayed collectors that are in the current view
        window:
*unmaskshown
","Errors
None.
",
1172,*unsetparametermark,"Description
Unparameterizes a data name or attribute on a mark of entities.
","Inputs

entity_type
The type of entity to unparameterize.
mark_id
The ID of the mark containing the entities to unparameterize. Valid values are 1 and 2.
data_name_or_attribute
The data name or attribute name/ID to unparameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.

","Example
To unparameterize attribute LSD_DA1 on entity sets 5, 6 and 7:
*createmark sets 1 5 6 7
*unsetparametermark sets 1 LSD_DA1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1173,*untrim_selected_edges,"Description
This command modifies surfaces by removing free edges selected by the user and replacing
        each chain of edges by a new edge that is determined as follows:
In case of ""shortcut"" option, the new straight edge joins the end-points of selected
            edge chain. 
In case of ""extend"" option, the command attempts to finds the intersection of two rays
            along tangents at the edge chain end-points. If such an intersection point exists, the
            new straight edges join the end-points of original edge chains with this intersection
            point. 


The input can include free edges on several surfaces simultaneously, and can include both
        internal and external free edges. The command ignores all non-free edges of the
        selection.
If all edges of an internal or external loop are selected, the command would remove the
        entire loop. In these special cases, the command extends the functionalities of
          *edgesmarkuntrim and *surfacemarkuntrim.
","Inputs

mark_id_lines
The ID of the mark containing the free edges to untrim. Valid values are 1 and 2.
mark_id_surfs
Reserved for future use.
untrim_option
Specifies how the new edges be constructed: 
0 - Use the shortcut option 
1 - Use the extend option
keep_vertices
0 - Vertices at the ends of the selected edge chains might be removed if necessary
            (based on the value of the user-specified ""geom. feature angle"")
1 - Vertices at the ends of the selected edge chains will be preserved
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To untrim the red edges with ID 36800-36802 via shortcut option and to preserve the
        vertices at the ends of the selected edge chains:
*createmark lines 2 36800 36801 36802
*createmark surfaces 2
*untrim_selected_edges 2 2 0 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1174,*updatefeatures,"Description
This command specifies for element remesh with feature edges, if 1D elements selected as
        features are also refined. 
Use of this command implies that it will be followed by a command that performs
        remeshing/meshing by elements with redo option selected.
","Inputs

flag
0 - 1D elements selected as feature edges are not refined (default). 
1 - 1D elements selected as feature edges are refined. New 1D elements, connected to a
            new mesh, will be created

","Example
To remesh elements 1-40 with element size 10 using 1D elements with IDs 100-110 as feature
        edges and create along these feature edges new, connected to created mesh, 1D elements with
        same properties:
*createmark elems 1 100-110
*elementsaddelemsfixed 1
*updatefeatures 1
*setusefeatures 1
*createmark elems 2 1-40
*defaultremeshelems 2 10.0 2 2 1 1 1 1 0 0 0 0 2 30
*setusefeatures 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1175,*updateinclude,"Description
Updates include file basic information.
","Inputs

id
The ID of the include file to update. If 0, the shortname is used
            instead.
shortname_flag
0 - Do not update the file short name 
1 - Update the file short name
shortname
The new short name if shortname_flag is 1, or the short name to use
            to select the file if id is 0.
fullname_flag
0 - Do not update the file full name 
1 - Update the file full name
fullname
The new full name if fullname_flag is 1.
parentid_flag
0 - Do not update the parent ID 
1 - Update the parent ID
parent_id
The new parent ID if parentid_flag is 1.

","Example
To change the include file with ID 1, stored as
          C:/common_files/mats/mat1.dyn from mat1.dyn to
          mat2.dyn and change its parent from the master file to a file with ID
        3:
*updateinclude 1 1 mat2.dyn 1 C:/common_files/mats/mat2.dyn 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1176,*vectorplot,"Description
Creates a vector plot from results data. The results file must be loaded before executing
        this command. The *freesimulation command clears the plot.
","Inputs

title
The title to use for the plot.
vector_size
The size of the vectors. If constant_size is set to 0, this defines
            a scale factor for the vectors. If constant_size is set to 1, this
            defines the size in model units
mesh_color
The color used to plot the mesh. Valid values are 1 through 64. 
-1 - Uses the elements color. 
0 - Uses the background color.


full_size
Determines whether the contour plot fills the entire screen. Valid values are: 
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return.
constant_size
Set to 1 to plot all vectors with a constant length, otherwise set to 0.

","Example
To load the result file named C:/my_results/test.res and generate a
        vector plot for Subcase 1 with Displacements data type, a vector model size of 2.5, a mesh
        color of black, and normal plot size:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*vectorplot """" 2.5 0 0 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1177,*verticescombine,"Description
Given one surface fixed point to retain, and one or more additional fixed points, combines
        all of the points into the first point. Some surface edges or entire surfaces may be deleted
        in the process. 
","Inputs

retained_point
The ID of the point to keep.
mark
The ID of the mark containing the points that are to be adjusted.

","Example
To combine points 7, 8, and 9 into point 21:
*createmark(points,2) 7 8 9
*verticescombine(21,2)
Typically, the points to be combined must be very close to each other.
","Errors
None.
"
1178,*verticesrelease,"Description
This command is applied to a selection of points given by the points mark. All selected
        fixed points are released.  All the suppressed (blue), shared (green), and nonmanifold
        (yellow) edges that share fixed points are released, generating free (red) edges.
","Inputs

markmask
Selection markmask for points to be released (1 or 2).

","Example
*verticesrelease (1)
Unstitches selected vertices selected by markmask 1.  
","Errors
The command returns error code for no points selected.
"
1179,*walldisplay,"Description
Displays a wall. 
","Inputs

blockname
The name of the block which contains the wall. 
function
The function to be performed. 
wallname
The name of the wall.  

","Errors
None.
",
1180,*window,"Description
Modifies the current window.
","Inputs

function
Defines the function being performed: 
0 - The window is redefined so that all of the current model is inside the
                window. All of the other parameters are ignored. 
1 - The window is recalculated. All of the other parameters are ignored. This
                function is only used internally.
2 - Zooming is performed on the current window based on the value passed in xmin.
                If xmin is positive, the current window is multiplied by xmin,
                and the result is zooming in. If xmin is negative, the current
                window is divided by xmin, and the result is zooming out. This is defined each time
                the + and - zooming options are used.
3 - The window is set to the values passed in xmin,
                  ymin, xmax, and ymax. The
                parameters are specified in model units. This is defined each time the z zooming
                option is used. 
4 - The window is centered at the point specified by xmin and
                  ymin. The parameters are specified in model units. This is
                defined each time the c paning option is used.


xmin
The minimum x value of the window.
ymin
The minimum y value of the window.
xmax
The maximum x value of the window. 
ymax
The maximum y value of the window. 

","Errors
None.
",
1181,*writequalitysummary,"Description
Collects a summary of the mesh quality, including details such as the number of quads which
        fail the Jacobian test or trias with angles exceeding the acceptable number, and writes the
        results to a formatted text file.
","Errors
None.
",,
1182,*xyplotcoloroverride,"Description
Sets the override color for xy plots. 
","Inputs

color 
Set to the color which should be used to plot all of the xy plot information on the
            screen (1-15). 

","Example
If the color is set with this command, all of the entities on an xy plot are plotted in
        that color. If color is set to zero, then the color of each of the entities on the xy plot
        is used. 
","Errors
None.
"
1183,*xyplotcurvemodify,"Description
Modifies a curve. 
","Inputs

curve name
The name of the curve being modified. 
item name
The name of the item of data being modified. 
string
The string value of the item. 
value
The value of the item. 
plot
A logical which determines if the current xy plot should be replotted when the change
            is made to the curve

","Errors
None.
",
1184,*xyplotfindcurves,"Description
Resizes the xy plot window so that the curves on the xy plot are fully visible. 
","Inputs

plot name
The name of the plot to be modified. 

","Errors
None.
",
1185,*xyplotorganize,"Description
Organizes the active plots so that they are fully visible on the screen. 
","Errors
None.
",,
1186,*xyplotpop,"Description
Pops an xy plot to the top level. 
","Inputs

plot name
The name of the plot to be popped. 

","Errors
None.
",
1187,*xyplotreadcurve,"Description
Reads a curve(s) from an ASCII file. 
","Inputs

filename 
The name of the file which contains the curve data.

","Errors
None.
",
1188,*xyplotsetcurrent,"Description
Sets the current xy plot 
","Inputs

plot name
 The name of the plot to be made current. 

","Errors
None.
",
1189,*xyplotstack,"Description
Stacks the active xy plots. 
","Errors
None.
",,
1190,*xyplotzoomout,"Description
Modifies the window of an xy plot by zooming out (reducing the size of the curves). 
","Inputs

plot name
The name of the plot to be modified. 

","Errors
None.
",
1191,*absorbbeamsections,"Description
This command creates/compares beam sections with 1D property values as per the options
        provided.  Currently valid only for OptiStruct and Nastran profiles.
","
Inputs


<select_type>=<selection>
The properties to be modified. There are several ways to provide the entities to be
            modified. Only one option can be used at a time.  If not specified, all properties in
            the model are considered:
id=<id>
The ID of the single entity to modify.
mark=<mark_id>
The ID of the mark containing the entities to modify.


deleteunused=<value>
0 - Preserves the beam sections not referenced in any entity.
1 - Deletes the beam sections not referenced in any entity (default).
option=<value>
0 - Create new beam sections if there are not beam sections attached to the 1D
            properties (default).
1 - If the beam section is attached to the 1D property, it will compare the beam
            section values and property values. If there is a mismatch in values, it will create a
            new beam section honoring the values on the property.
2 - Creates new beam sections even if beam sections are attached to the 1D property,
            by honoring the values on the property.
tolerance=<value>
Valid for option=1 to compare the beam section values and property values with the
            user defined tolerance value. Default value is 0.01.

","Examples
Create beam sections for all the 1D properties in the model which don’t have beam
        section:*absorbbeamsections
or *absorbbeamsections option=0
or *createmark props 1 all
*absorbbeamsections mark=1
or *createmark props 1 all
*absorbbeamsections mark=1 option=0
Compare the beam section and property values for property ID 1 with a default relative
        tolerance of 0.01:*absorbbeamsections id=1 option=1
Compare the beam section and property values for property ID 1 with a relative tolerance of
        0.05:*absorbbeamsections id=1 tolerance=0.05
Overwrite the beam section referred in property ID
        1:*absorbbeamsections id=1 option=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1192,*absorbloads,"Description
Absorb classical loads to engineering loads.
","
Inputs


entity_type
The type of entity to absorb.  Valid values are loads and loadcols.  If specified as
            0, all loads in all load collectors are absorbed and mark_id is
            ignored.
mark_id
The ID of the mark of entities to absorb. Valid values are 1 and 2.
disable_value_comparison
Optional argument specifiying whether value comparison is disabled.  Value comparison
            determines if a given non-uniform load can manifest in a uniform representation.  Valid
            values are:
0 - Value comparison is enabled (default)
1 - Value comparison is disabled
renumber_flag
Option to renumber after absorb:
0 - Do not renumber (default)
1 - Renumber
compression_status
Option to honor the compression status (e.g. certain loads may be on a set or on the
            actual entitiy, and this state may be honored or expanded).  Valid values are:
0 - Do not honor source state (default)
1 - Honor source state

","Examples
Absorb and renumber all loads in the model:*absorbloads 0 0 0 1
Absorb all loads in load collector
        5:*createmark loadcols 1 ""by id"" 5
*absorbloads loadcols 1
Absorb all loads in the model and honor the compression
        state:*absorbloads 0 0 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1193,*acm_create_mpc,"Description
This command creates MPCs between selected master and slave elements. It is extracted as a
        standalone functionality from the acoustic cavity mesher.
","Inputs

master_mark_id
The ID of the mark containing elements belonging to the master body. Valid values are 1 and 2.
slave_mark_id
The ID of the mark containing elements belonging to the slave body. Valid values are 1 and 2.
interface_mark_id
The ID of the mark containing components that define patched holes. Valid values are 1 and 2.
tolerance
The maximum search distance to use for finding independent nodes for each dependent
            node.
behavior
MPC creation.
0 - By proximity only.
1 - By proximity and by intersection check with patched holes. Creates only those
                MPCs which intersect patched hole components. 
2 - By proximity and by intersection check with patched holes. Creates only those
                MPCs which do not intersect patched hole components.



","Examples
To produce MPCs between master elems in component 813, slave elements in comp 816, and
        patch elements in component 812, using a tolerance of 50.0 and creating MPCs using behavior
        2:
*createmark elems 1 ""by comp id"" 813
*createmark elems 2 ""by comp id"" 816
*createmark comps 1 812
*acm_create_mpc 1 2 1 50.0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1194,*acousticmeshend,"Example
To finalize an acoustic mesh process:
*acousticmeshend
",,,
1195,*acousticmeshinterface,"Description
Used to query the results of an acoustic cavity mesh operation. This command must be run
        after *acousticmeshcreate. It specifically utilizes a bounding box
        defined by the acmodl_normal, acmodl_intol, and
          acmodl_dskneps input parameters to identify:
The wetted nodes on the body: nodes on elements on the interface with the fluid that
            satisfy the bounding box criteria.
The interface nodes of the fluid: the nodes on the fluid faces that are on faces that
            have at least one body node within their bounding box. 
The wetted element faces of the body: the elements on the body that contain at least
            one node within a bounding box.
The interface faces of the fluid: the fluid faces that have at least one body node
            within their bounding box. 
The wetted body components: the components that contain at least one element on the
            body that has a node on the wetted interface.


It should be noted that the body is composed of the structural and the seat components.
","Inputs

mark_id
The ID of the mark containing the acoustic cavity components for which the faces are
            considered for building the bounding boxes. Valid values are 1 and 2.. 
If set to 0, then the faces of all cavities are considered.
wetted_node_output_mark_id
The ID of the mark containing the found wetted body nodes. Valid values are 1 and 2.. 
If set to 0, the values are not returned.
interface_node_output_mark_id
The ID of the mark containing the found fluid interface nodes. Valid values are 1 and 2.. 
If set to 0, the values are not returned.
wetted_element_output_mark_id
The ID of the mark containing the found wetted body element faces. Valid values are 1 and 2.. 
If set to 0, the values are not returned.
interface_element_output_mark_id
The ID of the mark containing the found fluid interface element faces. Valid values
            are 1 and 2, if the createcavityfaces option was enabled for
              *acousticmeshcreate. 
If set to 0, the values are not returned.
wetted_component_output_mark_id
The ID of the mark containing the found wetted body components. Valid values are 1 and 2.. 
If set to 0, the values are not returned.
acmodl_normal
Used to define the (positive) height of bounding box for particular fluid faces. This
            height is equal to the largest side of the face multiplied by this value, and is in the
            outward direction.
acmodl_intol
Used to define the (negative) height of the bounding box for particular fluid faces.
            This height is equal to the largest side of the face multiplied by this value, and is in
            the inward direction.
acmodl_dskneps
Used to define the in-plane extension of the bounding box for particular fluid faces.
            This extension is measured relative to the distance from the center of the face to each
            corner. This value is the ratio by which the face is extended at each corner.
reserved1
Reserved for future use. Must be specified as 0.
reserved2
Reserved for future use. Must be specified as 0.

","Examples
Calculate, and then highlight, the wetted nodes, wetted elements and wetted components for
        two structural and seat cavities:
*createmark components 1  ""AC_Structural.1"" ""AC_Seat.1"" ""AC_Seat.2"" ""AC_Structural.2""
*acousticmeshinterface 1 1 0 1 0 2 0.4 0.2 0.2 0 0
hm_highlightmark nodes 1 h
hm_highlightmark nodes 1 n
hm_highlightmark elems 1 h
hm_highlightmark elems 1 n
hm_highlightmark comps 2 h
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1196,*activatetransformations,"Description
Apply or unapply all the transformations in the model.
","
Inputs



mark_id

The ID of the mark containing all transformations in the model.

flag

0 - Unapply
1 - Apply

","Examples
To apply all the transformations in the model:
*createmark positions 1 all
*activatetransformations 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1197,*adaptive_wrapper_build,"Description
This command builds the skeletal octree structure for the adaptive wrap mesher. It performs
        proximity checks, refines the octree based on various input parameters, and also identifies
        gaps/holes and patches them.
This command must be called between *adaptive_wrapper_init and
          *adaptive_wrapper_end. 
It uses input defined by *adaptive_wrapper_set_features,
          *adaptive_wrapper_set_params and
          *adaptive_wrapper_proximity_params.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1198,*adaptive_wrapper_init,"Description
This command specifies the base mesh which need to be wrapped, along with the type of wrap.
        Base mesh self intersections can be resolved. 
This command must be called before *adaptive_wapper_build and must be
        followed by *adaptive_wrapper_end.
","Inputs

entity_type
The type of entities used for adaptive wrap mesh. On this base mesh wrapping will be
            performed. Currently only supported for elems.
mark_id
The mark ID containing base mesh. Valid values are 1 and 2.
clean_intersection
0 - Do not generate intersection lines and remesh base mesh using these intersection
            lines. 
1 - Generate intersection lines and remesh base mesh using these intersection
            lines.
wrap_type
0 - Exterior wrap 
1 - Cavity wrap

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1199,*adaptive_wrapper_leak_check_mc,"Description
Check leakage and generate 1Ds for the leak path for an adaptive wrap mesh control.
","Inputs

mc_mark_id
The ID of the mark containing the adaptive wrap mesh controls. Valid values are 1 and 2.
entity_type
In case the mesh controls do not have a base entity selection, then comps and elems
            must be assigned separately.
mark_id
The ID of the mark containing any base entity selections. Valid values are 1 and 2.

","Examples
To perform a leak check on mesh control 2 by specifying components 20 and 21 as input:
*createmark meshcontrols 1 1
*createmark comps 1 20 21
*adaptive_wrapper_leak_check_mc 1 comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1200,*adaptive_wrapper_mesh_mc,"Description
Creates the mesh for selected adaptive wrap mesh controls.
","Inputs

mc_mark_id
The ID of the mark containing the adaptive wrap mesh controls. Valid values are 1 and 2.
entity_type
In case the mesh controls do not have a base entity selection, then comps and elems
            must be assigned separately.
mark_id
The ID of the mark containing any base entity selections. Valid values are 1 and 2.

","Examples
To create the mesh for mesh control 2 by specifying components 20 and 21 as input:
*createmark meshcontrols 1 1
*createmark comps 1 20 21
*adaptive_wrapper_mesh_mc 1 comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1201,*adaptive_wrapper_preview,"Description
In case of a cavity mesh, this command can be used to preview cavities which are detected
        by the adaptive wrap mesher. For each cavity, a unique component is created which holds the
        shell elements defining the cavity.
This command must be called after *adaptive_wapper_build.
","Inputs

num_cavities (optional)
The number of largest cavities to display. 
If 0 or not defined, then display all cavities.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

#Build skeletal octree structure
*adaptive_wrapper_build

#Preview all cavities
*adaptive_wrapper_preview

#Clear the preview
*adaptive_wrapper_preview_clear

#Generate Mesh 
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0  1 2 

#End of wrapper mesh
*adaptive_wrapper_end

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1202,*adaptive_wrapper_preview_reject,"Description
Rejects the mesh generated by *adaptive_wrapper_preview and the
        preparation generated by all *adaptive_wrapper_* commands.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

#Build skeletal octree structure
*adaptive_wrapper_build

#Preview all cavities
*adaptive_wrapper_preview

#Reject preview
*adaptive_wrapper_preview_reject

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1203,*adaptive_wrapper_reject_clear,"Description
Clears the reject buffer for all *adaptive_wrapper_* commands.
","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

#Build skeletal octree structure
*adaptive_wrapper_build

#Preview all cavities
*adaptive_wrapper_preview

#Generate Mesh 
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0  1 2 

#Clear the reject
*adaptive_wrapper_reject_clear

#End of wrapper mesh
*adaptive_wrapper_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1204,*adaptive_wrapper_set_params,"Description
Assigns meshing parameters to the adaptive wrapper mesher. Controls include refinement box,
        refinement options, hole patch, gap patch, leak check, min and max element size, etc. 
This command must be called after *adaptive_wrapper_init and before
          *adaptive_wrapper_build.
","Inputs

max_elem_size
The maximum element size for adaptive wrap meshing.
min_elem_size
The minimum element size for adaptive wrap meshing.
string_array
The ID of the string array that contains the proximity control parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each string should be contained in quotes and contain one of the following parameters
            as keywords followed by the parameters values. Keywords and the corresponding values can
            be separated by a semicolon. Each keyword can be used multiple times to define different groups.
GapPatchTolerance: <tolerance> (optional)
The gap patch tolerance value.
HolePatchTolerance: <tolerance>  (optional)
The hole patch tolerance value.
LeakCheckNodes: <node IDs>... 
Seed node IDs to use for leak checking. These nodes should not be part of the
                  base mesh.
RefineByAllElemSize: <option> 
0: Do not refine the wrap mesh based on average element size. 
1: Refine the wrap mesh based on average element size.
RefineByBoxCompIds: <comp IDs>... 
Specify a refined wrap mesh with the specified size for the specified box. The
                  box definition is given by a list of comp IDs. The component name should be
                    ^elem_size_ctrl_<idx>_<elem_size>, where
                    <idx> is part of the component name and
                    <elem_size> is the size to be assigned to the box.
RefineByFeatureProximity: <option> 
0 - Do not refine the wrap mesh based on proximity of features. 
1 - Refine the wrap mesh based on proximity of features.
RefineByNodeCurvature: <option> 
0 - Do not refine the wrap mesh based on node curvature. 
1 - Refine the wrap mesh based on node curvature.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
#Initialization of wrapper mesh with base mesh
*createmark elements 1 ""all""
*adaptive_wrapper_init elements 1 1 0

# Define features
*clearmark elements 1 
*adaptive_wrapper_set_features 1 1 30 1 1

#Set various meshing and refinement parameters
*createstringarray 7 ""LeakCheckNodes: 20 24 19"" ""GapPatchTolerance: 3.0"" ""HolePatchTolerance: 10.0"" ""RefineByBoxCompIds: 4 5 6"" ""RefineByNodeCurvature: 1"" ""RefineByFeatureProximity: 0"" ""RefineByAllElemSize: 1""
*adaptive_wrapper_set_params 10 0.1 1 7

#Proximity options
eval *createstringarray 3 ""WithinGroup: 0.5 1 3 10 12 13"" ""WithinGroup: 1.5 3 9 20"" ""AcrossGroup: 0.5 3 10 12 13 4 9 8 7 19""
*adaptive_wrapper_proximity_params 1 0.2 1 3

#Build skeletal octree structure
*adaptive_wrapper_build

#Generate mesh
*createstringarray 2  ""DoRemesh: 1"" ""RemeshGrowthRate: 1.2""
*adaptive_wrapper_mesh 0 1 2

#End of wrapper mesh
*adaptive_wrapper_end

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1205,*add_remove_distance_manipulator,"Description
Adds or removes distance (dimension) manipulators between two surface vertices. The
        manipulators are displayed upon entering the Dimensioning panel.
","Inputs

mode
The mode to use: 
0 - Remove the distance manipulator between the two points.
1 - Add a distance manipulator between the two points. 
2 - Remove all distance manipulators.


point_id1
The first vertex point ID. Only used when mode is 0 or 1.
point_id2
The second vertex point ID. Only used when mode is 0 or 1.
lock_turnover
Specifies the end point lock controls which determine which manipulator side surfaces
            are selected automatically and what end(s) are movable. The value specified overwrites
            the area_selection_ratio constraint but cannot overwrite the
              max_pick_angle constraint. If the latter constraint does not allow
            the sides (point_id1 and point_id2) to move, or
            allows only one side to move, only the allowed side will move, regardless of this
            parameter. 
Bit values are used and the value is calculated as (Bit0 + 2*Bit1 +
              4*Bit2).
Bit0
0 - The point with the smaller ID cannot move during offset. Only valid when
                    Bit2 is set to 1. 
1 - The point with the smaller ID can move during offset. Only valid when
                    Bit2 is set to 1.
Bit1
0 - The point with the larger ID cannot move during offset. Only valid when
                    Bit2 is set to 1. 
1 - The point with the larger ID can move during offset. Only valid when
                    Bit2 is set to 1.
Bit2
0 - Do not edit the lock controls and ignore Bit0 and
                    Bit1. 
1 - Edit the lock controls based on Bit0 and
                    Bit1 values.


reserved
Reserved for future use. Must be specified as 0.

","Examples
To add a distance manipulator between vertices 100 and 101:
*add_remove_distance_manipulator 1 100 101 7 0
To remove a distance manipulator between vertices 100 and 101:
*add_remove_distance_manipulator 0 100 101 0 0
To remove all distance manipulators:
*add_remove_distance_manipulator 2 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1206,*addfacestocontactsurf,"Description
Adds elements using the face/edge option to a contact surface.
","Inputs

name
The name of the contact surface to update.
elem_mark_id
The mark ID that contains the elements to add. Valid values are 1 and 2.
node_mark_id
The mark ID that contains the nodes that define an edge or a face of an element. Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
Create contact surface.
0 - Along element normal.
1: Opposite element normal.


face_or_edge
Create contact surface.
0 - On edge.
1 - On face.



","Examples
To add elements 1-100 with faces defined by nodes 1-5 to contactsurf
          ""test"" with a break_angle of 30.0:
*createmark elems 1 1-100
*createmark nodes 1 1-5
*addfacestocontactsurf ""test"" 1 1 30.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1207,*addicconnectivity,"Description
Updates the connectivity of an IC element.
","Inputs

id
The ID of the IC element to update.
inode_id
The independent node ID.
dependency_array
The 2D integer array ID created by *createintarray2d. Each row
            contains a dependent node ID and its associated DOF.
nrows
The number of rows in dependency_array. Must always be set to
            2.
ncols
The number of columns in dependency_array.

","Examples
Create an IC element and update the independent node to 15, and dependent nodes to 16, 17,
        18, and 19 with DOF’s 123, 345, 1234, and 123456:
*icelementcreate
*createintarray2d 2 4 16 17 18 19 123 345 1234 123456
*addicconnectivity 1 15 1 2 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1208,*addnewmodel,"Description
Used by multiple models to add a new secondary model.  A new file can be loaded in this
        newly created secondary database.
","
Inputs



name

The unique name of the new model to add.

read_only

Optional argument that says whether the new model is read only (1) or editable (0,
            default).

","Examples
To add a new secondary model named model-2:
*addnewmodel model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1209,*addtransformation,"Description
Adds transformations to positions.
Alternatively, *setvalue can be used.
","
Inputs



mark_id1

The ID of the mark containing the position entities to which the transformations in
              mark_id2 must be added to.

mark_id2

The ID of the mark containing the transformation entities to be added.

","Examples
To add all the transformations to all the positions:
*createmark positions 1 all
*createmark transformations 1 all
*addtransformation 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1210,*adjustgroupsnormal,"Description
Adjusts a group normal using an orientation element.
","Inputs

name
The name of the group entity to adjust.
master_slave_flag
0 - Use slave
1 - Use master
mark_id1
The ID of the mark of elements to adjust, when flag is 1. Valid values are 1 and 2.
elem_flag
Flag for reversing the contact normal of all or individual elements of the group.
0 - All elements, mark_id is ignored
1 - Individual elements, mark_id is used.
orientation_element
The ID of the shell element that should be used for shell group normal correction on
            shell face. This element should be part of the selection.
reverse_normal
0 - Correct group normal along the direction of orientation_element
            normal (default)
1 - Correct group normal opposite to the direction of
              orientation_element normal

","Examples
To reverse the normal of all master elements of the group ""test"":
*adjustgroupsnormal ""test"" 1 1 0 0 0
To reverse the normal of all slave elements of the group
        ""test"":*adjustgroupsnormal ""test"" 0 1 0 0 0
To adjust the normal of group ""test"" for the elements on mark 1 in the normal direction of
        reference element id
        23:*createmark elems 1 12 29 53 23
*adjustgroupsnormal ""test"" 1 1 1 23 0
To adjust the normal of group ""test"" for the elements on mark 1 in the reverse normal
        direction of reference element id
        23:*createmark elems 1 12 29 53 23
*adjustgroupsnormal ""test"" 1 1 1 23 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1211,*adjustnodes,"Description
Fixes the penetrations by moving only the failed nodes.
","Inputs

mark
The mark of the entity to be modified.
reduction
The average thickness reduction.
scale
The thickness scale factor.
segment
The segment orientation option.
magnitude_mode
Determines if a magnitude percentage or a uniform size is to be used.
1 - Magnitude percentage.
0 - Uniform size.



","Examples
To move the failed nodes. *createmark() and
          *templatefileset() are required.
*createmark(groups, 1) ""E2E""
*adjustnodes(1,0,1,1,1)
",
1212,*admascreatemultentselectwithsets,"Description
Creates mass elements with the option to create the mass on the independent entities or to
        create a set out of those entities and attach the set to the element mass created.
","Inputs

entity_type
The type of entity containing the nodes which the mass element will be created with.
            Valid entity types are comps, mats, blocks, assems, props, sets and nodes.
mark_id
The mark ID containing the entity_type entities. Valid values are 1 and 2.
additional_node_mark_id
The mark ID containing any additional nodes. Valid values are 1 and 2.
For now this option is ignored.
vis_node_id
The visualization node ID.
type
The mass solver type. This depends on the current template.
magnitude
The magnitude of the mass.
attach_sets_flag
Indicates whether to create the mass on the independent selected entities or to create
            a set out of those entities and create the mass on the set. 
0 - Do not create set.
1 - Create set.



","Examples
To create a mass element using components 1 through 3 as a set, visualization node 50,
        solver type 3 and magnitude of 5.5:
*createmark comps 1 1-3
*admascreatemultentselectwithsets comps 1 0 50 3 5.5 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1213,*AE_AttachmentControlConvert,"Description
Convert an existing attachment control to a different config.
","
Inputs


name
The name of the attachment control to update.
config
The new config:
1 - Rigid spider
2 - Rigid patch

","Examples
Update the rigid_attachment attachment control to a rigid patch:
*AE_AttachmentControlConvert ""rigid_attachment"" 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1214,*AE_AttachmentControlCreateFromDefault,"Description
Creates an attachment control that can be used for attachment realizations and saved to the
        binary file.
Must be called after *AE_AttachmentControlDefaultCreate.
","
Inputs


name
The name of the new attachment control.
default
The internal control default to derive from:
rigidpatch
rigidspiler
reserved
Reserved for future use.  Must be set to 1.

","Examples
Create an attachment control named ""myattachmentcontrol"", derived from the rigid spider
        default:
*AE_AttachmentControlDefaultCreate """" 1
*AE_AttachmentControlCreateFromDefault ""myattachmentcontrol"" ""rigidspider"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1215,*AE_AttachmentCreateWithOptions,"Description
Creates attachments with options.
","
Inputs


target_entity_type
The target entity type to consider for adding attachments.  Valid values are parts and
            comps.
target_mark_id
The ID of the mark containing the target entities.  Valid values are 1 and 2.
location_entity_type
The location entity type to use for determining the attachment location (one
            attachment per location).  Valid values are nodes.  This is optional if doing a hole
            search.
location_mark_id
The ID of the mark containing the location entities.  Valid values are 1 and 2.
search_type
Hole - If nodes are passed in via location_mark_id, attempt to find
            a single hole per node.  If no nodes are passed, create an attachment for each hole
            found on entities in target_mark_id.
Node - Create a special node attachment on the nodes pass in via
              location_mark_id
string_array
The ID of the array created using *createstringarray, which
            contains the additional input strings.  Must be set to 1.  Valid strings are:
attachmentcontrol=<id>
The ID of the attachment control to use for realization.
maxdiameter=<value>
The maximum hole diameter to find.
mindiameter=<value>
The minimum hole diameter to find.
tolerance=<value>
The tolerance used for hole searches and projections.


number_of_strings
The number of strings in string_array.

","Examples
Create an attachment for each location entity (nodes 266 and 380), looking for the nearest
        hole on Part1 or Part2 for each node:
*createmark modules 1 ""Part1"" ""Part2""
*createmark nodes 1 266 380
*createstringarray 4 ""mindiameter=5"" ""maxdiameter=25"" ""tolerance=25"" ""attachmentcontrol=1""
*AE_AttachmentCreateWithOptions modules 1 nodes 1 ""Hole"" 1 4
Create attachments for each hole on 3 different parts, specifying an attachment control be
        created:
*createmark modules 1 ""Part1"" ""Part2"" ""Part3""
*createstringarray 4 ""mindiameter=5"" ""maxdiameter=25"" ""tolerance=25"" ""attachmentcontrol=1""
*AE_AttachmentCreateWithOptions modules 1 nodes 0 ""Hole"" 1 4
Create two node attachments (nodes 221 and 365), referencing specific nodes with no other
        realization:
*createmark nodes 1 221 365
*AE_AttachmentCreateWithOptions modules 0 nodes 1 ""Node"" 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1216,*AE_Realize,"Description
Realize attachments.
","
Inputs


mark_id
The ID of the mark of attachments to realize.  Vaild values are 1 and 2.
options
0 - Reacquire hole info while keeping any previous part/comp info
1 - Reacquire hole, part, and comp info (helpful after a part swap)

","Examples
Realize all attachments in the model:
*createmark attachments 1 all
*AE_Realize 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1217,*align1delemsbysystem,"Description
Aligns 1D elements with respect to global or local system.
Options can be provided in any order.
","
Inputs



mark=<mark_id>

The ID of the mark containing the input elements.  Valid values are 1 and 2.

align=<mark_id>

The axis of the system with respect to which the elements will be aligned. Valid
            values are:
x, r - X axis
y, t - Y axis
z, p - Z axis
xy, rt - XY axis
yz, tp - YZ axis
xz, rp - XZ axis
all, xyz, rtz, rtp - All axes
vec - Uses vector components to define the alignment

angle=<value>

The angular tolerance while aligning elements with respect to the axis of the input
            system.

angledeviation=<value>

The angular tolerance to consider a particular axis for aligning.

dimension=<value>

The dimension of the elements to consider. Valid value is 1D.

system=<id>

The reference system ID. For global system, it will be 0.

vectorx=<value>


xcomp=<value>

The x component of the vector when align=vec.

vectory=<value>


ycomp=<value>

The y component of the vector when align=vec.

vectorz=<value>


zcomp=<value>

The z component of the vector when align=vec.

","Examples
Align selected 1D elements with respect to local system with ID 1, along all its axes:
*createmark elements 1 1 2 3 4
*align1delemsbysystem mark=1 dimension=1D system=1 angle=15 align=xyz
Align selected 1D elements using vector components (1,0,0):
*createmark elements 1 1 2 3 4
*align1delemsbysystem mark=1 dimension=1D angledeviation=15 align=vec xcomp=1 ycomp=0 zcomp=0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1218,*alignnode2,"Description
Aligns a node along the imaginary line between two other nodes, using a ratio
        coefficient.
","Inputs

end_node1
The first end node ID.
end_node2
The second end node ID.
node
The node ID to align.
ratio
The ratio that determines the alignment of node between end_node1
            and end_node2. 
0.5  - Aligns node in the middle and behaves exactly as
                  *alignnode.
0  - Aligns node at the same location as end_node1.
1 - Aligns node at the same location as end_node2. 
Other values are linearly interpolated in between.



","Examples
To align node 100 between nodes 200 and 300 using a ratio of 0.25:
*alignnode2 200 300 100 0.25
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1219,*aligntoedges,"Description
This command attempts to move nodes near edges to align them with the geometry of the edge.
        It further takes arguments that control the quality of the resulting mesh so that quality
        does not become too bad. When it cannot move nodes to an entire edge, it then attempts to
        move nodes to end vertices of that edge, performing smoothing where necessary on elements
        around those nodes. The command requires that quality criteria have been set already.
","Inputs


line_mark_id
The ID of the mark containing the lines to which to align FE edges to. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the node to align to lines. Valid values are 1 and 2.
After successful movement, this mark will be repopulated to contain nodes moved
              during the alignment.
string_array
The ID of the string array that contains the additional input parameters. The string
              array is created using the *createstringarray command. This should
              always be set to 1.
These are optional parameters that control the quality of the mesh around the edges.
              They are provided as name value params in the format ""param_name:param_value"".
The following parameters are supported:
FailureCountTolerance
The percentage local failure count tolerance at each edge to which nodes are
                    being moved to. If the failure count of elements around the nodes being moved
                    increases beyond this percent of the neighboring element count, the node
                    movement will be rolled back. The default value is 0.1.
FailureIndexTolerance
The percentage local failure quality index tolerance at each edge to which
                    nodes are being moved to. If the failure quality index of elements around the
                    nodes being moved increases beyond this percent of the previous quality index of
                    elements around these nodes, the node movement will be rolled back. The default
                    value is 0.05.
GlobalFailureCountTolerance
The percentage global failure count tolerance to use for the mesh quality
                    control after node movement to each edge. If the movement of nodes to an edge
                    causes the global failure count of the mesh to increase beyond this percent of
                    the total element count, the node movement will be rolled back. The default
                    value is 0.1.
GlobalFailureIndexTolerance
The percentage global failure quality index tolerance to use for the mesh
                    quality control after node movement to each edge. If after the movement of nodes
                    to an edge, the global failure quality index of the mesh increases beyond this
                    percent of the previous global quality index of elements in the model, the node
                    movement will be rolled back. The default value is 0.05.


number_of_strings
Integer indicating the size (number of strings) of the string array created using
                *createstringarray.


","Examples
To attempt to align all nodes to all lines, using a failure count tolerance of 0.2 and
        failure index tolerance of 0.2:
*createmark lines 1 all
*createmark nodes 1 all
*createstringarray 2 ""FailureCountTolerance:0.2"" ""FailureIndexTolerance:0.2""
*aligntoedges 1 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1220,*allsuppressoutput,"Description
Sets the export/do not export state of all entities.
","Inputs

state
0 - Set the state to 'export'.
1 - Set the state to 'do not export'.

","Examples
To set all entities to 'export':
*allsuppressoutput 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1221,*alternatefejointupdate,"Description
Updates FE joint elements for use with the OptiStruct FE
        solution sequence.
","Inputs

mark_id
The ID of the mark containing the joint entities to update.  Valid values are 1 and
            2.
type
The type of FE joint element.  Valid values are:
42 - Ball.  system1 and system2 must be
            specified as 0.
43 - Revolute.  system1 is mandatory, but
              system2 may be specified as 0.
44 - Universal.  system1 and system2 must be
            specified.
node1
The ID of the first FE joint node.
node2
The ID of the second FE joint node.
system1
The ID of the first FE joint system.
system2
The ID of the second FE joint system.
type_flag
Set to 1 to update type, 0 otherwise.
node_flag
Set to 1 to update node1 and node2, 0
            otherwise.
system1_flag
Set to 1 to update system1, 0 otherwise.
system2_flag
Set to 1 to update system2, 0 otherwise.

","Example
To update revolute type FE joint elements 9 and 10 to be joints of type ball:
*createmark elements 1 9 10
*alternatefejointupdate 1 42 0 0 0 0 1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1222,*alternatejointupdate,"Description
This command updates elements contained on mark_id based on the
        arguments specified below:
","Inputs

type
Joint element type. Supported values are:


8 - Ball
9 - Fixed
10 - Revolute
11 - Translational
12 - Cylindrical
13 - Universal
14 - Constant velocity
15 - Planar
16 - Inline
17 - Perpendicular
18 - Parallel axes
19 - Inplane
20 - Orient
21 - Point to Curve
22 - Curve to Curve
23 - Point to Deformable Curve
24: Point to Deformable Surface


node1
The ID of the first node of the joint element.
node2
The ID of the second node of the joint element.
orient1_node
The ID of the first orientation node of the joint element.
orient2_node
The ID of the second orientation node of the joint element.
orient1_x
x coordinate defining the first orientation vector.
orient1_y
y coordinate defining the first orientation vector.
orient1_z
z coordinate defining the first orientation vector.
orient2_x
x coordinate defining the second orientation vector.
orient2_y
y coordinate defining the second orientation vector.
orient2_z
z coordinate defining the second orientation vector.
curve_set1
The ID of the first entity set used to define the MBD curve.
curve_set2
The ID of the second entity set used to define the MBD curve.
typeflag
1 - Update the joint type.
0 - Do not update this joint type.
nodeflag
1 - Update the nodes of the joint.
0 - Do not update the nodes of the joint.
orient1flag
1 - Update the first orientation of the joint.
0 - Do not update.
orient2flag
1 - Update the second orientation of the joint.
0 - Do not update.
curvesetflag
1 - Update entity sets used to define the curves.
0 - Do not update entity sets.

","Examples
To update cylindrical type joint elements of ID's 9 and 10 to be joints of type ball:
*createmark elements 1 9 10
*alternatejointupdate 1 8 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1223,*altgapelementupdate,"Description
Updates property and orientation of node-to-node (CGAP) or node-to-element (CGAPG) gap
        elements.
","Inputs

mark
The ID of the mark.
property_name
The name of the property to which the gap elements should point.
vectorid
The ID of the orientation vector associated with the gap elements.
nodeid
The ID of the orientation node associated with the gap elements.
orient_x
X component of the orientation vector.
orient_y
Y component of the orientation vector.
orient_z
Z component of the orientation vector.
comps_flag
Flag to indicate whether individual components are used in defining the orientation of
            the element.
0 - Components are not used.
1 - Components are used.
systemid
The ID of the coordinate system used to orient the gap element.
Update_Property
Flag to indicate whether or not to update the property.
0 - Do not update.
1 - Update.
Update_Vector
Flag to indicate whether or not to update the vector.
0 - Do not update.
1 - Update.

","Examples
To update gap elements 25, 26 and 27 with property pgap1, using system with ID 15 as
        orientation system:
*createmark(elements,1) 25 26 27   *
altgapelementupdate(1,""pgap1"",0,0,0,0,0,0,15,1,1)
Orientation of the gap element may be specified using either a vector, node, coordinate
        system or individual components.
",
1224,*analysiscurvecreate,"Description
Creates a curve by extracting values from a results file. The results file must be loaded
        before executing this command.
","Inputs

entity_type
The type of entities on the mark.
mark_id
The ID of the mark that contains the entities. Valid values are 1 and 2.
x_data_type
The name of the x data type from which to extract data.
y_data_type
The name of the y data type from which to extract data.
x_component
The name of the x component to be extracted from the file if the x data type is
            displacement. Valid values are:
total
x comp
y comp
z comp


y_component
The name of the y component to be extracted from the file if the y data type is
            displacement. Valid values are:
total
x comp
y comp
z comp



","Examples
To create a curve from the displacement results for node 12, starting with the simulation
          simulation1:
*analysisfileset C:/my_results/test.res
*createmark nodes 1 12
*analysiscurvecreate nodes 1 ""displacements"" ""simulationid"" ""total"" """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1225,*analysisfileset,"Description
Loads a results file for use in subsequent operations. All IDs are assumed to be HyperMesh internal IDs.
","Inputs

filename
The full path and name of the results file.

","Examples
To load the result file named C:/my_results/test.res:
*analysisfileset C:/my_results/test.res
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1226,*animatecycles,"Description
Sets the number of animation cycles for the subsequent animation.
","Inputs

number
The number of animation cycles to perform. A value of -1 indicates an infinite
            cycle.

","Examples
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements data type, using a 10.0 model unit
        scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*animatecycles 10
*animatemodal """" 10.0 4 0
*freesimulation
",
1227,*animatelinear,"Description
Creates a linear animation from results data.  The results file must be loaded before
        executing this command. The *freesimulation command clears the
        animation.
","Inputs

title
The title to use for the animation.
max_deflection
The maximum deflection in model units, or the scale factor, to which the maximum
            analysis result should be scaled. Use a negative value for model units and a positive
            value for scale factor.
frames
The number of frames to use during the animation sequence. The maximum value is
            machine dependent.
display_mode
The type of display to generate. Valid values are: 
0 - Mesh wireframe only.
1 - Rendered with mesh lines.
2 - Feature lines only.
3 - Rendered with feature lines.
4 - Rendered only.


output_type
This argument is no longer supported and is ignored.

","Examples
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements data type, using a 10.0 model unit
        scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*animatecycles 10
*animatelinear """" 10.0 4 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1228,*animatetransient,"Description
Creates a transient animation from results data.  The results file must be loaded before
        executing this command. The *freesimulation command clears the
        animation.
","Inputs

title
The title to use for the animation.
max_deflection
The maximum deflection in model units, or the scale factor, to which the maximum
            analysis result should be scaled. Use a negative value for model units and a positive
            value for scale factor.
frames
The number of frames to use during the animation sequence. The maximum value is
            machine dependent.
display_mode
The type of display to generate. Valid values are: 
0 - Mesh wireframe only.
1 - Rendered with mesh lines.
2 - Feature lines only.
3 - Rendered with feature lines.
4 - Rendered only.


increment
The simulation increment to use. This allows for skipping simulations in the results
            file.
output_type
This argument is no longer supported and is ignored.

","Examples
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 through Subcase 4 with Displacements data type, using a
        10.0 model unit scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*lastsimulation ""Subcase 4"" ""Displacements""
*animatecycles 10
*animatetransient """" 10.0 4 1 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1229,*appendmark,"Description
Appends entities on a mark based on user supplied options.
In addition to the options below, all of the options for *createmark are
        also supported.  See that topic for more details on those options, and general behaviors of
        both commands.
","Inputs

entity_type
Entity type to use. Depending on the options specified, the supported entity types
            will change.
mark_id
The ID of the mark.  Valid values are 1 and 2.
""by model"" <model_name>
The optional model to append the mark from.  If not specified, the current model is
            used.
?""options""?


","Examples
To delete the elements adjacent to the elements in components with names FRONT and
        SIDE:*createmark elems 1 ""by comp name"" FRONT SIDE
*createmark elems 2 ""[hm_getmark elems 1]""
*appendmark elems 1 ""by adjacent""
*markdifference elems 1 elems 2
*deletemark elems 1
To translate all of the elements attached to element 40404 by
        (5,0,0):*createmark elems 1 40404
*appendmark elems 1 ""by attached""
*createvector 1 1.0 0.0 0.0
*translatemark elements 1 1 5
To mark elements that share a face with elements 50 and
        100:*createmark elems 1 50 100
*appendmark elems 1 ""by face""
To mark elements that share a face with elements 50 and 100 for model
        model-2:*createmark elems 1 ""by model"" model-2 50 100
*appendmark elems 1 ""by model"" model-2 ""by face""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1230,*applydisplayattributes,"Description
Sets the components on the graphics component list (select/apply on the menu) to the
        specified style and color.
","Inputs

style
Determines the type of graphical entities used to display the component. The options are:
0 - Wire frame.
1 - Hidden line.
2 - Hidden line with mesh.
3 - Hidden line with features.
4 - Hidden line transparent.


colortype
Determines how the components are colored. The options are:
0 - None.
1 - Component color.
2 - Assigned plots.
3 - Contours.



",,
1231,*applyresultsasloads,"Description
Create loads at an entity's nodes based on a models result information. 
","Inputs

entities
The entity type.
mark
The mark which contains the entities to be added to the set.
multiplier
The multiplier to apply to the result.
datatype
The data type.
loadtype
The type of load to create.
For vector datatypes:
forces 
moments 
velocities 
accels


For scalar datatypes:
temp 
flux


loadcomp
The load component. The value is only used for vector data types; it should be set to
            0 for scalar data types. It may be specified as one of the following:
For vector datatypes:
total 
comp1
comp2
comp3


For scalar datatypes:
0



",,
1232,*assemblymodify,"Description
Creates or modifies an assembly.
","Inputs

assemblyname
The name of the assembly.
mark
The ID of the mark containing the components that should be in the assembly. 
color
The index number of the color in the HyperMesh
            palette.

The components in the mark will be the only components in the assembly after this command
        is executed. 
","Examples
To create the assembly frontend that contains the components fender,
        hood, and hoodinr, and is colored blue, indicated by the number 9. 
*createmark(components,1) fender hood hoodinr
*assemblymodify(frontend,1,9)
",
1233,*assemblyremovemark,"Description
Removes the components within a mark from the components contained in an assembly mark.
","Inputs

assemblymark
The ID of the assembly mark from which you wish to remove assemblies, components, or
            multibodies.
entitytype
The type of entity contained on the entitymark: assemblies, components, or
            multibodies.
entitymark
The ID of the mark to be removed from the assembly.

","Examples
To remove component 14 from assembly 2:
*createmark(assemblies,2) 2
*createmark(components, 1) 14
*assemblyremovemark(2,components,1)
",
1234,*assignsystem,"Description
References a coordinate system to an element. The specified axis of this system is then
        projected on the element plane. Re-orients and visualizes the element (material) coordinate
        system for selected elements. When review is complete, the command
          *vectorsoff must be run.
","Inputs

entity_type
The type of entity to update. Only elements are supported.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
system_id
The ID of the system to project onto the element plane. A value of 0 indicates the
            global axes.
axis
Determines the selected axis of the coordinate system to be projected. This axis is
            projected onto the element plane to define the element orientation. Angle theta is
            determined from the new x-element direction and the element normal, and then saved. The
            new x-element direction is visualized. 
-1 - The system ID is saved and the first axis is used for projection and
            visualization. 
0 - First axis. 
1 - Second axis. 
2 - Third axis.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient =1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1 through 64.

","Examples
To project the z-axis of the global coordinate system (ID = 0) on the element plane of four
        selected elements and display the projection as blue vectors (color 7) with size = 3:
*createmark elems 1 376 377 389 418
*assignsystem elems 1 0 2 1 5 7
*vectorsoff
To project the local coordinate system (ID = 1) on the element plane of those elements and
        display the projection as green lines (color
        10):*createmark elems 1 376 377 389 418
*assignsystem elems 1 1 -1 0 0 10
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1235,*assignsystem_option,"Description
References a coordinate system to an element. The specified axis of this system is then
        projected on the element plane. Re-orients and visualizes the element (material) coordinate
        system for selected elements. When review is complete, the command
          *vectorsoff must be run.
","Inputs

entity_type
The type of entity to update. Only elements are supported.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
system_id
The ID of the system to project onto the element plane. A value of 0 indicates the
            global axes.
axis
Determines the selected axis of the coordinate system to be projected. This axis is
            projected onto the element plane to define the element orientation. Angle theta is
            determined from the new x-element direction and the element normal, and then saved. The
            new x-element direction is visualized. 
-1 - The system ID is saved and the first axis is used for projection and
            visualization. 
0 - First axis. 
1 - Second axis. 
2 - Third axis.
only_orient
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient =1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1 through 64.
option
Option for review customization. Valid values are: 
1 - Abaqus rebar layer will be reviewed.

","Examples
To project the z-axis of the global coordinate system (ID = 0) on the element plane of four
        selected elements and display the projection as blue vectors (color 7) with size = 3:
*createmark elems 1 376 377 389 418
*assignsystem_option elems 1 0 2 1 5 7 1
*vectorsoff
To project the local coordinate system (ID = 1) on the element plane of those elements and
        display the projection as green lines (color
        10):*createmark elems 1 376 377 389 418
*assignsystem_option elems 1 1 -1 0 0 10 1
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1236,*attributeupdate_entityidarray2d,"Description
Updates an attribute that is a 2D array of entity IDs. 
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity that owns the attribute. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
target entity
The type of entity to which the attribute refers.
data
The 2D array of IDs.
rows
The number of rows in the array.
cols
The number of columns in the array. 

","Examples
If you want to store the following 2x2 table in an attribute, 
12
89


You would do the following:
*createarray(4) 1 2 8 9
*attributeupdate_entityidarray2d(loadcols, 1, 1234, 1, 2, 0, materials, 2, 2)
",
1237,*attributeupdatedouble,"Description
Updates an attribute of type double.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
value
The value of the attribute.

","Example
Update an attribute of type double to a value of 200 on an element with
        ID, 100.*attributeupdatedouble(elements,100,1241,6,2,0,200.0)
",
1238,*attributeupdatedoublearray2d,"Description
Updates an attribute of type 2D double array. 
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
data
2D array of doubles.
rows
The number of rows in the array.
cols
The number of columns in the array.

","Example
Update an attribute of type 2D double array to [1,2,3] on the material with ID 7. 
[4,5,6]*createdoublearray2d(2,3) 1 2 3 5 6 7
*attributeupdatedoublearray2d(materials,7,615,2,2,0,1,1)
",
1239,*attributeupdatedoublearray2dmark,"Description
Updates an attribute of type 2D double array on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
data
2D array of doubles.
rows
The number of rows in the array.
cols
The number of columns in the array.

","Example
Update an attribute of type 2D double array to [1,2,3] on materials with IDs 7 and 8. 
[4,5,6]*createmark(materials,1) 7 8
*createdoublearray2d(2,3) 1 2 3 5 6 7
*attributeupdatedoublearray2dmark(materials,1,615,2,2,0,1,1)
",
1240,*attributeupdatedoublearraymark,"Description
Updates an attribute of type double array on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
data
Double array.
length
Double array length.

","Examples
Update an attribute of type double array to [1, 2, 3, and 4] on the materials with IDs 7
        and
        8.*createmark(materials,1) 7 8
*createdoublearray(4) 1 2 3 4
*attributeupdatedoublearraymark(materials,1,615,2,2,0,1,4)

",
1241,*attributeupdateentity,"Description
Updates an attribute of type entity.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute.
behavior
The behavior of the attribute.
targetentity
The type of entity to which the attribute points.
targetentityid
The ID of the entity to which the attribute points.

","Example
Update an attribute of type entity (on element 17) to point to a node with ID
        1.*attributeupdateentity(elements,17,1247,6,0,0,nodes,1)	
",
1242,*attributeupdateentityidarray2delementmark,"Description
Updates one element of an attribute of type 2D entity ID array.
","Inputs

entity type
The entity type that owns the attribute.
mark
The number of the mark where the list of IDs resides. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
target entity
The type of entity to which the attribute refers. 
row
The row number the value to be changed resides in (first row is zero). 
col
The column number the value to be changed resides in (first column is zero).
value
The new value of the 2D array element. 

","Examples
This example assumes you want to update an element in a 2D entity ID array attribute to
        point to a loadcol with an ID of 5 (specifically located at row 3, column 2). The attributes
        are found on materials with ID's of 7 and 8. Do the following:
*createmark(materials, 1) 7 8
*attributeupdatedoublearray2delementmark(materials, 1, 1234, 1, 2, 0, loadcols, 2, 1, 5)
",
1243,*attributeupdateentityidarraymark,"Description
Updates an attribute, which is an array of entity IDs, on a set of entities. 
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs resides. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
targetentity
The type of entity to which the attribute refers. 
data
An array of IDs to entities.
length
The length of the data array.

","Examples
*createarray(4) 0 0 0 0
*attributeupdateentityidarraymark(loadcols, 1, 6436, 1, 2, 0, materials, 1, 4)
",
1244,*attributeupdateint,"Description
Updates an attribute of type int. 
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
value
The value of the attribute.

","Examples
Update an attribute of type int to a value of 200 on an element with ID 100.
*attributeupdateint(elements,100,1241,6,2,0,200)
",
1245,*attributeupdateintarray2d,"Description
Updates an attribute of type 2D int array.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The 2D array of ints.
rows
The number of rows in the array.
cols
The number of columns in the array.

","Examples
Update an attribute of type 2D int array to [1,2,3] on the material with ID 7. 
[4,5,6]
        *createintarray2d(2,3) 1,2,3,5,6,7 
*attributeupdateintarray2d(materials,7,615,2,2,0,1,1)
",
1246,*attributeupdateintarray2dmark,"Description
Updates an attribute of type 2D int array on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark where the list of IDs resides. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The 2D array of ints.
rows
The number of rows in the array.
cols
The number of columns in the array.

","Examples
Update an attribute of type 2D int array to [1,2,3] on materials with ID's 7 and 8. 
[4,5,6]*createmark(materials,1) 7 8
*createintarray2d(2,3) 1,2,3,5,6,7
*attributeupdateintarray2dmark(materials,1,615,2,2,0,1,1)
",
1247,*attributeupdateintarraymark,"Description
Updates an attribute of type int array on a set of entities.
","Inputs

entity type
The entity  type that owns the attribute.
mark
The number of the mark. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The int array.
length
The int array length.

","Examples
Update an attribute of type int array to [1, 2, 3, and 4] on the materials with ID's 7 and
        8.
*createmark(materials,1) 7 8
*createintarray(4) 1 2 3 4
*attributeupdateintarraymark(materials,1,615,2,2,0,1,4)

",
1248,*attributeupdatesolverid,"Description
Solver IDs and ID pools let HyperMesh maintain the organization
        of models for solvers whose data model does not correspond well to the natural layout. The
        IDs themselves are stored on a special kind of attribute attached to the entity. 
This command is used to update the solver ID attribute for a specified entity. 
The need to use this command is very rare and is provided for situations that understand
        the ID pool organization of a particular solver. 
","Inputs

entity_type
The entity type that owns the attribute.
entity_id
The HyperMesh internal ID of the entity.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
solver_id
The solver ID to record to the attribute.
pool_id
The ID of the solver ID pool to which the solver ID belongs.

","Examples
Update a solver ID attribute 1241 on a material with ID 100 to record a solver ID of 3 in
        pool number
        1:*attributeupdatesolverid materials 100 1241 6 2 0 3 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1249,*attributeupdatestringarray,"Description
Updates an attribute of type string array.
","Inputs

entity type
The type of entity that owns the attribute.
id
The ID of the entity. 
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The string array.
length
The string array length.

","Examples
Update an attribute of type string array to [layer1, layer2] on the material with ID
        7.*createstringarray(2) ""layer1"" ""layer2""
*attributeupdatestringarray(materials,7,615,2,2,0,1,2)
",
1250,*attributeupdatestringarraymark,"Description
Updates an attribute of type string array on a set of entities.
","Inputs

entity type
The type of entity that owns the attribute.
mark
The number of the mark.
identifier
The identifier of the attribute.
solver
The solver number of the attribute.
status
The status of the attribute. 
behavior
The behavior of the attribute.
data
The string array.
length
The string array length.

","Examples
Update an attribute of type string array to [layer1, layer2] on the materials with IDs, 7
        and
        8.*createmark(materials,1) 7 8
*createstringarray(2) ""layer1"" ""layer2""
*attributeupdatestringarraymark(materials,1,615,2,2,0,1,2)
",
1251,*autocolor,"Description
Automatically colors any collectors that are currently set to gray (colors 10-18). 
","Inputs

entity_type
The type of collector to be colored. Valid values are comps, loadcols, systemcols,
            vectorcols.

","Examples
To automatically color all of the components that are gray:
        *autocolor comps
",
1252,*automesh_mc,"Description
Meshes elements or surfaces using mesh controls. The following rules apply: 
A model control is mandatory for meshing, and only one is needed. It will indicate
            whether meshing is performed on surfaces, or on elements. 
The entities selected in each local, feature and refinement control must existing in
            the final selection, which is composed of entities selected by the model control, and
            those on the entity_mark_id. 
Feature-based meshing is only available for surfaces. When feature controls are
            involved, depending on the mode, a feature global or body control may be mandatory. See
            the mode argument for details. 
During meshing, entities in local and feature controls will be meshed by themselves.
            The rest will be taken care of by model control, or by the feature body control.


","Inputs

entity_type
The type of entities selected for meshing. Valid values are surfs, elems, comps, and
            regions.
entity_mark_id
The ID of the mark containing the entities to be meshed. Valid values are 0
            (indicating selection comes from the model control only), 1 and 2.
mesh_control_mark_id
The ID of the mark containing the mesh controls to use. Valid values are 1 and 2.
mode
The meshing mode for feature based meshing. Valid values are: 
0 - Normal mode. Both body and feature controls will be meshed. At least one
                feature global or body control is needed. 
1 - Feature only mode. Only feature controls will be meshed. Feature global or
                body controls are optional.



","Examples
To mesh all surfaces using mesh controls
        1-3:*createmark surfs 1 all
*createmark meshcontrols 1 1 2 3
*automesh_mc surfs 1 1 0
To mesh elements defined in the model control and all other mesh
        controls:*createmark meshcontrols 2 all
*automesh_mc elems 0 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1253,*autotopocleanup,"Description
Performs automatic preparation of a model’s topology for meshing, using specified element
        size and element quality criteria. These criteria may include geometry feature recognition
        (fillets, holes, beads, flanges, etc.), the topology simplification, cleaning of small
        features, etc. The parameters controlling the topology cleanup stages and tools are given as
        a set of topology cleanup parameters.
","Inputs

Surfmark
The mark of surfaces to be processed.
criteria_filename
 The path to the file with element quality criteria. 
param_filename
The path to the file with topology cleanup parameters.

The quality criteria and topology cleanup parameters files should be prepared using
          Criteria Editor dialog from HyperMesh or BatchMesher. Both criteria and parameters set can be
        pre-set directly in the command file. In this case, use ""dummy"" (without quotes) for the
        criteria and/or parameters file name, respectively (this allows you to specify
        criteria/parameters directly within of of the following commands):
*readqualitycriteria or *setqualitycriteria for
        criteria; 
*createcleanupparamsfromstrings, *create_batch_file,
        or *readbatchparamsfile for cleanup parameters.
 The cleanup parameters are deleted after every call of the
          *autotopocleanup command, so when a ""dummy"" parameter is used the
        cleanup parameters must be set with one of the above mentioned commands prior to each call
        of *autotopocleanup.
","Examples
To perform topology cleanup of all displayed surfaces using element quality criteria
          nvh10.criteria and quality parameters file
          nvh10.param:*createmark surfaces 1 ""displayed""
*autotopocleanup 1 ""nvh10.criteria"" ""nvh10.param""
To perform topology cleanup of all displayed surafaces using element quality criteria set
        directly in the command file and quality parameters file
        nvh10.param:*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
*createmark surfaces 1 ""displayed""
*autotopocleanup 1 ""dummy"" ""nvh10.param""
",
1254,*bagdeleteall,"Description
This command deletes all bags on mark mark_id and all of the associated
        entities contained within each of those bags.
","Examples
To delete bags admpart1 and admmaterial1 and all
        entities contained within
        them:hm_createmark bags 1 ""admpart1 admmaterial1""
*bagdeleteall 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1255,*bar3elementcreatewithoffsets,"Description
Creates a bar3 element with offsets.
","Inputs

node1
The first node ID (end a).
node2
The second node ID.
node3
The third node ID (end b).
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This argument is only used if
              orientation_node is 0.
orientation_node
The orientation node ID. If set to 0, then vector_id is used. If
            non-zero, then y_dir specifies whether this node defines the local y-
            or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
property_name
The name of the property collector assigned to the bar.
offset_system_a
The system used to define the offsets at end a. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_a
The offset in the x-direction at end a.
offset_y_a
The offset in the y-direction at end a.
offset_z_a
The offset in the z-direction at end a.
offset_system_b
The system used to define the offsets at end b. Valid values are: 
0 - Offsets given in global coordinate system.
1 - Offsets given in local coordinate system of node1.
2 - Offsets given in elemental coordinate system.


offset_x_b
The offset in the x-direction at end b.
offset_y_b
The offset in the y-direction at end b.
offset_z_b
The offset in the z-direction at end b.

","Examples
To create a bar3 element between nodes 101, 102 and 103 with its local y-axis defined by
        the vector (1, 0, and 0) and assigned property prop1. The element has an offset vector at
        end a defined using the global system (0.2, 0.2, and 0.2) and offset vector at end b defined
        using the global system (0.3, 0.3, and
        0.3):*createvector 1 1.0000 0.0000 0.0000
*bar3elementcreatewithoffsets 101 102 103 1 0 0 0 0 ""prop1"" 0 0.2 0.2 0.2 0 0.3 0.3 0.3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1256,*barelement,"Description
Creates a bar element.
","Inputs

node1
The first node ID (end a).
node2
The second node ID (end b).
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This argument is only used if
              orientation_node is 0.
orientation_node
The orientation node ID. If set to 0, then vector_id is used. If
            non-zero, then y_dir specifies whether this node defines the local y-
            or local z-axis.
y_dir
If set to 1, then orientation_node defines the local y-axis of the
            bar. Otherwise, orientation_node defines the local z-axis.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
property_name
The name of the property collector assigned to the bar.

","Examples
To create a bar3 element between nodes 101 and 102 with its local y-axis defined by the
        vector (1,0,0) and assigned property
        prop1:*createvector 1 1.0000 0.0000 0.0000
*barelement 101 102 1 0 0 0 0 ""prop1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1257,*barelementorientbysystem,"Description
Orients bar elements along a given direction with respect to an input system.
","
Inputs



mark_id

The ID of the mark containing the elements to orient. Valid values are 1 and 2.

vector_id

The ID of the direction vector created using *createvector.  Valid
            values are 1 and 2.

system_id

The ID of the local system  For global system, set as 0.

","Examples
Orient elements 1-4 along the x-direction with respect to local system 1:
*createmark elements 1 1-4
*createvector 1 1 0 0
*barelementorientbysystem 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1258,*barelementupdate,"Description
Updates the vector (global system), pin flags and property for multiple bar and/or bar3
        elements. 
","Inputs

mark_id
The ID of the mark containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
update_vector
If non-zero, vector_id is used to update the local y-axis.
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This vector is defined in the global
            system.
update_pins
If non-zero, pin_flags_a and pin_flags_b are
            used to update the pin flags.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
update_property
If non-zero, property_name is used to update the property.
property_name
The name of the property collector assigned to the bar.

","Examples
To update bar elements 10 and 12 with local y-axis defined by (1.0, 0.0, 0.0) and property
        ""crossmem"":*createmark elements 1 12 12
*createvector 1 1.0 0.0 0.0
*barelementupdate 1 1 1 0 0 0 1 crossmem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1259,*barelementupdatelocal,"Description
Updates the vector (local system), pin flags and property for multiple bar and/or bar3
        elements.
","Inputs

mark_id
The mark ID containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
update_vector
If non-zero, vector_id is used to update the local y-axis.
vector_id
The ID of the y-axis vector to use, defined using the *createvector
            command. If used, this must be set to 1. This vector is defined in the local system at
            end a.
update_pins
If non-zero, pin_flags_a and pin_flags_b are
            used to update the pin flags.
pin_flags_a
The pin flags at end a. A pin flag of 0 passes forces in all degrees of freedom.
pin_flags_b
The pin flags at end b. A pin flag of 0 passes force in all degrees of freedom.
update_property
If non-zero, property_name is used to update the property.
property_name
The name of the property collector assigned to the bar.

","Examples
To update bar elements 10 and 12 with local y-axis defined by (1.0, 0.0, and 0.0) using the
        local system at end a and property
        ""crossmem"":*createmark elements 1 12 12
*createvector 1 1.0 0.0 0.0
*barelementupdatelocal 1 1 1 0 0 0 1 crossmem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1260,*baroffset,"Description
Updates the offsets in the global system for a single bar or bar3 element.
","Inputs

element_id
The ID of the bar or bar3 element to update.
offset_x_a
The offset in the x-direction at end a. This is defined in the global system.
offset_y_a
The offset in the y-direction at end a. This is defined in the global system.
offset_z_a
The offset in the z-direction at end a. This is defined in the global system.
offset_x_b
The offset in the x-direction at end b. This is defined in the global system.
offset_y_b
The offset in the y-direction at end b. This is defined in the global system.
offset_z_b
The offset in the z-direction at end b.  This is defined in the global system.

","Examples
To update bar element 23 with offset vector at end a defined as (1.0, 2.0, 3.0) and at end
        b as (4.0, 5.0, 6.0):*baroffset 23 1.0 2.0 3.0 4.0 5.0 6.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1261,*baroffsetupdatelocal,"Description
Updates the offsets in the local system for multiple bar and/or bar3 elements.
","Inputs

mark_id
The ID of the mark containing the bar and/or bar3 elements to update. Valid values are 1 and 2.
update_offset_a, update_offset_b
If non-zero, the offsets at end a, and end b are updated, respectively.
offset_x_a, offset_y_a, offset_z_a
The offset at end a in the x-direction, y-direction, and z-direction, respectively.
            This is defined in the local system at end a
offset_x_b, offset_y_b, offset_z_b
The offset at end b in the x-direction, y-direction, and z-direction, respectively.
            This is defined in the local system at end b.

","Examples
To update bar element 23 with offset vector at end a defined as (1.0, 2.0, 3.0) relative to
        the local system at a and at end b as (4.0, 5.0, 6.0) relative to the local system at
        b:*createmark elements 1 23
*baroffsetupdatelocal 1 1 1.0 2.0 3.0 1 4.0 5.0 6.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1262,*barrierpositioner,"Description
Positions the barrier according to various protocols with respect to given vehicle.
The model must contain vehicle and barrier parts, the vertical axis of these parts must be
        aligned with global positive z axis (0,0,1), the barrier model must be imported as an
        include file, and all barrier parts must be in the same include file.
","
Inputs


barrierfrontaxis={<x y z>}
The vector pointing toward the front of the barrier. It must be different from the
            global z axis.  This is mandatory.
basenode={<x y z>}
The coordinates of the base node for ground.  This is mandatory.
barrierfoamdistance=<value>
The frontal distance of the foam part of the barrier to be considered for calculating
            the bounding box of those nodes/coordinates for offset or overlap, default is
            350.0.
barrierheightposition=<value>
The desired final distance between vehicle and barrier, defaults are given for each
              config below.
barrierimpactside=<value>
The default is 1 except for config=16.  Valid values are:
1 - Left
2 - Right
barrierlateralangle=<value>
The lateral angle with which the barrier is rotated from expected barrier final axis.
            For front load case, barrier final axis is opposite of vehicle front axis. For side load
            case, it is lateral axis of vehicle and towards the vehicle, whereas it is front axis of
            vehicle for rear load case.  Defaults are 0.0 except for config=14
            the default is 15 degrees and for config=18 the default is 75
            degrees.
barriermark=<value>
The ID of the mark of barrier components. Valid values are 1 and 2.  This is
            mandatory.
barrieroverlappercent=<value>
The percentage overlap between car and vehicle for front load cases, defaults are
            given for each config below.
barriervehicleoffsetdist=<value>
The desired final distance between vehicle and barrier, default is 10.0.
config=<value>
The type of load case and regulation.  Valid values are:


Config
Load Case
Regulation
Description
barrierheightposition
barrieroverlappercent
rpointoffset




11
Side
IIHS
Mobile Deformable Barrier (MDB)
379.0
-
-


12
Side
FMVSS-214D
Passenger Car
279.0
-
-


13
Side
FMVSS-214D
MPV
279.0
-
-


14
Side
Euro NCAP
MDB
300.0
-
250.0


15
Side
UN-R95
MDB
300.0
-
0.0


16
Side
J-NCAP
MDB
300.0
-
250.0


17
Side
C-NCAP
MDB
350.0
-
250.0


18
Side
Euro NCAP
Oblique Pole
102.0
-
-


31
Front
Euro NCAP
ODB
200.0
40.0
-


32
Front
Euro NCAP
MPDB
150.0
50.0
-


33
Front
IIHS
Small Overlap Rigid Barrier
0.0
25.0
-


34
Front
US NCAP
OMDB
200.0
15.0
-


51
Rear
FMVSS-301
 
229.0
70.0
-





inclinationnode={<x y z>}
The coordinates of the inclination node for ground.  This is mandatory.
rpointoffset=<value>
The barrier distance from R Point of vehicle for side load cases or impact reference
            distance (IRD).
If the value is 0.0 for config 11, 12 or 13, then it will compute
            IRD.  Defaults are given for each config above.  Non-zero offset
            values take precedence and will be used as it is for positioning.
sidenode={<x y z>}
The coordinates of the side node for side load cases.
vehiclefrontaxis={<x y z>}
The vector pointing toward the front of the vehicle. It must be different from the
            global z axis.  This is mandatory.
vehiclemark=<value>
The ID of the mark of vehicle components. Valid values are 1 and 2.  This is
            mandatory.
wheelbasedistance=<value>
The wheelbase distance as the distance between front wheel axis and rear wheel axis,
            used for IRD calculations.

","Examples
Example of Front ODB load
        case:*createmark comps 1 ""by include"" $includeidvehicle
*createmark comps 2 ""by include"" $includeidbarrier
*barrierpositioner config=31 vehiclemark=1 barriermark=2 vehiclefrontaxis={1 0 0} barrierfrontaxis={-1 0 0} basenode={0.000087 913.163 0} inclinationnode={-4806.71 913.163 0} barrieroverlappercent=40.0 barrierheightposition=200.0 barrierfoamdistance=150.0 barriervehicleoffsetdist=10.0
Example of Front OMDB load
        case:*createmark comps 1 ""by include"" $includeidvehicle
*createmark comps 2 ""by include"" $includeidbarrier
*barrierpositioner config=34 vehiclemark=1 barriermark=2 vehiclefrontaxis={1 0 0} barrierfrontaxis={1 0 0} basenode={0.000087 913.163 0} inclinationnode={-4806.71 913.163 0} barrieroverlappercent=35.0 barrierheightposition=200.0 barrierlateralangle=15.0 barriervehicleoffsetdist=10.0 barrierfoamdistance=150.0
Example of Side IIHS MDB load
        case:*createmark comps 1 ""by include"" $includeidvehicle
*createmark comps 2 ""by include"" $includeidbarrier
*barrierpositioner config=11 vehiclemark=1 barriermark=2 vehiclefrontaxis={1 0 0} barrierfrontaxis={0 1 0} basenode={0.000087 913.163 0} inclinationnode={-4806.71 913.163 0} sidenode={-777.060791 982.340820 330.154846} wheelbasedistance=2538.0 barrierimpactside=1 barrierheightposition=379.0 barrierfoamdistance=350.0 barriervehicleoffsetdist=10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1263,*batchparams_update,"Description
Updates the global mesh parameter values.
","
Inputs

Basic:
element_order=<value>
The element order for meshing. Valid values are first and second.
element_organization=<value>
The component organization for meshing. Valid values are:
current_component
surface_component
element_size=<value>
The target element size for meshing.
element_type=<value>
The element type for meshing. Valid values are mixed, quad, and tria.
geometry_cleanup=<value>
Enable this flag to enable geometry cleanup and the feature related options:
0 - Disabled 
1 - Enabled
import_model_tolerance=<value>
The tolerance used while importing the CAD model. Set to auto (recommended) to
              automatically calculate the tolerance based on the type and dimensions of the
              model.
midmesh_extract=<value>
Enable this flag to enable midmesh extraction and its related options:
0 - Disabled
1 - Enabled
midsurface_extract=<value>
Enable this flag to enable midsurface extraction and its related options:
0 - Disabled
1 - Enabled


Midsurface:
midsurface_method=<value>
The midsurface algorithm:
offset
offset_planes
offset_planes_sweeps
skin_offset
midsurface_pre_cleanup=<value>
Perform geometry cleanup steps on the model before midsurface extraction:
0 - Disabled
1 - Enabled
thin_solids_feature_angle=<value>
The minimum angle used to distinguish top and bottom faces of a thin solid from its
              sides. Angles less than this value are treated as if they were flat for purposes of
              midsurface extraction. Used when thin_solids_only=1.
thin_solids_max_ratio=<value>
The maximum ratio between the approximate thickness of the thin solid part (shortest
              dimension) and its approximate width (2nd shortest dimension), used to limit the
              midsurface extraction to parts for which the thickness is smaller than the length and
              the width. Used when thin_solids_only=1.
thin_solids_only=<value>
Extract midsurfaces for thin (sheet metals) solids only:
0 - Disabled
1 - Enabled
thin_solids_max_thickness=<value>
Ignore thin solids with a thickness less than this value. Used when
                thin_solids_only=1.


Midmesh:
midmesh_extract_element_size=<value>
The element size for direct midmesh. By default, it is set to target element
              size.
midmesh_flat_edges_ignore=<value>
Imprint flat edges from the input geometry onto the midmesh:
0 - Disabled
1 - Enabled
midmesh_holes_defeature=<value>
Remove small holes/openings less than
                midmesh_holes_defeature_width:
0 - Disabled
1 - Enabled
midmesh_holes_defeature_width=<value>
The width to use when midmesh_holes_defeature=1.
midmesh_non_manifold_edges_combine=<value>
Join non-manifold edges closer than
                midmesh_proximity_edge_suppression_factor * minimum element
              size.
midmesh_non_manifold_edges_combine_factor=<value>
The factor to use when midmesh_non_manifold_edges_combine=1.
midmesh_proximity_edge_suppression=<value>
Suppress small edges in proximity closer than
                midmesh_proximity_edge_suppression_factor * minimum element
              size.
midmesh_proximity_edge_suppression_factor=<value>
The factor to use when midmesh_proximity_edge_suppression=1.
midmesh_ribs_flatten=<value>
Flatten/align ribs and t-connections:
0 - Disabled
1 - Enabled


Geometry Cleanup:
flat_feature_suppression_character_size_method=<value>
The method to calculate the feature character size, which is defined by an element
              size or calculated automatically based on characteristic dimensions of the part. Valid
              values are:
auto - Automatically calculate feature character size based on characteristics of
              the part
element_size - Feature character size is set element size
user_defined - Specify feature character size using
                flat_feature_suppression_character_size
flat_feature_suppression_character_size=<value>
The custom feature character size which is used to calculate curvature break angle
              when
              flat_feature_suppression_character_size_method=user_defined.
flat_feature_suppression_feature_angle=<value>
The custom feature angle when
                flat_feature_suppression_level=user_defined.
flat_feature_suppression_level=<value>
Suppress feature edges based on different levels of curvature break angle. Valid
              values are:
very_low
low
medium
high
very_high
user_defined - Specify the feature angle using
                flat_feature_suppression_feature_angle.
components_boundary_preserve=<value>
Preserve boundaries between components and do not modify such edges:
0 - Disabled
1 - Enabled
overlapping_surfaces_fix=<value>
Fix overlapping surfaces:
0 - Disabled
1 - Enabled
overlapping_surfaces_fix_max_tanangle=<value>
The tolerance used to find overlapping surfaces when
                overlapping_surfaces_fix=1. Set to ""auto"" to calculate the
              tolerance internally. Specify a value when auto is not sufficient.
surface_duplicates_delete=<value>
Control the deletion of duplicate surfaces within
                surface_duplicates_delete_tolerance. Valid values are:
all - Consider all the surfaces in all the components against each other
none - Do not remove duplicate surfaces
within_components_only - Consider all the surfaces within components only
surface_duplicates_delete_tolerance=<value>
The tolerance used to find duplicate surfaces for
                surface_duplicates_delete. Set to ""auto"" to calculate the
              tolerance internally. Specify a value when auto is not sufficient.
surface_edges_stitch_allow_non_manifold=<value>
Equivalence t-connections:
0 - Disabled
1 - Enabled
surface_edges_stitch_max_tolerance=<value>
The tolerance used to equivalence edges. Set to ""auto"" to calculate the tolerance
              internally. Specify a value when auto is not sufficient.
surface_edges_stitch_within_components_only=<value>
Equivalence edges across components instead of just within:
0 - Disabled
1 - Enabled
surfaces_merge_proximity=<value>
Suppress edges within surfaces_merge_proximity_width to avoid
              creation of sliver elements and disruptions in the mesh flow:
0 - Disabled
1 - Enabled
surfaces_merge_proximity_width=<value>
The proximity width used to suppress edges when
                surfaces_merge_proximity=1. This can be specified as a value
              (e.g. 0.67) or as a multiple of minimum element size (e.g. Lmin*0.67).
surfaces_merge_sharp_edge_proximity=<value>
Suppress sharp steps within
                surfaces_merge_sharp_edge_proximity_width to avoid creation of
              sliver elements when surfaces_merge_proximity=1:
0 - Disabled
1 - Enabled
surfaces_merge_sharp_edge_proximity_width=<value>
The proximity width used to suppress sharp steps when
                surfaces_merge_sharp_edge_proximity=1. This can be specified as a
              value (e.g. 0.67) or as a multiple of minimum element size (e.g. Lmin*0.67).


Bead Features:
beads_recognition=<value>
Recognize beads on sheet metal parts:
0 - Disabled
1 - Enabled
beads_rounded_midline_preserve=<value>
Enforce node placement along the midline of a rounded beads when
                beads_recognition=1:
0 - Disabled
1 - Enabled
beads_suppression=<value>
Suppress beads on sheet metal parts when
              beads_recognition=1:
0 - Disabled
1 - Enabled
beads_suppression_height=<value>
The height of beads to suppress when beads_recognition=1 and
                beads_suppression=1.


Fillet Features:
edge_fillets_recognition=<value>
Recognize and remove edge fillets of 2D surfaces:
0 - Disabled
1 - Enabled
max_fillet_radius=<value>
The maximum edge fillet radius to defeature when
                edge_fillets_recognition=1.
surface_fillets_minimize_transitions=<value>
Minimize transitions during fillet meshing:
0 - Disabled, mesh settings can be defined as an exact number of rows.  May result
              in more trias.
1 - Enabled, mesh settings are defined as a minimum number of elements/rows required
              to meet the maximal chordal deviation.  Helps to reduce trias.
surface_fillets_recognition=<value>
Recognize and optionally treat fillets on sheet metal parts. This is useful to
              prevent the main (long) edges of the fillets from being suppressed, and prevent the
              nodes of those edges from moving while fixing element quality:
0 - Disabled
1 - Enabled
surface_fillets_table={<operation> <option1>=<value1>
                ?<option2>=<value2>? ... ?<optionN>=<valueN>?}
Operates on the surface fillets table. Operations are supported for:
Add
Add new rows to the table. The following options are available:
max_chord_dev=<value>
The chordial deviation to be achieved while meshing for the given row.
                          This is required for method=enforce.
method=<value>
The treatment for surface fillets. This is mandatory. Valid values
                          are:
enforce
remove
split
split_suppress
min_num_rows=<value>
The number of elements across the width of the fillets for the given
                          row.  This is required for method=enforce.
radius_range=<value>
The radius range of the fillets for the row.  Fillets within this range
                          will be recongized and considered for the specified treatment. This is
                          mandatory.
width_range=<value>
The width range of the fillets for the row.  Fillets within this range
                          will be recongized and considered for the specified treatment. This is
                          mandatory.




Delete
Delete rows from the table. The following options are available:
row_id=<value>
The index of the row to delete, starting from 0.




Edit
Edit rows of the table. The following options are available:
row_id=<value>
The index of the row to edit, starting from 0. This is mandatory.
max_chord_dev=<value>
The chordial deviation to be achieved while meshing for the given row.
                          This is required for method=enforce, otherwise not
                          required unless setting/changing the value.
method=<value>
The treatment for surface fillets. Not required unless changing the
                          value. Valid values are:
enforce
remove
split
split_suppress
min_num_rows=<value>
The number of elements across the width of the fillets for the given
                          row.  This is required for method=enforce, otherwise
                          not required unless setting/changing the value.
radius_range=<value>
The radius range of the fillets for the row.  Fillets within this range
                          will be recongized and considered for the specified treatment.  Not
                          required unless changing the value.
width_range=<value>
The width range of the fillets for the row.  Fillets within this range
                          will be recongized and considered for the specified treatment.  Not
                          required unless changing the value.






Flange Features:
flanges_max_width=<value>
The maximum width of flanges to detect when
              flanges_recognition=1.
flanges_min_width=<value>
The minimum width of flanges to detect when
              flanges_recognition=1.
flanges_num_elements_across=<value>
The minimum number of elements to be created across the flange width when
                flanges_recognition=1.
flanges_recognition=<value>
Recognize flanges on sheet metal parts. Flanges may be modified to suppress
              construction lines, subdivide them into rectangular areas, or otherwise prepare them
              for proper meshing. As this functionality is not supported for solid geometries, it
              should be disabled for such models to improve performance:
0 - Disabled
1 - Enabled
flanges_remove_narrow=<value>
Allow removal of narrow flanges when flanges_recognition=1:
0 - Disabled
1 - Enabled
flanges_remove_narrow_width=<value>
The narrow flange width when flanges_remove_narrow=1. Set as
              ""auto"" to auto-calculate a relevant narrow width.


Hole 2D Features:
surface_holes_coordinates=<value>
Activate the use of coordinates tables and related functionalities:
0 - Disabled
1 - Enabled
surface_holes_flanges_suppress=<value>
Recognize holes with flanges and remove the flanges:
0 - Disabled
1 - Enabled
surface_holes_flanges_suppress_height=<value>
The maximum height of flanges to remove when
                surface_holes_flanges_suppress=1.  Flanges with a height less
              than the minimal element size are extended to the minimum element size if not
              removed.
surface_holes_maintain_narrow_slot_ends=<value>
Create honeycomb and square mesh patterns for narrow slots:
0 - Disabled
1 - Enabled
surface_holes_narrow_slot_type=<value>
The mesh patterns for narrow slots when
                surface_holes_maintain_narrow_slot_ends=1:
rectangular_ends - Rectangular/square mesh patterns
rounded_ends - Honeycomb/rounded mesh patterns
surface_holes_recognition=<value>
Recognize holes in 2D parts, and allow 2D hole treatment:
0 - Disabled
1 - Enabled
surface_holes_table={<operation> table_id=<value>
                <option1>=<value1> ?<option2>=<value2>? ...
                ?<optionN>=<valueN>?}
Operates on the surface holes tables. Operations are supported for:
Add
Add new rows to the table. The following options are available:
coords_file=<value>
The name and path of the coordinates file.  This is mandatory for
                          coordinate tables.
max_radius=<value>
The maximum 2D hole radius. This should be greater than the maximum
                          radius of the last row. Adds the row to the end of the table. If not
                          specified, range must be used.
num_elems=<value>
The minimum/exact number of elements around the hole. This is required
                          for treatment=seed and
                            treatment=washer.
range=<value>
The range of radii. Inserts the row between existing rows. If not
                          specified, max_radius must be used.
table_id=<value>
The index of the table to update.  -1 is the default table, coordinate
                          files tables start from 0.  This is mandatory.
treatment=<value>
The treatment for 2D holes.  This is mandatory.  Valid values are:
ignore (valid for coordinates tables only)
remove (valid for default table only)
remove_mark (valid for default table only)
seed
seed_mark
washer
washer_mark
washer_layers={<value1>, ?<value2>?, ...
                            ?<valueN>?}
Create washers around holes.  Multiple layers of washers can be created.
                          Sets the width of the washer layers as a constant value (e.g. 10.0), a
                          scale of the hole radius (e.g. 0.6*radius) or a subtraction formula (e.g.
                          14.0-radius).  This is mandatory for treatment=washer
                          and treatment=washer_mark.




Delete
Delete rows from the table. The following options are available:
row_id=<value>
The index of the row to delete, starting from 0.  If not specified, the
                          entire table_id is deleted.
table_id=<value>
The index of the table to delete.  -1 is the default table, coordinate
                          files tables start from 0.  This is mandatory.




Edit
Edit rows of the table. The following options are available:
max_radius=<value>
The maximum 2D hole radius. If row_id is not
                          specified, the last row is modified.
num_elems=<value>
The minimum/exact number of elements around the hole. This is required
                          for treatment=seed and
                            treatment=washer, otherwise not required unless
                          setting/changing the value.
row_id=<value>
The index of the row to edit, starting from 0. This is mandatory unless
                            max_radius is specified.
table_id=<value>
The index of the table to update.  -1 is the default table, coordinate
                          files tables start from 0.  This is mandatory.
target_radius=<value>
Adjust holes in the specified radius range to have the specific target
                          radius. The radius can be specified as an exact value (e.g. 5.0), or as an
                          expression based on the original radius (e.g. radius*1.1, radius-0.5,
                          radius+0.5).  Not required unless changing the value.
treatment=<value>
The treatment for 2D holes.  Not required unless changing the value.
                          Valid values are:
ignore (valid for coordinates tables only)
remove (valid for default table only)
remove_mark (valid for default table only)
seed
seed_mark
washer
washer_mark
washer_layers={<value1>, ?<value2>?, ...
                            ?<valueN>?}
Create washers around holes.  Multiple layers of washers can be created.
                          Sets the width of the washer layers as a constant value (e.g. 10.0), a
                          scale of the hole radius (e.g. 0.6*radius) or a subtraction formula (e.g.
                          14.0-radius).  This is required for treatment=washer
                          and treatment=washer_mark, otherwise not required
                          unless setting/changing the value.




surface_holes_washer_trims_remove=<value>
Remove trim lines created during washer creation:
0 - Disabled
1 - Enabled


Hole 3D Features:
solid_holes_recognition=<value>
Recognize holes in 3D parts, and allow 3D hole treatment:
0 - Disabled
1 - Enabled
solid_holes_table={<operation> <option1>=<value1>
                ?<option2>=<value2>? ... ?<optionN>=<valueN>?}
Operates on the solid holes table. Operations are supported for:
Add
Add new rows to the table. The following options are available:
max_radius=<value>
The maximum 3D hole radius. This should be greater than the maximum
                          radius range of the entire table. Adds the row to the end of the table. If
                          not specified, range must be used.
num_elems=<value>
The minimum/exact number of elements around the hole. This is required
                          for treatment=mark and
                            treatment=seed.
range=<value>
The range of radii. Inserts the row between existing rows. If not
                          specified, max_radius must be used.
treatment=<value>
The treatment for 3D holes. This is mandatory.  Valid values are:
mark
remove
remove_mark
seed




Delete
Delete rows from the table. The following options are available:
row_id=<value>
The index of the row to delete, starting from 0.




Edit
Edit rows of the table. The following options are available:
max_radius=<value>
The maximum 3D hole radius. This should be greater than the maximum
                          radius range of the entire table. Not required unless changing the
                          value.
num_elems=<value>
The minimum/exact number of elements around the hole. This is required
                          for treatment=mark and
                            treatment=seed, otherwise not required unless
                          setting/changing the value.
row_id=<value>
The index of the row to edit, starting from 0. This is mandatory.
treatment=<value>
The treatment for 3D holes. Not required unless changing the value.
                          Valid values are:
mark
remove
remove_mark
seed






Logo Features:
logo_max_height=<value>
The maximum height of la letter within a logo to remove when
                logo_remove=1.
logo_max_size=<value>
The maximum size/width of a letter within a logo to remove when
                logo_remove=1.
logo_min_concavity=<value>
Creates a filter that provides more flexible control of automatic logo recognition.
              As this is a heuristic tool, it may remove real features, such as flat bottom round
              dimples, that were not intended for removal. The value is a quantitative measure of a
              letters shape complexity. Extend the recognition and removal of logos by reducing this
              value. Used only when logo_remove=1.
logo_remove=<value>
Remove small features that represent logos:
0 - Disabled
1 - Enabled


Thread Features:
threads_remove=<value>
Recognize and remove features that represent threads by replacing then with a smooth
              cylinder or cone:
0 - Disabled
1 - Enabled
threads_remove_max_depth=<value>
The maximum depth of cylindrical or conical threads to be replaced when
                threads_remove=1.
threads_replacement_diameter_type=<value>
The method used to define the diameter for replacing threads with a cylinder or cone
              when threads_remove=1:
auto - Autodecide, based on the diameter of the blank before thread cutting begins.
              For inner (hole) threads, it corresponds to the thread minor diameter. For outer
              (bolt) threads, it corresponds to thread major diameter.
major - Use diameter of thread major
mean - Use dimeter of thread mean
minor - Use diameter of thread minor


Quality Correction:
element_folding_angle=<value>
Elements whose angle exceeds this value are considered folded and are attempted to
              be cleaned.
feature_angle=<value>
The feature angle to maintain while performing element cleanup.
nodes_keep_on_free_round_holes=<value>
Prevent node movement off of free round holes.  This is useful if distortion of
              holes is not allowed:
0 - Disabled
1 - Enabled
nodes_keep_on_free_round_holes_elements=<value>
Do not allow any nodes to move off the edges of free holes (without washers) with
              less than this number of elements when
                nodes_keep_on_free_round_holes=1.
nodes_move_across_free_edges=<value>
Allow node movement across free edges:
0 - Disabled
1 - Enabled
nodes_move_across_free_edges_max=<value>
The maximum allowable node movement across free edges when
                nodes_move_across_free_edges=1.  This can be specified as a value
              (e.g. 0.1) or as a multiple of minimum element size (e.g. Lmin*0.1) or target element
              size (e.g. L*0.1).
nodes_move_across_non_manifold_edges=<value>
Allow node movement across non-manifold edges:
0 - Disabled
1 - Enabled
nodes_move_across_non_manifold_edges_max=<value>
The maximum allowable node movement across non-manifold edges when
                nodes_move_across_non_manifold_edges=1.  This can be specified as
              a value (e.g. 0.1) or as a multiple of minimum element size (e.g. Lmin*0.1) or target
              element size (e.g. L*0.1).
nodes_move_across_shared_edges=<value>
Allow node movement across shared edges:
0 - Disabled
1 - Enabled
nodes_move_across_shared_edges_max=<value>
The maximum allowable node movement across shared edges when
                nodes_move_across_shared_edges=1.  This can be specified as a
              value (e.g. 0.1) or as a multiple of minimum element size (e.g. Lmin*0.1) or target
              element size (e.g. L*0.1).
nodes_move_normal=<value>
Allow node movement normally to surfaces:
0 - Disabled
1 - Enabled
nodes_move_normal_max=<value>
The maximum allowable node movement normal to surfaces when
                nodes_move_normal=1.
quads_divide_warped=<value>
Split warped quads into trias:
0 - Disabled
1 - Enabled


Special Components:
special_components_add=<value>
The name of a component to add to the special components list.
special_components_remove=<value>
The index of a component, starting from 0, to remove from the special components
              list.
special_components_selection=<value>
Handling of special components selection:
0 - Disabled
1 - Enabled
special_components_treatment=<value>
Options for meshing of special components when
                special_components_selection=1:
ignore_and_keep_connectivity - Ignore the listed components while maintaining
              connectivity to any existing mesh. The mesh and geometry of the ignored components are
              not modified. The mesh created on other adjacent components is connected to any
              existing mesh on the ignored components. This is useful for meshing of different
              components with different criteria/parameters files, or when pre-meshing components
              interactively or with some other procedure, followed by meshing of other
              components.
mesh_and_keep_connectivity - Mesh the listed components while maintaining
              connectivity to any existing mesh. This is useful when components are to be meshed
              with multiple element sizes but transitions at the common edges of the different sizes
              are required. Each component should be meshed individually with its own parameter and
              criteria files with this option enabled.
mesh_without_geometry_cleanup - Mesh the listed components but do not perform any
              geometry cleanup. Any remaining components that are not listed will be meshed using
              the normal process, including geometry cleanup. This is useful for models in which
              some components do not require geometry cleanup while others do.
special_components_wildcard_use=<value>
The component names provided in the special components list are used as a search
              string to find all matching components in the current model and add them internally to
              the list when special_components_selection=1:
0 - Disabled
1 - Enabled


","Examples
Turn off geometry cleanup and set the element size to
        7.5:*batchparams_update geometry_cleanup = 0 element_size = 7.5
Edit the first row of the default 2D holes table to apply washer
        treatment:*batchparams_update surface_holes_table = {Edit table_id = -1 row_id = 0 treatment = washer target_radius = 1.1*radius num_elems = 4 washer = {2,radius-5} }
Add a new row to the fillet
        table:*batchparams_update surface_fillet = {Add radius_range = {0-10} width_range = {5-10} method = enforced min_num_rows = 2 max_chord_dev = 0.2}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1264,*BCM,"Description
This command creates loads by interpolating between existing loads (field loads) or loads
        defined in a text file (linear interpolation).
","Inputs

entity_type
The type of entity to create loads on. Valid values are nodes and elements.
mark_id
The ID of the mark containing the entities to create the loads on. Valid values are 1 and 2.
load_mark_id
The ID of the mark containing any existing loads to use during the interpolation. The
            mark does not have to be populated. Valid values are 1 and 2.
config
The configuration of the load to create. Valid values are: 
1 - forces
2 - moments
4 - pressures
5 - temperatures
6 - fluxes
type
The solver type of the load to create. This value is dependent on the current solver
            template loaded.
filename
The name and path of a file containing the coordinates and values of any input loads
            to use for the linear interpolation. This parameter is optional and should be set to """"
            if not specified. The format of the file is: 
x y z value 
x y z value 
etc…
tolerance
The search radius to use for finding nodes/elements for interpolation. If a negative
            value is provided, gap filling is used and a load is created at every selected
            node/element regardless of the search tolerance.
facenode_mark_id
The ID of the mark containing the face nodes when defining solid element faces. The
            mark does not have to be populated. Valid values are 0 (when
              entity_type is set to nodes), 1 and 2.
break_angle
The break angle to use when defining solid element faces. Should be set to 0 when
              entity_type is set to nodes.

","Examples
To create forces on nodes 100, 101 and 102 by interpolating from existing loads on nodes 99
        and 103, using a search radius of
        10.0:*createmark nodes 1 101-102
*createmark loads 2 99 103
*BCM nodes 1 2 1 1 """" 10.0 0 0 0
To create forces on nodes 100, 101 and 102 by interpolating from loads defined in the file
          C:/my_loads.txt, using a search radius of
        10.0:*createmark nodes 1 101-102
*createmark loads 2
*BCM nodes 1 2 1 1 ""C:/my_loads.txt"" 10.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1265,*beams_to_surfaces,"Description
Create surfaces/meshes from 1D beams.  The beams must have valid section data assigned.
","
Inputs


domesh=<value>
Specifies whether the generated surfaces should be meshed:
0 - Do not mesh
1 - Mesh (default)
dosnap=<value>
Specifies whether the generated surfaces should be snapped at the surface intersection
            within snaptol:
0 - Do not snap (default)
1 - Snap
entitytype=<value>
The type of input 1D entities.  Valid values are elements and components.  This is a
            mandatory option.
mark=<value>
The ID of the mark of input entities.  Valid values are 1 and 2.  This is a mandatory
            option.
meshextension=<value>
Specifies whether the generated mesh should be extended to the connected
            surfaces:
0 - Do not extend (default)
1 - Extend
meshsize=<value>
The size of the mesh when domesh=1.  The default is the global
            element size.
meshtype=<value>
Specifies the mesh element type when domesh=1:
0 - Tria
1 - Quad only
2 - Mixed (default)
stitchtol=<value>
The stitch tolerance when dosnap=1.  The default is the global
            geometry cleanup tolerance.
tobeamcomponent=<value>
Specifies the surface/mesh component organization:
0 - Current component (default)
1 - Source 1D component
usebeamnode=<value>
Specifies whether the generated surfaces and mesh should be congruent to the base
            mesh:
0 - Non-congruent (default)
1 - Congruent

","Examples
To create surfaces and mixed mesh of size 100, snapping the surfaces, extending the mesh,
        and making the surfaces and mesh congrument with the base
        mesh:*beams_to_surfaces entitytype=elems mark=1 usebeamnode=1 meshextension=1 dosnap=1 domesh=1 meshsize=100 meshtype=2 stitchtol=0.0 tobeamcomponent=1 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1266,*beamsectioncreateatplane,"Description
A shell or solid type beam section will be created by cutting through the selected entities
        at the plane location and using the resulting section lines. The beam section may be
        centered at the centroid of the section, the shear center, or at an arbitrary point defined
        by you. Optionally, nodes can be created at the centroid and shear center of the beam
        section. 
The entities selected will be cut at the selected plane and the section lines created by
        doing so will be rotated such that the orient vector points vertically (beam y-axis). If a
        shell beam section is to be created the shell beam section parts will placed along the
        section lines. If a solid beam section is to be created, the interior of the section lines
        will be filled in with beam section elements, but only if the section lines form one or more
        loops. The section plane normal forms the beam section’s local x-axis (length) and the
        orient vector forms the beam section’s local y-axis (height). 
Additionally, a boundary may be assigned such that the section lines will be cropped where
        they cross the boundary. For shell beam sections the portions of the section lines which lie
        outside the boundary are discarded. For solid beam sections the boundary will be used in
        place of the portions of the section lines which lie outside the boundary when filling in
        the section. 
The results for the beam section will be automatically calculated after creation.
","Inputs

entity_type
The type of input entity to cut. Valid values are surfs, elems (2D or 3D only) and
            comps (surfs take priority over elems).
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
double_array
The ID of the double array that contains the vertices defining the boundary. The
            double array is created using the *createdoublearray command. This
            should always be set to 1. 
The contents of this array are stored in pairs representing a series of local y and z
            locations for the vertices of the boundary in beam coordinates. 
For example, to represent a rectangular boundary with a height (y-axis) of 6 and a
            width (z-axis) of 3, boundary points are needed at (3, 1.5), (3, -1.5), (-3, -1.5), and
            (-3, 1.5). The syntax would be:
            *createdoublearray 8 3 1.5 3 -1.5 -3 -1.5 -3 1.5

The loop does not need to be closed. A minimum of three boundary points are required,
            but there is no maximum. The boundary can be of any shape, however the boundary should
            be well behaved and contain no crossovers. Extra spaces were added above for clarity. If
            only two doubles are given in the array, these values are used as the maximum height and
            width of the boundary. Thus the above boundary can be simplified to:
            *createdoublearray 2 6 3
number_of_doubles


merge_tol
The tolerance used to merge input lines.
plane_id
The ID of a plane created using the *createplane command. The plane
            defines the plane to cut the input entities.
vector_id
The ID of a vector created using the *createvector command. The
            vector defines the orientation vector.
center_option
Defines how the beam section is centered: 
0 - Centered at the section plane base point. 
1 - Centered at the beam section centroid. 
2 - Centered at the beam section shear center.
create_method
For shell sections, this is the part generation mode: 
0 - Parts for the section are automatically generated. 
1 - Parts for the section will be generated using a simple algorithm. 
For solid sections, this is the element order: 
1 - Elements generated for the beam cross-section interior are first order. 
2 - Elements generated for the beam cross-section interior are first order.
create_centroid_node
Defines whether to create a node at the centroid: 
0 - Do not create a node at the centroid. 
1 - Create a node at the centroid.
create_shear_node
Defines whether to create a node at the shear center: 
0 - Do not create a node at the shear center. 
1 - Create a node at the shear center.
beam_type
The type of beam to create: 
0 - Shell section. 
1 - Solid section.
keep_lines
Defines whether to keep the section cut lines: 
0 - Do not keep section cut lines. 
1 - Keep section cut lines.

","Examples
To create a shell beam section by cutting surfaces, using automatic calculation of the
        orientation vector, assigning no boundary, and positioning it at the shear
        center:*createmark surfs 1 19 20
*createplane 1 0.0000 0.0000 1.0000 22.53 30.00 1.2343
*createvector 1 0.0000 0.0000 0.0000
*beamsectioncreateatplane surfs 1 1 0 0.1 1 1 2 1 0 0 0 0
To create a solid beam section by cutting elements, using a user orientation vector,
        positioning it at the plane base point, assigning a boundary with height 6 and width 3, and
        creating nodes at the centroid and shear
        center:*createmark elems 1 1-22
*createplane 1 0.0000 0.0000 1.0000 22.53 30.00 1.2343
*createvector 1 0.0000 1.0000 0.0000
*createdoublearray 2 6 3
*beamsectioncreateatplane elems 1 1 2 0.1 1 1 0 1 1 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1267,*beamsectioncreateshelldirect,"Description
Creates a shell beam section for HyperBeam, using the given
        parameters. The shell type beam section may be centered at the centroid of the section, the
        shear center, or at an arbitrary point defined by you. Optionally, nodes can be created at
        the centroid and shear center of the beam section. 
The entities selected will be projected to a plane aligned normal to the normal vector,
        rotated such that the orient vector points vertically, and then converted into a shell type
        section. The normal vector forms the beam section’s local x-axis (length) and the orient
        vector forms the beam section’s local y-axis (height). 
The results for the beam section will be automatically calculated after creation.
","Inputs

entity_type
The type of entity that defines the cross-section. Valid values are lines and elems.
            For elements, only 1D elements can be used.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
merge_tol
The tolerance used to merge input lines.
use_normal_vector
0 - The normal vector will be automatically calculated for the given entities.
1 - The normal vector defined by normal_vector_id will be
            used.
normal_vector_id
The ID of a vector created using the *createvector command. The
            vector defines the local x-axis for the section. This is only used when
              use_normal_vector is set to 1.
use_orient_vector
0 - The orientation vector will be automatically calculated for the given
            entities.
1 - The orientation vector defined by orient_vector_id will be
            used.
orient_vector_id
The ID of a vector created using the *createvector command. The
            vector defines the local y-axis for the section. This is only used when
              use_orient_vector is set to 1.
center_option
0 - The beam section will be centered at a point defined by x_loc,
              y_loc, and z_loc. 
1 - The beam section will be centered at the beam section centroid. 
2 - The beam section will be centered at the beam section shear center.
x_loc
Defines the x coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
y_loc
Defines the y coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
z_loc
Defines the z coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
part_generation
0 - Parts for the section will be automatically generated. 
1 - Parts for the section will be generated using a simple algorithm.
create_centroid_node
0 - No node will be created at the centroid. 
1 - A node will be created at the centroid of the section relative to the
            entities.
create_shear_node
0 - No node will be created at the shear center. 
1 - A node will be created at the shear center of the section relative to the
            entities.

","Examples
To create a shell type beam section from a line, using automatic calculation of the normal
        and orientation vectors and positioning it at the shear
        center:*createmark lines 1 19
*createvector 1 0.0000 0.0000 1.0000
*createvector 2 0.0000 1.0000 0.0000
*beamsectioncreateshelldirect lines 1 0.01 0 1 0 2 2 0 0 0 0 0 0
To create a shell type beam section from elements, using user defined normal and
        orientation vectors, positioning it at a user-defined point, and creating nodes at the
        centroid and shear
        center:*createmark elems 1 1-22
*createvector 1 -0.2322 0.0104 0.4257
*createvector 2 0.0000 0.0000 1.0000
*beamsectioncreateshelldirect elems 1 0.01 1 1 1 2 0 1.4 0.5 6.0 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1268,*beamsectioncreatesoliddirect,"Description
A solid type beam section will be created using the given parameters. The solid type beam
        section may be centered at the centroid of the section, the shear center, or at an arbitrary
        point defined by you. Optionally, nodes can be created at the centroid and shear center of
        the beam section. 
The entities selected will be projected to a plane aligned normal to the normal vector,
        rotated such that the orient vector points vertically, and then filled in to form a solid
        type section. The normal vector forms the beam section’s local x-axis (length) and the
        orient vector forms the beam section’s local y-axis (height). 
The interior of the solid section will be automatically meshed and results for the beam
        section will be automatically calculated after creation.
","Inputs

entity_type
The type of entity that defines the cross-section. Valid values are lines, surfs and
            elems. For elements, only 2D shell elements can be used.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
merge_tol
The tolerance used to merge input lines or surfaces.
use_normal_vector
0 - The normal vector will be automatically calculated for the given entities.
1 - The normal vector defined by normal_vector_id will be
            used.
normal_vector_id
The ID of a vector created using the *createvector command. The
            vector defines the local x-axis for the section. This is only used when
              use_normal_vector is set to 1.
use_orient_vector
0 - The orientation vector will be automatically calculated for the given
            entities.
1 - The orientation vector defined by orient_vector_id will be
            used.
orient_vector_id
The ID of a vector created using the *createvector command. The
            vector defines the local y-axis for the section. This is only used when
              use_orient_vector is set to 1.
center_option
0 - The beam section will be centered at a point defined by x_loc,
              y_loc, and z_loc. 
1 - The beam section will be centered at the beam section centroid. 
2 - The beam section will be centered at the beam section shear center.
x_loc
Defines the x coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
y_loc
Defines the y coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
z_loc
Defines the z coordinate of the center of the beam for a
              center_option value of 0. For other
              center_option values, this is ignored.
elem_order
Elements generated for the beam cross-section interior are: 
1 - First order. 
2 - Second order.
create_centroid_node
0 - No node will be created at the centroid. 
1 - A node will be created at the centroid of the section relative to the
            entities.
create_shear_node
0 - No node will be created at the shear center. 
1 - A node will be created at the shear center of the section relative to the
            entities.

","Examples
To create a solid type beam section from a line, using automatic calculation of the normal
        and orientation vectors and positioning it at the shear
        center:*createmark lines 1  19
*createvector 1 0.0000 0.0000 1.0000
*createvector 2 0.0000 1.0000 0.0000
*beamsectioncreatesoliddirect lines 1 0.01 0 1 0 2 2 0 0 0 0 0 0
To create a solid type beam section from elements, using user defined normal and
        orientation vectors, positioning it at a user-defined point, and creating nodes at the
        centroid and shear
        center:*createmark elems 1 1-22
*createvector 1 -0.2322 0.0104 0.4257
*createvector 2 0.0000 0.0000 1.0000
*beamsectioncreatesoliddirect elems 1 0.01 1 1 1 2 0 1.4 0.5 6.0 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1269,*beamsectioncreatestandardsolver,"Description
Creates a standard solver-specific HyperBeam section. For a
        list of values that are supported by each solver, see the topics in the See Also section. 
","Inputs

type
Integer indicating the type of section to create. Each solver has a number of
            available sections.
solver
Integer indicating the solver the section is being created for. Valid values are: 
0 - HyperBeam

1 - OptiStruct/Nastran

2 - Abaqus

8 - ANSYS

9 - LS-DYNA

21 - Permas 
22 - Madymo
type_name
Name indicating the type of section to create. Each type can have multiple available
            section names.
orient
Flag indicating the orientation of the section: 
0 - 0 degrees 
1 - 90 degrees 
2 - 180 degrees 
3 - 270 degrees

","Examples
To create a standard HyperBeam T-section having a 0 degree
        orientation:*beamsectioncreatestandardsolver 1 12 I 0
To create a standard OptiStruct T-section having a 0 degree
        orientation:*beamsectioncreatestandardsolver 15 0 HMTSec 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1270,*beamsectionsetdataroot,"Description
Updating a beam section requires two commands, of which this is the first. This command
        updates the root data for a beam section and will also clear all other beam section data.
        Thus, this command should be followed by *beamsectionsetdatastandard,
          *beamsectionsetdatashell, *beamsectionsetdatasolid,
        or *beamsectionsetdatageneric depending on the
          beam_config selected. Beam section data cannot be updated piecemeal
        with this command; all data must be known for the beam and sent in as arguments.
","Inputs

beam_sect_id
The ID of the beam section to update.
collector_id
The ID of the beam section collector to update.
solver
Integer indicating the solver the section is for. Valid values are: 
0 - HyperBeam

1 - OptiStruct/Nastran

2 - Abaqus
8 - ANSYS
9 - LS-DYNA
21 - Permas 
22 - Madymo
beam_config
Basic configuration of the beam section. Valid values are: 
0 - Solid section 
1 - Generic section 
2 - Standard section 
3 - Shell section
line_color
Currently unused. Must be set to 7.
fill_color
Currently unused. Must be set to 1.
torsion_factor
Currently unused. Must be set to 1.
warping_factor
Currently unused. Must be set to 1.
flags
Currently unused. Must be set to 0.
orient_vector1
Currently unused. Must be set to 0.
orient_vector2
Currently unused. Must be set to 0.
orient_origin1
Currently unused. Must be set to 0.
orient_origin2
Currently unused. Must be set to 0.

","Examples
To update the root data for a standard section specifying HyperMesh as the solver
        type:*beamsectionsetdataroot 1 1 0 2 7 1 0 1.0 1.0 0 0 0 0
Note that this command should be used in tandem with one of four beam section update
        commands such as *beamsectionsetdatastandard as
        follows:*beamsectionsetdataroot 1 1 0 2 7 1 0 1.0 1.0 0 0 0 0
*createdoublearray 12 6 6 6 0.5 0.5 0.5 4 4 4 1 1 1
*beamsectionsetdatastandard 1 12 1 4 0 HMHat
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1271,*beamsectionsetdatasolid,"Description
Updating a solid beam section requires two commands of which this is the second. This
        command will update all data for a solid type beam section. The command
          *beamsectionsetdataroot should precede use of this command. 
Beam section data cannot be updated piecemeal with this command; all data must be known for
        the beam and sent in as arguments. 
The solid beam section interior will be remeshed and results will be calculated for the
        beam section automatically after updating.
","Inputs

point_array
The ID of the double array that contains the points defining the solid section
            perimeter. The double array is created using the *createdoublearray
            command. This should always be set to 1. 
The contents of this array are stored in groups of pairs with each group representing
            a series of local y and z locations of one of the perimeters defining the section. Each
            group must begin and end with the same point so that perimeter groups can be
            differentiated. This is true even if there is only one perimeter defined for the
            section. The first two values are the y and z locations, respectively, of the first
            point of the first perimeter. The next two values are the y and z locations,
            respectively, of the second point of the first perimeter, and so on. This repeats for
            all points and all perimeters. 
Thus, to define a rectangular section running through points (5,5), (5,0), (0,0),
            (0,5) and back to (5,5) with a rectangular hole running through points (4,4), (4,1),
            (1,1), (1,4) and back to (4,4) cut into it, the following array would be
            needed:*createdoublearray 20 5 5 5 0 0 0 0 5 5 5 4 4 4 1 1 1 1 4 4 4

number_of_points
Integer indicating the size (number of points) of the double array created using
              *createdoublearray.
elem_order
The order (1 or 2) of the elements to use.
is_hollow
0 - The solid section does not have an internal void. 
1 - The solid section has an internal void.
beam_sect_id
The ID of the beam section to update.

","Examples
To update the parameter data for a solid type section with ID 3, consisting of a single
        perimeter and no internal voids. Note that this command should be used in tandem with
          *beamsectionsetdataroot as
        follows:*beamsectionsetdataroot 3 1 0 0 7 1 0 0 0 0 0 0 0
*createdoublearray 10 3 -3 3 3 -3 3 -1 -2 3 -3
*beamsectionsetdatasolid 1 10 1 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1272,*beamsectionsetdatastandard,"Description
Updating a shell beam section requires two commands of which this is the second. This
        command will update all data for a shell type beam section. The command
          *beamsectionsetdataroot should precede use of this command. 
Beam section data cannot be updated piecemeal with this command; all data must be known for
        the beam and sent in as arguments. 
Results will be calculated for the beam section automatically after updating.
","Inputs

parameter_array
The ID of the double array that contains the standard section parameters. The double
            array is created using the *createdoublearray command. This should
            always be set to 1. 
The contents of this array are stored in threes with one group of three for each
            parameter. The first three values are the initial, minimum, and maximum values for the
            first parameter, such as the height, in that order. The second three values are the
            initial, minimum, and maximum values for the second parameter, such as the length. This
            repeats for all parameters. See the table below for a list of the number of parameters
            and descriptions of them for each section, solver, and subtype. 
The terms height, width, top, bottom, vertical, horizontal, left and right refer to
            the directions when viewing the section, such that the y-axis is pointing upward and the
            z-axis is pointing to the right. If the beam section type can have multiple orientation
            angles, the terms apply to the zero degree case.


Section
Type
# of Param
Parameter values (at zero or default angle)
Analysis code
Section subtype




Box
0
3
1: Thickness 2: Height
3: Width

HyperMesh
HMBox


4
1: Thickness (top and bottom)2: Height
3: Width
4:
                        Thickness (left and right)

Rad/OS/Nas LS-DYNA
Permas
Samcef
BoxTubular Box
Type3
PROFIL_7



6
1: Thickness (bottom)2: Height
3: Width
4: Thickness
                        (left)
5: Thickness (top)
6: Thickness (right)

Rad/OS/Nas Ansys
LS-DYNAAbaqus

Box1HREC
Box-shape1
BOX



General Symmetric
1
8
1: Thickness2: A/T
3: J/T
4: Iyy/T
5: Izz/T
6:
                        Width
7: Height
8: Bredt Area

HyperMesh
HMGensym


General Asymmetric
2
9
1: Thickness2: A/T
3: J/T
4: Iyy/T
5: Izz/T
6:
                        Stress Recovery Y
7: Stress Recovery Z
8: Bredt Area
9:
                        Iyz/T

HyperMesh
HMGennonsym


Constant Perimeter Box
3
3
1: Thickness2: Width & Height
3: Perimeter

HyperMesh
HMCpbox


Hat
4
4
1: Width2: Thickness
3: Height (without flanges)
4: Flange
                        length

HyperMesh
LS-DYNA

HMHat Hat-shape



1: Height2: Thickness
3: Width (without flanges)
4: Flange
                        length

Rad/OS/Nas
HAT


9
1: Width2: Leg thickness (top)
3: Height (without
                        flanges)
4: Flange length (bottom)
5: Flange thickness
                        (bottom)
6: Arch thickness
7: Flange thickness (top)
8:
                        Flange length (top)
9: Leg Thickness (bottom)

ANSYS
HATS


Tube
7
2
1: Inner radius2: Outer radius

HyperMesh Rad/OS/Nas ANSYS
AbaqusLS-DYNA
Permas Samcef

HMTube
                        Tube
CTUBE
PIPE
Tubular
Type2
PROFIL_9



Rectangle
10
2
1: Height2: Width

HyperMesh
ANSYS
Abaqus
LS-DYNA
Samcef

HMRect RECT
RECT
Solid box
PROFIL_6



1: Width2: Height

Rad/OS/Nas
Bar


Circle
11
1
1: Radius
HyperMesh
Rad/OS/Nas 
ANSYS
Abaqus
LS-DYNA
Samcef

HMCirc
                      Rod
CSOLID
CIRC
Circular
PROFIL_8



I-Section
12
4
1: Total width (flange)2: Total height (web)
3: Web
                        thickness
4: Flange thickness

LS-DYNA
I-shape


6
1: Total width (web)2: Flange width (left)
3: Flange width
                        (right)
4: Web thickness
5: Flange thickness (left)
6:
                        Flange thickness (right)

HyperMesh
ANSYS
Abaqus
LS-DYNA
LS-DYNA
Samcef
HMIsec
                      I
I
I-shape1
I-shape2
PROFIL_1B



1: Total height (web)2: Flange width (bottom)
3: Flange width
                        (top)
4: Web thickness
5: Flange thickness (bottom)
6:
                        Flange thickness (top)

Rad/OS/Nas
I


Channel
13
4
1: Leg length2: Base length
3: Base thickness
4: Leg
                        thickness (both)

HyperMesh
Rad/OS/Nas
Rad/OS/Nas
Rad/OS/Nas 
LS-DYNA
LS-DYNALS-DYNA
Samcef
HMChan
                        Chan
Chan1
Chan2
Channel
Channel1
Channel2
PROFIL_2



6
1: Base length2: Leg length (right)
3: Leg length
                        (left)
4: Leg thickness (right)
5: Leg thickness (left)
6:
                        Base thickness

ANSYS
CHAN


L-section
14
4
1: Leg length (height)2: Base length (width)
3: Leg thickness
                        (vertical)
4: Base thickness (horizontal)

HyperMesh Rad/OS/Nas
ANSYS
Abaqus
LS-DYNA
Samcef
Samcef

HMLsec
                        L
L
L
L-shape
PROFIL_3
PROFIL_3B



T-section
15
4
1: Flange length (total)2: Web length + flange thickness
3:
                        Flange thickness
4: Web thickness

HyperMesh
Rad/OS/Nas 
Rad/OS/Nas
Rad/OS/Nas 
ANSYS
AbaqusLS-DYNA
LS-DYNA
LS-DYNA
Samcef
HMTsec
                        T
T1
T2
T
T
T-shape
T-shape1
T-shape2
PROFIL_5



H-section
16
4
1: Web height (excluding flanges)2: Flange thickness (each)
3:
                        Flange thickness (total)
4: Web thickness

HyperMesh
Rad/OS/Nas 
Rad/OS/Nas
LS-DYNA
Samcef

HMHsecH
I1
H-shape
PROFIL_1



Asymmetric
17
4
1: Base length (total)2: One leg length + base thickness
3: Base
                        thickness
4: Leg thickness (each)

Rad/OS/NasSamcef
Samcef

ZPROFIL_4
PROFIL_4B



6
1: Base length (total)2: Leg length (right/down)
3: Leg length
                        (left/up)
4: Leg thickness (right/down)
5: Leg thickness
                        (left/up)
6: Base thickness

ANSYS
Z


8
1: Total width (web)2: Total flange length (left)
3: Total
                        flange length (right)
4: Web thickness
5: Flange thickness
                        (left)
6: Flange thickness (right)
7: Flange offset
                        (left)
8: Flange offset (right)

Permas
Type1


Cross
18
4
1: Leg length (horizontal - exclude web)2: Web thickness
                        (vertical)
3: Total web length (vertical)
4: Leg thickness
                        (horizontal)

Rad/OS/NasLS-DYNA

CrossCross



Trapezoid
19
3
1: Altitude (horizontal)2: Base length (left)
3: Base length
                        (right)

Abaqus
TRAPEZOID





parameter_array_length
Integer indicating the size (three times the number of parameters) of the double array
            created using *createdoublearray.
beam_sect_id
The beam section ID to update.
beam_sect_type
Standard beam section type. Valid values are:
0 - Thin walled box section 
1 - Generic symmetric section 
2 - Generic non-symmetric section 
3 - Constant perimeter box section 
4 - Hat section 
7 - Tube section 
10 - Rectangle section 
11 - Circle section 
12 - Symmetric I-section 
13 - Channel section 
14 - L-section 
15 - T-section 
16 - H-section 
17 - Asymmetric section 
18 - Cross section 
19 - Trapezoid section 

Note: Not all section types are supported for all solvers. Consult the
                beam_sect_subtype table below.

orientation_angle
Angle of rotation for the standard section. Valid values are: 
0 - 0 degrees. 
1 - 90 degrees. 
2 - 180 degrees. 
3 - 270 degrees. 



Section
Type
HyperMesh
OptiStruct
Nastran
ANSYS
Abaqus
LS-DYNA
Permas
Samcef




Box
0
0
0
0
0
0
0
0


General Symmetric
1
0
---
---
---
---
---
---


General Asymmetric
2
0
---
---
---
---
---
---


Constant Perimeter Box
3
0
---
---
---
---
---
---


Hat
4
0
270
0
---
0
---
---


Tube
7
0
0
0
0
0
0
0


Rectangle
10
0
90
0
0
0
---
0


Circle
11
0
0
0
0
0
---
0


I-Section
12
0
270
0
0
0
---
0


Channel
13
0
0 (chan2)90 (chan)
90 (chan1)

0
---
0 (Channel)0 (Channel1)
90
(Channel2)

---
0


L-section
14
0
0
0
0
0
---
0


T-section
15
0
0 (T1)90 (T2)
270 (T)

180
0
0 (T-shape)90 (T-shape1)
180 (T-shape2)

---
0


H-section
16
0
0 (I1)90 (H)

---
---
0
---
90


Asymmetric
17
---
90
0
---
0
0
0


Cross
18
---
0
---
---
0
---
---


Trapezoid
19
---
---
---
0
---
---
---




Note: Not all angles are supported for all beam sections for all Solvers.
              Consult the table below. The angles are shown where they differ for the full list of
              supported types.

beam_sect_subtype
The name of the section subtype. Consult the table below for supported values for each
            Solver and section type.


Section
Type
HyperMesh
OptiStruct
Nastran
ANSYS
Abaqus
LS-DYNA
Permas
Samcef




Box
0
HMBox

Box
Box1

HREC
BOX
Box-shape1 Tubular box
Type3
PROFIL_7


General Symmetric
1
HMGensym
---
---
---
---
---
---


General Asymmetric
2
HMGennonsym
---
---
---
---
---
---


Constant Perimeter Box
3
HMCpbox
---
---
---
---
---
---


Hat
4
HMHat
HAT
HATS
---
Hat-shape
---
---


Tube
7
HMTube
Tube
CTUBE
PIPE
Tubular
Type2
PROFIL_9


Rectangle
10
HMRect
Bar
RECT
RECT
Solid box
---
PROFIL_6


Circle
11
HMCirc
Rod
CSOLID
CIRC
Circular
---
PROFIL_8


I-Section
12
HMIsec
I
I
I
I-shapeI-shape1
I-shape2

---
PROFIL_1B


Channel
13
HMChan

Chan
Chan1
Chan2

CHAN
---
ChannelChannel1
Channel2

---
PROFIL_2


L-section
14
HMLsec
L
L
L
L-shape
---
PROFIL_3PROFIL_3B



T-section
15
HMTsec

T
T1
T2

T
T
T-shapeT-shape1
T-shape2

---
PROFIL_5


H-section
16
HMHsec
H11

---
---
H-shape
---
PROFIL_1


Asymmetric
17
---
Z
Z
---
---
Type1
PROFIL_4PROFIL_4B



Cross
18
---
Cross
---
---
Cross
---
---


Trapezoid
19
---
---
---
TRAPEZOID
---
---
---






","Examples
To update the parameter data for a standard hat section with ID 1. Note that this command
        should be used in tandem with *beamsectionsetdataroot as
        follows:*beamsectionsetdataroot 1 1 0 2 7 1 0 0 0 0 0 0 0
*createdoublearray 12 6 6 6 0.5 0.5 0.5 4 4 4 1 1 1
*beamsectionsetdatastandard 1 12 1 4 0 HMHat
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1273,*beamsectionupdateshellpartname,"Description
Renames a HyperBeam shell section part.
","Inputs

beam_sect_id
The ID of the shell beam section to update.
part_index
The index of the part to rename for that shell section, starting from 0.
new_name
The new name of the part.

","Examples
To rename the part with index 3 for shell beamsection ID 100 to
        ""edge4"":*beamsectionupdateshellpartname 100 3 edge4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1274,*blmesh_2d_computeblthickness,"Description
Specifies non-boundary layer input for *bl_mesh2d2 and
          *bl_mesh2d_computeblthickness. 
If *blmesh_2d_input_nonbl is not called before
          *blmesh_2d2, then all edges of the selected region are considered as
        boundary layer edges.
","Inputs

base_entity_type
The type of entities to use for the base to generate BL thickness. Only elems are
            valid.
base_mark_id
The ID of the mark containing the base entities. Valid values are 1 and 2.
num_layers
The number of boundary layers to generate.
first_layer_thickness
The thickness value of the first layer.
growth_rate
The growth rate of the boundary layers.
core_to_BL_ratio
Ratio of core mesh to BL thickness, which is used for BL reduction.
corner_factor
A dimensionless value used for corner management. The range is 0.1-1.0 for thinner BL
            thickness, and 1.0-10.0 for thicker BL thickness.

","Examples
To create a 5 layer boundary mesh from elements 10-100, with the first layer being 0.15
        thick and a growth rate of 1.2, a core-to-BL ratio of 2.5, a corner factor of 1.0, and using
        non-boundary layer elements 1 and 2 as fixed and 5 and 6 as
        float:*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createmark elems 1 10-100
*blmesh_2d_computeblthickness elems 1 5 0.15 1.2 2.5 1.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1275,*blmesh_2d_input_bl,"Description
Specifies boundary layer input for *bl_mesh2d2 and
          *bl_mesh2d_computeblthickness1. If
          *blmesh_2d_input_bl is not called before either command, then all edges
        of the selected region are considered as boundary layer edges.
","Inputs

fixed_entity_type
The type of entities to use for the fixed boundary layer. Valid values depend on the
              base_entity_type value specified in *bl_mesh2d2. 
If base_entity_type is surfs, then the only valid value is lines. 
If base_entity_type is elems, then the valid values are elems or
            nodes. For elems, only plotel elements are allowed.
fixed_mark_id
The ID of the mark containing the fixed entities. Valid values are 1 and 2.
float_entity_type
The type of entities to use for the float boundary layer. Valid values depend on the
              base_entity_type value specified in *bl_mesh2d2. 
If base_entity_type is surfs, then the only valid value is lines. 
If base_entity_type is elems, then the valid values are elems or
            nodes. For elems, only plotel elements are allowed
float_mark_id
The ID of the mark containing the float entities. Valid values are 1 and 2.

","Examples
To create a 5 layer boundary mesh with a quad dominated mesh of size 2.0 on surface 10,
        with the first layer being 0.15 thick and a growth rate of 1.2, using boundary layer
        elements 10 and 11 as fixed and 12 and 13 as float, and non-boundary layer elements 1 and 2
        as fixed and 5 and 6 as
        float:*createmark elems 1 10 11
*createmark elems 2 12 13
*blmesh_2d_input_bl elems 1 elems 2
*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createstringarray 2 ""element_size: 2.0"" ""element_type: quads""
*createmark surfs 1 10
*blmesh_2d2 surfs 1 5 0.15 1.2 1 2 2
To create a 5 layer boundary mesh from elements 10-100, with the first layer being 0.15
        thick and a growth rate of 1.2, a core-to-BL ratio of 2.5, a corner factor of 1.0, using
        boundary layer elements 10 and 11 as fixed and 12 and 13 as float, and non-boundary layer
        elements 1 and 2 as fixed and 5 and 6 as
        float:*createmark elems 1 10 11
*createmark elems 2 12 13
*blmesh_2d_input_bl elems 1 elems 2
*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createmark elems 1 10-100
*blmesh_2d_computeblthickness elems 1 5 0.15 1.2 2.5 1.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1276,*blmesh_2d2,"Description
Generates a 2D boundary layer mesh on boundary layer edges, with specified parameters. 
Non-boundary layer information is specified using the
          *blmesh_2d_input_nonbl and boundary layer information is specified
        using *blmesh_2d_input_bl. If *blmesh_2d_input_nonbl
        is not called before *blmesh_2d2, then all edges of the selected region
        are considered as boundary layer edges.
","Inputs

base_entity_type
The type of entities to use for the base. Valid values are surfs and elems.
base_mark_id
The ID of the mark containing the base entities. Valid values are 1 and 2.
num_layers
The number of boundary layers to generate.
first_layer_thickness
The thickness value of the first layer.
growth_rate
The growth rate of the boundary layers.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters include:
element_size
The core mesh element size.


element_type
The core mesh element type.


BL_reduction
Option to reduce BL during meshing.


Auto_BL_reduction
Option to auto reduce BL during meshing.


CoreToBLThicknessRatio
Ratio of core mesh to BL thickness, which is used for BL reduction.


CornerFactor
A dimensionless value used for corner management. The range is 0.1-1.0 for
                  thinner BL thickness, and 1.0-10.0 for thicker BL thickness.


ElemsToSurfComp
Option to organize new elements to surface components.


DefaultBLSelection
Default BL/non-BL selection for all boundary edges. Valid values are: 
With_BL 
Without_BL_fixed 
Without_BL_remesh


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create a 5 layer boundary mesh with a quad dominated mesh of size 2.0 on surface 10,
        with the first layer being 0.15 thick and a growth rate of 1.2, using boundary layer
        elements 10 and 11 as fixed and 12 and 13 as float, and non-boundary layer elements 1 and 2
        as fixed and 5 and 6 as
        float:*createmark elems 1 10 11
*createmark elems 2 12 13
*blmesh_2d_input_bl elems 1 elems 2
*createmark elems 1 1 2
*createmark elems 2 5 6
*blmesh_2d_input_nonbl elems 1 elems 2 1
*createstringarray 2 ""element_size: 2.0"" ""element_type: quads""
*createmark surfs 1 10
*blmesh_2d2 surfs 1 5 0.15 1.2 1 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1277,*blockcontrolplanes,"Description
Controls the planes on a block. 
","Inputs

index
The index to be modified. 
on
Set to 1 to display the block lines. 

",,
1278,*blocksetcurrent,"Description
Sets the current block. 
","Inputs

name
The name of the block. 

",,
1279,*blockwalladdcell,"Description
Adds one cell to a finite difference wall. 
","Inputs

wallname
The name of the wall into which the cell is to be added. 
cellid
The ID of the cell to be added. 

The ID of any cell, knowing the (i,j,k) location, may be found by the formula
          (i*divj*divk)+(j*divk)+k, where divj and divk are the number of divisions
        in the j and k directions, respectively. All cells do not have to be members of a wall.
",,
1280,*blockwalldelete,"Description
Deletes a wall from a finite difference block. 
","Inputs

blockname
The name of the block. 
wallname
The name of the wall to be deleted

",,
1281,*blockwallfill,"Description
 Fills an enclosed plane of cells in a finite difference wall. 
","Inputs

wallname
The name of the wall to be edited. 
cellid
The ID of the cell from which to start the filling. 

The ID of any cell, knowing the (i,j,k) location, may be found by the formula
          (i*divj*divk)+(j*divk)+k, where divj and divk
        are the number of divisions in the j and k directions, respectively. 
Display must be in planar mode for this function to work, and only one plane can be
        displayed. The displayed plane is the plane that is filled.
",,
1282,*blockwallremove,"Description
Removes all cells from the given finite difference wall. 
","Inputs

blockname
The name of the block.
wallname
The name of the wall from which all cells are to be removed.

",,
1283,*blockwallreset,"Description
Deletes all walls from a finite difference block. 
","Inputs

name
The name of the block from which all walls are to be removed. 

",,
1284,*bm_markpreservedcompsboundary,"Description
Flags the boundaries of components to be preserved during batch meshing and
        autocleanup.
","Inputs

mark_id
1 or 2 - The mark containing the desired components. 
0 -  Flag all components for preservation (not just the ones inside of a mark).
common_bound
0 - Boundaries between components within the selection are flagged.
1 - Only the boundary of the entire selection is flagged (comps are treated as a
            single set).
free_edges
0 - Free edges are not marked for preservation.
1 - Free edges are marked for preservation. 

","Examples
Mark the boundaries of components 100 and 101, flagging only the boundary of the entire
        selection:*createmark comps ""by id only"" 100 101
*bm_markpreservedcompsboundary 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1285,*body_split_with_points,"Description
Splits surfaces or solids using swept lines.
","Inputs

entity_type
The type of entities being split: solids or surfaces.
mark_id
The mark that contains the entities being split.
splinepoints
An array of X, Y, Z coordinates for a series of points. HyperMesh uses these points to generate the splitting surface.
size
The number of entries in the splinepoints argument.
options
Determines the extent of the split: 
0 - HyperMesh constructs the splitting surface strictly
            within the boundaries of the selected points (3 points produce a triangular splitting
            surface, even in a solid cube).
1 - The splitting surface extends beyond the chosen points to the full extent of the
            selected solids/surfaces (so 3 points would create a quadrilateral splitting surface
            within a solid cube).

","Examples
To split the solid with ID 1 along a surface passing through points (1, 2, 3), (4, 5,
        6),and (7, 8, 9), without extending the cutting
        surface:*createmark solids 1 1
*createdoublearray 9 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
*body_split_with_points solids 1 1 9 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1286,*body_trim_with_templine,"Description
This command uses coordinates specified by coords and size parameters to construct
        temporary line. Depending on ""mode"" setting in options parameter the line can be either
        smooth spline or a set of straight segments connecting points. The line is then used to
        construct cutting surface, which is then used to trim selected solids or surfaces. Depending
        on options parameter setting, the cutting surface itself either becomes
        part of the model or used only to produce trimming lines on surfaces it intersects. One more
        setting in options parameter controls whether the surface is generated
        exactly as specified by input vector and coordinates or it is also analytically extended to
        intersect as many surfaces from the input set as possible.
","Inputs

entity_type
The type of entity selected for trimming. Surfaces and solids are supported.
mark_id
The mark of surfaces or solids selected for trimming.
vector_id
The ID of the vector defining the sweeping direction for generating the cutting
            surface using the temporary line, defined using the *createvector
            command. This must be set to 1.
coords
The ID of array of ""double"" type values specifying x, y, and z values of consecutive
            points used to generate temporary line.
size
Number of values in the array specified by coords.
options
The options to use for trimming the selected entities. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3).
Bit0
0 - Trimming surface is created by connecting input points and sweeping obtained
                  line in input direction. 
1 - Trimming surface is also extended to trim as many input surfaces as
                  possible.


Bit1
0 - Line is generated as a smooth spline through input points. 
1 - Line is generated as a set of segments connecting input points.


Bit2
0 - Trimming surface becomes part of the model. 
1 - Trimming surface is temporary and is only used to generate trimming lines on
                  intersected surfaces.


Bit3
0 - Trimming surface becomes part of the model. 
1 - Trimming surface is temporary and is only used to generate trimming lines on
                  intersected surfaces.


Bit4
0 - Do not close open trimming line loop. 
1 - Close trimming line loop.



","Examples
To trim solid 111 by sweeping a smooth spline curve generated from three points with
        coordinates (0, 0.5, 11), (2, 0.5, 12), and (3, 0.7, 13) in the
        z-direction:*createmark solids 1 111
*createvector 1 0 0 1
*createdoublearray 9 0 0.5 11 2 0.5 12 3 0.7 13
*body_trim_with_templine solids 1 1 1 9 0
To use the same points but extend the generated surface to ensure that the solid is split
        as a result of this
        trim:*createmark solids 1 111
*createvector 1 0 0 1
*createdoublearray 9 0 0.5 11 2 0.5 12 3 0.7 13
*body_trim_with_templine solids 1 1 1 9 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1287,*calculateElemDrapingAngles,"Description
This command updates connectors with entities.
","Inputs

mark_id
The ID of the mark containing the ply elements. Valid values are 1 and 2.
result_file
Reserved for future use. Must be set to """".
table_name
The name of the table entity to use for storing the results.
fiber_vector_id
The ID of the vector defining the fiber direction, defined using the
              *createvector command.
stamping_vector_id
The ID of the vector defining the stamping direction, defined using the
              *createvector command.
ply_id
The ID of the ply.

","Examples
To calculate the draping angle of elements associated with ply 10 having fiber direction
        (1,0,0) and stamping direction
        (0,1,0):*createmark elements 1 ""by ply id"" 10
*createvector 1 1 0 0
*createvector 2 0 1 0
*calculateElemDrapingAngles 1 """" drapetable 1 2 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1288,*carddelete,"Description
Deletes a control card.
","Inputs

name
The name of the control card to delete.

",,
1289,*carddisablebyid,"Description
This command allows browsers to disable duplicate control cards by id
        and name.
","Inputs

name
The name of an existing card to disable.
id
The HyperMesh ID of the existing card.

","Examples
To disable a control card called ""PARAM"" that has a HyperMesh
        ID of 10:*carddisablebyid (""PARAM"", 10)
The current existing command *carddisable works only on the
          name of control cards, and is not sufficient to pick the right control
        card from HyperMesh browsers, if there are duplicate control
        cards with the same name (i.e. same name but with different ID) in the database and also
        potentially in different include files.
",
1290,*cardenablebyid,"Description
This command allows browsers to enable duplicate control cards by id and
          name.
","Inputs

name
The name of an existing card to enable.
id
The HyperMesh ID of the existing card.

","Examples
To enable a control card called ""PARAM"" that has a HyperMesh ID
        of 10:*cardenablebyid (""PARAM"", 10)
The current existing command *cardenable works only on
          name of control cards, and is not sufficient to pick the right control
        card from HyperMesh browsers, if there are duplicate control
        cards with the same name (i.e. same name but with different ID) in the database and also
        potentially in different include files.
",
1291,*CE_AddLinkEntitiesDirectByRule,"Description
Allows the user to add link directly to the connectors without considering tolerance or
        number of layers.
","
Inputs



mark_id

The ID of the mark of connectors to update.  Valid values are 1 and 2.

link_type

The entity type to be added to the connectors as links.

link_rule

The rule by which the link entity is added to the connector.  If the rule is
            specified, the modification is performed in accordance with the rule. For example, a
            value of 2 requires link IDs to be specified for link_string_array.
            Valid values are:
0 - Undefined 
1 - None 
2 - Use ID
3 - Use Name
4 - Proximity 
5 - Use UID

link_state

The state of the link entity which is to be added:
0 - Undefined
1 - Elems
2 - Geom

link_string_array

A string array containing the list of link IDs/names/UIDs to be added directly to
            connectors, created using*createstringarray. This must be set to
            1.
The strings are generally IDs/names/UIDs based on the
            link_rule.

link_number_of_strings

Integer indicating the size (number of strings) in the
              link_string_array created using
              *createstringarray.

extra_link_string_array

A string array containing the list of extra link additions allowed for spots and
            seams, created using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            link_rule.

extra_link_number_of_strings

Integer indicating the size (number of strings) in the
              extra_link_string_array created using
              *createstringarray.

create_group

0 - Add the newly chosen links separately to the connector
1 - Add the newly chosen links as a group to the connector

","Examples
Add two component links (ID 1 and 2) directly to connector ID 2 of type spot using without
        creating a group link:
*createmark connector 1 2
*createstringarray 2 1 2
*createarray 2 2 2
*CE_AddLinkEntitiesDirectByRule 1 comps 2 1 1 2 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1292,*CE_AddLinkEntitiesWithDetails,"Description
This command updates connectors at the specified locations with rules and other
        details.
","Inputs

connector_mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2.
entity_type
Type of entity to be added to the connectors as links.
entity_mark_id
The ID of the mark containing the entities to use as links. Valid values are 1 and 2.
entity_state
The state of the link entities. Valid values are: 
0 - Geometry.
1 - Elements.
ce_rules
Flag indicating when to make the links. Valid values are: 
0 - Now.
1 - At realize.
ce_le_rule
Flag indicating how to make the links. Valid values are: 
0 - None. 
1 - Use ID.
2 - Use name.
tolerance_flag
Flag indicating whether to use the default tolerance. Valid values are: 
0 - Use default.
1 - Use specified value.
tolerance
Used to add entities only within the given tolerance from the specified
            connector.
num_ents
Number of entities to add/update connector (connectors thickness (2T, 3T, etc.)
            value).
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. Valid strings are: 
ce_delete_links=1
Delete existing connector links. 
ce_spot_extralinknum=1
The number of extra links for spot connectors. 
ce_seam_extralinknum=0
The number of extra links for seam connectors.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
Update links for spot connector 1 and seam connector 2 by deleting existing links
        first:*createmark connectors 1 1 2
*createmark comps 1 21 23 24 27
*createstringarray 3 ""ce_delete_links=1"" ""ce_spot_extralinknum=1"" ""ce_seam_extralinknum=0""
*CE_AddLinkEntitiesWithDetails 1 comps 1 1 1 0 0 0 2 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1293,*CE_AddLinkEntitiesWithXYZs,"Description
This command updates connectors as group links with criteria.
","Inputs

connector_mark_id
The ID of the mark containing the connectors to update. Valid values are 1 and 2..
entity_type
Type of entity to be added to the connectors as links.
entity_mark_id
The ID of the mark containing the entities to use as links. Valid values are 1 and 2..
entity_state
The state of the link entities. Valid values are: 
0 - Geometry.
1 - Elements.
ce_rules
Flag indicating when to make the links. Valid values are: 
0 - Now.
1 - During realization by proximity.
ce_le_rule
Flag indicating how to make the links. Valid values are: 
0 - None.
1 - Use ID.
2 - Use name.
locator
Flag that indicates how to use the XYZs. Valid values are: 
1 - Do projection. 
2 - Find closest node. 
3 - Find node at XYZ.
xyz_array
The ID of the XYZ double array created using *createdoublearray
            command. This should always be 1.
xyz_size
The size of the XYZ double array. Must be a multiple of 3.

","Examples
To add comps 1 and 2 as a group link to connectors 1-3, using (1.0, 2.5, 3.0) and (2.0,
        3.0, 0.5) as locating coordinates. The link state is ""elem"", make link now, link rule is
        ""use ID"", and the locator is to use
        projection:*createmark connectors 1 1-3
*createmark comps 1 1 2
*createdoublearray 6 1.0 2.5 3.0 2.0 3.0 0.5
*CE_AddLinkEntitiesWithXYZs 1 comps 1 1 0 1 1 1 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1294,*CE_Cleanup,"Description
Sets connectors to unrealized and back to a clean undefined state.
","Inputs

mark_id
The ID of the mark containing the connectors to clean. Valid values are 1 and 2.

","Example
To clean connectors 1-10:
*createmark connectors 1 1-10
*CE_Cleanup 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1295,*CE_ConnectorAreaCreateFromList,"Description
 Create area connector(s) at the specific location(s) by list with certain rules.
","Inputs

entities
Types that specify location of area connector(s).
Lines.
Nodes
entitylist
The list for lines or nodes.
width
The width of area connector(s).
offset
Create area connnector(s) offset this value from selected location.
linkentity
Type of entity to be added to the area connector as a link.
Surfs
Comps
linkmark
Mark of surfaces or components to add to the area connector as links.
ent_state
Specifies whether geometry or element gets precedence during realization of connector.
            Currently, only element is supported.
0 - Geometry.
1 - Element. 
ce_rules
Rule to specify if and how a link entity is to be added to a connector.
0 - None.
1 - Now. 
2 - A fe realize.
ce_le_rule
Rule that specifies how an entity is to be remembered by the connector.
0 - None.
1 - Use ID.
2 - Use name.
tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.
tolerance
Specified to add entities only within the given tolerance from the connector.
group
Specified if to group after creation.
0 - Do not group.
1 - Group.
param1
For future use.
param2
For future use.

","Examples
Create 2 area connector at line 1, 2, 3, 6, 7, 8 and add nearest 2 of the four components
        specified within a tolerance of 1.0. Remember the components by their IDs. do not group
        connectors after creation.
        *createlist(lines, 1) 1, 2, 3, 6, 7, 8
*createmark(components, 2) 21 23 24 27
*CE_ConnectorAreaCreateFromList(lines, 1, components, 2, 1, 1, 1, 1, 1.0, 0, 0, 0.0)
Each created area connector is displayed as a plane with cylinders located at the corners
        and only the closest two components are added to it. The total number of layers defined at
        each area connector is 2.
",
1296,*CE_ConnectorAreaMesh,"Description
This command meshes area connectors.
","Inputs

ce_mark
Mark of area connectors.
elementsize
Element size for meshing.
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values
            are: 
0 - trias 
1 - quads 
2 - mixed 
3 - right trias
elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are: 
0 - trias 
1 - quads 
2 - mixed 
3 - right trias
link_opposite_edge
Make opposite edge having the same node density.
1 - Yes
0 - No
size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 - Yes
0 - No
skew_control
Determines if optimal shape elements in mapping algorithms should be created. 
1 - Yes
0 - No
edge_mesh_algorithm
Determines the algorithm for edge/surface meshing: 
0 - Standard edge meshing.
1 - Chordal deviation edge meshing.
min_size
Minimum edge size for chordal deviation edge meshing..
max_size
Maximum edge size for chordal deviation edge meshing.
chordal_dev
Chordal deviation for chordal deviation edge meshing.
max_angle
Maximum angle value (in degrees) between edges for chordal deviation edge
            meshing.
param1
For future use.
param2
For future use.
A meshed area connector displays as a plane with virtual quad elements.

","Examples
To create quads with a default edge size of 1.0 for the area connector with ID 3:
        *createmark(connectors,1) 3*CE_ConnectorAreaMesh(1,1,1,1,1,0,0,0,0,0,0,0,0,0.0)
",
1297,*CE_ConnectorAreaTrim,"Description
Trim/split area connectors using nodes.
","Inputs

mark_id
The ID of the mark containing the area connectors to trim. Valid values are 1 and 2..
node_mark_id
The ID of the mark containing the trim/split nodes. Valid values are 1 and 2..
tolerance
The tolerance value used to snap the nodes to the points of area connectors when
              snap is 1.
snap
0 - Do not snap nodes to area connectors.
1 - Snap nodes to area connectors.
mode
0 - Split area connectors.
1 - Trim area connectors.

","Examples
To split area connector 101 using node
        1001:*createmark connectors 1 101
*createmark nodes 1 1001
*CE_ConnectorAreaTrim 1 1 0.5 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1298,*CE_ConnectorCreate,"Description
Creates spot connector(s) at the specified location(s) by mark. No links are added to the
        created spot connectors.
","Inputs

entity_type
The entity type that specifies the location to create connectors. Valid values are
            nodes, points, and lines.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2..

","Examples
To create connectors at nodes 1, 2 and
        3:*createmark nodes 1 1 2 3
*CE_ConnectorCreate nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1299,*CE_ConnectorCreateByAutopitch,"Description
Create connectors using autopitch points, obtained by flange detection techniques.
","
Inputs



entity_type

The entity types to find flanges in, to create connectors. Valid values are
            components.

mark_id

The mark ID containing the entities. Valid values are 1 and 2.

feature_angle

Used to identify each connected sequence of feature edges. Specifically, a feature
            edge is one whose adjoining faces form an angle greater than this value. Acceptable
            values are [0.0, 180], otherwise closer extreme is used.

consider_thin_solids

0 - Closed shell thin solids are not considered as input. Only standard shell
            midmeshes are considered.
1 - Closed shell thin solids are considered as input, along with standard shell
            midmeshes.

max_flange_width

The maximum flange width. Used only if it is greater than 0.0.

max_proximity_distance

The maximum proximity distance that can be used. Also, used as the tolerance value for
            connector creation.

autopitch_interval

Spacing between autopitch points. Points are not created if set to 0.0.

autopitch_offset

The initial offset for autopitch point. If set to 0.0,
              autopitch_interval/2 is used.

autopitch_to_edge_distance

The distance from the free edge for autopitch points.

create_points_in_middle

0 - Autopitch points are created on one of the flanges
1 - Autopitch points are created at the midplane of flanges

max_variation_percent

The maximum percentage variation allowed in inter-flange distances, from the average
            inter-flange distance.

","Examples
To create connectors at the midplane of the components 1 and 2 using a feature angle of 30
        degrees, not considering closed shell thin solids as input, maximum flange width of 20.0,
        maximum proximity distance of 20.0, autopitch interval of 50.0, offset of 10.0, and a
        distance from free edge of 10.0:
*createmark comps 2 1 2
*CE_ConnectorCreateByAutopitch components 2 30 0 20.0 20.0 50.0 10.0 10.0 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1300,*CE_ConnectorCreateByList,"Description
Creates a certain style of connector at locations specified by a list, with certain rules
        and details.
","Inputs

entity_type
The entity type that specifies the location to create connectors. Valid values
            are:
Lines (for seam and area).
Nodes (for spot, bolt, seam and area).
list_id
The ID of the list containing the entities. Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are area, bolt, seam and spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are comps and surfs.
link_mark_id
The ID of the mark containing the link entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. Valid parameters include:
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default).
1 - Offset connectors.
line_spacing=<value>
The spacing for spot or seam connectors on lines. Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elements (elems) or geometry (geom). Default is
                  elems.
link_rule=<value>
The link rule. Valid values are now, at_fe_realize or none. Default is
                  none.
relink_rule=<value>
The relink rule. Valid values are id, name or none. Default is none.
seam_area_group=<value>
Group flag for seam or area connector. 
0 - No (default).
1 - Yes.
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
0 - Do not offset tol (default).
1 - Use tol.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To create a seam connector at the location of line 10 to connect component 3 and 4 using a
        tolerance of
        6.0:*createlist lines 1 10
*createmark components 2 3 4
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.000000""
*CE_ConnectorCreateByList lines 1 ""seam"" 2 comps 2 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1301,*CE_ConnectorCreateByListWithCC,"Description
Creates a connector from a list and assigns a connectorcontrol/connectorcontroldefault.
","
Inputs


entity_type
The entity type that specifies the location to create connectors. Valid values
            are:
elems (for area)
lines (for spot, bolt, seam and area)
nodes (for spot, bolt and apply_mass)
points (for spot, bolt and apply_mass)
surfs (for area).
list_id
The ID of the list containing the entities.  Valid values are 1 and 2.
ce_style
The style of connectors to create. Valid values are apply_mass, area, bolt, seam, and
            spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are:
comps (for spot, bolt, seam, area or apply_mass)
elems (for spot or apply_mass)
nodes (for spot or apply_mass)
surfs (for spot, seam or area)
tags (for spot or apply_mass)
link_mark_id
The ID of the mark of link entities.  Valid values are 1 and 2.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
area_mesh_size=<value>
The mesh size for area connectors when entity_type is surfs.
                  Default 10.0.
area_mesh_type=<value>
The mesh type for area connectors when entity_type is
                  surfs.
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default)
1 - Offset connectors
line_spacing=<value>
The spacing for spot or seam connectors on lines.  Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elems (default) or geom.
link_rule=<value>
Specifies the link rule. Valid values are now, at_fe_realize or none
                  (default).
relink_rule=<value>
Specifies the relink rule. Valid values are id, name or none (default).
seam_area_group=<value>
Flag for seam or area connector grouping:
0 - No (default)
1 - Yes
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
Flag for seam or area connector grouping:
0 - Do not use tol (default)
1 - Use tol


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
cc_type
The type of control to assign.  Valid values are connectorcontrol and
            connectorcontroldefault.
cc_name
The name of the connectorcontrol/connectorcontroldefault to assign.

","Examples
Create a seam connector at the location of line 10 to connect component 3 and 4 using a
        tolerance of 6.0 and assign connectorcontrol
        seam_quad_ltb:*createlist lines 1 10
*createmark components 2 3 4
*createstringarray 5 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.000000""
*CE_ConnectorCreateByListWithCC lines 1 ""seam"" 2 comps 2 1 5 connectorcontrol ""seam_quad_ltb""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1302,*CE_ConnectorCreateByMarkAndRealizeWithDetails,"Description
Create a certain style of connectors at locations specified by mark using certain rules and
        details, and realize them using specified details.
","Inputs

entitytype
The type of specified location(s). Possible options depend on the type of connector:
points
Valid for Spot, Bolt, and Apply Mass connectors.
nodes
Valid for Spot, Bolt, and Apply Mass connectors.
lines
Valid for Spot, Bolt, and Seam connectors.
elems
Valid only for Area connectors.
surfs
Valid only for Area connectors.


entitymark
Mark containing the list of points, nodes, lines, elems, or surfs.
ce_style
Style of connectors. Valid options are:
spot 
bolt
apply_mass
seam
area


num_ents
Number of links.
linkentity
Type of link entity:
elems
Valid for Spot or Apply_mass connectors.


nodes
Valid for Spot or Apply_mass connectors.


comps
Valid for Spot, Bolt, Apply_mass, Seam, or Area connectors.


surfs
Valid for Spot, Seam, or Area connectors.


tags
Valid for Spot or Apply_Mass connectors.


linkentmark
The mark containing the link entities.
solvername
The target solver for realization.
config
The element type for realization:
2 - plot 
3 - weld 
5 - rigid 
21 - spring 
55 - rigidlink 
60 - bar2 
61 - rod 
70 - gap 
104 - quads 
1001 - custom


fe_type
The type ID for the current solver specified in the FEconfig
            file. Only used for custom config (1001).
tolerance
The maximum distance allowed between the connector (on mark) and each of its links
            during realization.
options
The string array to specify optional details for creation:


Detail
Description
Default Value




area_mesh_type
Mesh type for area connectors when using SURFS as the location: 
0 = Trias 
1 = Quads 
2 = Mixed 
3 = Right trias


1


area_mesh_size
Mesh size for area connectors when using SURFS as the location.
10.0


link_elems_geom
Connecting element (elems) or geometry (geom).
elems


link_rule
Link rule: 
now
at_fe_realize
none


none


relink_rule
Relink rule: 
id
name
none


none


tol_flag
Indicates whether to use tolerance.
0 = Yes
1 = No


0


tol
Add entities as links only within this distance of the specified
                      location.
0.0


line_spacing
Spacing for spot or seam connectors on lines.
1.0


line_density
Density for spot or seam connectors on lines.
0


line_offset_flag
Indicates whether to offset connector.
0 = Yes
1 = No


0


line_offset
Offset value from the ends of line for spot or seam connectors.
0.0


seam_area_group
Group flag for seam or area connector.
0 = No
1 = Yes


0


area_width
Width of area connectors created from node lists or line lists.
1.0


area_offset
Offset area connnector(s) created from node or line lists from the
                      selected location by this value.
0.0


ce_propertyid
Property ID value.
0


ce_systems
Build system flag.
0 = No
1 = Yes


0


ce_connectivity
Connectivity type: 
0 - Mesh independent 
1 - Mesh dependent + remesh 
2 - Mesh dependent + ensure projection 
3 - Mesh dependent + quad transition 
4 - Mesh dependent + projection and find nodes 
5 - Mesh dependent + find nearest nodes


0


ce_forcecollinear
Collinear flag: 
0 = Non-collinear 
1 = Collinear


0


ce_nonnormal
Non-normal projection flag.
0 = Normal 
1 = Non-normal


0


ce_diameter
Diameter value for some custom types (acm, cweld, mat100, etc.)
0


ce_areathicknesstype
Thickness type for area connector: 
0 = (T1+T2)/2 
1 = Shell gap 
2 = Mid thickness 
3 = Const thickness


0


ce_areaconstthickness
Constant thickness value for area connector.
0.0


ce_areastacksize
Density for area connector.
0


ce_boltmindiameter
Minimum diameter for a hole to be accepted as a bolt hole.
0.0


ce_boltmaxdiameter
Maximum diameter for a hole to be accepted as a bolt hole.
10.0


ce_appliedmass
Mass value for apply massx
0.0


ce_appliedmassdis
Mass distribution type for apply mass:
0 = Apply to all nodes. 
1 = Divide by nodes. 
2 = Divide by area. 
3 = Unit area.


0


ce_configfile
fe configuration file.
""""


ce_dvstfile
Diameter vs. thickness file.
""""


ce_propertyscript
Property script file.
""""


ce_fevectorrevers
Reverse direction flag for seam connectors: 
0 = No reverse 
1 = Reverse


0





options_ size
The size of the options string array.

","Examples
To create a spot connector at the location of node 10 to connect component 3 and 4 using
        rigid
        element.*createmark(nodes,1) 10
*createmark(components,2) 3, 4
*createstringarray(8) ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=6.000000"" ""ce_systems=0"" ""ce_connectivity=0"" ""ce_nonnormal=0"" 
*CE_ConnectorCreateByMarkAndRealizeWithDetails(Nodes, 1, ""spot"", 2, Comps, 2, ""natsran"", 5, 0, 6.0, 1, 8)
",
1303,*CE_ConnectorCreateWithRules,"Description
Creates connector(s) at the specified location(s) with defined rules.
","Inputs

entities
Types that specify location of connector(s).
Nodes
Points


markmask
The mark for nodes or points.
entity
The entity type to be added to the connector as a link:
nodes
elems
tags
surfs
comps


entitymark
Mark of entities to add to the connector as links.
ent_state
Specifies whether geometry or FE gets precedence during realization of connector.
            Applicable to components and surfaces only. 
0 - geoms
1 - elems


ce_rules
Rule to specify if and how a link entity is to be added to a connector.
0 - none
1 - now
2 - at fe realize


ce_le_rule
Rule that specifies how an entity is to be remembered by the connector.
0 - none
1 - use ID
2 - use name


tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.


tolerance
Specified to add entities only with in the given tolerance from the specified
            connector (same as search radius in fe realize panel).
num_ents
Total number of entities to add/update connector (connectors thickness (2T, 3T, etc.)
            value). 

","Examples
Create a connector at point 1 and add nearest 2 of the four components specified within a
        tolerance of 1.0. Components need to be connected through elements in them and not geometry
        if connector is realized. Remember the components by their IDs.
        *createmark(points, 1) 1
*createmark(components, 2) 21 23 24 27
*CE_ConnectorCreateWithRules(points, 1, components, 2, 1, 1, 1, 1, 1.0, 2)
Created connector is displayed as a cylinder and only the closest two components are added
        to it. The total number of layers defined at the connector is 2.
",
1304,*CE_ConnectorGroupCreateAndOrganizeConnectors,"Description
Create new connector group(s) and reorganize connector(s) inside them based on criteria
        given.
","
Inputs



entity_type

Must be set to connectorgroups.

criteria

The criteria used for creating new connector group and reorganizing connector. Valid
            values are:
1 - Create one connector group per link combination
3 - Create one connector group per Include

delete_cleared_groups

0 - Do not delete empty connector gropus
1 - Delete empty connector groups

organize_all_ces

0 - Reorganize only ungrouped connectors
1 - Reorganize all connectors

","Examples
To auto reorganize all connectors based on criteria 1 (one connector group per link
        combination) and delete empty connector groups:
*CE_ConnectorGroupCreateAndOrganizeConnectors CONNECTORGROUPS 1 1 1
To auto reorganize only ungrouped connectors based on criteria 3 (one connector group per
        include) and keep empty connector groups:
*CE_ConnectorGroupCreateAndOrganizeConnectors CONNECTORGROUPS 3 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1305,*CE_ConnectorLineCombineWithCC,"Description
Combines multiple line connectors to a single line connector and assigns a connector
        control.  In addition, the internal lines (within the connectors) are merged into a single
        internal line.
","
Inputs


mark_id
The ID of the mark of connectors.  Valid values are 1 and 2.
entity_type
The entity type that specifies the location to create connectors. Valid values are
            lines.
entity_mark_id
The ID of the mark containing the entities.  Valid values are 1 and 2.  If specified,
            set entity_list_id as 0.
entity_list_id
The ID of the list containing the entities.  Valid values are 1 and 2.  If specified,
            set entity_mark_id as 0.
ce_style
The style of connectors to create. Valid values are apply_mass, area, bolt, seam, and
            spot.
num_links
The number of links to use.
link_entity_type
The type of entity to create links for. Valid values are:
comps (for spot, bolt, seam, area or apply_mass)
elems (for spot or apply_mass)
nodes (for spot or apply_mass)
surfs (for spot, seam or area)
tags (for spot or apply_mass)
link_mark_id
The ID of the mark of link entities.  Valid values are 1 and 2.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
area_mesh_size=<value>
The mesh size for area connectors when entity_type is surfs.
                  Default 10.0.
area_mesh_type=<value>
The mesh type for area connectors when entity_type is
                  surfs.
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
area_offset=<value>
Offset area connectors created from node or line lists from the selected
                  location by this value. Default 0.0.
area_width=<value>
Width of area connectors created from node or line lists. Default 1.0.
line_combine_option=<value>
The combine option for combining the two or more line
                    connectors:combine_smooth – Combines lines/connector with smooth
                    curve
combine_straight – Combines lines/connectors with straight
                    curve
combine_midline – Combines two lines/connectors as one midline
                    connector

line_density=<value>
The density for spot or seam connectors on lines. Default 0.0.
line_offset=<value>
Offset value from the ends of the line for spot or seam connectors on lines.
                  Default 0.0.
line_offset_flag=<value>
0 - Do not offset connectors (default)
1 - Offset connectors
line_spacing=<value>
The spacing for spot or seam connectors on lines.  Default 1.0.
link_elems_geom=<value>
Specifies whether to connect elems (default) or geom.
link_rule=<value>
Specifies the link rule. Valid values are now, at_fe_realize or none
                  (default).
relink_rule=<value>
Specifies the relink rule. Valid values are id, name or none (default).
seam_area_group=<value>
Flag for seam or area connector grouping:
0 - No (default)
1 - Yes
tol=<value>
Add entities as links only within this distance of the specified location.
                  Default 0.0.
tol_flag=<value>
Flag for seam or area connector grouping:
0 - Do not use tol (default)
1 - Use tol


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
cc_type
The type of control to assign.  Valid values are connectorcontrol and
            connectorcontroldefault.
cc_name
The name of the connectorcontrol/connectorcontroldefault to assign.

","Examples
To combine spot line connectors 1 and 2, lines 3 and 4, and components links 1, 2, 3 and 4
        with combine_smooth
        option:*CE_FE_CreateDCC 1
*CE_FE_CreateUCCFromDCC ""connectorcontrol1"" ""plot_spot_template""
*createmark connectors 1 1 2
*createmark lines 1 3 4
*createmark comps 2 3 4
*createstringarray 9 ""link_elems_geom=elems"" ""link_rule=now"" ""relink_rule=none"" ""tol_flag=1"" ""tol=99.0"" ""line_density=0"" ""line_spacing=5.000000"" ""line_offset=0.000000"" ""line_combine_option=combine_smooth""
*CE_ConnectorLineCombineWithCC 1 lines 1 1 spot 2 comps 2 1 9 connectorcontrols connectorcontrol1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1306,*CE_ConnectorLineCreateWithRules,"Description
Creates connector(s) at the specified location(s) with defined rules.
","Inputs

entities
Types that specify location of connectors.
Lines
markmask
The mark for lines.
density
Integer number to split line into number of points. Spacing between points (=
            line_length/density).
spacing
Float number to split line into number of points with specified distance between
            points (= spacing).
half_spacing_offset
Create points from an offset (= spacing/2) from the start and end of line.
offset
Create points from an offset (= offset) from the start and end of line.
entity
Type of entity to be added to the connector as a link.
nodes
elems
tags
surfs
comps


entitymark
Mark of entities to add to the connector as links.
ent_state
Specifies whether geometry or FE has precedence during realization of connector.
            Applicable to components and surfaces only.
0 - geoms
1 - elems


ce_rules
Rule to specify if and how a link entity is to be added to a connector.
0 - none
1 - now
2 - at fe realize


ce_le_rule
Rule that specifies how an entity is to be remembered by the connector.
0 - None
1 - Use ID
2 - Use name


tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.


tolerance
Specified to add entities only with in the given tolerance from the specified
            connector (same as search radius in fe realize panel).
num_ents
Number of entities to add/update for a connector (connectors thickness (2T, 3T, etc.)
            value).

","Examples
Create a connector at line 1 with spacing of 2.0 and
        half_spacing_offset, and add nearest two of the four components specified
        within a tolerance of 1.0. If the connector is realized, components must be connected
        through their elements rather than geometry. Remember the components by their IDs.
        *createmark(lines, 1) 1
*createmark(components, 2) 21 23 24 27
*CE_ConnectorLineCreateWithRules(points, 1, 0, 2.0, 1, 0.0, components, 2, 1, 1, 1, 1, 1.0, 2)
A created connector is displayed as a cylinder at the center of the line and only the
        closest two components are added to it. The total number of layers defined at the connector
        is two.
",
1307,*CE_ConnectorRemoveDuplicates,"Description
Deletes connectors that are considered to be duplicates of other connectors within a given
        tolerance.
","Inputs

markMask
The mark mask (1 or 2).
tolerance
The maximum distance between two connectors that are considered to be duplicates.

","Examples
To delete duplicate connectors on the mark mask 1 within 0.05
        tolerance:*CE_ConnectorRemoveDuplicates(1, 0.05)
Currently only supported for connectors located at geometric points.
",
1308,*CE_ConnectorSeamCreateUsingLines,"Description
Create seam connectors at specified locations by line list with certain rules.
","Inputs

entities
Types that specify location of connectors (currently only ""lines"").
markmask
The mark of lines.
density
Split the line into this number of evenly-spaced points.
spacing
Split line into points with this distance between them.
entity
Entity type to be added to the connector as a link.
surfs
comps


entitymark
Mark of entities to add to the connector as links.
ent_state
Link elements or geometry.
0 - geometry
1 - elements


ce_rules
Rule to specify how a link entity is to be added to a connector.
0 - None
1 - User select
2 - Proximity


ce_le_rule
Rule that specifies how an entity is to be remembered by the connector.
0 - None
1 - Use ID
2 - Use name


tol_flag
Specifies if tolerance value is applicable.
0 - Use default.
1 - Use specified value.


tolerance
Specified to add entities only with in the given tolerance from the specified
            connector (same as search radius in fe realize panel).
group
Specifies if the individual connectors created from continuous line segments must be
            grouped to behave as a single connector.
0 - Not grouped
1 - Grouped


param1
For future use; only ""0"" is currently valid.
param2
For future use; only ""0"" is currently valid.

","Examples
To create 2 seam connectors at the locations of line 1 and 2 to link components 3 and
        4:*createmark(Lines, 1) 1, 2
*createmark(Comps, 2) 3, 4
*CE_ConnectorSeamCreateUsingLines(Lines, 1, 5, 0.0, Comps, 2, 1, 1, 1, 1, 10.0, 1, 0, 0.0)
This command is outdated, and *CE_ConnectorCreateByMark() is recommanded
        to be used for creating seam connector. 
A created seam connector is displayed as a line with cylinder like icons at each of the
        test points (at the specified spacing) with the closest components added to it. The total
        number of layers supported by seam connector is two.
",
1309,*CE_ConnectorSetVectorById,"Description
Sets the projection vector for a connector specified by ID.
","Inputs

ce_id
The connector entity ID.
type
The method used to set the vector:
0 - Use i, j, and k values (see arguments below). These should be specified as
                the next 3 arguments to this command. 
1- Requires a HyperMesh vector id (see vector below)
                from which the vector i, j, and k will be taken internally. The i, j, and k syntax
                arguments can be set as 0. 
2 - Requires the two node id’s (node1 and node2 below) as the last two arguments
                to this command. These node ID’s will be required to create a vector, and assigned
                to the ce_id. The rest of the above arguments can be set as 0.
                These two nodes should not be coincident. 


i
1st of 3 float numbers defining a vector. Only applies when type is
            set to 0.
j
2nd of 3 float numbers defining a vector. Only applies when type is
            set to 0.
k
3rd of 3 float numbers defining a vector. Only applies when type is
            set to 0.
vector
HyperMesh Vector entity ID. Only applies when
              type is set to 1.
node1
1st node ID to define a vector in HyperMesh. Only applies
            when type is set to 2.
node2
2nd node ID to define a vector in HyperMesh. Only applies
            when type is set to 2.

","Examples
To set a projection vector for connector 1 using vector
        3:*CE_ConnectorSetVectorById(1, 1, 0, 0, 0, 3, 0, 0)
The connector’s projection vector will be used during the realization process.
",
1310,*CE_ConnectorSpotTrim,"Description
Trims/splits spot line connectors using nodes.
","
Inputs


mark_id
The ID of the mark of connectors. Valid values are 1 and 2.
node_mark_id
The ID of the mark of nodes. Valid values are 1 and 2.
tolerance
The tolerance value used to snap the nodes to the point of spot connectors when
              snap is 1.
snap
0 - Do not snap nodes to spot connectors
1 - Snap nodes to spot connectors
mode
0 - Split
1 - Trim

","Examples
To split spot connector 101 using node 1001:
*createmark connectors 1 101
*createmark nodes 1 1001
*CE_ConnectorSpotTrim 1 1 0.5 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1311,*CE_ConnectorUpdateByCC,"Description
Updates connectors using a connector control or connector control default.
","
Inputs


mark_id
The ID of the mark of connectors.  Valid values are 1 and 2.
name
The name of the connector control or connector control default to use.
entity_type
The type of entity to use.  Valid values are connectorcontrol and
            connectorcontroldefault.

","Examples
Update connectors 101, 102, 103 using the connector control named ""my_acm"":
*createmark connectors 1 101 102 103
*CE_FE_ConnectorUpdateByCC 1 ""my_acm"" connectorcontrol
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1312,*CE_ConvertByMark_new,"Description
Converts several spot or bolt connectors into a spotline or boltlline.
","Inputs

mark_id
The ID of the mark containing the connectors to convert. Valid values are 1 and 2.
source_style
The source connector style ""spot"" or ""bolt"".
target_style
The target connector style ""spotline"" or ""boltline"".
tolerance
The maximum distance between locations.
angle
The maximum angle between locations to create the line.
unrealize_flag
0 - Do not unrealize the new connectors 
1 - Unrealize the new connectors
combine_within_comp_only
0 - Combine connectors across components 
1 - Combine connectors only within the same component

","Example
To combine spot connectors 101, 102 and 103 to spotline connectors:
*createmark connectors 1 101 102 103
*CE_ConvertByMark_new 1 ""spot"" ""spotline"" 15.0 10.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1313,*CE_CreateNodeOnSeamConnector,"Description
Creates a node on a seam connector at a given position.  This node can then be used to trim
        the seam connector at that location. To create a node with a mouse click on a connector, the
          x, y, and z values should all be
        passed as -1.
","
Inputs


mark_id
The ID of the mark of seam connectors to trim.  Valid values are 1 and 2.
x
The x position on the seam connector.
y
The y position on the seam connector.
z
The z position on the seam connector.

","Examples
To create a temp node on seam connector 101 at (100, 50,
        50):*createmark connectors 1 101
*CE_CreateNodeOnSeamConnector 1 100 50 50
To create a temp node on seam connector 101 at a mouse click
        position:*createmark connectors 1 101
*CE_CreateNodeOnSeamConnector 1 -1 -1 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1314,*CE_DetailDelete,"Description
Delete connector details (stored in connector metadata) from connectors specified by
        ID.
","Inputs

ce_id
ID of the connector to delete details from.
detailType
Detail type to delete: 
int
uint
double
string
triple
detailName
The name of the detail to delete.
unknownFlag
For future use (must be 0).

","Examples
To delete user-defined integer details named ""test"" for connector
        2:*CE_DetailDelete 2 int ""test"" 0
",
1315,*CE_DetailsCopy,"Description
Copy realization details from a connector to a list of connectors.
","
Inputs



id

The ID of the connector to copy from.

mark_id

The ID of the mark of connectors to copy to.  Valid values are 1 and 2.

reserved

Reserved for future use. Must be set to 0.

","Examples
To copy realization details from connector 1001 to connectors 1002, 1003, 1004:
*createmark connectors 1 1002 1003 1004
*CE_DetailsCopy 1001 1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1316,*CE_DetailSetDoubleByMark,"Description
Sets a double connector detail for a mark of connectors.
","Inputs

mark_id
The ID of mark containing the connectors to update. Valid values are 1 and 2.
detail_name
The name of the standard double detail, or user-defined double detail to update. See
              *CE_DetailSetDouble for valid details.
double_value
The double value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the tolerance to 10.0 for connectors 1, 2 and
        3:*createmark connectors 1 1 2 3
*CE_DetailSetDoubleByMark 1 ce_tolerance 10.0 0 0
To set a user-defined double detail ""test"" to a value of 5.0 for connectors 2 and
        3:*createmark connectors 1 2 3
*CE_DetailSetDoubleByMark 1 ""test"" 5.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1317,*CE_DetailSetIntByMark,"Description
Sets an integer connector detail for a mark of connectors.
","Inputs

mark_id
The ID of mark containing the connectors to update. Valid values are 1 and 2.
detail_name
The name of the standard integer detail, or user-defined integer detail, to update.
            See *CE_DetailSetInt for valid details.
integer_value
The integer value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the thickness (number of layers) to 3 for connectors 1, 2 and
        3:*createmark connectors 1 1 2 3
*CE_DetailSetIntByMark 1 ce_layers 3 0 0
To set a user-defined integer detail ""test"" to a value of 5 for connectors 2 and
        3:*createmark connectors 1 2 3
*CE_DetailSetIntByMark 1 ""test"" 5 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1318,*CE_DetailSetStringByMark,"Description
Sets a string connector detail for a mark of connectors.
","Inputs

mark_id
The ID of mark containing the connectors to update. Valid values are 1 and 2.
detail_name
The name of the standard string detail, or user-defined string detail, to update. See
              *CE_DetailSetString for valid details.
string_value
The string value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the user property script for connectors 1, 2, 3, and
        4:*createmark connectors 1 1 2 3 4
*CE_DetailSetStringByMark 1 ce_propertyscript ""C:/temp/scripts/connectors/test.tcl"" 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1319,*CE_DetailSetTripleByMark,"Description
Sets a triple connector detail for a mark of connectors.
","Inputs

mark_id
The ID of mark containing the connectors to update. Valid values are 1 and 2.
detail_name
The name of the standard triple detail, or user-defined triple detail, to update. See
              *CE_DetailSetTriple for valid details.
triple_value1
The first triple value to update for the detail.
triple_value2
The second triple value to update for the detail.
triple_value3
The third triple value to update for the detail.
reserved
Reserved for future use. Must be set to 0.
force_storage
0 - Do not store user-defined detail.
1 - Store user-defined detail.

","Examples
To set the projection vector to (0.0, 1.0, 0.0) for connectors 1, 2 and
        3:*createmark connectors 1 1 2 3
*CE_DetailSetTripleByMark 1 ce_ijk 0.0 1.0 0.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1320,*CE_DetailSetUintByMark,"Description
Sets an unsigned integer as connector detail for a connector specified by ID.
","Inputs

markmask
Mark containing the connectors to attach details to.
detailName
Name for a user-defined unsigned integer detail.
unit_val
The unsigned integer value for the detail.
unknownFlag
Reserved for future use. Must be set to 0.
force_storage_flag
The flag indicating whether or not to store a user-defined detail.
1 = yes 
0 = no



","Examples
To set a user-defined unsigned integer detail ""test = 2.0"" for connectors 1, 2, 3, and
        4:*createmark(connectors, 1) 1, 2, 3, 4
*CE_DetailSetUintByMark(1, ""test"", 2.0, 0, 1)
There are currently no standard unsigned integer details, only user-defined ones.
",
1321,*CE_ErrorSet,"Description
This command assigns a pre-defined error to a connector.
","Inputs

id
The ID of the connector.
error_code
The error code to assign to the connector. Valid values are:
0 - CE_ERROR_UNDEFINED 
1 - CE_ERROR_PROJECTIONS_LACKING 
2 - CE_ERROR_LINKS_UNRESOLVED 
3 - CE_ERROR_INCOMPLETE_REALIZATION 
4 - CE_ERROR_INCOMPATIBLE_FECONFIG 
5 - CE_ERROR_NO_TEST_POINT 
11 - CE_ERROR_LINK_LACKING_THICKNESS 
51 - CE_ERROR_AREA_LACKING_MESH 
61 - CE_ERROR_BOLT_HOLE_NOT_FOUND 
62 - CE_ERROR_BOLT_HOLE_LACKING 
63 - CE_ERROR_OVERLAP_1D_ELEM 
71 - CE_ERROR_MESH_IMPRINT_INCOMPLETE 
72 - CE_ERROR_MESH_IMPRINT_ACROSS_FEATURE 
73 - CE_ERROR_MESH_IMPRINT_OVERLAP_WITH_ITSELF 
74 - CE_ERROR_MESH_IMPRINT_EXTREME_CASE 
75 - CE_ERROR_MESH_IMPRINT_MISSING_ELEMS 
76 - CE_ERROR_MESH_IMPRINT_OVERLAP_WITH_OTHER 
77 - CE_ERROR_LESS_HEXA_HEIGHT 
78 - CE_ERROR_CUSTOM 
79 - CE_ERROR_MESH_IMPRINT_FAILED 
80 - CE_ERROR_NSM_PROPERTY_NOT_POSSIBLE



","Examples
To assign error code 80 to connector ID 10:*CE_ErrorSet 10 80
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1322,*CE_ExportFiles,"Description
This command exports selected connectors to their original files in original formats or
        specified format. The exported connectors file in XML format can be viewed either in an
        internet browser or in XML notepad. The ASCII or VIP format
        file can be viewed in any text viewer.
","Inputs

mark_id
The ID of the mark containing the connectors to export. Valid values are 1 and 2.
ce_style
Filter the specific type of connector to exported. Valid values are: 
all
spot
bolt
apply_mass
seam
area


option
Specifies the output format: 
0 - original format 
1 - ASCII

3 - XML 
4 - VIP 
5 - XML 2.0 
6 - XML 2.0 (version A) 
7 - XML 2.0 (version B)


reserved1
Reserved for future use. Must be set to """".
reserved2
Reserved for future use. Must be set to 0.
reserved3
Reserved for future use. Must be set to 0.

","Examples
To export all of the displayed connectors in XML format to their original
        files:*createmark connectors 1 ""displayed""
*CE_ExportFile 1 ""all"" 3 """" 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1323,*CE_ExportOneFile,"Description
This command exports selected connectors which belong to a specified original file to the
        file in original format or specified format. The exported connectors file in XML format can
        be viewed either in an internet browser or in XML notepad. The ASCII or VIP format file can be viewed in any text viewer.
","Inputs

mark_id
The ID of the mark containing the connectors to export. Valid values are 1 and 2.
ce_style
Filter the specific type of connector to exported. Valid values are: 
all
spot
bolt
apply_mass
seam
area


filename
The full path and filename of the original file.
option
Specifies the output format: 
0 - Original format 
1 - ASCII

3 - XML 
4 - VIP 
5 - XML 2.0 
6 - XML 2.0 (version A) 
7 - XML 2.0 (version B)


reserved1
Reserved for future use. Must be set to """".
reserved2
Reserved for future use. Must be set to 0.
reserved3
Reserved for future use. Must be set to 0.

","Examples
To export all of the displayed connectors which belong to
          C:/ce_info.xml in XML
        format:*createmark connectors 1 ""displayed""
*CE_ExportOneFile 1 ""all"" ""C:/ce_info.xml"" 3 """" 0 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1324,*CE_FE_3DQuality,"Description
Checks the quality of 3D elements (welds) created by realizing connector entity (CE). It
        places all failed connectors on an output mark and highlights them.
","Inputs

ce_inmark
Mark of displayed connectors.
entities
Only quality checks for Elements are now supported.
outputmark
All connectors that contain FE (welds) that failed quality check criteria are placed
            on this mark. Mark only connectors.
length_flag
Check if the length of FE (welds) exceeds a certain value specified by the
              length parameter. 
1 - turned on 
length
The value of the length of the weld that should not be exceeded. Used in conjunction
            with length_flag.
jacobian_flag
Check if the Jacobian of the FE (3D welds) exceeds the value specified by the
              jacobian parameter. 
1 - turned on
jacobian
The value of the Jacobian of the 3D weld that should not be exceeded. Used in
            conjunction with jacobian_flag.

","Examples
To check all the quality options of FE (3D weld elements) in a realized connector with IDs
        1, 2, and 3. Let the value of length be 3.0 and the
          jacobian value be 0.7. The failed connectors are placed on mark 2 and
        highlighted.
        *createmark(connectors,1) 1 2 3
*CE_FE_3DQuality(1,elements,2,1,3.0,1,0.7)

",
1325,*CE_FE_AutoRegisterSharedEntitiesByMark,"Description
Auto register pre-existing entities to multiple connectors.
Notes:
A single entity can be registered with multiple connectors. This will register
            pre-existing entities shared by multiple connectors’ realizations, contact definitions,
            etc...
Component, property, material, curve, plot, system collector, vector collector and
            load collector are supported for all user-profiles.
Sets and groups are supported for Abaqus, LS-DYNA, OptiStruct, PAM-CRASH and Radioss.
The registered entities could be checked by performing a X-ref on the connectors.


","Inputs

mark_id
The ID of the mark containing the connectors to register to.  Valid values are 1 and
            2.

","Example
Register to connectors 1-10:
*createmark connectors 1 1-10
*CE_FE_AutoRegisterSharedEntitiesByMark 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1326,*CE_FE_CreateUCCFromConnector,"Description
Creates a connector control from a connector.
","
Inputs


cc_name
The name of the connector control to create.
ce_id
The ID of the connector to use.

","Examples
Create a connector control named ""my_acm"" from connector 101:
*CE_FE_CreateUCCFromConnector ""my_acm"" 101
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1327,*CE_FE_CreateUCCFromUCC,"Description
Creates a connector control from another connector control.
","
Inputs


cc_name
The name of the connector control to create.
cc_existing_name
The name of the connector control to use.

","Examples
Create a connector control named ""my_acm1"" from the connector control named ""my_acm"":
*CE_FE_CreateUCCFromUCC ""my_acm_1"" ""my_acm""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1328,*CE_FE_LoadFeConfig,"Description
This command loads or unloads an FE config file.
","Inputs

filename
The full path and filename of the FE config file.
load_option
0 - to unload 
1 - to load
overwrite
Valid only when load_option is 1. 
0 - Skip FE types with names or IDs conflicting with existing ones.
1 - Overwrite existing FE types with names or IDs conflicting with current
                ones.



","Examples
To load the FE config file C:/test/my_feconfig.cfg to overwrite
        existing FE types with those in the
        file:*CE_FE_LoadFeConfig 1 ""C:/test/my_feconfig.cfg"" 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1329,*CE_FE_Register,"Description
Registers pre-existing FE to a single connector ID. Successfully registering pre-existing
        FE forces a connector to its realized state. 
To use this command, a connector must be in user control mode. Also, note that a single FE
        entity can be registered with, at most, a single connector. Any FE registered with a given
        connector is treated as part of that connector’s realization.
","Inputs

id
The ID of the connector to register to.
testpoint_idx
The connector sub-index in which to register this FE. A connector line with a density
            of three has three sub-indices (0-2), and a connector point has a single sub-index
            (0).
entity_type_string_array
The ID of the string array that contains the additional entity type names. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Supported types are elements, systems, vectors, loads and equations. This array should
            either map 1-to-1 with id_integer_array, or it should only have a
            single index in which case all the IDs would be of the same type.
number_of_entity_types
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
id_integer_array
The ID of the integer array that contains the entity IDs. The integer array is created
            using the *createarray command. This should always be set to 1.
number_of_ids
Integer indicating the size (number of integers) in the integer array created using
              *createarray.

","Examples
First, change connector 7 to the user control
        mode:*CE_SetSpecificDetailById 7 2 1 0.0
Second, create the necessary
        arrays:*createstringarray 3 ""systems"" ""elements"" ""systems""
*createarray 3 30 2127 31
Third, call the CE_FE_Register function for connector
        7:*CE_FE_Register 7 0 1 3 1 3
Finally, turn the user control mode off for connector 7
        (optional):*CE_SetSpecificDetailById 7 2 0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1330,*CE_FE_RegisterSharedEntities,"Description
Registers pre-existing entities to a single connector.
Note that a single entity can be registered with multiple connectors.
","Inputs

connector_id
The ID of the connector to register to.
entity_type_string_array
The ID of the string array containing the additional entity types to register.  The
            array is created using the *createstringarray command.  This should
            always be set to 1.
This array should either map one-to-one with id_integer_array or it
            should have a single index indicating all of the IDs are of the same entity type.
number_of_strings
Integer indicating the size (number of entity types) in the string array created using
              *createstringarray.
id_integer_array
The ID of the integer array containing the entity IDs to register.  The array is
            created using the *createarray command.  This should always be set to
            1.
number_of_integers
Integer indicating the size (number of IDs) in the integer array created using
              *createarray.

","Example
Change connector 10 to the user-control mode:
*CE_SetSpecificDetailById 10 2 1 0;
Create the necessary arrays to register component 3, property 7, material 8, set 12 and
        group 14:
*createstringarray 5 ""component"" ""property"" ""material"" ""set"" ""group"";
*createarray 5 3 7 8 12 14;
Register the entities with connector 10:
*CE_FE_RegisterSharedEntities 10 1 5 1 5;
Change connector 10 back to normal control mode (optional):
*CE_SetSpecificDetailById 10 2 0 0;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1331,*CE_FE_SetCommonDetails,"Description
Sets common parameters required to realize connectors as welds. 
Using this command in scripts is not advised, unless absolutely necessary. Future support
        may change for this command.
The feconfig.cfg and DiameterMappingTable.txt
        files are the only parameters that this command still sets. The diameter can now be set on a
        per-connector basis with *CE_DetailSetDouble or
          *CE_DetailSetDoubleByMark. If the configuration type used in the
          feconfig.cfg file has a property script associated with it (in the
        *post line), then that property script is used during the connector realization. However, to
        set a property script on a connector that does not refer to a feconfig configuration type,
        use *CE_DetailSetString or *CE_DetailSetStringByMark. 
Alternatively, all of these variables can be set in the
          *CE_FE_RealizeWithDetails command, which is generally the preferred
        option for most scripting needs.
","Inputs

string_array
The ID of the string array that contains the input data. The string array is created
            using the *createstringarray command. This should always be set to
            1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
reserved
Reserved for future use. Must be set to 0.

","Examples
Set the common parameters required for realizing
        connectors:*createmark connectors 2 ""all""
set path [file nativename [hm_info -appinfo HMBIN_DIR]]
*createstringarray 2 ""$path/feconfig.cfg"" ""$path/DiameterMappingTable.txt""
*CE_FE_SetCommonDetails 1 2 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1332,*CE_FE_SetDetailsAndRealize,"Description
Set FE realization details for the connector(s) on mark and realize them with welds. 
","Inputs

connector_mark
The mark of connectors that needs to be updated.
config
Weld element type.
2 - plot 
3 - weld 
5 - rigid 
21 - spring 
55 - rigidlink 
60 - bar2 
61 - rod 
70 - gap 
104 - quads 
1001 - custom


tolerance
The maximum distance allowed between the connector (on mark) and the entity (on mark)
            in order to create welds.
property_id
ID of property collector. Used to retrieve property specified for connector.
systems
Systems flag.
1 - Build systems
0 - Do NOT build systems
snap_to_node
Force weld to use one of the element connectivity nodes rather than create a new
            node.
remesh
Specifies if the welded region needs to be re-meshed. 
0 - Do not re-mesh
1 - Re-mesh region
force_collinear
Force all the welds along all layers to be collinear.
0 - Non-collinear welds
1 - Collinear welds
diameter
Diameter value to be used, if the dvstfile is not specified.
fe_type
The FE type for the current solver specified in the FE. Configuration file for custom
            FE only.
file_name
The dvstfile, feconfig file and property scripts to be set.
num_strings
Number of files specified through the above string.

","Examples
Set the required properties for the connectors 1, 2 and 3 on mark and FE realize
        them.*createmark(connectors, 1) 1 2 3
* CE_FE_SetDetailsAndRealize(1, 60, 1.0, 2, 51, 1, 1, 0, 1, 0.0, 0, """", 0)
This sets the FE data and also realizes the connectors at one shot. The connectors state is
        marked as realized and are displayed as green colored cylinders. The
          dvstfile, property script and config file are used for certain weld
        types only. The dvstfile and property script can be used to create
        specific property cards for welds. The FE configuration file is for custom welds only.
",
1333,*CE_FE_SetSpecificDetailById,"Description
Changes a single FE detail for a connector specified by ID.
","Inputs

ce_id
The desired connector’s ID.
detail_type
The number of a detail:


Detail:
#
Range:
Meaning:




config
1
>0
FE configuration type of the realized connector


 
 
2
plot


 
 
3
weld


 
 
5
rigid


 
 
21

spring


 
 

5
5

rigidlink


 
 
60

bar2


 
 
61

rod


 
 

7
0

gap


 
 
10
4

quads


 
 
10
0
1

custom


tolerance
2
>=0.0
Tolerance value for FE realization.


property_ID
3
>0
FE property ID


systems
4
0,1
Build system flag:0=do not build systems
1=build
                      systems



snap_to_node
5
0,1
FE snap to node flag0= do not snap to node
1= snap to
                      node



remesh
6
0,1
FE remesh flag


force_collinear
7
0,1
FE force collinear flag: 0 = non-collinear
1 =
                      collinear



fe_type
8
>0
FE type value defined in the feconfig.cfg
                      file


non_normal
9
0,1
Nonnormal projection:0 = normal
1 = nonnormal



allow_adjacent
10

0,1
Allow adjacent projection:0= don’t allow
1= allow



solver
11

>=0
Solver type for FE realization


fevector_reverse
15

0,1
Vector reverse flag for seam connector


trim_surf_each_side
16

0,1
Flag to trim surf at each side for area connectors


connectivity
17

0,1,2
Connectivity type:0 = independent
1 = dependent
2 = use
                        shell node



area_thick
31

0,1,2,3
Area connector thickness type:0 = (T1+T2)/2
1 = shell
                        gap
2 = mid thickness
3 = const thickness



area_const_thick
32

>0.0
Constant thickness for area connectors.


area_stack_size
33

>=0
Density for area connectors.


bolt_min_dia
41

>=0.0
Minimum diameter for bolt hole.


bolt_max_dia
42

>=0.0
Maximum bolt hole diameter.


app_mass_mass
51

>=0.0
Mass for applied masses.


app_mass_dis
52

0,1,2,3
Applied mass distribution type:0= all nodes 
1= divide by
                        nodes
2= divide by area
3= unit area






int_val
The value for integer details.
dbl_val
The value for details with decimals.

","Examples
To set tolerance to 10.0 for connector 3:
        *CE_FE_SetSpecificDetailById(3, 2, 0, 10.0)
Details with decimals in the listed ""range"" use the dbl_val while
        details without them use the int_val. 
This command is outdated. The following commands are recommended for the purpose of setting
        details for connectors:
*CE_DetailSetDouble

*CE_DetailSetInt

*CE_DetailSetString

*CE_DetailSetTriple

*CE_DetailSetUint



",
1334,*CE_FE_UCCUpdateUseConnector,"Description
Updates a connector control using a connector.
","
Inputs


cc_name
The name of the connector control to update.
ccd_name
The ID of the connector to use.

Comment.
","Examples
Update a connector control named ""my_acm"" from connector 101:
*CE_FE_UCCUpdateUseConnector ""my_acm"" 101
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1335,*CE_FE_UnregisterSharedEntitiesByMark,"Description
Un-register registered entities from multiple connectors.
This will only remove the references of the entities from the connectors. This will not
        delete the actual entities. This sets the connectors to the modified state after the
        un-registration.
","Inputs

mark_id
The ID of the mark containing the connectors to register to.  Valid values are 1 and
            2.

","Example
Un-register from connectors 1-10:
*createmark connectors 1 1-10
*CE_FE_UnregisterSharedEntitiesByMark 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1336,*CE_GlobalSetInt,"Description
This command sets global integer parameters to control the display of connectors.
","Inputs

name
The name of the parameter to set:
g_ce_colorby
Determines the connector coloring:
0 - by state 
1 - by component 
2 - by layer 
3 - by style


Range: 0 - 3
g_ce_realizedvis
Turn off/on realized connectors
Range: 0, 1
g_ce_unrealizedvis
Turn off/on unrealized connectors.
Range: 0, 1
g_ce_failedvis
Turn off/on failed connectors.
Range: 0, 1
g_ce_modifiedvis
Turn off/on modified connectors.
Range: 0, 1
g_ce_lt2tvis
Turn off/on connectors with fewer than 2 layers.
Range: 0, 1
g_ce_2tvis
Turn off/on connectors with 2 layers.
Range: 0, 1
g_ce_3tvis
Turn off/on connectors with fewer than 3 layers.
Range: 0, 1
g_ce_gt3tvis
Turn off/on connectors with 3 layers.
Range: 0, 1
g_ce_spotvis
Turn off/on spot connectors.
Range: 0, 1
g_ce_seamvis
Turn off/on seam connectors.
Range: 0, 1
g_ce_areavis
Turn off/on area connectors.
Range: 0, 1
g_ce_boltvis
Turn off/on bolt connectors.
Range: 0, 1
g_ce_applymassvis
Turn off/on apply mass connectors.
Range: 0, 1
g_skip_imprint
Skip the imprint run and places the imprint elements in a separate component
                  when set to 1.
Range: 0, 1
g_do_strict_imprint
Resolve conflicts during the mesh imprint when set to 1.
Range: 0, 1
g_do_keep_snap
Snap to an edge or feature during mesh imprint when set to 1.
Range: 0, 1
g_ce_boltcylinderdisplaystatus
Display status:
0 - Bold on 
1 - Bolt dynamic 
2 - Bolt off


Range: 0 - 2
g_ce_boltcylinderdisplaytransparency
Set the transparency for the bolt cylinder.
Range: 0 - 10


value



","Examples

*CE_GlobalSetInt g_ce_colorby 1

",
1337,*CE_MarkCombineLinks,"Description
Combine the individual/group links into a single group link.
","
Inputs



mark_id

The ID of the mark of connectors to combine.  Valid values are 1 and 2.

search_type

The specific link type to search in the connector.

search_rule

The rule by which the link entity was added to the connector:
0 - Undefined 
1 - None 
2 - Use ID
3 - Use Name
4 - Proximity 
5 - Use UID

update_state

The update state of the links desired to be grouped:
0 - Undefined 
1 - Elems
2 - Geom 

search_string_array

A string array containing the list of of link IDs/names/UIDs need to be combined into
            a group, created using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            search_rule.

search_number_of_strings

Integer indicating the size (number of strings) in the
              search_string_array created using
              *createstringarray.

keep_realized

Option to keep the current connector state after the update operation:
0 - Unrealize if needed (default)
1 - Keep current state

","Examples
To combine the component link IDs 1,2,3 and 4 of the connector IDs 2 and 5 into a group
        link:
*createmark connectors 1 2 5
*createstringarray 4 1 2 3 4
*CE_MarkCombineLinks 1 comps 1 2 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1338,*CE_MarkRemoveLinkMark,"Description
Remove link entities of a specific type and ID or name from the connectors on mark.
","
Inputs



mark_id

The ID of mark for the connectors to be modified. Valie values are 1 or 2.

link_type

Specific link type to search in the connector. 

link_mark_id

The ID of mark for the links to be removed. Valie values are 1 or 2.

update_layer_option

Option to update the number of layers after removing links from the connectors:
0 - Do not update
1 - Update number of layers for connectors

","Examples
To remove component with ID 3 from connectors with IDs 1,2 and 4:
*createmark connectors 1 1 2 4
*createmark components 2 component3
*CE_MarkRemoveLinkMark 1 components 2 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1339,*CE_MarkSplitLink,"Description
Split group links into individual links.
","
Inputs



mark_id

The ID of the mark of connectors to split.  Valid values are 1 and 2.

search_type

The specific link type to search in the connector.

search_rule

The rule by which the link entity was added to the connector:
0 - Undefined 
1 - None 
2 - Use ID
3 - Use Name
4 - Proximity 
5 - Use UID

search_string_array

A string array containing the list of of link IDs/names/UIDs in the group link,
            created using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            search_rule.

search_number_of_strings

Integer indicating the size (number of strings) in the
              search_string_array created using
              *createstringarray.

keep_realized

Option to keep the current connector state after the update operation:
0 - Unrealize if needed (default)
1 - Keep current state

","Examples
To split the group link of 3 components consisting of component IDs: 1, 2 and 4 in
        connector ID 5:
*createmark connectors 1 5
*createstringarray 3 1 2 4
*CE_MarkSplitLink 1 comps 1 1 3 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1340,*CE_MarkUpdateLinkGroup,"Description
Allows search and replace of existing link information in the specified connector mark with
        new link information.
","Inputs

mark_id
Mark of connectors.
search_type
The entity type to search in the connector. This must be specified. The supported
            entities are comps, props, assems, surfs, tags, elems, nodes and parts.
search_rule
The rule by which the link entity was added to the connector. The following codes
            define the different rules:
0 - Undefined
1 - None
2 - Use ID
3 - Use name
4 - Proximity
5 - Use UID
The rule must be specified to perform a search.
replace_type
The type of entity that replaces the found link entity
            (search_type) in the connector. If not specified, the entity type
            information is not replaced for the found link (replace_type =
              search_type). The supported types are the same as that for
              search_type.
replace_rule
The rule to set for the found link entity. All the rules supported for
              search_rule parameters are supported.
search_list_and_update_list_string_array
A string array created using *createstringarray, containing the list of search
            IDs/names/UIDs, and the list of replace IDs/names/UIDs. This must be set to 1.
The string has two pieces:
1)  The first part is a search list of IDs/names/UIDs based on the
              search_rule.
2)  The second part is a replace list of IDs/names/UIDs based on the
              replace_rule.
total_string_array_length
The total number of strings in the string array (search list + replace list). 
search_list_length
The number of strings/items in the search list.  The replace list length =
              total_string_array_length -
            search_list_length.
replace_state
The flag to set for the link entity that specifies if you are connecting to mesh or to
            geometry. The supported values are:
0 - Undefined
1 - Connect to mesh 
2 - Connect to geometry
?keep_current_state?
Optional option to keep the current connector state after the update operation. Valid
            states are:
0 - Unrealize if needed (default)
1 - Keep current state
At most, one of the ""replace"" data must be specified to see a change in the link
            attributes. If the replace data exactly matches the search data, the connector is not
            unrealized and no change is made to the link entity.

","Example
To replace component 1 with component group (3 and 4) across all displayed connectors:
*createmark connectors 1 ""displayed"";
set search_list [list 1];
set replace_list [list 3 4];
set string_list [concat $search_list $replace_list];
set total_length [llength $string_list];
set search_length [llength $search_list];
eval *createstringarray $total_length $string_list;
*CE_MarkUpdateLinkGroup 1 comps 2 comps 2 1 $total_length $search_length 0 0;
To replace component group (1 and 2) with component group (3 and 4) across all displayed
        connectors:
*createmark connectors 1 ""displayed"";
set search_list [list 1 2];
set replace_list [list 3 4];
set string_list [concat $search_list $replace_list];
set total_length [llength $string_list];
set search_length [llength $search_list];
eval *createstringarray $total_length $string_list;
*CE_MarkUpdateLinkGroup 1 comps 2 comps 2 1 $total_length $search_length 0 0;
To update the link rule of component group (1 and 2) to ""use name"" across all displayed
        connectors:
*createmark connectors 1 ""displayed"";
set search_list [list 1 2];
set replace_list [list];
set string_list [concat $search_list $replace_list];
set total_length [llength $string_list];
set search_length [llength $search_list];
eval *createstringarray $total_length $string_list;
*CE_MarkUpdateLinkGroup 1 comps 2 comps 3 1 $total_length $search_length 0 0;
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1341,*CE_PositionConnectors,"Description
Positions connectors to the middle point or back to the source location.
","Inputs

mark_id
The ID of the mark containing the connectors to modify.  Valid values are 1 and
            2.
center_source
0 - Position to center
1 - Position to source
upon_state
0 - Unrealize
1 - Rerealize

","Example
To position connectors to middle point and unrealize them:
*createmark connectors 1 all
*CE_PositionConnectors 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1342,*CE_PreviewCombine,"Description
Find connectors that need to be combined and place them on the output mark.
","Inputs

outputmark
Connector mark to be populated.
tolerance
Search radius to find combinations.

","Examples
Connectors found inside a tolerance of 0.5 will be populated on the output mark 1 if they
        meet all the requirements to be combined.
        *CE_PreviewCombine(1, 0.5)
This command works similar to the preview empty or preview unused options in the HyperMesh Delete panel. The output mark should not contain any
        connectors prior to calling this command. The preview combine feature highlights all
        connectors that need conversion (two 2T connectors that share certain common information to
        a single 3T connector) within the specified tolerance.
",
1343,*CE_ProjectionCheck,"Description
Check quality of projections with connectors.
","Inputs

ce_inmark
Mark including connectors to be checked.
ce_outmark
Mark including failed connectors.
length_flag
0 - Use T1+T2/2 as checking length.
1 - Use length as checking length.
length
The value of checking length, only be used when length_flag
            =1.
length_tol
The allowable variation in projection length compared to the value for
              length.
checking_type
0 - Check too long.
1 - Check too short.
2 - Check both too long and too short.
future1
Not presently used. 
future2
Not presently used. 
future3
Not presently used. 

","Examples
Connectors marked will be checked if they are too long with respect to length 10.0, with
        tolerance 0.2, and failed connectors will be placed on mark
        2:*createmark connectors 1 all
*CE_ProjectionCheck 1 2 1 10.0 0.2 0 0 0 0
hm_getmark connectors 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1344,*CE_Realize,"Description
FE realize all the defined connectors on mark (creates FE). 
","Inputs

markmask
The mark of connectors that needs to be updated.

","Examples
FE realize the connectors 1 and 2 on mark 1.
        *createmark(connectors, 1) 1 2
*CE_Realize(1)
This command should be called only after the *CE_FE_SetDetails command.
        The connector state is set to realized and the connectors are displayed as green
        cylinders.
",
1345,*CE_ReviewConnectorCollectors,"Description
Review connectors according to user options according to collector.
","
Inputs



collector_type

The collector type for the connectors. Currently only supported for
            connectorgroup.

mark_id

The ID of the mark to review.  Valid values are 1 and 2.

operation_type

The string for the type of operation to be performed:
hide
isolate
isolateonly
show

string_array

A string array containing any additional input parameters, created
              using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            link_rule.



consider_geom=<value>

Defines if geometry is also considered along with elements during
                  show/hide/isolate operations. Valid values are true and false.

consider_HAZ_elems=<value>

Defines if HAZ (Heat Affected Zone) elements should also be considered during
                  show/hide/isolate operations. The possible values are true and false.

filter_projection_entities=<value>

Filters links to the projection entities during show/hide/isolate operations,
                  according to following options which are possible values:
0 - None
1 - Projection components
2 - Projection elements
3 - Projection and attached elements



number_of_strings

Integer indicating the size (number of strings) in the string_array
            created using *createstringarray.

output_mark

The ID of the mark onto which reviewed entities are placed.  Valid values are 1 and
            2.

","Examples
To isolate connector 1 and 2 from within connector groups and place the reviewed entities
        on mark 2:
*createmark connectorgroups 1 ""by id only"" 1 2
*createstringarray 1 ""consider_HAZ_elems=true""
*CE_ReviewConnectorCollectors connectorgroups 1 isolate 1 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1346,*CE_ReviewConnectors,"Description
Review connectors according to user options.
","
Inputs



mark_id

The ID of the mark to review.  Valid values are 1 and 2.

operation_type

The string for the type of operation to be performed:
findlinks
hide
isolate
isolateonly
show
To operate on twin connectors:
twince_hide
twince_isolate
twince_isolateonly
twince_show

string_array

A string array containing any additional input parameters, created
              using*createstringarray. This must be set to 1.
The strings are generally IDs/names/UIDs based on the
            link_rule.



consider_geom=<value>

Defines if geometry is also considered along with elements during
                  show/hide/isolate operations. Valid values are true and false.

consider_HAZ_elems=<value>

Defines if HAZ (Heat Affected Zone) elements should also be considered during
                  show/hide/isolate operations. The possible values are true and false.

find_twince_option=<value>

Find twin connectors according to:
1 - Minimum two links
2 - Exact links

filter_projection_entities=<value>

Filters links to the projection entities during show/hide/isolate operations,
                  according to following options which are possible values:
0 - None
1 - Projection components
2 - Projection elements
3 - Projection and attached elements



number_of_strings

Integer indicating the size (number of strings) in the string_array
            created using *createstringarray.

output_mark

The ID of the mark onto which reviewed entities are placed.  Valid values are 1 and
            2.

","Examples
To isolate connector with ID 5:
*createmark connectors 1 5
*createstringarray 1 ""consider_HAZ_elems=true""
*CE_ReviewConnectors 1 isolate 1 2 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1347,*CE_SetGlobalSharedEntitySettings,"Description
Set the global shared entity management settings.
","Inputs

setting
The name of the setting to update.
auto_register
Auto-register shared entities to the connectors during connector realization, HM
                  binary import, solver deck import and FE absorb.
sharedent_cleanup_delete
Cleanup shared entities during connector+FE deletion.
sharedent_cleanup_unrealize
Cleanup shared entities during connector unrealization.


value
0 - Turn off
1 - Turn on

","Example
To turn on auto-registration:
*CE_SetGlobalSharedEntitySettings ""auto_register"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1348,*CE_SetSpecificDetail,"Description
Sets a specific detail for all the connectors on the mark.
Note: A connector must be in user control mode in order to edit the state.
Note: If the connector is in the unrealized state it can only be set to the failed
        state.
Note: If the connector is in the realized, modified, failed or unconfirmed state it cannot be
        set to the unrealized state.
","Inputs

ce_mark
Mark of connectors.
detail_type
The number for the connector detail you are editing:
Generic Connector Details:
1 = thickness (integer) 
2 = user control (integer: 0 or 1) 
3 = state (integer: 0 = unrealized, 1 = realized, 2 = failed, 3 = modified, 4 =
                unconfirmed)


Connector Line Details:
101 = spacing (double) 
102 = density (integer) 
103 = offset (double) 
104 = half spacing (integer: 0 or 1)


int_val
Pass necessary integers values through this parameter.
dbl_val
Pass necessary double values through this parameter.

","Examples
To change the thickness of the connectors on mark 1 from 2T to
        3T:*createmark connectors 1 ""displayed""
*CE_SetSpecificDetail 1 1 3 0.0
To change the spacing for a connector with ID 10 and 11 created at a line to
        5.0:*createmark connectors 1 10 11
*CE_SetSpecificDetail 1 101 0 5.0
",
1349,*CE_Unrealize,"Description
FE unrealize all the defined connectors on mark (removes all created FE).
","Inputs

mark_id
The mark of connectors that needs to be unrealized.

","Examples
FE unrealize the connectors 1 and 2 on mark
        1:*createmark connectors 1 1 2
*CE_Unrealize 1
This command should be called only after the *CE_FE_SetDetails command.
        The connector state is set to unrealized and the connectors are displayed in yellow.
",
1350,*CE_UpdateLink,"Description
Allows search and replace of an existing link in the specified connector with a new link
        entity. 
","Inputs

id
The connector ID to update.
search_type
The entity type to search in the connector. This must be specified. The supported
            entities are comps, props, assems, surfs, tags, elems, nodes and parts.
search_id
The link entity ID to replace in the connector. The ID is optional only if one of the
            following is true:
3 - Use name
4 - Proximity
5 - Use UID
search_name
The name of the link entity to replace in the connector. The name is optional only if
            one of the following is true:
1 - None
2 - Use ID
4 - Proximity
5 - Use UID
?search_rule?
The rule by which the link entity was added to the connector. The following codes
            define the different rules:
0 - Undefined
1 - None
2 - Use ID
3 - Use name
4 - Proximity
5 - Use UID
If the rule is specified, the entity search is performed in accordance with the rule.
            For example, a search_rule of 2 requires
            search_id.
?replace_type?
The type of entity that replaces the found link entity
            (search_type) in the connector. If not specified, the entity type
            information is not replaced for the found link (replace_type =
              search_type). The supported types are the same as that for
              search_type.
?replace_id?
The entity ID that replaces the found link entity. If not specified, the entity ID
            information is not replaced for the found link (replace_id =
              search_id).
?replace_name?
The entity Name that replaces the found link entity. If not specified, the entity name
            information is not replaced for the found link (replace_name =
              search_name).
?replace_rule?
The rule to set for the found link entity. All the rules supported for
              search_rule parameters are supported.
?replace_state?
The flag to set for the link entity that specifies if you are connecting to mesh or to
            geometry. The supported values are:
0 - Undefined
1 - Connect to mesh 
2 - Connect to geometry
?keep_current_state?
Optional option to keep the current connector state after the update operation. Valid
            states are:
0 - Unrealize if needed (default)
1 - Keep current state
At most, one of the ""replace"" data must be specified to see a change in the link
            attributes. If the replace data exactly matches the search data, the connector is not
            unrealized and no change is made to the link entity.
?search_uid?
The UID of the link entity to replace in the connector. The UID is optional, only if
              search_rule is 1, 2, 3 or 4.
?replace_uid?
The entity UID that replaces the found link entity. If not specified, the entity UID
            information is not replaced for the found link (replace_uid =
              search_uid).

","Examples
To replace component ID 10 with component ID 20 for connector ID
        1:*CE_UpdateLink 1 comps 10 """" 0 0 20 """" 0 0
To replace component name ""comp1"" with component name ""bumper"" for connector ID
        1:*CE_UpdateLink 1 comps 0 ""comp1"" 0 0 0 ""bumper"" 0 0
To replace use-id with use-name rule for component ID 10 for connector ID
        1:*CE_UpdateLink 1 comps 10 """" 2 0 0 """" 3 0
To replace the state for component ID 10 in connector ID 1 from ""connect to elems"" to
        ""connect to geom"":*CE_UpdateLink 1 comps 10 """" 0 0 0 """" 0 2
Note: In all the above cases, the connector entity is unrealized and any existing welds are
        removed from the connector. At most, one of the ""replace"" data must be specified to see a
        change in the link attributes. If the replace data exactly match the search data, the
        connector is not unrealized and no change is made to the link entity. 
",
1351,*change_edgedensities,"Description
This command changes the densities of selected surface edges and remeshes the adjacent
        surfaces, according to the specified mode. This is an automesh function.
","Inputs

mark_id
The ID of the mark containing surface edges.
mode
The method used to assign the density to the surface edges:
1 - Set edge density to the density value.
2 - Increment/decrement the edge density by the density value.
                A positive density will increment while a negative density will decrement. 
3 - Set edge density to be the same as on reference edge
                  refedge.


density
The density value to assign to the surface edges on mark_id. Valid
            with mode 1 and 2.
refedge
ID of edge used when mode =3.

","Examples
To set edge density to 10 on edge with ID
        208:*createmark lines 1 208
*change_edgedensities 1 1 10 0
To increment by 1 density on edge with ID
        208:*createmark lines 1 208
*change_edgedensities 1 2 1 0
To decrement by 2 densities on edges with ID 208 and
        209:*createmark lines 1 208 209
*change_edgedensities 1 2 -2 0

To set density on edges with ids 229, 222 and 219 same as on edge with ID 211, use the
        command:*createmark lines 1 229 222 219
*change_edgedensities 1 3 0 211
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1352,*check_symmetric_surfaces,"Description
Checks whether a selection of surfaces is symmetric. Optionally, the transformation can be
        supplied. The transformation can be supplied as a translation, a rotation, or a 4x4
        transformation matrix. If not supplied, the transformation is computed internally. The
        tolerance for matching the mesh can also be supplied. If not given, the global geometry
        cleanup tolerance is used instead. The global node tolerance is used for the computation. If
        the surfaces deviate on the number of fixed points, it can fix the target surfaces by adding
        or suppressing fixed points.
The output information is logged into two global Tcl arguments:
          g_hw_argc and g_hw_argv. These can be accessed after
        the execution of the command. 
If a transformation was not supplied to the command, the internally computed transformation
        is logged in terms of translation and rotation. It also contains the general status of the
        command (whether the surfaces are symmetric or not).
","Inputs

entity_type
The type of source/target entity. Currently only supported for surfaces.
mark_id_source
The ID of the source mark of entities. Valid values are 1 and 2.
mark_id_target
The ID of the target mark of entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
rotation:
angle: <angle in degrees> 
axis: <axis, x component> <axis, y component > <axis, z component > 
base: <base, x component> < base, y component > < base, z component
                  >
tolerance:
<value> 
transformation:
<tr11> <tr12> <tr13> <tr14> <tr21> <tr22> <tr23> <tr24>
                  <tr31> <tr32> <tr33> <tr34> <tr41> <tr42> <tr43>
                  <tr44>
translation:
<x component> <y component > <z component>


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To check if surfaces with ID’s 10 and 20 are symmetric with a translation along the y
        direction, and a rotation of 90 degrees along the global
        y-axis:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 {{translation: 0 1 0} {rotation: angle :90 axis : 0 1 0 base: 0 0 0}}
*check_symmetric_surfaces surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
To do the check using a custom tolerance and transformation
        matrix:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""transformation: 0 0 1 0 0 1 0 0 -1 0 0 0 2.5 0 12.5 1"" ""tolerance: 0.1""
*check_symmetric_surfaces surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
To do the check by auto-detecting the
        transformation:*createmark surfs 1 10
*createmark surfs 2 20
*createstringarray 2 ""tolerance: 0.1""
*check_symmetric_surfaces surfs 1 2 1 2
if { [info exists g_hw_argc] } {
    foreach outMessage $g_hw_argv {
        puts $outMessage
    }
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1353,*cleanup_unoffsetable_nodes,"Description
Smooths the area around any unoffsetable nodes to attempt to make them offsetable. Useful
        for CFD BL meshing.
Consider a node and all its surrounding elements. The visibility angle of an element is the
        signed angle between the node normal and the element normal after subtracting 90 degrees.
        The visibility angle of the node is the minimum of the element visibility angle for all
        surrounding elements. The best visibility angle of the node is the maximum of the node
        visibility angle for all choices on the node normal. A node having zero or negative best
        visibility angle is considered absolutely unoffsetable. A node having its best visibility
        angle less than angle_threshold is considered unoffsetable.
","Inputs

entity_type
The type of entity used as input. Valid values are comps and elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
angle_threshold
 A value ≥ 0.0 and < 45.0 that defines the threshold visibility angle in degrees
            for determining a node is unoffsetable.
layers
Defines the number of adjacent layers to consider for the smoothing. Must be ≥ 1. A
            value between 1 and 3 is generally recommended.
iters
The number of smoothing iterations to perform. Must be ≥ 1. A value between 1 and 5 is
            generally recommended.

","Examples
To fix unofsettable nodes for elements 10-13, using an angle of 2.5, using 2 layers and 3
        smoothing
        iterations:*createmark elements 1 10-13
*cleanup_unoffsetable_nodes elems 1 2.5 2 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1354,*clearallidranges,"Description
Clears all ID ranges for various portions of a model.
","Inputs

id_or_type
The submodel ID or entity type, depending on the requested mode.
mode
bymodel - Clear all ID ranges in the whole model.
bysubmodel - Clear all ID ranges in a submodel.
byentities - Clear all ID ranges on an entity type in the whole model.
byexcludedmodel - Clear all excluded IDs in the whole model.
byexcludedsubmodel - Clear all excluded IDs in a submodel.
byexcludedentities - Clear all excluded IDs on an entity type in the whole model.

","Examples
To clear all ID ranges for the whole
        model:*clearallidrange 0 bymodel
To clear all ID ranges for an
        include:*clearallidrange $include_id bysubmodel
To clear ID ranges for all comps in the
        model:*clearallidrange comps byentities
To clear all excluded IDs in the whole
        model:*clearallidrange 0 byexcludedmodel
To clear all excluded IDs in an
        include*clearallidrange $include_id byexcludedsubmodel
To clear excluded in an entity type cross the
        model:*clearallidrange groups byexcludedentities
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1355,*clearallunresolvedids,"Description
When importing a file that references entities that are in another file that is not
        imported at the same time, those entities are recorded and protected from overwrite so that
        the links will not be lost. This way, fragments of a larger model can be edited while
        keeping links to the other parts of the model intact. 
If another fragment of the larger model containing some of the unresolved references is
        imported, HyperMesh will complete the links between the two
        model fragments and remove the protected entity IDs from the unresolved IDs database. 
If you wish to discard all of those links for a certain entity type, this command will
        clear the unresolved IDs from the database for that entity type.
Normally, the feinput system handles everything automatically. Therefore, the need to use
        this command is very rare and is provided for situations that need to exactly target the
        creation of new entities to fulfill the unresolved links.
","Inputs

entity_type
The type of entity to remove unresolved IDs for.

","Examples
To remove all unresolved IDs for
        properties:*clearallunresolvedids props
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1356,*clearlock,"Description
This command clears all entity locks for a specified entity type.
","Inputs

entity_type
The type of entity to clear locks for.
dataname
The dataname to clear locks for. Currently only supported for ""ID"".

","Examples
To clear ID locks for all elements:*clearlock elems id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1357,*clearmark,"Description
This command clears all entity IDs of the passed entity type from the specified mark.
","Inputs

entity_type
The type of entity mark to clear.
mark_id
The mark ID. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to clear the mark from.  If not specified, the current model is
            used.

","Examples
To clear the components on mark 2 before creating a new
        mark:*clearmark comps 2
*createmark comps 2 all
To clear the components on mark 2 for model model-2 before creating a new
        mark:*clearmark comps 2 ""by model"" model-2
*createmark comps 2 ""by model"" model-2 all
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1358,*clearpreservednodes,"Description
This command clears the selected nodes that were marked as preserved.
","Inputs

mark_id
The ID of the mark containing the preserved nodes to clear. Valid values are 1 and 2.

","Examples
To clear preserved nodes
        1-4:*createmark nodes 1-4
*clearpreservednodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1359,*clearunusedunresolvedids,"Description
Audits the list of unresolved ID references and discards any which are no longer needed. 
Suppose you have a property that refers to a material with ID=17, but that material is not
        presently defined in the database. HyperMesh will preserve that
        slot in the database as an unresolved ID, so that you won’t accidentally overwrite it and
        corrupt that reference. If, in the future, you import a solver deck file that includes a
        definition for that material, the property will automatically now refer to it, resolving the
        reference. 
Instead, if you delete the property, and no other entity in the database refers to that
        material, then HyperMesh doesn’t need to preserve a slot for
        some future material with ID=17. It continues to preserve the slot, on the assumption that
        material will eventually be defined for the model you are working on.
","Inputs

entity_type
The type of entity to update the unresolved ID list for.

","Examples
To discard unresolved material IDs, that are no longer required by any entity currently
        defined in the model:*clearunusedunresolvedids materials
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1360,*coarsening_mesh,"Description
Performs mesh coarsening on selected components. The ability exists to specify sacred nodes
        that will be maintained after coarsening.
","Inputs

comps_mark_id
The ID of the mark containing the input components. This must also include any 1D
            multi-leg rigid elements that will be processed by the update_rigids
            option. Valid values are 1 and 2..
nodes_mark_id
The ID of the mark containing any nodes to be treated as sacred/fixed. These nodes
            must belong to the initial mesh. These nodes will be maintained during coarsening. Valid values are 1 and 2.
failed_comps_mark_id
The ID of the mark to store any failed components. Valid values are 1 and 2.
This mark can then be passed to *decimate_mesh for further
            processing.
elem_size
The element size to use for coarsening. This must be larger than the initial mesh
            size.
elem_type
Flag indicating the element type to generate for the coarsened mesh. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


feature_angle
This specifies the maximum angle between the normals of two connected elements. This
            value is ignored for shell elements. For 3D elements, the appropriate free faces of
            shell elements are created and meshed with the given feature angle. This value is also
            used to construct the connected edges for the failed components. Then these components
            are coarsened/decimated in a second attempt. 
If this value is less than 1.0, the default value of 85.0 degrees is used.
max_diameter
This option specifies the maximum hole diameter that will be filled by the coarsening
            operation. The default value is 0.0 (do not fill any holes).
options
Flags that specify various methods of pre-processing and post-processing of 1D and 2D
            elements.  Bit values are used and the value is calculated as (Bit0 + 2*Bit1 +
              4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6). 
Bit0
0 - Do not utilize this option.
1 - All selected 1D element paths not sharing sacred nodes must be deleted
                  before mesh coarsening. 1D elements paths comprising sacred nodes are preserved.
                  Unselected 1D elements are ignored. Preserved 1D elements which are not free
                  should be attached to the shell mesh after coarsening..


Bit1
0 - Do not utilize this option.
1 - Selected 1D elements that appear free (are not attached to the shell or
                  solid mesh) after mesh coarsening must be deleted after meshing. 1D elements
                  sharing sacred nodes must be preserved.


Bit2
0 - Do not utilize this option.
1 - Selected 1D multi-leg elements having free legs after meshing (are not
                  attached to shell or solid mesh) must be updated by deleting the free legs.


Bit3
0 - Do not utilize this option.
1 - Selected 1D elements remaining after meshing should be converted to plot
                  elements.


Bit4
0 - Do not utilize this option.
1 - Selected 2D elements should be converted to plot elements after meshing.
                  This flag is utilized only for the OptiStruct user
                  profile.


Bit5
0 - Do not utilize this option.
1 - Retain the input mesh, and organize the coarsened mesh into a new
                  component.


Bit6
0 - Do not utilize this option.
1 - Creates 1D plotel elements on coarsened 2D element edges.



","Examples
Create a coarsened mesh with mixed type elements of element size 30 using all components.
        Put failed components on mark ID 2. Keep node IDs 16 and 27 as anchor nodes. Ignore all
        internal loops with diameter less than 65. If the model has solid elements, create free
        faces of shell elements and mesh them with a feature angle of 45 degrees. Delete selected 1D
        elements not sharing sacred nodes before meshing (option Bit0=1). Delete selected free 1D
        elements after meshing (option Bit1=1). If the model has rigidlink/RBE3 elements, delete any
        free legs in the input components (option Bit2=1). Convert 1D elements to plot elements
        after meshing (option Bit3=1). The options are computed as 1 + 2 + 4 + 8 = 15:

*createmark components 1 ""all""
*createmark nodes 1 16 27
*coarsening_mesh 1 1 2 30.0 2 45.0 65.0 15

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1361,*collisioncheck_temp,"Description
Performs a collision detection using the input entities defined by
          hm_collisionentitycreate. This must be preceded by
          hm_collisioninit and one or two calls to
          hm_collisionentitycreate. Multiple calls to this API can be made to
        perform different detections.
This command is a temporary command and may be deprecated in a future release.
","Inputs
The inputs are the same as hm_collisioncheck except for:

pair_results
If set to 0, detailed pair results are not calculated and none of the
              hm_collisionget* APIs can be used (default, same as
              hm_collisioncheck).
If set to 1, detailed pair results are calculated and the
              hm_collisionget* andhm_collisionwriteresultsfile
            APIs can be used (same as hm_collisioncheck). 
If set to 2, additional collision result entities are created that can be rendered in
            the collision browser or used as input of other commands like
              *collisionfix_temp (option not available in
              hm_collisioncheck).
If set to 3, only the collision result entities are created (for browser ,
            *collisionfix_temp...), but not the detailed pair results (for
              hm_collisionget*).  This option is not available for
              hm_collisioncheck, and is only available for the collirad
            engine.
Note that hm_collisionend does not delete any collision result
            entities.  The deletion must be handled using *deletemark.

","Example
To check intersections and penetrations of comps 1001 and 1002, using the nodes of comp
        1002 against the elements of comp 1001 for the penetration check, creating only collision
        result entities:
*createmark comps 1 1001
*createmark comps 2 1002
hm_collisioninit [hm_collisiongetconfig collirad]
hm_collisionentitycreate comps 1 0 1 0.0 0 0 0 0 1
hm_collisionentitycreate comps 2 0 1 0.0 0 0 0 0 2
*collisioncheck_temp 1 1 0 0 1 0 0 90.0 0 0 0.0 3
hm_collisionend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1362,*collisionfix_temp,"Description
Fixes collisions (intersections or penetrations) that have been detected with a call of
          *collisioncheck_temp or *collisioncheck2_temp, by
        automatically moving individual nodes. The collision result entities passed as input get
        updated or deleted, if the fix is successful. This has no effect if the implemented
        algorithm cannot find any appropriate fix.
There are some restrictions regarding the collision result entities that are used as
          input:
Only possible for either intersections or penetrations at a time.  All provided
            collision result entities should have the same ""config"" (otherwise the ones with another
            config than the first one are ignored).
Only possible for one group at a time.  All provided collision result entities have to
            have the same ""parent"" (otherwise the ones with another parent than the first one are
            ignored).


Note that hm_collisionend does not delete any collision result entities.
        The deletion must be handled using *deletemark.
This command is a temporary command and may be deprecated in a future release.
","Inputs

reserved
Reserved for future use.  Must be set to 0.
mark_id
The ID of the mark containing the entities to fix.  Valid values are 1 and 2.
smooth
Used to improve the results of the automatic penetration fix. Valid values are
            integers >= 0. Setting to 0 will apply the built-in default, which has proven to be
            efficient.

","Example
Intersection and penetration fix of all comps in the model, implementing the recommended
        approach to fix penetrations only if there are no intersections:
#Delete potential obsolete collision results
hm_collisionend
*createmark collisions 1 all
if {[hm_marklength collisions 1]} {
    *deletemark collisions 1
}
*clearmarkall 1

*createmark comps 1 all
hm_collisioninit [hm_collisiongetconfig collirad]
hm_collisionentitycreate comps 1 0 2 0.0 0 0 0 0 0

#Intersection check triggered by providing mark_id_int_elems
*collisioncheck_temp 1 0 0 0 0 0 0 90.0 0 0 0.0 2

#Intersection fix if there are intersections
*createmark collisions 1 all
set collision_count [hm_marklength collisions 1]
if {$collision_count} {
    *collisionfix_temp 0 1 0 
    *createmark collisions 1 all
    set collision_count [hm_marklength collisions 1]
}

#Penetration check and fix only if no intersections remain
if {! $collision_count} {
    #Penetration check triggered by providing mark_id_pene_elems
    *collisioncheck_temp 0 1 0 0 0 0 0 90.0 0 0 0.0 2 
    *createmark collisions 1 all
    set collision_count [hm_marklength collisions 1]
    if {$collision_count} {
        *collisionfix_temp 0 1 0
        *createmark collisions 1 all
        set collision_count [hm_marklength collisions 1]
    }
}

#Delete collision results
hm_collisionend
*createmark collisions 1 all
if {[hm_marklength collisions 1]} {
    *deletemark collisions 1
}

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1363,*colormapedit,"Description
Modifies a color in the color map. 
","Inputs

color
The index numbe of the color in the color map.
red
The red component of the color. 
green
The green component of the color. 
blue
The blue component of the color. 

",,
1364,*combineelements,"Description
Combines the selected elements into one. 
","Inputs

mark
The ID of the mark containing the elements to be combined.
tolerance
The maximum tolerance allowed before a node within the group of selected elements is
            considered to be not on the plane formed by any three nodes attached to the group of
            selected elements.
angle
The maximum angle between three nodes which is considered to be a flat side.

","Examples
To combine elements 10, 13, and 15 with an off plane tolerance of 0.1 and a flat angle of
        150.0 degrees:
        *createmark(elements,1) 10 13 15
*combineelements(1,0.1,150.0)
This command is obsolete and is provided only for backward compatibility.
        *combineelements() only works with two-dimensional elements.  
",
1365,*compactsubmodelids,"Description
Renumbers ID ranges starting from the minimum allowed ID.
","Inputs

submodel_type
Submodel type to compact the IDs for. Valid values are includes and includefiles.
id
The ID of the submodel.
entity_type
The type of entity to compact the IDs for. 
0 - all entity types in the submodel are considered.
pool_id
The optional ID of the solver pool.

","Examples
To compact component IDs in include file
        1:*compactsubmodelids includes 1 comps
To compact all entity type IDs in include file
        1:*compactsubmodelids includes 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1366,*compositeanalysis ,"Description
Analyzes composite materials, plies, sequences or laminates.
","
Inputs


entity_type
The type of entity to modify.
<select_type>=<selection>
The entity or entities that are to be analyzed. There are several ways to provide the
            entities to be modified. Only one option can be used at a time:
id=<id>
The ID of the single entity to modify.
name=<name>
The name of the single entity to modify.
mark=<mark_id>
The ID of the mark containing the entities to modify.


result=<value>
The type of result. Valid values are:
23d-behavior - For material or ply analysis
25d-behavior - For sequence or laminate analysis
output=<value>
The file name of the output .csv file.

","Examples
To analyze material with ID 1:
*compositeanalysis mats id=1 result=23d-behavior output=C:/temp/result.csv
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1367,*computeboundarylayerthickness,"Description
This command is used for computing the boundary layer thickness reduction factors based on
        the proximity used for the boundary layer mesh generation. The input to this command is a
        list of wall elements (on which the boundary layer needs to be grown), and another list of
        elements which are not ‘wall’ elements, like inlet, outlet, symmetry, far field, etc.. The
        output is a load collector named ^CFD_BL_Thickness with loads representing the reduction
        factors.
","Inputs

bl_entity_type
Entity type used for the boundary layer input. Valid values are elements and
            components. 
bl_mark_id
The ID of the mark containing the boundary layer input. Valid values are 1 and 2.
non_bl_entity_type
Entity type used for non-boundary layer input. Valid values are elements and
            components. 
non_bl_mark_id
The ID of the mark containing the non-boundary layer input. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. Valid parameters and their syntax are:
cfd: <first_layer_thickness> <number_of_layers> <layer_growth_rate>
                <minimum_core_to_boundary_layer_thickness_ratio>
                <corner_thickness_scaling_factor> <check_for_closure_flag> 
logfile: <log file path>


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To generate thickness reduction factors for the component named wall, with the components
        named inlet and outlet being the non-boundary layer
        elements:*createmark comps 1 wall 
*createmark comps 2 inlet outlet
*createstringarray 1 {{cfd : 0.1 5 1.2 2.0 1.0 1} {logfile: output.txt}}
*computeboundarylayerthickness comps 1 comps 2 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1368,*connect_surfaces_11,"Description
Extends surfaces to meet other surfaces.
","Inputs

source_mark_id
The ID of the mark containing the surfaces to extend. Valid values are 1 and 2.
target_mark_id
The ID of the mark containing the surfaces to target (destination surfaces). Valid values are 1 and 2.
extend_mode
The mode for extending the surfaces. Valid values are:
1 - By distance. 
2 - By thickness ratio. 
3 - Over edges to target surface. 
4 - Over edges by distance. 


trim_mode
The mode for trimming the surfaces. Valid values are:
0 - Do not trim the result.
1 - Trim the result.


distance
The extend distance, if extend_mode = 1. 
Thickness ratio, if extend_mode = 2.
min_angle_to_target_surf
The minimum angle between surfaces that will be considered for extension.
max_angle_edge_to_surf
The maximum angle between an edge and a surface that will be considered for
            extension.
lines_to_extend_over
The ID of the mark containing the edges over which the extension can occur. Valid values are 1 and 2.
guide_mode
The mode for using guide edges. Valid values are:
0 - Do not use guide edges.
1 - Use guide edges.


ignore_guide_edges
The ID of the mark containing the edges to ignore as guide edges. Valid values are 1 and 2.
guide_angle
The minimum angle to use for determining if an edge is a guide edge.
advanced_options
The advanced option settings for surface extension. Bit values are used and the value
            is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5).
Bit0
0 - Do not allow shortening. 
1 - Allow shortening.
Bit1
0 - Do not allow inter-component extensions. 
1 - Allow inter-component extensions.
Bit2
0 - Place result in original components. 
1 - Duplicate input surfaces and place result in ""Extended Surfaces""
                  component.
Bit3
0 - If Bit4=1, place the extended surfaces in the component defined by Bit2. 
1 - If Bit4=1, place the extended surfaces in the current component.
Bit4
0 - Extensions are created using original surfaces. 
1 - Extensions are created using new surfaces.
Bit5
0 - Create a new surface for each edge of the original surface. 
1 - Create a single surface for each original surface.


reserved
Reserved for future use. Must be set to 0.

","Examples
To extend surfaces 2 and 3 by a distance of 5.0, with no advanced
        options:*createmark surfaces 1 2 3
*connect_surfaces_11 1 1 1 1 5.0 15.0 30.0 1 0 1 30.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1369,*contactsurfcreatewithfacesusingfacenumber,"Description
Creates a contact surface using 2D element edges or 2D/3D element faces.
","Inputs

name
The name of the contact surface to create.
color
The color of the contact surface. Valid values are 1 through 64.
mark_id
The ID of the mark that contains the elements to use. Valid values are 1 and 2.
face_number
The face number of the element (starting from 0).
reverse_normals
0 - Create contact surface along element normal. 
1 - Create contact surface opposite element normal.
element_id
The single element ID to use (default is 0).
use_element_id
0 - Use mark_id (default).
1 - Use element_id.

","Examples
To create a contact surface named ""test"" with elements 1-100 using face number
        3:*createmark elems 1 1-100
*contactsurfcreatewithfacesusingfacenumber ""test"" 5 1 3 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1370,*contourplot,"Description
Creates a contour plot from results data. The results file must be loaded before executing
        this command. The *freesimulation command clears the plot.
","Inputs

title
The title to use for the plot.
legend_min
0 - Indicates if the minimum value found in the file should be used as the minimum
            value on the legend. 
1 - Indicates if the legend_min_value argument should be used
            instead.
legend_min_value
If legend_mid is set to 1, the minimum value to display on the
            legend. 
legend_max
0 - Indicates if the maximum value found in the file should be used as the maximum
            value on the legend.
1 - Indicates if the legend_max_value argument should be used
            instead.
legend_max_value
If legend_max is set to 1, the maximum value to display on the
            legend. 
mesh_color
The color used to plot the mesh. Valid values are 1 through 64. 
-1 - Uses the elements color. 
0 - Uses the background color.
scale_factor
The scale factor used for scaling a deformed plot.
full_size
Determines whether the contour plot fills the entire screen. Valid values are:
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return.


reserved
Reserved for future use. Must be set to zero.
vector_comp
Vector data type component to use. Valid values are:
x comp
y comp
z comp
magnitude


mult
The value used to multiply the results values.
min_max_titles
Indicates if the min/max titles should be displayed. Valid values are:
0 - Do not display min/max titles. 
1 - Display min/max titles.


plot_info_title
Indicates if the plot information title should be displayed. Valid values are:
0 - Do not display plot information title. 
1 - Display plot information titles.



","Examples
To load the result file named C:/my_results/test.res and generate a
        contour plot for Subcase 1 with Displacements data type, using the maximum and minimum
        values defined in the analysis file, a mesh color of black, and normal plot
        size*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*contourplot """" 0 0.0 0 0.0 0 0.0 0 0 ""magnitude"" 1.0 0 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1371,*convertbeamsection,"Description
Updates the target solver ID for beamsections.
","Inputs

mark_id
The ID of the mark containing the beamsections to update. Valid values are 1 and 2.
source_solver_id
The ID of the source solver for the specified beamsections. This can be queried using
              hm_getsolver.
target_solver_id
The ID of the target solver for the specified beamsections. This can be queried using
              hm_getsolver.

","Example
To convert beamsections 1-5 from solver ID 2 (Abaqus) to solver
        ID 1 (OptiStruct):*createmark beamsects 1 1-5
*convertbeamsection 1 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1372,*convertlegacyentities,"Description
Converts any of the source legacy entities, in a particular solver interface, to a
        specified target entity.
This is typically used when an old HyperWorks Desktop file has legacy entities
        defined that need to be migrated to a new entity. For example, if there are old HyperWorks Desktop files with ANSYS contacts defined through
        the old Contact Manager via components, by executing this command they will be migrated from
        components to groups. It also updates the existing source entity relationships maintained
        with other entities (that are not converted) with the target entity equivalent.
Supported solver conversions are:
Solver
Source and Target Types


ANSYS
comps, groups


Nastran (MSC)

groups, contactgroups



Note that the solver ID is an implicit input, obtained from the current solver template
        from which this command is executed.
","Inputs

source_entity_type
The type of entity to convert. If there are no source entities of the requested type,
            no conversion is performed.
target_entity_type
The type of entity to convert into.

","Example
To convert ANSYS contact components to groups:
*convertlegacyentities comps groups
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1373,*convertthermalloads,"Description
This command converts thermal loads from one solver to another. Currently it converts *FILM
        and *SFILM loads from Abaqus to PCONV group in OptiStruct. It should be used in conjunction with *setoption
          retain_loads. This command works when the OptiStruct
        template is loaded after the model is imported in Abaqus.
","Inputs

source_solver
The source solver name. Must be set to Abaqus.
target_solver
The target solver name. Must be set to OptiStruct.
source_card
The source card to convert from. Can be either FILM or SFILM.
target_card
The target card to convert to. Must be set to PCONV.

","Example
To convert FILM to PCONV:
*setoption retain_loads=1
*convertthermalloads Abaqus Optistruct FILM PCONV
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1374,*copy_feature,"Description
Copies a selection of elements and pastes them onto the displayed shell elements at the
        target location.  The neighborhood of the pasted region will be remeshed.
","Inputs

entity_type
The type of entity to copy.  Valid values are components and elements.  The selection
            may consist of shell or solid elements. Any 1D elements attached to shell elements are
            automatically included.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
All parameters are case insensitive, order insensitive and optional.  If not supplied,
            the default values will be used. Valid parameters and their syntax are:
NumCopies : <value>
The number of copies to make (default 1).
NumLayers : <value>
The number of layers to remesh (default 2).
MappingMethod : <value>
The method in which the transformed feature's stitch boundary is mapped on to
                  the target mesh:
auto – (default) Decides the best method among extend, morph and none based on
                  the way the selected feature is connected to the the target mesh.
extend – The stitch boundary is extended till it meets the target mesh, or if it
                  already crosses the target mesh, the extended part of the mesh is trimmed out.
                  This is ideal for features that intersects sharply with the target mesh.
morph – The feature is morphed such that the stitch boundary conforms to the
                  target mesh. This is ideal for features that meet the target mesh
                  tangentially.
none - The transformed feature is kept as it is.
Rebuild : <value>
0 - Remesh using size and bias.
1 - Remesh using rebuild (default).
StitchBoundary : <node_id1> <node_id2> … <node_idN-1>
                  <node_idN>
The mesh edges that needs to be extended or trimmed from or morphed to the
                  target mesh, and subsequently be stitched with the target mesh. In most cases the
                  command can deduce which mesh edges are to be extended or morphed. But when it
                  comes to features which already cross the target mesh this needs to supplied so
                  that the command knows where to trim from.
This is a list of node IDs of the involved edges. It expects two node IDs per
                  mesh edge. If there are N edges to be supplied, there should be 2N node IDs in
                  this list. For example:
StitchBoundary: n1 n2 n2 n3 n3 n4.
ToOriginalComponent : <value>
0 - The copied elements are organized in the current component
1 - The copied elements are organized in the original component (default)
TransformByMatrix : <tr11> <tr12> <tr13> <tr14> <tr21> <tr22>
                  <tr23> <tr24> <tr31> <tr32> <tr33> <tr34> <tr41> <tr42>
                  <tr43> <tr44>
The transformation specified as a 4x4 matrix.
TransformByNodes : <sn1> <sn2> <sn3> <tn1> <tn2> <tn3>
The transformation specified between two systems defined at source and target
                  locations. The system at source is defined by three nodes sn1, sn2 and s3. The
                  origin is defined by the node sn1. The x-axis is defined by the vector from sn1 to
                  sn2. The x-y plane is defined as the plane containing all three nodes sn1, sn2 and
                  sn3. Similarly, the system at target is defined by three nodes tn1, tn2 and tn3.
                


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To copy elements 5100-5200 into 3 copies along the -y direction with a distance of 1, and
        remeshing 2 layers with the rebuild algorithm:
*createstringarray 5 ""TransformByMatrix : 0 -1 0 0 1 0 0 0 0 0 1 0 0 0 0 1 "" ""MappingMethod : morph"" ""NumCopies : 3"" ""Rebuild : 1"" ""NumLayers : 2""
*createmark elements 1 5100-5200
*copy_feature elements 1 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1375,*copymarkgroup,"Description
Copies master/slave elements from one group to another.
","Inputs

entity_type
Must be set to elems.
mark_id
The ID of the mark containing the master/slave elements to copy. Valid values are 1 and 2.
name
The name of the group to copy the entities to.

","Examples
To copy all elements in group1 to
        group2:*createmark elems 1 ""by group name"" group1
*copymarkgroup elems 1 group2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1376,*create_batch_file,"Description
Use this command to set a limited set of cleanup parameters directly in the command file
        for use with *autotopocleanup. Only a few automatic cleanup options are
        used; others are switched off or used with default parameters.
","Inputs

element_size
The target mesh element size. 
element_type
Mesh element types:
0 - triangle
1 - quadrilateral
2 - mixed 


feature_angle
Elements feature angle used for features definition.
pinholes_diameter
Maximum diameter of the holes to be removed (filled).
layers_around_holes
Target number of layers of quadrilateral elements around the round holes (usually it
            is 0, 1, 2)
nodes_around_holes
Minimum number of nodes (element links) for round holes.
beads_suppr_height
Maximum height of beads to be totally suppressed (removed).
Max_edge_fillets_radius
Maximum radius of edge fillets to be removed (converted to hard corners).

","Examples
To perform topology cleanup of all displayed surfaces using element quality criteria from
        the file nvh10.criteria as well as the following following target
        cleanup parameters:
Element size - 10 mm
Element type - mixed
Element feature angle - 30 degrees
Remove holes with diameter less than 8 mm
Create 2 layers of quad elements around holes
Keep minimal 6 element links for the holes
Remove edge fillets with radius less than 9.0 mm

*create_batch_file(10,2,30,8,2,6,9 )
*createmark(surfaces,1) ""displayed""
*autocleanup( 1, ""nvh10.criteria"" )

The cleanup parameters are deleted just after each use, so they must be set before every
        use.
",
1377,*create_shell_mesh_features,"Description
Generates plot elements between 2D elements whose normals exceed the a specific angle.
        Connects features to the boundary or to other features, trying to create convex areas. All
        features generated are placed into a component named ^feature. 
Connected features are created by default for interactive and automatic elements
        remesh.
","Inputs

entity_type
Entity type containing the 2D elements. Valid values are:
comps
elems


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
feature_angle
The maximum angle allowed between any two plate elements before a plot element is
            generated between the shared sides of the two elements.
reserved
Reserved for future use. Must be set to 0.

","Examples
To create connected lines representing features on the component named ""hood"" based on a
        30.0 degree feature
        angle:*createmark components 1 hood
*create_shell_mesh_features component 1 30.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1378,*create_tube_midline,"Description
Creates midlines from tube solids.
The options can be specified in any order.
","
Inputs



mark=<mark_id>

The ID of the mark containing the input solids.  Valid values are 1 and 2.  This is
            mandatory.

copy_metadata=<value>

This specifies whether the metadata is copied from the input solids to the appropriate
            midline:
0 – Do not copy
1 – Copy (default)

dest_comp=<value>

This specifies which component the midlines will be created in:
current – Creates all midlines in the current component
midline – Creates all midlines in a component with the name “midline” (default)
midline.# – Creates the midlines in components with names midline.1, midline.2,
            etc...corresponding to the components containing the original solids.
original – Creates the midline for each solid in the same component as the solid
            itself.  If the solid lies in several components, the midline will be created in one of
            these.
original.# – Creates the midline for each solid in the component with the original
            component name suffixed with 1., 2., etc...

tube_ends_mark=<mark_id>

The ID of the mark containing hint surfaces that constitute ends of the tube. Valid
            values are 1 and 2.

","Examples
To extract the midlines from solids 234 and 235 and place the result in the same components
        as the original solids:
*createmark solids 1 234 235
*create_tube_midline mark=1 dest_comp=original
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1379,*createairbag,"Description
Creates an airbag control volume. 
","Inputs

entities
Control volumes are created using sets or contact surfaces. 
markmask
Source of sets or contact surfaces used to create airbag. 
1 -  Nodes selected by user.
name
Name of the airbag.

","Examples
To an airbag (called ""airbag"") using elements selected by
        user:*createcontrolvol(elements,1,""airbag"")
",
1380,*createarray,"Description
Creates an array of integers for use in a subsequent command.
","Inputs

size
The size of the array.
integers
The integers to put in the array.

","Examples
To create an integer array with the values
        1-5:*createarray 5 1 2 3 4 5
",
1381,*createbestcirclecenternode,"Description
This command creates a node or a point at the center of the circle that best approximates
        the input set of lines or points. If the input entities are found to be on a straight line,
        then an error is returned.
","Inputs

entity_type
Input entity types. Valid values are:
Nodes
Points
Lines


mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
point_flag
Parameter specifying whether a node or point is created at the approximated circle
            center. Valid values are:
0 - Create node.
1 - Create point.


any_tol
Parameter specifying whether the best fit is verified against the currently set
            geometry cleanup tolerance. Valid values are:
0 - An error is returned, if the input entities are not on the circle within the
                geometry cleanup tolerance. 
1 - Tolerance is ignored and best fit circle is always calculated.


make_circle
Parameter specifying whether a circle is also created:
0 - Only center point/node is created. 
1 - Center point/node and a circle are created.



","Examples
To create a node at the center of the circle passing through nodes 11, 12 and
        14:*createmark nodes 1 11 12 14
*createbestcirclecenternode nodes 1 0 1 0
To create a circle that approximates line 21, along with a point at the center of the
        circle:*createmark lines 1 21
*createbestcirclecenternode lines 1 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1382,*createcaero1panelmeshing,"Description
Creates a component for aeroelastic panel mesh CAERO1.
","
Inputs


componentid=<value>
The start value for component and element numbering.  This is mandatory.
createproperty=<value>
0 - Do not create PAERO1
1 - Create PAERO1 (default)
igid=<value>
The interference group identifier.
locations={<value>}
The coordinates of 4 corner points (12 values).  This is mandatory.
mode=<value>
0 - Create component (default)
1 - Update component
nchord=<value>
The number of chordwise boxes.  If not provided, must specify
              tableid2.
nspan=<value>
The number of spanwise boxes.  If not provided, must specify
              tableid1.
panelname=<value>
The name of the CAERO1 panel entity.  If not specified, CAERO1_<componentid> is
            used.
propertyname=<value>
The name of the PAERO1 property entity.  If not specified, PAERO1_<componentid> is
            used.
systemid=<value>
The ID of the system for locating points 1 and 4.
tableid1=<value>
The ID of an AEFACT table containing the list of division points for spanwise boxes.
            Used only if nspan is not provided.
tableid2=<value>
The ID of an AEFACT table containing the list of division points for chordwise boxes.
            Used only if nchord is not provided.

","Examples
Create an aero component with ID 60001 using tables 31001 and 31002:
*createcaero1panelmeshing componentid=60001 systemid=503 mode=0 locations={701.04 74.56 177.11 1000.67 70.5 176.9 1085.37 374.58 183.29 946.5 399.5 189.45} tableid1=31001 tableid2=31002 igid=1 createproperty=1 propertyname=PAERO1_60001 panelname=CAERO1_60001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1383,*createCAERO2card,"Description
Creates a body component of type CAERO2.
","
Inputs



start_id

The ID from which the component and element numbering will start.

system_id

The ID of the local coordinate system which the mesh will be generated based on.  A
            value of 0 indicates the global coordinate system.

origin_coordinate

The location of the origin.  This must be 3 values enclosed in double quotes.

length

The length along the x-axis of the the coordinate system.

n_int

The number of interference elements.

n_slend

The number of slender body elements.

radii

The radius at each interval along the length of the body.  This must be the same
            number of values as given by n_slend, and must be enclosed in double
            quotes.

theta

The angle along the radial direction of the body.  This must be the same number of
            values as given by n_int, and must be enclosed in double quotes.

axis

1 - x-axis
2 - y-axis
3 - z-axis

","Examples
Create a body component with ID 677771, system ID 508, and considering the length along the
        y-axis of the coordinate system:
*createCAERO2card 677771 508 ""1011.96772 124.925267 172.770859"" 500 6 7 ""0 40.0 40.0 50.0 60.0 60.0 80.0"" ""0 60.0 120.0 180.0 240.0 300.0"" 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1384,*createcirclecenterpoint,"Description
Creates a point at the center of a circle defined by 3 input points.
","Inputs

point_id1
The ID of the first point defining the circle.
point_id2
The ID of the second point defining the circle.
point_id3
The ID of the third point defining the circle.

","Examples
To create a point at the center of the circle defined by points 100, 200 and
        300:*createcirclecenterpoint 100 200 300
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1385,*createcirclefrompointplane,"Description
This command creates a circle or arc by spinning a point about the normal vector of a
        plane.
","Inputs

list_id
The ID of the list containing the nodes to be spun. A circle or arc is created for
            each node in the list.
plane_id
The ID of the plane defining the circle normal, defined using the
              *createplane command. The center of each circle is located at the
            base of the plane. This must be set to 1.
angle
The angle of the arc. To create a circle, set to 360.
offset
Sets the starting offset for an arc.

","Examples
To create a circle by spinning node 18 in the plane whose normal is defined by (0.0, 0.0,
        1.0) with base (0.0, 0.0,
        0.0):*createplane 1 0.0 0.0 1.0 0.0 0.0 0.0
*createlist nodes 1 18
*createcirclefrompointplane 1 1 360.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1386,*createcollectorforpartiallycontained,"Description
Creates a collector and moves certain entities into the collector.
","Inputs

entity_type
Entity type to move into the collector. Valid values are:
elems
loads
systs
vectors


mark_id
The mark ID containing the entities to move. Valid values are 1 and 2.
name
The new collector name. The collector type is determined by the
              entity_type.
config
Set to a valid config value to specify if only entities of that config should be
            moved. Otherwise, set to 0. 
Currently only supported for elements.
type
Set to a valid type value to specify if only entities of that type should be moved.
            Otherwise, set to 0. 
Currently only supported for elements.
reserved
Reserved for future use. Must be set to 0.

","Examples
To create a component named comp2 and move elements
        1-100:*createmark elems 1 1-100
*collectorcreateforpartiallycontained elems 1 comp2 0 0 0
To create a component named comp2 and move only quad elements from elements
        1-100:*createmark elems 1 1-100
*collectorcreateforpartiallycontained elems 1 comp2 104 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1387,*createcontrolvol,"Description
Creates an airbag control volume.
","Inputs

entities
Control volumes are created using elements.
markmask
Source of elements used to create control volume. 
1 - Elements selected by the user.
name
Name of the control volume.

","Examples
To create a control volume called ""airbag"" using the elements that you
        selected:*createcontrolvol(elements,1,""airbag"")
",
1388,*createdoublearray,"Description
Creates an array of doubles for use in a subsequent command.
","Inputs

size
The size of the array.
doubles
The doubles to put in the array.

","Examples
To create a double array with the values 2.5 and
        11.0:*createdoublearray 2 2.5 11.0
",
1389,*createelement,"Description
Creates an element from a node list.
","Inputs

config
The HyperMesh configuration of the element.
Type: integer
type
The solver type of the element.
Type: integer
list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
auto_order
0 - Use the nodes as ordered in the list.
1 - Auto order the nodes in the list.

","Examples
To create a quad4 element using nodes 14, 15, 16, and
        17:*createlist node 1 14 15 16 17
*createelement 104 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1390,*createelements1d,"Description
Creates 1D beams, bars and rods, and optionally assigns properties to created elements.
","
Inputs



entity_type

The type of entity to use as input.  Valid values are nodes and lines.

mark=<mark_id> or list=<list_id>
The ID of the mark (for nodes) or list (for nodes).  Valid values are 1 and 2.

beamsection=<beamsectionname>

If provided, an auto 1D property is created to which this beam section is assigned.
            The property card image depends on the elemtype provided. This
            property is assigned to the newly created 1D elements. In case both
              property and beamsection are provided,
              property takes precedence. This option is supported for OptiStruct, Abaqus and Nastran only.  For properties that do not support beam sections,
            the relevant attributes (e.g. area) of such properties are updated by copying values
            from the beam section.

biasdensity=<biasdensity>

The biasing value of the element length to use.

biasstyle=<biasstyle>

The style of biasing to use. Valid values are: 
0 - Linear
1 - Exponential
2 - Bell curve

breakangle=<breakangle>

If the angle between the lines’ tangents at a joint is greater than this value, the
            line is split to force a node at that location. If set to 0.0, no split will occur.
              useshell is not considered if this is > 0.

elemconfig=<elemtype>

The config of 1D element to be created.

elemdensity=<elemdensity>

The element density to use.

elemsize=<elemsize>

The size of the 1D elements to be created. This input will not be considered if
              useshell is 1.

elemtype=<elemtype>

The type of 1D element to be created.

linecomp=<linecomp>

The component in which the 1D elements are to be created. This option works only if
              entity_type is lines. Valid values are:
0 - Line component
1 - Current component

orientvec=<x,y,z>

If provided, specifies a custom orientation for 1D elements when
              useshell=0 or useshell=3.

property=<propertyname>

If provided, the property is assigned to newly created 1D elements. Also, it will
            ensure that the created 1D elements are of a type compatible with the property card
            image, thereby overriding the elemtype value. This option is
            supported for OptiStruct, Abaqus
            and Nastran only.

proximitytolerance=<proximitytolerance>

The proximity tolerance used to find the nearest shell nodes a long the line.  Default
            is -1.0.  Used when useproximity=1 and
            useshell=3.

useelemdensity=<useelemdensity>

0 - Do not use elemdensity
1 - Use elemdensity

useproximity=<useproximity>

0 - Do not use shell element nodes which exist along the line to create the line
            mesh.
1 - Use shell element nodes which exist along the line to create the line mesh.

useshell=<useshell>

If set to 1 or 2, considers neighboring shells of selected lines/nodes of a meshed
            surface for connectivity, orientation, and offset. After creation of 1D elements, the
            normal and thickness of these shells are used to orient and offset the 1D elements
            appropriately. Valid values are:
0 - Do not use shells for connectivity, orientation, or offset
1 - Use only displayed shells for connectivity, orientation, and offset
2 - Use all shells for connectivity, orientation, and offset
3 - Use shells for connectivity only.  within the tolerance zone.  If
              useproximity=1, the ordered nodes within
              proximitytolerance are used to create 1D elements.

","Examples
Create 1D elements using lines and assign properties to these newly created elements. Also,
        update the orientation and offset of these elements using neighbouring shells:
*createmark lines 1 1-4
*createelements1d lines mark=1 property=PBARL elemsize=10 elemconfig=bar2 elemtype=CBAR linecomp=1 useshell=1 breakangle=0 biasintensity=1 biasstyle=0
Create 1D elements using lines and proximity tolerance.  Also, update the orientation and
        offset of these elements using neighbouring shells:
*createmark lines 1 1-4
*createelements1d lines mark=1 elemsize=10 elemconfig=bar2 elemtype=CBAR linecomp=1 useshell=3 breakangle=0 elemdensity=1 useelemdensity=1 biasdensity=0 biasstyle=0 useproximity=1 proximitytolerance=-1.0
Create 1D elements using nodes and assign beam section to these newly created elements:
*createlist nodes 2 1 2 3 4
*createelements1d nodes list=2 beamsection=Circ elemsize=2 elemtype=CROD elemconfig=rod linecomp=0 useshell=0 breakangle=30 elemdensity=1 useelemdensity=0 biasdensity=0 biasstyle=0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1391,*createelementsbetweenpoints,"Description
Creates a spotweld element between two surfaces at the marked points with an element type,
        coordinate system, and property ID.
","Inputs

surf1_markmask
First or multiple surfaces in the mark.
surf2_markmask
Second surface in the mark, if given.
markmask
Marked points.
tol
Search tolerance to identify surfaces.
createplot
Creates a plot.
configval
Element type configuration value.
syst
Local coordinate system switch.
0 - Without coordinate system.
1 - With coordinate system.


code
Code for one or all surface options.
0 - All surfaces.
1 - One surface.


*property
Name of property collector. Retrieves property ID. 

","Examples
To create spot weld (spring elements) between surfaces 1 and 2, using the option individual
        surface within a tolerance of 0.01 at marked points. Elements are created with the
        coordinate system and property collector
        name_prop.*createelementsbetweenpoints(1,2,2,0.01,1,21,1,1, ""name_prop"")
",
1392,*createellipsoidsbypoints,"Description
Creates one or more ellipsoids based on the information provided.
","Inputs

markmask
The mark of points used for the center of the ellipsoids.
type
1 - Ellipsoids.
2 - Cylinder.
name
The name of the ellipsoids.
radiusa
The length of an ellipsoid in the A direction. Real number value.
radiusb
The length of an ellipsoid in the B direction. Real number value.
radiusc
The length of an ellipsoid in the C direction. Real number value.
shape
The shape of an ellipsoid. Must be a real number between 2 and 8.
systemid
The ID of the system to which the ellipsoid is attached.
multibodyid
The ID of the multibody to which the ellipsoids are attached.
color
The color value of the ellipsoid.

",,
1393,*createentity,"Description
Create a new entity with specified data. Data names only are allowed to be set.
There are also a few limitations to this command: 
Attributes are not supported. 
STATUS is not supported.


","Inputs

entity_type
Entity type to create.
<name>=<value>
The name=value data name and/or attribute pairs that define the
            relevant data for the entity. For attributes, this can be either the attribute name or
            ID. 
For entity attributes, both the entity type and the entity IDs must be provided. For
            example:*setvalue elements id=7 3222={elems 3}
modelname=<name_of_model>
This is the optional model name to update when there are multiple models in the
            database. If not specified, the current model is used.

","Examples
Create a set with a default set type and name.*createentity sets
Create a set of type nodes and node IDs
        1-4:*createentity sets type=nodes ids={1 2 3 4}
Create a set with name set1, cardimage
        GRNOD:*createentity sets name=set1 cardimage=GRNOD
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1394,*createentitypanel,"Description
This command provides you with a panel and a standard entity collector that is used to
        select a single entity. The entity selected is then retrieved using the command
          hm_info lastselectedentity
entity_type. 
If multiple entity selection is required, use *createmarkpanel.
","Inputs

entity_type
The type of entity to select.
message
The message to display to the user in the message bar.

","Examples
To prompt you to select a single coordinate
        system:*createentitypanel systs ""Select system""
if {[hm_info lastselectedentity systs] == 0} {
   hm_errormessage ""No system selected""
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1395,*createfacesonfreeboundaries,"Description
This command is used to find and create shell elements on free boundaries of all the solid
        elements. This command generates faces only for first order shell elements. It operates on
        all solid elements, regardless of display status. 
","Examples
To create faces on free boundaries:*createfacesonfreeboundaries
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1396,*createfbdfilefromfbdsummarytable,"Description
Creates a .fbd file from an FBD summary table.
","Inputs

filepath=<value>
The full name and path of the .fbd file to write.
summPt_systemId=<value>
The ID of the system to resolve the summation.
summaryTable_name=<value>
The name of the FBD summary table created by
            *createfbdsummarytable.

","Example
To write the FBD file to C:/temp/my_fbd.fbd using system ID 2 and summary table
        FBDSummary_Run1:
*createfbdfilefromfbdsummarytable C:/temp/my_fbd.fbd 2 FBDSummary_Run1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1397,*createfbdreport,"Description
Creates a report for FBD panel and FBD bar from panel and freebodysection entities
        respectively.
This queries the raw grid-point and element force data from result entities multiple
        subcases of the elements and nodes contained under the panel/freebodysection entities.  It
        is then formalized and calculated with respect to local or elemental system to get the final
        FBD force values. A table is then created which contains the detailed panel/freebodysection
        entities, subcase details and FBD force values.
","
Inputs


report_type
The type of report to generate.  Valid values are panel and bar.
entity_type
The type of entity for the report.  For panel reports, this must be panels.  For bar
            reports, this must be freebodysection.
mark_id
The ID of the mark containing the input panels or freebodysections.  Valid values are
            1 and 2.
subcase_ids
The subcase IDs to consider, as a comma separated string with each substring
            consisting of the result file ID, subcase ID and step ID.  For example: {1 1 0, 1 2 0, 2
            1 0, 2 1 1}.
resultid=<value>
The ID of the result entity to use.  This is a mandatory option.
envelope=<value>
0 - No envelope calculation (default)
1 - Envelope calculation
gpf=<value>
For panel reports only:
0 - Element forces (default)
1 - Grid-point forces
tolerance=<value>
The tolerance to limit the values for the table creation. Default is 0.00001.

","Examples
Create an FBD panel report with element
        forces:*createmark panels 1 1 2 3
*createfbdreport panel panels 1 {1 1 0, 1 2 0, 2 1 0, 2 1 1} resultid=1
Create an FBD panel report with grid-point
        forces:*createmark panels 1 1 2 3
*createfbdreport panel panels 1 {1 1 0, 1 2 0, 2 1 0, 2 1 1} resultid=1 gpf=1
Create an FBD panel report with
        envelope:*createmark panels 1 1 2 3
*createfbdreport panel panels 1 {1 1 0, 1 2 0, 2 1 0, 2 1 1} resultid=1 gpf=1 envelope=1
Create an FBD bar
        report:*createmark freebodysections 1 1 2 3
*createfbdreport bar freebodysections 1 {1 1 0, 1 2 0, 2 1 0, 2 1 1} resultid=1
Create an FBD bar report with
        envelope:*createmark freebodysections 1 1 2 3
*createfbdreport bar freebodysections 1 {1 1 0, 1 2 0, 2 1 0, 2 1 1} resultid=1 envelope=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1398,*createfillet,"Description
Creates a fillet between two lines. 
","Inputs

line1 id
The ID of the first line to which the fillet line is to be created.
line2 id
The ID of the second line to which the fillet line is to be created.
radius
The radius of the fillet.
trim
0 - To leave the lines intact.
1 - To trim line1 and line2 at the fillet boundary.
 
quadselected
The quadrant to select, if more than one possible fillet location exists. 

","Examples
To create a fillet between line 1 and line 2 with radius 5.4:
        *createfillet(1,2,5.4,0,0)
If more than one possible fillet line exists, you must select the fillet quadrant. The
        number of this quadrant is then used in the quadselected argument. 
",
1399,*createidrange,"Description
This command creates an ID range for a submodel.
","Inputs

submodel_type
Submodel type to create the ID range for. Valid values are includes and
            includefiles.
id
The ID of the submodel. Not required, if shortname is used.
shortname
The shortname of the submodel. Not required, if id is used.
entity_type
Entity type to create the ID range for.
min_id
The minimum ID for the range.
max_id
The maximum ID for the range.
offset
The offset for the range.
pool_id
The ID of the solver pool.
integer_array
The ID of the integer array that contains the locked IDs. The integer array is created
            using the *createarray command. This should always be set to 1.
number_of_integers
Integer indicating the size (number of integers) in the integer array created using
              *createarray.

","Examples
To create an ID range for include 1 with min ID 1,000 and max ID 100,000 for
        components:*createidrange includes 1 """" comps 1000 100000 0 1 0
To create an ID range for include 1 with min ID 1,000 and max ID 100,000 for components,
        with locked IDs 2000 and
        5000:*createarray 2 2000 5000
*createidrange includes 1 """" comps 1000 100000 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1400,*createincludeperpart,"Description
Create a new include file for prototype parts that do not have an include.  Only creates
        new includes for parts that do not already have one.
","
Inputs


mark_id
The ID of the mark of parts.  Valid values are 1 and 2.

","Examples
To create includes for all
        parts:*createmark parts 1 all
*createincludeparpart 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1401,*createintersectionsegments,"Description
Creates intersection segments as plot elements from the results of
          hm_collisioncheck. hm_collisioncheck must be run
        with the save_segments option specified before running this command. This
        command must also be called before hm_collisionend is called.
","Inputs

collector
0 - Create segments as plot elements in a component named
              ^intersection_segments.
1 - Create segments as plot elements in the current component.

","Examples
To find intersecting surfaces from IDs 1-10 and to create intersection
        segments:*createmark surfs 1 1-10
hm_collisioninit
hm_collisionentitycreate surfs 1 0 1 0 0 0 0 0 0
hm_collisioncheck 0 0 1 0 0 0 0 90.0 1
*createintersectionsegments 0
hm_collisionend
hm_getmark surfs 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1402,*createlist,"Description
Creates an ordered list of entities for use in a subsequent command.
","Inputs

entity_type
Entity type to put on the list. Valid values are elems, laminates, lines, nodes, plies
            and surfs.
list_id
The ID of the list to populate. Valid values are 1 and 2.
""by model"" <model_name>
The optional model to create the list from.  If not specified, the current model is
            used.
entities
The ID of the entities, in the appropriate order.

","Examples
To create a line from nodes 2, 10, and
        3:*createlist nodes 1 2 10 3
*linecreatefromnodes 1 0 150 5 179
To create, query, and clear a list from nodes 2, 10, and 3 for model
        model-2:*createlist nodes 1 ""by model"" model-2 2 10 3
set my_list [hm_getlist nodes 1 0 model-2]
*clearlist nodes 1 ""by model"" model-2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1403,*createlistpanel,"Description
Provides a panel to create an ordered list of entities for use in a subsequent command.
","Inputs

entity_type
The type of entities to put on the list. Valid values are:
elems
laminates
lines
nodes
plies
surfs


list_id
The ID of the list to populate. Valid values are 1 and 2.
message
A string indicating a message to display in the message bar. 

","Examples
To create a line from a user specified list of
        nodes:*createlistpanel nodes 1 ""Select nodes for the line:""
set node_list [ hm_getlist nodes 1 ];
if { ! [ Null node_list ] } {
    *linecreatefromnodes 1 0 150 5 179
}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1404,*createmarklast,"Description
Populates the mark with the entities used in the last command.
","Inputs

entity_type
The type of entities to populate.
mark_id
The ID of the mark. Valid values are 1 and 2.

","Examples
To determine the new ID of surface 100 after performing a surface
        offset:*createmark surfaces 1 100
*createmark lines 1 2471
*offset_surfaces_and_modify surfaces 1 0 1 -3 -0.5
*createmarklast surfaces 1
hm_getmark surfs 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1405,*createmultiplespotwelds,"Description
Creates multiple spotwelds between a set of nodes on the finite element mesh for a given
        type of element, coordinate system, and property ID.
","Inputs

nodecol1_markmask
Independent node mark list.
nodecol2_markmask
Dependent node mark list.
tolerance
Search tolerance to pair the nodes.
length_given
Specifies if a length has been given.
length
Length of the spotweld element.
systems
Local coordinate system switch.
0 - Without coordinate system.
1 - With coordinate system.


movenode
Moves dependent node.
remesh
Remeshes dependent region.
configval
Element type configuration value.
*property
Name of property collector. Retrieves property ID.

","Examples
To create spotwelds (rod elements) between nodes 1 and 2 with the coordinate system,
        property collector name_prop and the options movenode and remesh
        selected:*createmultiplespotwelds(1,2,0.05,0,0.0,1,1,1,61, ""name_prop"")
",
1406,*createnodesbetweennodelist,"Description
Creates nodes between each pair of nodes along a list. 
","Inputs

nodelist
The mark containing the list of nodes that are to have nodes created between them. 
numberofnodes
The number of nodes to be created between the selected nodes.
biasstyle
The type of biasing to use.
biasingintensity
The biasing intensity value.

","Examples
To create 3 nodes between nodes 166 and 170, and 3 more between nodes 170 and 174, and so
        on:
        *createlist(nodes,1) 166 170 174 178 183 187 191
*createnodesbetweennodelist(1,3)
",
1407,*createorthotropicdirection,"Description
Creates the INSHE/ORTHO_LOC tables based on the composite data in the session.
","Inputs
None.
","Example
To create the INSHE/ORTHO_LOC tables based on the composite data in the session:
*createorthotropicdirection
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1408,*createpoint,"Description
Creates a point in space.
","Inputs

x
The x coordinate of the point.
y
The y coordinate of the point.
z
The z coordinate of the point.
system id
The ID of the system that positions the point in space.

","Examples
To create a point at (12.0, 13.5,
        16.3):*createpoint(12.0,13.5,16.3,0)
The coordinates can be input in reference to a local coordinate system, but they are stored
        in the global coordinate system.
",
1409,*createpointsbetweenpositions,"Description
Creates midpoints between two geometric positions in space.
","
Inputs



x0

The x-coordinate of the start position.

y0

The y-coordinate of the start position.

z0

The z-coordinate of the start position.

x1

The x-coordinate of the end position.

y1

The y-coordinate of the end position.

z1

The z-coordinate of the end position.

count

The number of midpoints to create.

end_points

0 - No point at either end
1 - Create a point at the start position
2 - Create a point at the end position
3 - Create points at both ends

system_id

The ID of the system that positions the end points in space.  Use 0 for global.

","Examples
To create 7 points between (1.89, 8.83, 8.84) and (8.68, 1.82, 1.83):
*createpointsbetweenpositions 1.89 8.83 8.84 8.68 1.82 1.82 7 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1410,*createreferencegeometry,"Description
Creates a reference geometry control volume.
","Inputs

entities
Reference geometry is created using nodes. 
markmask
Source of nodes used to create reference geometry.
1 - Nodes selected by user.
name
Name of the reference geometry. 

","Examples
To create reference geometry (called ""ref"") using elements you
        selected:*createcontrolvol(elements,1,""ref"")
",
1411,*createsensor,"Description
Creates a sensor entity.
","Inputs

name
Name of the sensor being created.

","Examples
To create a sensor named sensor1:*createsensor(sensor1)
",
1412,*createspotweld,"Description
Creates a spotweld between two nodes on the finite element mesh for a given type of
        element, coordinate system, and property ID.
","Inputs

independent
Independent node pointer.
dependent
Dependent node pointer.
length_given
Specifies if a length has been given.
length
Length of the spotweld element.
systems
Local coordinate system switch.
0 - Without coordinate system.
1 - With coordinate system.


movenode
Moves dependent node.
remesh
Remeshes dependent region.
configval
Element type configuration value.
*property
Name of property collector Retrieves property ID.

","Examples
To create a spotweld (spring element) between nodes 1 and 3 with the coordinate system and
        property collector name_prop (movenode and
          remesh options are not
        used):*createspotweld(1,3,0,0.0,1,0,0,21, ""name_prop"")
",
1413,*createvector,"Description
Defines a vector for use in a subsequent command.
The vector length should never be 0.
Use the *createetity command to create a vector entity.
","Inputs

vector_id
The ID of the vector being defined.  Valid values are 1 and 2.
x_component
The x-component of the normal of the vector. 
y_component
The y-component of the normal of the vector. 
z_component
The z-component of the normal of the vector. 

","Examples
To define a vector along the y-axis: *createvector 1 0.0 1.0 0.0
",
1414,*createweldsbetweencompsusingpoints,"Description
Creates weld element(s) between pre-existing components at the given point(s).
","Inputs

comp1_mark
The component mark for the first comp collector.
comp2_mark
The component mark for the second comp collector, if given.
single_col
Flag for the number of comp collectors used.
0 - Two comp collectors.
1 - One comp collector. 


point_mark
The point mark for the point collector.
tol
The maximum distance allowed between the point (from the point mark) and the comp
            (from the comp mark) in order to weld the elements in it.
syst
Systems flag.
0 - Do NOT build systems.
1 - Build systems.


configval
Weld element type.
Property
Name of property collector. Used to retrieve property ID.
forced_length
For ACMs only.
1 - Sets Hexa length to be an average of two component thickness (t1 +
                  t2)/2. 
0 - Creates hexa from element plane.


DTfile
Name of Diameter Vs. Thickness file. Used to calculate the size of Hexa elements in
            ACM and diameter for CWELD only.

","Examples
ACM’s (configval = 71) are created between components on mark (1 and 2) at point locations
        on mark (2) within a tolerance of 1.0.
        *createweldsbetweencompsusingpoints(1, 2, 1, 2, 1.0, 1, 71, ""myprop"",0, 0, ""DvsTfile"")
If the single_col flag equals 1, then comp2_mark is
        ignored. 
",
1415,*createweldsbetweenelemsusingpoints,"Description
Creates weld element(s) between pre-existing elements at the given point(s).
","Inputs

elem1_mark
The element mark for the first element collector.
elem2_mark
The element mark for the second element collector, if given.
single_col
Flag for the number of element collectors used:
1 - One elem collector. 
0 - Two elem collectors.


point_mark
The point mark for the point collector.
tol
The maximum distance allowed between the point (from the point mark) and the element
            (from the elem mark) to weld this element.
syst
Systems flag:
1 - Build systems.
0 - Do NOT build systems.


configval
Weld element type created:
2 = plot 
3 = weld 
5 = rigid 
21 = spring 
60 = bar 
61 = rod 
70 = gap


property
Name of the property collector. Used to retrieve the property ID.
remesh
Remesh flag (always zero).

","Examples
Each of the three points on the mark (16, 17, and 18) try to project normally onto as many
        elements as they can that are within a tolerance of 1.0. All of the non-adjacent elements
        found for each point's projections are then welded together at their projection
        points.*createmark(elems, 2) ""all""
*createmark(points, 2) ""all""
*createweldsbetweenelemsusingpoints(2, 2, 1, 2, 1.0, 1, 3, ""myprop"")
If the single_col flag equals 1, then elem2_mark flag
        is ignored.
",
1416,*criteria_write,"Description
Writes the global mesh criteria to a file.
","
Inputs


filename
The name and path of the file.

","Examples
To write the criteria to C:/temp/5mm.crit:
*criteria_write ""C:/temp/5mm.crit""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1417,*curveaddpoint,"Description
Adds a new point in the curve.
","Inputs

curve_id
The ID of the curve.
index
The point number (point numbering starts with 1) after which the new point needs to be
            added.
0 - If point needs to be added at the beginning.
xvalue
The x coordinate of the point.
yvalue
The y coordinate of the point.

","Examples
To add a new point with x and y values to a curve with ID curve_id
        having N number of points:
At the
        beginning:*curveaddpoint($curve_id, 0, $ xvalue, $ yvalue)
After the second
        point:*curveaddpoint($curve_id, 2, $ xvalue, $ yvalue)
At the end (i.e., after Nth
        point):*curveaddpoint($curve_id, [hm_curve_getnumberofpoints $curve_id], $ xvalue, $ yvalue)
",
1418,*curvemathexternalfilter,"Description
Runs an external filter on a curve.
","Inputs

outputcurve
The name of the curve to be generated.
xbased
1 - If the function should operate on the x coordinate.
0 - If the function should operate on the y coordinate.
filter
The name of the filter.
parameter
The user-defined parameters for the filter.

",,
1419,*cuttingplanereverse,"Description
Reverses a cutting plane display orientation.
","Inputs

axis
The axis that is normal to the plane. Valid values are:
0 - The plane with x-axis as its normal.
1 - The plane with y-axis as its normal.
2 - The plane with z-axis as its normal.



","Examples
To reverse the cutting plane with y-axis as its
        normal:*cuttingplanereverse 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1420,*defaultmeshelems,"Description
Meshes a selection of elements using saved or default parameters and various options.
","Inputs

mark_id
The ID of the mark containing the elements to mesh. Valid values are 1 and 2.
elem_size
The default element size used to calculate element densities along edges (when
            necessary).
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. Boundaries between components
                are not maintained when remeshing. 
1 - Elements are created in the same components as the source elements.
                Boundaries between components are maintained when remeshing.


size_control
Flag indicating whether to create uniformly sized elements. Valid values are:
0 - Do not create uniformly sized elements. 
1 - Create uniformly sized elements.


skew_control
Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid values are:
0 - Do not create optimally shaped elements. 
1 - Create optimally shaped elements.


edge_mesh_type
Determines the algorithm for edge meshing:
1 - Standard edge meshing. 
2 - Chordal deviation edge meshing. 
11 - Standard edge meshing with flow ""align"" control. 
12 - Chordal deviation edge meshing with flow ""align"" control. 
14 - Standard edge meshing with flow ""align"" and ""size"" control.


min_size
Minimum edge size for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_size
Maximum edge size for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_deviation
Maximum deviation for chordal deviation edge meshing. Ignored, if
              edge_mesh_type is not set to 2 or 12.
max_angle
Maximum angle value (in degrees) between edges for chordal deviation edge meshing.
            Ignored, if edge_mesh_type is not set to 2 or 12.
previous_settings
Flag indicating whether to break, keep or redo connectivity between neighboring
            surfaces. Valid values are:
0 - Keep previous settings and do not break connectivity between neighboring
                surfaces. 
1 - Break connectivity between neighboring surfaces. 
2 - Keep connectivity between neighboring surfaces. 
3 - Redo connectivity between neighboring surfaces by expanding surface selection
                by one layer of adjacent surfaces.


vertex_angle
When the vertex between two edges exceeds this value, a new node is created to form a
            vertex. Thus, using high values results in fewer nodes on curved edges, and therefore
            less-accurate edge approximation. A standard value is 30.

","Examples
To mesh all elements with a first order mixed mesh of size 4.5, maintaining the original
        components,with size and skew control, with flow and alignment control, keeping the existing
        connectivity, a vertex angle of 25, and automatically detecting connected features with a
        feature angle of
        20:*setoption element_order=1
*setoption feature_angle=20
*setusefeatures 3
*createmark elems 1 all
*defaultmeshelems 1 4.5 2 2 1 1 1 14 0 0 0 0 2 25
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1421,*defaultmeshsurf_growth,"Description
Generates surface meshes using surface deviation parameters with growth ratio transitions
        given by refinement sizes defined on points, edges and surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 1 and 2.
elem_size
The default element size used to calculate element densities along edges (when
            necessary).
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


previous_settings
Flag indicating whether to break, keep or redo connectivity between neighboring
            surfaces. Valid values are:
0 - Keep previous settings and do not break connectivity between neighboring
                surfaces. 
1 - Break connectivity between neighboring surfaces. 
2 - Keep connectivity between neighboring surfaces. 
3 - Redo connectivity between neighboring surfaces by expanding surface selection
                by one layer of adjacent surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. 
1 - Elements are created in the same components as their parent surfaces.


size_control
Flag indicating whether to create uniformly sized elements. Valid values are:
0 - Do not create uniformly sized elements. 
1 - Create uniformly sized elements.


skew_control
Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid values are:
0 - Do not create optimally shaped elements. 
1 - Create optimally shaped elements.


mesh_type
Parameter specifying the meshing algorithm for edge/surface meshing. Valid values are:
34 - Proximity and curvature based surface meshing. 
35 - Curvature based surfaced meshing. 
36 - Proximity and curvature based meshing with free edge deviation. 
37 - Curvature based surface meshing with free edge deviation.


keep_mesh
Determines wether any existing mesh is preserved. Valid values are:
0 - Do not keep existing mesh. 
1 - Keep existing mesh.


min_size
The minimum edge size.
max_size
The maximum edge size.
chordal_dev
The chordal deviation value.
max_angle
The maximum angle (in degrees) between edges.
growth_rate
The growth rate of the refinement size transition.
id_array
The ID of the string array that contains the refinement geometry IDs. The integer
            array is created using the *createarray command. This should always
            be set to 1. 
The first three integers indicate the number of source points, edges and surfaces. The
            next set of integers are the point IDs, followed by the edge IDs, followed by the
            surface IDs.
number_of_ids
Integer indicating the size (number of integers) in the integer array created using
              *createarray.
size_array
The ID of the double array that contains the refinement geometry sizes. The double
            array is created using the *createdoublearray command. This should
            always be set to 1. 
The values must correspond to the same order as the IDs in the
              id_array.
number_of_sizes
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.

","Examples
To create a tria mesh with chordal deviation settings using a growth rate of 1.23 with
        refinement sources defined at point ID 93, size 1, edge ID 35, size 1.5 and surface ID 2,
        size
        2.1:*createmark surfaces 1 all
*createarray 6 1 1 1 93 35 2
*createdoublearray 3 1.0 1.5 2.1
*defaultmeshsurf_growth 1 5 0 0 2 1 1 1 35 0 0.5 5 0.1 15 1.23 1 6 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1422,*defaultremeshsurf,"Description
Re-meshes a selection of surfaces using saved or default parameters and various options,
        and deletes any elements already meshed on those surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to re-mesh. Valid values are 1 and 2.
elem_size
The default element size used to calculate element densities along edges (when
            necessary).
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


previous_settings
Flag indicating whether to break, keep or redo connectivity between neighboring
            surfaces. Valid values are:
0 - Keep previous settings and do not break connectivity between neighboring
                surfaces. 
1 - Break connectivity between neighboring surfaces. 
2 - Keep connectivity between neighboring surfaces. 
3 - Redo connectivity between neighboring surfaces by expanding surface selection
                by one layer of adjacent surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. 
1 - Elements are created in the same components as their parent surfaces.


size_control
Flag indicating whether to create uniformly sized elements. Valid values are:
0 - Do not create uniformly sized elements. 
1 - Create uniformly sized elements.


skew_control
Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid values are:
0 - Do not create optimally shaped elements. 
1 - Create optimally shaped elements.


mesh_type
Parameter specifying the meshing algorithm for edge/surface meshing. Valid values are:
1 - Standard edge meshing. 
2 - Chordal deviation edge meshing. 
3 - Proximity based surface meshing. 
4 - Proximity and curvature based surface meshing. 
5 - Curvature based surfaced meshing. 
6 - Proximity and curvature based meshing with free edge deviation. 
7 - Curvature based surface meshing with free edge deviation. 
11 - Standard edge meshing with flow ""align"" control. 
12 - Chordal deviation edge meshing with flow ""align"" control. 
14 - Standard edge meshing with flow ""align"" and ""size"" control.


min_size
The minimum edge size for chordal deviation meshing. Ignored otherwise.
max_size
The maximum edge size for chordal deviation meshing. Ignored otherwise.
chordal_dev
The chordal deviation value for chordal deviation meshing. Ignored otherwise.
max_angle
The maximum angle (in degrees) between edges for chordal deviation meshing. Ignored
            otherwise.

","Examples
To remesh using quads using a default edge size of 1.0 for the surface with ID
        3:*createmark surfaces 1 3
*defaultremeshsurf 1 1 1 1 1 0 0 0 1 0 0 0
To remesh using mixed type elements for the size controlled mapping algorithm using tria
        transitions, trias for free mesh and chordal deviation edge meshing for surfaces 3, 5 and
        6:*createmark surfaces 1 3 5 6
*defaultremeshsurf 1 1 2 0 1 0 1 0 2 0.5 30 0.1 15
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1423,*delaunay_2d_3d,"Description
Performs 2D/3D triangulation of selected nodes.
","
Inputs



type

The type of triangulation to perform.
2 - 2D triangulation
3 - 3D triangulation

entity_type

Must be set to nodes.

mark_id

The ID of the mark containing the input entities.  Valid values are 1 and 2.

reserved

Reserved for future use.  Must be set as """".

","Examples
To 2D triangulate the displayed nodes:
*createmark nodes 1 displayed
*delaunay_2d_3d 2 nodes 1 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1424,*deleteedges,"Description
Deletes the edges if any in the current database. 
","Examples
This operation deletes the component named ^edges. 
",,
1425,*deletefile,"Description
Deletes a file.
","Inputs

name
The name of the file to be deleted. 

","Examples
To delete the file named junk: *deletefile(junk)
",
1426,*deleteidrange,"Description
This command deletes an ID range for a submodel.
","Inputs

submodel_type
The type of submodel to delete the ID range for. Valid values are includes and
            includefiles.
id
The ID of the submodel. Not required if shortname is used.
shortname
The shortname of the submodel. Not required if id is used.
entity_type
The type of entity to delete the ID range for.
pool_id
The optional ID of the solver pool.

","Examples
To delete an ID range for include 1 for
        components*createidrange includes 1 """" comps
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1427,*deletemodel,"Description
Deletes all of the entities in a database
",,,
1428,*dependencycheck,"Description
Checks nodes for multiple dependence. 
","Inputs

entities
The entities contained on the mark. 
mark
The ID of the mark which contains the entities. 

",,
1429,*descriptorsetcolor,"Description
Sets the color of the plot descriptor. 
","Inputs

color
The color of the descriptor. 

",,
1430,*descriptorsettext,"Description
Sets the text which should be displayed in the plot descriptor. 
","Inputs

text
The text which should be displayed in the plot descriptor. 

",,
1431,*detach_fromwall,"Description
Detaches elements from the nodes of wall elements. The elements surrounding the wall can be
        classified as belonging to different clusters based on which side of the wall elements they
        appear. For each cluster of elements attached to the wall, the shared nodes are duplicated
        after detachment. 
The elements surrounding the wall must be one dimension higher than the wall elements. 
Use a non-zero offset distance to separate the duplicated nodes from the nodes on wall. If
          detach_ends is set to 1 then the command will also detach at the
        boundaries of the wall elements lying on the exterior of attached surrounding elements. Note
        that whether one sets detach_ends to 0 or not , the wall boundary nodes
        in the interior of elements attached to wall are not detached.
","Inputs

surround_mark_id
The mark ID of elements to detach from the wall. Valid values are 1 and 2. These elements must be one dimension higher than the wall
            elements.
wall_mark_id
The mark ID of wall elements to detach from. Valid values are 1 and 2. These elements must be one dimension lower than the surrounding
            elements.
offset
The distance by which the surrounding elements should be offset from the wall.
detach_ends
0 - The surrounding elements are not detached from the wall end, but the interior
            nodes are still detached. 
1 - Detaches the surrounding elements also at any free ends of the wall.

","Example
To detach shell elements 1-100 from 1D elements 1000-1010, offsetting by 5.0 and not
        detaching any free
        ends:*createmark elems 1 1-100
*createmark elems 2 1000-1010
*detach_fromwall 1 2 5.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1432,*detachallelements,"Description
Detaches elements from each other and from the attached structure, using the specified
        offset value.
","Inputs

mark_id
The ID of the mark of elements to detach. Valid values are 1 and 2.
offset
The distance by which the elements should be offset from the attached structure.

","Example
To detach elements 10 and one layer of adjacent elements from each other and from the
        remainder of the
        structure:*createmark elems 1 10
*appendmark elems 1 adjacent
*detachallelements 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1433,*detectandcreateface2facecontacts,"Description
Detects if the specified components are within the contact distance specified and creates
        contact entities relevant to the solver interface.
The current solver template is used as an implicit input.
The output contact entities are created specific to a supported solver. For example, in
          ANSYS it will create contact surfaces and groups whereas in
          OptiStruct it will create groups with card images.
This is supported for ANSYS, OptiStruct, Samcef and Nastran (MSC).
","Inputs

input_entity_type
The input entity type. Must be set to comps or elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
tolerance
A non-zero search distance specified as the vicinity within which the contact is to be
            detected by executing the penetration collision logic. Components spaced greater than
            the vicinity tolerance are not considered to be in contact.
reverse_angle
The angle value used to compute the extent of the contact surface. This parameter is
            used in detecting the span of a convex contact surface on non-planar surfaces.
use_shell_thickness
A flag to use element thickness values specified on shell elements as the search
            distance. When this flag is specified as 1, then tolerance is ignored or can be 0.
consolidate_surfaces
After the contact is detected, contact surfaces are created. Those contact surfaces
            can be on different topological locations (discontinuous) on the base component that is
            in contact with that particular target component. When set as 0, a contact surface for
            each discontinuous patch is created and updated in the contact group. If set as 1, then
            only 1 contact surface is created for all the discontinuous patches.
run_intersection_check
Before a contact is detected and established using the penetration algorithm, the user
            has the option to execute the intersection check between any two components for the same
            input parameters of tolerance and reverse_angle by
            setting this as 1. Intersection is detected even if one element on the source component
            physically intersects an element on the target component. In such cases the contact
            surface normal is not uniquely defined for those intersecting elements.
When this is 0, the intersection check is not executed. However, the contact will be
            detected and contact surfaces will be created, but the resulting contact surface normal
            may not be desirable.
contact_type
The type of contact to create. The following values are supported:


Solver
Value
Type




OptiStruct
0
Contact


1
Tie


Samcef
0
MCT


1
STI





master_entity_type
The master entity type. The following values are supported:


Solver
Value
Type




OptiStruct
0 (default)
SET_ELEM


1
SURF





slave_entity_type
The slave entity type. The following values are supported:


Solver
contact_type
Value
Type




OptiStruct
all
0
SET_GRID


1
SET_ELEM


2
SURF


Samcef
0 (MCT)
0
SET of elements (2D)CONTACT SURFACE (3D)



1
SET of nodes (2D)SET of face nodes (3D)






property_option
The property option. The following values are supported:


Solver
contact_type
Value
Type




ANSYS
N/A
0
Existing property ID is used


1
Infer sensors and auto-generate properties


OptiStruct
0 (Contact)
0
SLIDE


1
STICK


2
FREEZE


Nastran (MSC)
N/A
<prop_id>
Geometric contact property ID (BCGPIC)





contact_property_id
On creation of contact pairs, some of the interfaces have attributes to select
            property ID as the input. When this argument is specified with an ID, and if it exists,
            it is attached to the contact pair. For non-relevant interfaces this will be
            ignored.
Note that this argument supersedes property_option and
              static_friction_value, except for ANSYS. In ANSYS, if property_option is
            specified, then contact_property_id is ignored.
In Nastran (MSC) this is the physical contact property
            (BCPPID).
This is relevant for ANSYS, Nastran and OptiStruct.
static_friction_value
The value for the static friction coefficient. This is superseded by
              contact_property_id and property_option
            arguments. If contact_property_id, property_option
            and static_friction_value are all specified,
              contact_property_id takes precedence. If
              property_option and static_friction_value are
            both specified, property_option takes precedence. In both cases, the
            friction value is adjusted internally to a negative number to establish precedence and
            thus will be ignored.
This is only relevant for OptiStruct.
contact_material_id
On creation of contact pairs, some of the interfaces have attributes to select
            material ID as the input. When this argument is specified with such an ID, and if it
            exists, it is attached to the contact pair. For non-relevant interfaces this will be
            ignored.
This is only relevant for ANSYS.
contact_master_sensor_id
On creation of contact pairs, some of the interfaces have attributes to select master
            sensor ID as the input. When this argument is specified with such an ID, and if it
            exists, it is attached to the contact pair. For non-relevant interfaces this will be
            ignored. In ANSYS, property_option is
            ignored when specified along with this option.
This is only relevant for ANSYS.
contact_slave_sensor_id
On creation of contact pairs, some of the interfaces have attributes to select slave
            sensor ID as the input. When this argument is specified with such an ID, and if it
            exists, it is attached to the contact pair. For non-relevant interfaces this will be
            ignored. In ANSYS, property_option is
            ignored when specified along with this option.
This is only relevant for ANSYS.
skip_preview
After creation of contact entities, by default (0), all the newly created contact
            entities are considered to be ""under review"" and their export flag is turned off. If you
            choose to confirm all the auto-contact created entities and have their export flag
            turned on, this should be 1. When specified as 1, a confirmation dialog box with the
            entities list is also skipped.
consider_self
Consider elements in the same component for creation of contacts. By default (0),
            elements within the same components are not considered for the creation of contacts. If
            a single component is selected as input, this should be set to 1.
copy_tolerance_to_contact
Copies the tolerance value specified by the user to a relevant search distance
            parameter on the created group entity. By default (0), no value is copied to the
            createdgroup entity. When specified as 1, the specified tolerance value is copied to the
            following parameter on the created group entity:


Solver
Group Parameter




OptiStruct
SRCHDIS






","Examples
To detect contacts between all components in the model:
hm_createmark comps 1 ""advanced"" ""all""
*detectandcreateface2facecontacts components 1 1.0 15.0
To create contacts between components by using shell thickness and consolidating
        surfaces:*detectandcreateface2facecontacts components 1 0 15.0 1
To create contacts in ANSYS with property (1), material (2),
        master (3) and slave sensor (4)
        specified:*detectandcreateface2facecontacts components 1 1.0 15.0 0 0 1 0 0 0 0 1 0 2 3 4
To run an intersection check and create contact entities in OptiStruct with master entity type as SURF(1) and slave entity type as
        SURF(2) with static friction coefficient as
        0.18:*detectandcreateface2facecontacts components 1 5 15 0 1 1 0 1 2 0 0 0.18
To run intersection check and create contact entities in OptiStruct with master entity type as SET OF ELEMENTS(0) and slave
        entity type as SET OF NODES(1) with property option as
        STICK(1):*detectandcreateface2facecontacts components 1 5 15 0 1 1 0 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1434,*displayall,"Description
Turns on the display of all entities in the model.
","Example
To turn on the display of all entities:*displayall
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1435,*displaycollectorsall,"Description
Controls the display state of all collectors.
","Inputs

mode
The mode being performed, defined by the following:
on - All collectors are turned on. 
all - All collectors are turned on. 
off - All collectors are turned off. 
none - All collectors are turned off. 
toggle - All collectors are toggled (visible become invisible and vice-versa). 
reverse - All collectors are toggled (visible become invisible and
                vice-versa).


elements
Indicates if elements within collectors are to be turned on or off.
1 - Yes
0 - No


geometry
Indicates if geometry within collectors are to be turned on or off.
1 - Yes
0 - No



","Example
To turn off all entities in the user mark, except
        geometry:*displaycollectorsall(off,1,0)
",
1436,*displaycollectorsbymark,"Description
Changes the display state of collectors in a mark.
","Inputs

entity type
The collector type. Valid types for this function are:
Components
Loadcols
Systcols
Vectorcols
Multibodies


mark_id
The ID of the mark (1 or 2) that specifies collectors to be used in the above
            functions.
mode
The mode being performed, defined by the following:
on - All collectors are turned on. 
all - All collectors are turned on. 
off - All collectors are turned off. 
none - All collectors are turned off. 
toggle - All collectors are toggled (visible become invisible and vice-versa). 
reverse - All collectors are toggled (visible become invisible and vice-versa).
              


elements
Indicates if elements within collectors are to be turned on or off.
1 - Yes
0 - No


geometry
Indicates if geometry within collectors are to be turned on or off.
1 - Yes
0 - No



","Example
To turn the elements on in the components fender, box and bolt, and keep the geometry as it
        is:
        *createmark(comps,1) ""fender"" ""box"" ""bolt""
*displaycollectorsbymark(components,1,on,1,0)
",
1437,*displayelementsbyproperty,"Description
Controls the display of elements that have either a direct, indirect or mixed property
        assignment.
","Inputs

mode
The mode to control the element display. Valid values are:
on - Turn on the elements. 
off - Turn off the elements. 
reverse - Reverse the display of the elements (if off, turn on and if on, turn
                off). 
isolate - Isolate the display of the elements (turn off all others).


type
The property assignment type to use for selecting the elements to display. Valid
            values are:
0 - Direct property assignment. 
1 - Indirect property assignment. 
2 - Any property assignment.



","Example
To turn on the display of all elements with a direct property
        assignment:*displayelementsbyproperty on 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1438,*displayincludeonly,"Description
Displays all entities contained in the specified include file, and hides all other
        entities.
","Inputs

id
The ID of the include file whose entities you wish to display.
shortname
Currently not used.

","Example
To display all of the elements in the include file with ID 3, and hide all other entities
        without actually deleting them:*displayincludeonly(3,0)
",
1439,*draglinetoformsurface,"Description
Drags a trimmed line to create a surface, and optionally, prepares it for immediate use
        within the automesher. It can also identify a region in the shape of a dragged surface for
        the automesher to use under the mesh without surface option.
","Inputs

linelist
The ID of the list of lines to be dragged.
list
The list ID of the zero or two nodes which lie on the lines in the line list, which
            will be used to trim the line during surface creation. 
direction_vector
The direction to drag the lines. 
distance
The distance to drag the lines. 

","Example
To drag two lines, trimmed by two points, -100 units in the direction of the y-axis,
        creating a surface but no elements:
        *surfacemode(4)
*createlist(lines,1) 1 2
*createlist(nodes,1) 29 30
*createvector(1,0.0000,1.0000,0.0000)
*draglinetoformsurface(1,1,1,-100.0000)

The *surfacemode(4) directive tells HyperMesh not to pass the
        information on to the automesher for element creation. 
*createlist() and *createvector() are required for
        this command
",
1440,*drawlistresetstyle,"Description
Resets the display mode on the draw list to the default.
",,,
1441,*duplicateentities,"Description
Duplicates elems, nodes and comps along with any attached loads.
","Inputs

entity_type
The entity type to duplicate. Valid values are elements, components and nodes. 
input_mark_id
The mark ID containing the entities to duplicate. Valid values are 1 and 2.
output_mark_id
The mark ID containing the new entities. Valid values are 1 and 2.
option=<value>
The following options are available:
destcomponent=<value>
Required option.
1 - New component.
2 - Current component.




transformloads=<value>
0 - Do not transform loads (default).
1 - Transform loads.


destloadcol=<value>
Valid only if transformloads is 1. Required option.
1 - New load collector.
2 - Current load collector.




reverseloads=<value>
Valid only if transformloads is 1.
0 - Do not reverse loads (default).
1 - Reverse loads.





","Examples
To duplicate the element with ID 1 and place the new element in the current
        component:*createmark elems 1 1
*duplicateentities elems 1 2 destcomponent=2
To duplicate all elements, place the elements in a new component, and transform the loads
        and place them in a new load
        collector:*createmark elems 1 all
*duplicateentities elems 1 2 transformloads=1 destcomponent=1 destloadcol=
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1442,*dynamicrotatemode,"Description
Sets mode for output of intermediate rotation commands. 
","Inputs

mode
Set to 1 or 0.

","Example
When mode is set to 1, the following output is
        generated:*dynamicviewbegin()
*quatrotate(-0.00785649346,-5.7397916e-005,0.00228960797,0.999966514)
*quatrotate(-0.00994070323,0.00170778765,0.0047803938,0.999937705)
*quatrotate(-0.00529684395,-0.000673180986,0.000802068982,0.999985423)
*quatrotate(0.000230328525,0.00100703597,0.00106667981,0.999998898)
*quatrotate(-0.00263644785,-0.000327769044,0.000395387048,0.999996393)
*dynamicviewend()
When mode is set to 0, the following output is
        generated:*viewset(-0.722177, -0.299006,  0.623743,  0.000000,
0.657815, -0.575689,  0.485656,  0.000000,
0.213868,  0.761037,  0.612440,  0.000000,
    -3.756111,  5.964252, -3.030465,  1.000000,
    -8.703590,  2.583235,  0.886445,  8.621393)
When the mode is set to 1, intermediate *quadrotate() rotation commands
        are output to the command file. Otherwise, only the final position is output, reducing the
        size of the command file.
",
1443,*dynamicviewend,"Description
Ends a block of *rotate(), *window(), or
          *quatrotate() commands.
","Inputs
",,
1444,*edgerestore,"Description
Unsuppress the selected edge.
","Inputs

edge
The edge to unsuppress.

","Example
To unsuppress edge 5:*edgerestroe(5)
Only face edges that are interior to a surface or shared between two surfaces may be
        suppressed and unsuppressed. Unsuppressing an edge can split a surface into two new
        surfaces, and causes it to affect the mesh.
",
1445,*edgesmarkrelease,"Description
Unstitches each of the input edges.
","Inputs

markmask
The mark ID containing the edges.

","Example
To unstitch edges 16, 18, 25, and
        44:*createmark(lines,1) 16 18 25 44
*edgesmarkrelease(1)
Only unsuppressed face edges can be released.
",
1446,*edgesmarkrestorejoints,"Description
This command restores previously suppressed (by using
          *verticesmarksuppress) fixed points on selected surface edges.
","Inputs

mark_id
The mark ID of input surface edges. Valid values are 1 and 2.

","Example
To restore fixed points on surface edge
        99:*createmark lines 1 99
*edgesmarkrestorejoints 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1447,*edgesmarkuntrim,"Description
Removes the specified trimming lines from their surface.
","Inputs

mark
The mark ID containing trimming edges to remove. Valid values are 1 and 2.

",,
1448,*edgesuppress,"Description
Suppresses the selected edge.
","Inputs

edge
The edge to suppress.

","Example
To suppress edge 5:*edgesuppress(5)
Only face edges which are interior to a surface or shared between two surfaces may be
        suppressed and unsuppressed. Suppressing an edge can combine two separate surfaces, and
        removes its affect on the mesh.
",
1449,*element_smooth_nodes,"Description
Smooth a selection of elements with optional anchor nodes.
<option>=<value> options can be provided in any order.
","Inputs

mark_id
The ID of the mark containing the elements to smooth. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing any anchor nodes. Valid values are 1 and 2.

Iterations=<value>

The maximum number of smoothing iterations to perform (default 1).

Method=<value>

The smoothing method.
Angle - Angle correction-based smoothing
AutoDecideWithoutQI
AutoDecideWithQI - Size correction-based smoothing, and QI smoothing of failed
            elements with possible constrained movement of nodes off of geometry edges.  Control of
            the nodes movement off of the geometry edges, the thresholds of the movement, and the
            element feature angle, are controlled by the current parameter file.
AutoDecideWithQI_Params_locked - Size correction-based smoothing, and QI smoothing of
            failed elements.  Node movement off of geometry edges is not allowed.  The paramter file
            has no effect, and the element feature angle is taken from the global preferences.
QI - QI correction-based smoothing
Shape - Shape correction-based smoothing
Size - Size correction-based smoothing



TimeLimit=<value>

The time limit in minutes for QI and AutoDecideWithQI (default is off).

","Example
Smooth elements 100-200 with anchor nodes 150 and 151 using QI method:
*createmark elements 1 100-200
*createmark nodes 1 150 151
*element_smooth_nodes 1 1 Method=QI

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1450,*element2Dalign,"Description
Aligns the order of nodes in 2D elements based on the nodes of attached 1D elements. This
        is done in such a way that the starting edge the 2D element has the same nodes as the 1D
        element. This can also use aligned quad elements to align all ""attached by edge"" quads with
        the same node order.
","Inputs

mark_id_2D
The mark ID containing the quad elements to align.
mark_id_1D
The mark ID containing the 1D elements to use as reference. 2D elements can only be
            used when propagate is set to 1 or 2.
propagate
0 - Aligns only 2D elements directly attached by edge to 1D elements (1 layer). 
1 - Propagate alignment to all attached by edge quad elements. Several assumptions
            apply to this option: 
Mesh has a regular structure in terms of connectivity. ""Regular"" means that it is
                a drag-like structure. 
Mesh structure may contain holes, and layers may be truncated.
For example, you can take a regular 16x9 grid of quads and delete any quads from
                the grid, keeping the rest connected by edges. Not more than one 1D element for
                alignment should contact any 2D element. To avoid conflicts, aligning 1D elements
                should not be in different alignment directions.


For regular quad meshes just one 1D or 2D element is enough to set alignment for the
            whole grid. If there are other (tria) 2D elements in the mesh, the command aligns only
            the tria elements directly attached to 1D elements. 
2 - Same as 1, but shift base nodes to make a ""checkerboard"". 

","Examples
To align all quad4 elements by plot elements use the
        command:*createmark elems 1 ""by config"" quad4
*createmark elems 2 ""by config"" plot
*element2Dalign 1 2 1

To align all displayed elements to element ID
        100:*createmark elems 1 displayed
*createmark elems 2 100
*element2Dalign 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1451,*element3Dalign,"Description
Aligns the order of nodes in 3D elements based on the nodes of attached 2D elements. This
        is done in such a way that the base face of the 3D element has the same nodes as the 2D
        element. This can also use aligned hexa elements to align all ""attached by face"" hexas with
        the same node order.
","Inputs

mark_id_3D
The mark ID containing the hexa elements to align.
mark_id_2D
The mark ID containing the 2D/3D elements to use as reference. 3D elements can only be
            used when propagate is set to 1 or 2.
propagate
0 - Aligns only 3D elements directly attached by face to 2D elements (1 layer). 
1 - Propagate alignment to all attached by face hex elements. Several assumptions
            apply to this option: 
Mesh has a regular structure in terms of connectivity in the base face normal
                direction. ""Regular"" means that it is a drag-like structure. 
Mesh structure may contain holes, and layers may be truncated. For example, you
                can take a regular 16x9x5 grid of hexas and delete any hexas from the grid, keeping
                the rest connected by faces. 
Not more than one 2D element for alignment should contact any 3D element. To
                avoid conflicts, aligning 2D elements should not be in different alignment
                directions. 
For regular hexa meshes just one 2D or 3D element is enough to set alignment for
                the whole grid. If there are other non-hexa 3D elements in the mesh, the command
                aligns only the non-hexa elements directly attached to 2D elements. 


2 - Same as 1, but shift base nodes to make a ""checkerboard"". 

","Example
To align all hex8 elements by quad4 elements use the
        command:*createmark elems 1 ""by config"" hex8
*createmark elems 2 ""by config"" quad4
*element3Dalign 1 2 1
To align 1 layer of 3D elements by attached shell elements
        use:*createmark elems 1 displayed
*createmark elems 2 displayed
*element3Dalign 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1452,*elementchecksettings,"Description
This command specifies the methods for calculating element quality checks which are
        generally those used by an FE solver. 
If an invalid method index is specified for any check, the HyperMesh check is utilized.
","Inputs

solver
Solver method to use for all checks. If a value of -1 is given, a distinct method can
            be supplied for some individual checks (see each option below to determine relevance).
            Valid values for the method/solver are:
0 - HyperMesh

1 - Abaqus

2 - I-deas

4 - Moldflow 
5 - Nastran

6 - OptiStruct

8 - Radioss

9 - ANSYS

10 - Medina 
12 - HyperMesh-Alt


jacobian_2d
Flag indicating the type of Jacobian calculation to use for 2D elements. Valid values are:
0 - Calculate at integration points (default HyperMesh value). 
1 - Calculate at corners. 
2 - At corner and mid points. 
3 - At high order integration points.


jacobian_3d
Flag indicating the type of Jacobian calculation to use for 3D elements. Valid values are:
0 - Calculate at integration points. 
1 - Calculate at corners. 
2 - At corner and mid points. 
3 - At high order integration points.


min_len_2d
Flag for minimum 2D element edge calculations. Valid values are:
0 - Calculate using the shortest edge. 
1 - Calculate using the minimum normalized height (default HyperMesh value).
2 - Calculate using the minimum height. 
10 - Calculate using Radioss default formulation. 
20 - Calculate using LS-DYNA ISDO=0. 
21 - Calculate using LS-DYNA  ISDO=1. 
22 - Calculate using LS-DYNA  ISDO=2. 
30 - Calculate using PAM-CRASH LARGE active.
31 - Calculate using PAM-CRASH SMALL active.


Methods 1 and 2 differ only for tria elements. Method 1 finds minimum tria length as
            its minimum height multiplied by the factor sqrt(3)/2. For equilateral
            triangles, this method returns exactly the triangle side length. Method 2 finds the
            minimum tria length as its minimum height.
min_len_3d
Flag for minimum 3D element edge calculations. Valid values are:
0 - Calculate using the shortest edge 
1 - Calculate using the minimum height (tetra) (default HyperMesh value) 
10 - Calculate using  Radioss default formulation 
20 - Calculate using LS-DYNA ISDO=0 
21 - Calculate using LS-DYNA ISDO=1 
22 - Calculate using LS-DYNA ISDO=2 
30 - Calculate using  PAM-CRASH LARGE active 
31 - Calculate using  PAM-CRASH SMALL active


aspect_2d
Method used to calculate the aspect ratio of 2D elements. This value is used only if
            the solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus

2 - Ideas 
4 - Moldflow 
5 - Nastran
6 - OptiStruct

8 - Patran 
9 - ANSYS
10 - Medina 
12 - HyperMesh-Alt


aspect_3d
Method used to calculate the aspect ratio of 3D elements. This value is used only if
            the solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus

2 - Ideas 
4 - Moldflow 
5 - Nastran
8 - Patran 
9 - ANSYS


skew_2d
Method used to calculate the skew of 2D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus

2 - Ideas 
5 - Nastran
6 - OptiStruct

8 - Patran 
9 - ANSYS
10 - Medina 
12 - HyperMesh-Alt


skew_3d
Method used to calculate the skew of 3D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus


angle
Method used to calculate the interior angle of 2D elements. This value is used only if
            the solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus

5 - Nastran
6 - OptiStruct

8 - Patran 
9 - ANSYS
10 - Medina 


warpage
Method used to calculate the warpage of 2D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh

1 - Abaqus

2 - Ideas 
5 - Nastran
6 - OptiStruct

8 - Patran 
9 - ANSYS
10 - Medina 
12 - HyperMesh-Alt


taper
Method used to calculate the taper of 2D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh

2 - Ideas 
5 - Nastran
6 - OptiStruct

8 - Patran 
10 - Medina 
12 - HyperMesh-Alt


chord_dev
Method used to calculate chordal deviation of 2D elements. This value is used only if
            the solver parameter is set to -1. Valid methods are:
0 - HyperMesh



tetra_collapse
Method used to calculate tetra collapse of tetra elements. This value is used only if
            the solver parameter is set to -1. Valid methods are:
0 - HyperMesh



cell_squish_2d
Method used to calculate cell squish of 2D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh



equi_skew_2d
Method used to calculate the equi skew of 2D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh



cell_squish_3d
Method used to calculate cell squish of 3D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh



equi_skew_3d
Method used to calculate the equi skew of 3D elements. This value is used only if the
            solver parameter is set to -1. Valid methods are:
0 - HyperMesh



time_step
Method used to calculate time step. This value is used only if the solver parameter is
            set to -1. Valid methods are:
0 - HyperMesh



reserved_1
Reserved for future use. Should always be 0.
reserved_2
Reserved for future use. Should always be 0.
reserved_3
Reserved for future use. Should always be 0.
reserved_4
Reserved for future use. Should always be 0.

","Example
Set to use the OptiStruct
        checks:*elementchecksettings 6 0 0 1 1 6 0 6 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0
",
1453,*elementqualitycollapseedge,"Description
This command collapses an edge between two elements. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command.
 Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_id
The element ID.
edge_index
The index of the edge to collapse.

","Example
To collapse edge 1 for element 20 using quality criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualitycollapseedge 20 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1454,*elementqualitydragtriaelem,"Description
This command, within the interactive cleanup tool, moves a tria element towards a specified
        point. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_id
The tria element ID.
px py pz
Coordinates of a point that defines the drag direction.
merge_tria
0 - Do not merge trias when they are close together. 
1 - Merge trias when they come close together.
end
0 - This is an intermediate movement and there are additional movements following this
            one. 
1 - This is the last call of this command.

","Example
To drag tria element 3 towards (5.7, 3.78, 991.0) using quality criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualitydragtriaelem 3 5.7 3.78 991.0 0 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1455,*elementqualityoptimizeelement_2,"Description
Optimizes 2D element node locations to improve the element and adjacent elements’ quality
        index according to pre-set quality criteria.
This command only functions between *elementqualitysetup and
          *elementqualityshutdown commands.
The element quality criteria for optimization must be set before using this command. The
        command may be applied at any time without resetting the current quality criteria.
","
Inputs



id

The ID of the element to optimize.

midnodes

0 - Do not consider neighboring midnodes during optimization
1 - Consider neighboring midnodes during optimization

optimize

1 - Along surface
5 - Along associated geometry

","Examples
To optimize the node locations of the elements with IDs 397, 432, and 102 using quality
        criteria from a file:
*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualityoptimizeelement_2 397 1 1 
*elementqualityoptimizeelement_2 432 0 5
*elementqualityoptimizeelement_2 102 1 5
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1456,*elementqualityoptimizenodenew,"Description
This command optimizes a node location to improve the attached elements' quality index
        according to pre-set quality criteria. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

node_id
The node ID.
midnodes_flag
Neighboring mid-nodes during optimization.
0 - Do not consider neighboring.
1 - Consider neighboring.


optimize_flag
Optimize the node location.
1 - Along the surface.
2 - Normal to the surface.
3 - Along and then normal to the surface.



","Example
To optimize the location of the nodes with ID's 102, 397 and 432 using quality criteria
        from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualityoptimizenodenew 102 1 1
*elementqualityoptimizenodenew 397 0 2
*elementqualityoptimizenodenew 432 1 1
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1457,*elementqualityredoaction,"Description
Within the interactive element cleanup tool, repeats the effects of the last specified
        command that was reversed by a call to *elementqualityundoaction(). 
","Example

*elementqualityredoaction

This command only functions between a *elementqualitysetup() command and
        a *elementqualityshutdown() command.
",,
1458,*elementqualitysetup_new,"Description
Prepares a mark of elements for use within the interactive element cleanup tool.
This function interacts closely with the other *elementquality commands,
        and cannot function separately from them. It must be accompanied by a corresponding
          *elementqualityshutdown command.
","Inputs

mark_id
The mark ID containing the elements to be modified.  Valid values are 1 and 2.

","Example

*createmark elements 1 10 11 12 13 14 15 16
*elementqualitysetup_new 1
<<various *elementquality commands>>
*elementqualityshutdown 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1459,*elementqualitysmoothnodesnew,"Description
This command smooths/optimizes nodes of selected elements. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_mark_id
The mark ID containing the elements to smooth. Valid values are 1 and 2.
node_mark_id
The mark ID containing any anchor nodes. Valid values are 1 and 2.
algorithm
0 - Autodecide. 
1 - Size corrected. 
2 - Shape corrected. 
3 - QI optimization. 
4 - QI optimization maintaining nodes on geometry edges. For models without geometry,
            this is the same as 3.
target_qi
The target QI value, when algorithm is set to 3.
max_iterations
The maximum number of iterations, when algorithm is set to 3.
time_limit
The maximum time limit, when algorithm is set to 3.

","Example
To smooth elements 1-100 using QI optimization with a target QI of 0.2 using quality
        criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*createmark elems 1 1-100
*elementqualitysmoothnodesnew 1 1 3 0.2 5 0
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1460,*elementqualitysplitelem,"Description
This command splits a quad element into two trias. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command. 
Current element quality criteria for optimization must be set before using this command.
        The command may be applied at any time without resetting the current quality criteria.
","Inputs

elem_id
The quad element ID.

","Example
To collapse tria elements 10 and 11 using quality criteria from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elementqualitysplitelem 10
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1461,*elementqualityundoaction,"Description
Within the interactive element cleanup tool, reverses the effects of the last specified
        command.
","Example

*elementqualityundoaction()

This command only functions between a *elementqualitysetup() command and
        a *elementqualityshutdown() command.
",,
1462,*elementsaddnodesfixed,"Description
Marks the specified nodes of the old elements as fixed nodes (nodes that must be retained
        in the mesh to be created) before using the commands for remeshing/meshing by elements.
","Inputs

elements_mark
The mark of elements that are considered for remeshing/meshing by elements. Valid values are 1 and 2.
nodes_mark
The mark of nodes specifying the nodes to be retained in the new mesh. Valid values are 1 and 2.

","Example
To remesh the elements 154, 155, 158, 159, 160, 161, 164, 165, 339, 341, 343, 345, and 347,
        and retain the nodes 210, 277, and 370 in the mesh to be
        created:*createmark(elements,1) 154 155 158 159 160 161 164 165 339 341 343 345 347
*createmark(nodes,2) 210 277 370
*elementsaddnodesfixed(1,2)
*defaultremeshelems(1,3.0,2,2,0,1,1,1,0,0,0,0,0,30)
Using *elementsaddnodesfixed() implies that it will be followed by a
        command that performs remeshing/meshing by elements. For example,
          *defaultremeshelems(), *defaultmeshelems(),
          *interactiveremeshelems(), or
          *interactivemeshelems(). *createmark() directive is
        required for this command. 
",
1463,*elementtestaltitudeaspect,"Description
Tests tetra elements for whether or not they pass the tetra AR element quality check, and
        puts those that fail on the specified output mark.
","Inputs

entities
The entity types to be checked. Currently, the only allowable option is elements.
markmask
The mark that contains the elements to test.
aspectratio
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
contour
A code telling if HyperMesh should:
0 - Display the results of the test normally.
1 - Display the elements color coded by their ratings.
2 - Build a histogram showing the distribution of ratings.


title
The title with which to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestaspect(elements, 1, 5, 2, 0, ""Tetra Altitude Aspect"")

The tetra element aspect ratio corresponds directly to the Nastran TETRAAR element quality check. It is calculated by dividing the
        largest edge length of the element by its smallest altitude.
",
1464,*elementtestcellsquish,"Description
Tests 2D and 3D elements using the cell squish element quality check.
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
cell_squish
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
dimension
A code telling to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
Flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. Only required, if
              contour is 2.

","Example
To test all displayed elements for a cell squish of
        0.5:*createmark elements 1 ""displayed""
*createmark elements 2
*elementtestcellsquish elements 1 0.5 0 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1465,*elementtestconnectivity,"Description
Tests elements for whether or not they are connected in any one of a number of common but
        invalid ways and puts those that are on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
1 - Measure 1D elements. 
2 - Measure 2D elements.
4 - Measure 3D elements.



","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestconnectivity(elements,1,2,1)

",
1466,*elementtestduplicates,"Description
Tests elements for whether or not any two share the same nodes in the same order and puts
        all except one of any set of duplicates on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
1 - Measure 1D elements. 
2 - Measure 2D elements. 
4 - Measure 3D elements.



","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestduplicates(elements,1,2,1)

",
1467,*elementtestfree1d,"Description
Tests 1D elements for free nodes.
","Inputs

entity_type
The entity types to be returned. Both nodes and elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
output_mark_id
The mark ID where the failed elements or nodes will be placed. Valid values are 1 and 2.

","Example
To test all displayed elements to find the free 1D
        elements:*createmark elems 1 ""displayed""
*createmark elems 2
*elementtestfree1d elems 1 2
To test all displayed elements to find the free 1D element
        nodes:*createmark elems 1 ""displayed""
*createmark nodes 2
*elementtestfree1d nodes 1 2

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1468,*elementtestjacobian,"Description
Tests 2D and 3D elements for whether or not they pass the Jacobian ratio element quality
        check, and puts those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, elements is the only allowable option.
markmask
The mark that contains the elements to test.
jacobian
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestjacobian(elements,1,0.7,2,2,0,""2D Element Jacobian"")

The details of the Jacobian ratio element quality check can be found in the online help for
        the Check Elements panel. 
",
1469,*elementtestorthogonality,"Description
Tests 3D elements for whether or not they pass the orthogonality element quality check, and
        puts those that fail on the specified outputmark.
","Inputs

entity_type
The entity types to be checked. Currently, elements is the only allowable option.
input_mark_id
The mark that contains the elements to test.
orthogonality
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
output_mark_id
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Examples
To test all displayed 3D elements for an orthogonality value less than 0.2:
*createmark elements 1 ""displayed""
*createmark elements 2
*elementtestorthogonality elements 1 0.2 2 4 0 ""3D Orthogonality"")
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1470,*elementtestsizeratio,"Description
Tests 3D elements for whether or not they pass the neighbor size ratio element quality
        check, and puts those that fail on the specified outputmark.
","Inputs

entity_type
The entity types to be checked. Currently, elements is the only allowable option.
input_mark_id
The mark that contains the elements to test.
size_ratio
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
output_mark_id
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Examples
To test all displayed 3D elements for a neighbor size ratio value less than 0.1:
*createmark elements 1 ""displayed""
*createmark elements 2
*elementtestsizeratio elements 1 0.1 2 4 0 ""3D Neighbor Size Ratio"")
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1471,*elementtesttetracollapse,"Description
Tests tetra elements for whether or not they pass the tetra collapse element quality check,
        and puts those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, only elements is supported.
markmask
The mark that contains the elements to test.
collapseval
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtesttetracollapse(elements,1,0.5,2,0,""Tetra Collapse"")

The details of the tetra collapse element quality check can be found in the online help for
        the Check Elements panel. 
",
1472,*elementtestvolumeareaskew,"Description
Tests 2D and 3D elements using the volumetric and areal element quality check. The 3D
        volumetric skew corresponds directly to the Abaqus and Fluent
        CFD tetra element quality checks.
","Inputs

entity_type
The entity types to be checked. Only elements are supported.
mark_id
The mark ID containing the elements to test. Valid values are 1 and 2.
skew
The value to use as a threshold beyond which elements should be considered to have
            failed the test.
dimension
A code to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


output_mark_id
The mark ID where the failed elements will be placed. Valid values are 1 and 2.
contour
A flag that determines how the results are presented. Valid values are:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram. Only required, if
              contour is 2.

","Example
To test all displayed tetra elements for a volumetric skew of
        0.6:*createmark elems 1 ""displayed""
*elementtestvolumeareaskew elems 1 0.6 0 4 0 """"
To test all displayed tria elements for an areal skew of
        0.5:*createmark elems 1 ""displayed""
*elementtestvolumeareaskew elems 1 0.5 0 2 0 """"
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1473,*elementtestwarpage,"Description
Tests 2D and 3D elements for whether or not they pass the warpage element quality check,
        and puts those that fail on the specified outputmark.
","Inputs

entities
The entity types to be checked. Currently, only elements is supported.
markmask
The mark that contains the elements to test.
angle
The value to use as a threshold beyond which elements should be considered to have
            failed the test (in degrees).
outputmark
The mark where HyperMesh should put the elements that fail
            the test.
dimension
A code telling to measure the dimension of:
2 - Measure 2D elements. 
4 - Measure 3D elements.


contour
A code telling if HyperMesh should:
0 - Display the results of the test normally. 
1 - Display the elements color coded by their ratings. 
2 - Build a histogram showing the distribution of ratings.


title
The title to label the curve in the histogram.

","Example

*createmark(elements,1) ""displayed""
*createmark(elements,2)
*elementtestwarpage(elements,1,5,2,2,0,""2D Element Warpage"")

The details of the warpage element quality check can be found in the online help for the
        Check Element panel.
",
1474,*elemoffset,"Description
Offsets shell elements normally to create solid elements.
","Inputs

mark_id
The mark ID containing the elements to offset. Valid values are 1 and 2.
density
The density (number of layers) of solid elements to create in the normal
            direction.
bias_style
The bias style.
bias
The bias intensity value.
initial_offset
The initial offset value.
corner_type
0 - Create elements with square corners. 
1 - Create elements with rounded corners. 
8 - Offset the elements using CFD corners. When this option is specified, an
            additional mark of surfaces and elements can be specified to specify the geometry to
            follow.
thickness_type
0 - Elements are offset by the value of thickness. 
1 - Elements are by the thickness of the selected elements. 
2 - Elements are offset by the thickness from the element size.
4 - Elements are offset by a distribution with different thickness ratios per
            node.
thickness
The total thickness of the layers of elements to create.
shells_only
0 - Create hexas and pentas from quads and trias, and create quads from plot elements. 
1 - Create offset quads, trias, and plot elements. 
3 - Thicken shell elements into solids.
offset_type
0 - Create elements in the positive normal element direction. 
1 - Create elements in the negative normal element direction.
component_flag
0 - Newly created elements should be organized into the current component. 
1 - Newly created elements should be organized into the component of the input
            elements.

","Example
To build layers of solid elements by offsetting shells 22 and
        109:*createmark elems 1 22 109
*elemoffset 1 3 0 0 0.5 1 0 1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1475,*elempatchdecraction,"Description
Decreases the QI patch checker patch size by one element layer. 
This command only functions between an *elempatchstartaction command and
        an *elempatchstopaction command.
","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1476,*elempatchnextaction,"Description
Moves to the next failed element patch in the QI patch checker patch. 
This command only functions between an *elempatchstartaction command and
        an *elempatchstopaction command.
","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1477,*elempatchstartaction,"Description
Starts the QI patch checker. 
This command only functions between an *elementqualitysetup command and
        an *elementqualityshutdown command.
","Inputs

patch_type
Must be set to 0.
threshold
Threshold value for the element quality:
0.8 - Warning elements 
1.0 - Failed elements 
10.0 - Worst elements



","Example
To start the patch checker and move through several patches, changing the patch size, while
        using quality criteria given from a
        file:*readqualitycriteria c:/criteria/mycriteria.txt
*createmark elems 1 displayed
*elementqualitysetup 1
*elempatchstartaction 0 1.0
*elempatchnextaction
*elempatchnextaction
*elempatchincraction
*elempatchprevaction
*elempatchdecraction
*elempatchstopaction
*elementqualityshutdown 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1478,*elemswarpagefix,"Description
Attempts to fix quad elements violating warpage criteria threshold. If necessary, tries to
        move nodes normal to surfaces.
","Inputs

mark_id
The mark ID containing the quad elements to consider. Valid values are 1 and 2.
criteria_file_path
The path to the criteria file. Use ""dummy"" for using the current criteria, set
            separately.
max_move
The limit for node movement normal to the surface.
break_mode
Specifies how node associativity of moved nodes is handled. Valid values are:
0 - Associativity is broken for moved nodes.
1 - Associativity is broken for all nodes of an element that has a moved
                node.
2 - Asscociativity is not broken.


feature_angle
The element feature angle in degrees.

","Example
To fix the displayed elements, using the criteria file
          C:/my_criteria/criteria.txt, with a maximum move of 0.1, without
        breaking surface
        associativity:*createmark elems 1 displayed
*elemswarpagefix 1 ""C:/my_criteria/criteria.txt"" 0.1 2 30.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1479,*end_batch_import,"Description
Finalizes a sequence of multi-file batch import/merge operations. This is intended to
        improve performance of importing/merging a series of files. Certain operations that
        generally are run for each import/merge, and queued up and executed just once at then end of
        the import. These operations are different for each type of import/merge operation, and
        therefore cannot be mixed. It is essential to only import/merge valid file types per the
        mode argument. This command must be preceded by a corresponding call to
          *start_batch_import. It is potentially dangerous to perform other
        operations within a *start_batch_import/*end_batch_import
          block, so take proper precaution and make sure to always call these commands in
        pairs.
","Example
To execute a sequence of importing multiple CAD files, where the variable
          cad_files contains the list of
        files:*start_batch_import 3
foreach cad_file $cad_files {
    *feinputwithdata2 ""#Detect"" ""$cad_file"" 1 0 -0.01 0 0 1 0 1 0
}
*end_batch_import
",,
1480,*entitybundleaddid,"Description
Adds a single entity to a data item of a bundle.
","Inputs

name
The name of the entity bundle to be modified.
data_item
The data item of the entity bundle to be modified. Note that these indices start with
            0.
id
The ID of the entity to add. Note that the entity type is inferred from the bundle
            definition.

","Example
To add entity ID 17 as the first data item of the bundle ""compbundle"":
*entitybundleaddid ""compbundle"" 0 17
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1481,*entitybundleclear,"Description
Removes all entities either from a single data item of an or from all the data items of an
        entitybundle.
","Inputs

name
The name of the entity bundle to be modified.
data_item
The data item of the entity bundle to be cleared. Note that these indices start with
            0. If set to -1, all data items are cleared.

","Examples
To clear all the data stored in the first data item of the entity bundle ""compbundle"":
*entitybundleclear ""compbundle"" 0
To clear all the data stored all data items of the entity bundle
        ""compbundle"":*entitybundleclear ""compbundle"" -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1482,*entitybundleremoveid,"Description
Removes a single entity from a data item of a bundle.
","Inputs

name
The name of the entity bundle to be modified.
data_item
The data item of the entity bundle to be modified. Note that these indices start with
            0.
id
The ID of the entity to remove. Note that the entity type is inferred from the bundle
            definition.

","Examples
To remove entity ID 17 as the first data item of the bundle ""compbundle"":
*entitybundleremoveid ""compbundle"" 0 17
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1483,*EntityDeleteEmpty,"Description
Delete the entities put in the outputmark by *EntityPreviewEmpty().
","Inputs

entity type
The entity type to check.
outputmark
The unused entities IDs.

",,
1484,*entitydisplaywithattached,"Description
Isolates an entity and its attached entities.
","Inputs

entity_type
The type of entity to be used for display. Currently only valid for groups.
Supported group configs:
1 - elem and elem (Customized for Abaqus to get the
                surface from attributes)
2 - node and elem
3 - elem
4 - node (elements/components attached to node is shown)


Supported group definitions:
0 - entities
1 - components
4 - sets
5 - contactsurfs


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
attached_entity_type
Valid values are comps, elems and groups.
display_flag
0 - Show
1 - Isolate

","Examples
To show the components attached to group 1:
*createmark group 1 1
*entitydisplaywithattached group 1 comps 0

To isolate the components attached to groups 1 and
        10:*createmark group 1 1 10
*entitydisplaywithattached group 1 comps 1
To show the elements attached to group
        1:*createmark group 1 1
*entitydisplaywithattached group 1 elems 0
To isolate the elements attached to groups 1 and
        10:*createmark group 1 1 10
*entitydisplaywithattached group 1 elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1485,*EntityPreviewEmpty,"Description
Searches the entities specified and stores any empty entities in the
          outputmark.
","Inputs

entity type
The entity type to check.
outputmark
The empty entities IDs.

","Example
To store all empty components in the
        mark:*EntityPreviewEmpty(comps, mark)
The following elements can be used with *EntityPreviewEmpty():
Components
Empty when it does not contain any elements, lines, points, surfaces, or
              attributes.
Plots
Empty when there are no curves are in the plot.
Assemblies
Empty when it does not contain any components.
Outputblocks
Empty when it does not contain any entities.
Loadsteps
Empty when it does not contain any entities.
Groups
Empty when both the master and slave sections are empty.


If the master section does not exist for this interface type, then the master section is
        empty. If the master section does exist and it is set to components, elements, or sets, a
        check is done to see if it points to any entities. If it does not point to any entities, the
        master section is empty. Also, if the master section points to any other type (such as box
        or all), it is assumed that the master is not empty. 
The same check is done for the slave section. 
LoadCols
Empty when it does not contain any loads.
BeamSectCols
Empty when it does not contain any beamsects.
SystemCols
Empty when it does not contain any systems.
VectorCols
Empty when it does not contain any vectors.
Sets
Empty when it does not contain any entities.


",
1486,*equationcreate,"Description
This command creates an equation between a dependent node and multiple independent
        nodes.
","Inputs

mark_id
The mark ID containing the independent nodes. Valid values are 1 and 2.
independent_dofs
The array ID containing the degrees of freedom for which each respective independent
            node of the equation is active. This array is created with the
              *createarray command. 
The DOFs use bit operations to represent the value. In order to specify multiple DOFs
            for a node, corresponding values for the required DOFs must be summed.
DOF1 - 1 
DOF2 - 2 
DOF3 - 4 
DOF4 - 8 
DOF5 - 16 
DOF6 - 32


For example, there are 2 independent nodes with DOF1 and DOF3. The array of
            independent DOFs will be [5 5].
dof_size
The size of the independent_dofs array. This should be equal to the
            number of independent nodes.
independent_weights
The array ID containing the weight for each respective independent node. The size of
            array is 6* dof_size. This array is created with the
              *createdoublearray command. 
For example, there are 2 independent nodes with DOF1 weights 1.2 and DOF3 weights 1.3.
            The array of independent weights will be [1.2 1.2 1.2 1.2 1.2 1.2 1.3 1.3 1.3 1.3 1.3
            1.3].
weight_size
The size of the independent_weights array. This should be equal to
              6*dof_size.
dependent
The dependent node ID.
dof
The degree of freedom for which the dependent node of the equation is active. Valid
            values are 1 through 6.
weight
The dependent node weight.
constant
The constant value assigned to all independent and dependent nodes.

","Example
To create an equation with dependent node 100 and independent nodes 101-103 with all
        independent nodes having DOF1, DOF3 and DOF4, a weight of 1.23 and a constant of 5.0, and
        the dependent node having
        DOF5:*createmark nodes 1 101-103
*createarray 3 13 13 13
*createdoublearray 18 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23 1.23
*equationcreate 1 1 3 1 18 100 5 1.23 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1487,*equationupdatemeshconnectivity,"Description
Updates MPC equation connectivity. It updates the independent/dependent nodes to the
        nearest nodes within the specified tolerance, if the independent/dependent nodes are not
        connected to any elements.
","Inputs

mark_id
The mark ID containing the equations. Valid values are 1 and 2.
tolerance
The tolerance to use when finding the nearest nodes to connect to.

","Example
To update the mesh connectivity of equation 1 and 3 using a tolerance of
        10:*createmark equations 1 1 2 3
*equationupdatemeshconnectivity 1 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1488,*equivalence2,"Description
Equivalences duplicate nodes on the ""exposed"" faces of 2D/3D elements in selected
        components to all other nodes in the model within a tolerance.
","Inputs

mark_id
The mark ID containing the input components. Valid values are 1 and 2.
Only nodes on the ""exposed"" faces of the 2D/3D elements in the selected components are
            considered.
tolerance
The tolerance used to find neighboring nodes, not in the specified components, to
            equivalence with.
location
Location of equivalenced nodes:
0 - Equivalence at the location of the node in the component.
1 - Equivalence at the location of the node not in the component.
2 - Equivalence at the midpoint of the two nodes.


numbering
The numbering of the retained node:
0 - Retain the number of the node in the component.
1 - Retain the number of the node not in the component.



","Example
To equivalence the nodes on the exposed faces of components 1-5, using a tolerance of 0.1
        and keeping the location and number of the component
        nodes:*createmark comps 1 1-5
*equivalence2 1 0.1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1489,*evaltclstring,"Description
Evaluate a Tcl/Tk based expression.
","Inputs

string
Expression to evaluate.
flag
Flag to run command end functions. 
Default = 0

","Example
This command allows you to evaluate the Tcl//Tk based string, supplied
        in string. 
The flag argument should be specified as 0.
",
1490,*ExportAssemblyAndGlobalEntities,"Description
Exports part assembly and child data.
","
Inputs


file_path
The location to write to.

","Examples
To export to C:/temp:*ExportAssemblyAndGlobalEntities ""C:/temp""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1491,*exportbom,"Description
Exports a UDMXML BOM file for a given part.
<option>=<value> options must be enclosed in quotes, but can be
        provided in any order.
","Inputs

file_name
The name and path of the file to write.

part_hmid=<value>

The HyperMesh part ID to be used as root for
            exporting.
If not specified, part_udmid is used.

part_udmid=<value>

If part_hmid is not provided, this is the UDMID of the HyperMesh part to be used as root for exporting.

recursive=<value>

0 - Only the top level elements under the part ID are exported.
1 - All elements under the part ID are exported (default).

subsystem=<value>

0 - Do not export subsystem structure.
1 - Export subsystem structure.

","Example
Export a UDMXML BOM for part 2 to
        c:/temp/exportedbom.xml:*exportbom c:/temp/exportedbom.xml ""part_hmid=2""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1492,*exportuserdefinedshapes,"Description
This command exports shape design variables, shapes and nodal information in user-defined
        format for HyperStudy or Templex analysis codes. 
","Inputs

header
Header information for the node block. 
keyword
Keyword for a node. 
delimiter1
The delimiter type between keyword and the node ID. Valid values are:
Delimiter - Use for delimiters such as slash, comma, etc. 
Whitespace - Use for spaces.


delimeter1_value
If deliminter1 is Delimiter, this is the character to use as the
            delimiter. 
If delimiter1 is Whitespace, this is the number of spaces.
nodeid_width
Width of the node ID field.
delimiter2
The delimiter type between the node ID and the x-coordinate. Valid values are:
Delimiter - Use for delimiters such as slash, comma, etc. 
Whitespace - Use for spaces.


delimeter2_value
If deliminter2 is Delimiter, this is the character to use as the
            delimiter. 
If delimiter2 is Whitespace, this is the number of spaces.
x_coord_width
Field width for output of the x-coordinate.
x_coord_precision
Field precision for output of the x-coordinate.
y_coord_width
Field width for output of the y-coordinate.
y_coord_precision
Field precision for output of the y-coordinate.
z_coord_width
Field width for output of the z-coordinate.
z_coord_precision
Field precision for output of the z-coordinate.
delimiter3
The delimiter type between the x-y and y-z coordinates. Valid values are:
Delimiter - Use for delimiters such as slash, comma, etc. 
Whitespace - Use for spaces.


delimeter3_value
If deliminter3 is Delimiter, this is the character to use as the
            delimiter. 
If delimiter3 is Whitespace, this is the number of spaces.
outputfile
Name of the output file.

","Example
To output nodal coordinates in the following format to the shape.dat
        file:COORDINATES
NODE  /     8844, 5.0000000e+001  6.0000000e+001  5.0000000e+001
...

*exportuserdefinedshapes ""COORDINATES""  ""NODE "" ""Delimiter"" ""/"" 9 ""Delimiter"" "","" 15 7 15 7 15 7 ""Whitespace"" 1 ""shape.dat""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1493,*facedeleteduplicates,"Description
Deletes duplicate faces.
","Inputs

mark
The mark ID which contains the faces to compare for and delete duplicates.
tol
The tolerance used to find duplicate faces.

","Example
To find and delete duplicates within a tolerance of 0.1, among the faces 2, 4, 7, 14, and
        23:*createmark(faces,1) 2 4 7 14 23
*facedeleteduplicates(1,0.1)
The *createmark() command is required.
",
1494,*facesdelete,"Description
Deletes the component ^faces.
",,,
1495,*fastenercreation,"Description
Creates fastener connectors, elements, properties, and materials using the Huth formula.
        Currently only supported for Abaqus profile.
Valid column labels in the CSV file are:


x,y,z for location
x1,y1,z1,x2,y2,z2 for start and end point of line
lineid for ID of line
nodeid for ID of node
pointid for ID of point
material for ID of material
diameter for fastener diameter
tolerance or length for tolerance of line
cid for system ID if the locations are in a specific system


The default Huth constants are:
Coefficient a: 2/3 for metallic and bolted graphite/epoxy, 2/5 for riveted
            metallic
Coefficient b: 3 for bolted metallic, 2.2 for riveted metallic, 4.2 for bolted
            graphite/epoxy
Coefficient b1=b/n b2=b/n^2 where n is the number of shear


","
Inputs


coeffa1=<value>
The a1 value when method=""User defined(Huth)"".
coeffb1=<value>
The b1 value when method=""User defined(Huth)"".
coeffb2=<value>
The b2 value when method=""User defined(Huth)"".
componentmark=<value>
The ID of the mark of components for finding attached shells or projections.  Valid
            values are 1 and 2.
conntype=<value>
The connection type, Bolts or Rivets.
createupdateoption=<value>
0 - Connector creation
1 - Connector post-processing for creating materials, properties, etc...
diameter=<value>
The diameter value when diameteropt=Value.
diameteropt=<value>
Calculated - Consider from file if it has diameter information, else from
            perpendicular lines on markid
Value - Specified via diameter
elemtype=<value>
The solver element type.  Must be set to Fastener for creating CONN3D in Abaqus.
entitytype=<value>
The type of entity for create (lines, points, nodes) and update (connectors)
            operations.
fileloc=<value>
The full file path which contains values like diameter, line ID, node ID, point ID,
            material ID, point location, etc... when filelocopt=1.
filelocopt=<value>
If set to 1, fileloc is used.
k4=<value>
The stiffness value k4.
k5=<value>
The stiffness value k5.
k6=<value>
The stiffness value k6.
markid=<value>
The ID of the mark of entities.  Valid values are 1 and 2.
materialid=<value>
The material ID when youngmodopt=material
method=<value>
""Huth Formula""
 ""User defined(Huth)"" - Must specify coeffa1,
              coeffb1, and coeffb2.
numlayer=<value>
The number of layers when numlayeropt=Value.
numlayeropt=<value>
Calculated - Automatic calculation (default)
Value - Specified via numlayer
orientopt=<value>
The orientation option:
Auto - Automatic (default)
UserDefined - Specified via systemid
projectiondirection=""<value1> <value2> <value3>""
The direction values when projectionmethod=""along discrete
              direction""
projectionmethod=<value>
The method for calculating the projection.  Valid values are:
""along discrete direction""
""normal to closest link""
""normal to furthest link""
""normal to links"" (default)
""normal to specific link""
projectionspecificlink=<value>
The component ID when projectionmethod=""normal to specific
            link""
systemid=<value>
The system ID when orientopt=UserDefined
tolerance=<value>
The tolerance value when toleranceopt=Value.
toleranceopt=<value>
The connector tolerance:
Calculated - Automatic calculation from lines
Value - Specified via tolerance
youngmodopt=<value>
material - Value is taken from materialid
<value> - The specific value to use

","Examples
To create fasteners on all lines (via comps), with diameter of 5, automatic number of
        layers, Young's modulus taken from material 1, and the tolerance calculated using lines:
*createmark comps 1 all
*createmark lines 2 all
*fastenercreation entitytype=lines filelocopt=0 diameteropt=Value diameter=5 numlayeropt=Calculated numlayer=-1 method={Huth Formula} elemtype=fastener youngmodopt=material materialid=1 toleranceopt=Calculated k4=100 k5=1.0E8 k6=1.0E8 conntype=Bolts mark=2 orientopt=Auto componentmark=1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1496,*fbddisplacement,"Description
Creates an FBD displacement plot, and fields or loads from the results.
This queries the displacement data from the result entity on a freebodysection.
","Inputs

set_ids=<value>
The set entity IDs.
data_strings=<value>
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid parameters and their syntax are:
arrlen=<value>
Controls the FBD plot arrow length.  Default is 75 (%).
arroworigin=<value>
0 - Tail of arrow at node for the plot (default)
1 - Tip of arrow at node for the plot
colorfx=<value>
The color of the Fx arrow.  Valid values are 1-64.
colorfxy=<value>
The color of the Fxy arrow.  Valid values are 1-64.
colorfxyz=<value>
The color of the Fxyz arrow.  Valid values are 1-64.
colorfxz=<value>
The color of the Fxz arrow.  Valid values are 1-64.
colorfy=<value>
The color of the Fy arrow.  Valid values are 1-64.
colorfyz=<value>
The color of the Fyz arrow.  Valid values are 1-64.
colorfz=<value>
The color of the Fz arrow.  Valid values are 1-64.
colormx=<value>
The color of the Mx arrow.  Valid values are 1-64.
colormxy=<value>
The color of the Mxy arrow.  Valid values are 1-64.
colormxyz=<value>
The color of the Mxyz arrow.  Valid values are 1-64.
colormxz=<value>
The color of the Mxz arrow.  Valid values are 1-64.
colormy=<value>
The color of the My arrow.  Valid values are 1-64.
colormyz=<value>
The color of the Myz arrow.  Valid values are 1-64.
colormz=<value>
The color of the Mz arrow.  Valid values are 1-64.
createfield=<value>
0 - Do not create a nodal displacement field (default)
1 - Create a nodal displacement field
createload=<value>
0 - Do not create FBD displacement loads (default)
1 - Create FBD displacement loads
declim=<value>
Controls the decimal limit.  Default is 2.
display=<value>
0 - Do not plot FBD displacements
1 - Plot FBD displacements (default)
displacement=<value>
0 - Applied forces are not particupating in the FBD calculation (default)
1 - Applied forces are particupating in the FBD calculation
freenode=<value>
Currently must be set to 2. This is a mandatory argument.
fx=<value>
0 - Fx translations are not included in the plot, load or field creation
                  (default)
1 - Fx translations are included in the plot, load or field creation
fxy=<value>
0 - Fxy resultant translations are not included in the plot (default)
1 - Fxy resultant translations are included in the plot
fxyz=<value>
0 - Fxyz resultant translations are not included in the plot (default)
1 - Fxyz resultant translations are included in the plot
fxz=<value>
0 - Fxz resultant translations are not included in the plot (default)
1 - Fxz resultant translations are included in the plot
fy=<value>
0 - Fy translations are not included in the plot, load or field creation
                  (default)
1 - Fy translations are included in the plot, load or field creation
fyz=<value>
0 - Fyz resultant translations are not included in the plot (default)
1 - Fyz resultant translations are included in the plot
fz=<value>
0 - Fz translations are not included in the plot, load or field creation
                  (default)
1 - Fz translations are included in the plot, load or field creation
mx=<value>
0 - Mx rotations are not included in the plot, load or field creation
                  (default)
1 - Mx rotations are included in the plot, load or field creation
mxy=<value>
0 - Mxy resultant rotations are not included in the plot (default)
1 - Mxy resultant rotations are included in the plot
mxyz=<value>
0 - Mxyz resultant rotations are not included in the plot (default)
1 - Mxyz resultant rotations are included in the plot
mxz=<value>
0 - Mxz resultant rotations are not included in the plot (default)
1 - Mxz resultant rotations are included in the plot
my=<value>
0 - My rotations are not included in the plot, load or field creation
                  (default)
1 - My rotations are included in the plot, load or field creation
myz=<value>
0 - Myz resultant rotations are not included in the plot (default)
1 - Myz resultant rotations are included in the plot
mz=<value>
0 - Mz rotations are not included in the plot, load or field creation
                  (default)
1 - Mz rotations are included in the plot, load or field creation
resfileid=<value>
The result file ID for resultid. Useful when multiple result
                  files are loaded for a single result entity.
resolvein_sys=<value>
0 - Resolve in analysis system (default)
1 - Resolve in global system
2 - Resolve in user system
resultid=<value>
The result entity ID.
rotation=<value>
0 - SPC forces are not particupating in the FBD calculation (default)
1 - SPC forces are particupating in the FBD calculation
scid=<value>
The results subcase ID for resultid.
scientific=<value>
0 - Fixed format text (default)
1 - Scientific format text
showvalue=<value>
0 - Show text (default)
1 - Hide text
sizescale=<value>
0 - Constant FBD plot arrow length (default)
1 - Magnitude FBD plot arrow length
stepid=<value>
The step/simulation ID for scid.
tolerance=<value>
The tolerance to limit the values. Default is 0.00001.
user_sys_id=<value>
The system ID when resolvein_sys=2.
vecstyle=<value>
0 - 3D FBD plot arrow (default)
1 - 2D FBD plot arrow


num_strings=<value>
Integer indicating the size (number of strings) in the data_strings
            array.

","Example
Create an FBD displacement
        plot:*createstringarray 46 ""scientific=1"" ""arroworigin=0"" ""tolerance=0.00001"" ""scid=1"" ""resfileid=1"" ""resultid=1"" ""showvalue=1"" ""stepid=1"" ""sizescale=0"" ""vecstyle=0"" ""resolvein_sys=3 "" ""user_sys_id=2"" ""displacement=1"" ""rotation=1"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""fxy=1"" ""fyz=1"" ""fxz=1"" ""mxy=1"" ""myz=1"" ""mxz=1"" ""fxyz=1"" ""mxyz=1"" ""arrlen=75"" ""declim=2"" ""freenode=2"" ""display=1"" ""colorfx=3"" ""colorfy=4"" ""colorfz=5"" ""colorfxy=7"" ""colorfyz=8"" ""colorfxz=9"" ""colorfxyz=12"" ""colormx=3"" ""colormy=4"" ""colormz=5"" ""colormxy=7"" ""colormyz=8"" ""colormxz=9"" ""colormxyz=12""
set setIds {1 2 3}
*fbddisplacement $setIds 1 46
Create
        loads:*createstringarray 17 ""createload=1"" ""resolvein_sys=0"" ""scid=1"" ""resfileid=1"" ""resulted=1"" ""stepid=1"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""tolerance=0.00001"" ""displacement=1"" ""rotation=1"" ""display=0"" ""freenode=2""
set setIds {1 2 3}
*fbddisplacement $setIds 1 17
Create a
        field:*createstringarray 18 ""createload=1"" ""resolvein_sys=3 "" ""user_sys_id=2"" ""scid=1"" ""resfileid=1"" ""resulted=1"" ""stepid=1"" ""fx=1"" ""fy=1"" ""fz=1"" ""mx=1"" ""my=1"" ""mz=1"" ""tolerance=0.00001"" ""displacement=1"" ""rotation=1"" ""display=0"" ""freenode=2""
set setIds {1 2 3}
*fbddisplacement $setIds 1 18
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1497,*fbdtraceplot,"Description
Creates an FBD trace plot.
This queries the GPF, Applied, SPC and MPC data from the result entity on a
        freebodysection.
","Inputs

freebodygroup_id=<value>
The freebodygroup entity ID.
data_strings=<value>
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
Valid parameters and their syntax are:
appf=<value>
0 - Applied forces do not participate in the FBD calculation (default)
1 - Applied forces do participate in the FBD calculation
arrlen=<value>
Controls the FBD plot arrow length.  Default is 75 (%).
declim=<value>
Controls the decimal limit.  Default is 2.
displayat=<value>
0 - Allong the cutting nodes (default)
1 - Along the centroid of each freebodysection
fx=<value>
0 - Do not display Fx forces (default)
1 - Display Fx forces
fy=<value>
0 - Do not display Fy forces (default)
1 - Display Fy forces
fz=<value>
0 - Do not display Fz forces (default)
1 - Display Fz forces
gpf=<value>
0 - Grid-point forces do not participate in the FBD calculation (default)
1 - Grid-point forces do participate in the FBD calculation
intf=<value>
0 - Internal forces do not participate in the FBD calculation (default)
1 - Internal forces do participate in the FBD calculation
mpcf=<value>
0 - MPC forces do not participate in the FBD calculation (default)
1 - MPC forces do participate in the FBD calculation
mx=<value>
0 - Do not display Mx moments (default)
1 - Display Mx moments
my=<value>
0 - Do not display My moments (default)
1 - Display My moments
mz=<value>
0 - Do not display Mz moments (default)
1 - Display Mz moments
plotdir=<value>
0 - Auto.  The direction axis is automatically determined on the basis of values
                  (default)
1 - Global x-direction
2 - Global x-direction negative
3 - Global y-direction
4 - Global y-direction negative
5 - Global z-direction
6 - Global z-direction negative
resfileid=<value>
The result file ID for resultid. Useful when multiple result
                  files are loaded for a single result entity.
resultid=<value>
The result entity ID.
scid=<value>
The results subcase ID for resultid.
scientific=<value>
0 - Fixed format text (default)
1 - Scientific format text
showvalue=<value>
0 - Show text (default)
1 - Hide text
spcf=<value>
0 - SPC forces do not participate in the FBD calculation (default)
1 - SPC forces do participate in the FBD calculation
stepid=<value>
The step/simulation ID for scid.
sumat=<value>
0 - Along cutting nodes (default)
1 - Along the centroid of each freebodysection
sysproj=<value>
0 - Do not project the system along the plot (default)
1 - Project the system along the plot
tolerance=<value>
The tolerance to limit the values. Default is 0.00001.


num_strings=<value>
Integer indicating the size (number of strings) in the data_strings
            array.

","Example
Create an FBD trace
        plot:*createstringarray 24 ""scientific=1"" ""tolerance=0.00001"" ""scid=1"" ""resfileid=1"" ""resultid=1"" ""showvalue=1"" ""stepid=1"" ""fx=1"" ""fy=0"" ""fz=0"" ""mx=0"" ""my=0"" ""mz=0"" ""gpf=1"" ""appf=1"" ""spcf=1"" ""intf=1"" ""mpcf=1"" ""arrlen=75"" ""declim=2"" ""plotdir=0"" ""sysproj=0"" ""sumat=0"" ""displayat=0""
*fbdtraceplot 1 1 24
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1498,*feature_replace,"Description
This command geometrically replaces a selection of surfaces with a second selection of
        surfaces, reconnecting the new surfaces to the rest of the original surfaces according to
        the original connections. 
In this command, a part of the boundary of the source surfaces, after transformation by the
        input transformation matrix, is assumed to be matching with a part of the boundary of the
        target surfaces, within a given tolerance. This command checks and finds the matching
        boundary edges between the source and target surfaces. Then, the target surfaces are
        replaced by a transformed copy of the source surfaces. The connections with the other
        surfaces along the matching boundary are preserved according to the original connections.
        The new surfaces are put in the same component as the target surfaces. If some of the target
        surfaces are part of a solid, those solids are recreated after replacement if the new
        configuration forms a closed volume/volumes that allow creation of solids. If the source
        surfaces contain solids, those solids are also maintained in the replacement.
","Inputs

source_entity_type
The source entity types. Valid values are surfs.
source_mark_id
The mark ID containing the source entities. Valid values are 1 and 2.
target_entity_type
The target entity types. Valid values are surfs.
target_mark_id
The mark ID containing the target entities. Valid values are 1 and 2.
double_array
The double array ID that contains the 4x4 transformation matrix. The double array is
            created using the *createdoublearray command. This should always be
            set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. This should always be set to 16.
tolerance
The tolerance used for edge stitching.
keep_source
0 - Keep source surfaces after replacement.
1 - Delete source surfaces after replacement.

","Example
To replace target surfaces 4, 19 and 25 with source surfaces 7, 9, 10, 33 and 34 with a
        tolerance of 0.5, and using a transformation matrix which is a translation of 20 units in
        the z-direction
        only:1.0  0.0  0.0  0.0
0.0  1.0  0.0  0.0
0.0  0.0  1.0  0.0
0.0  0.0  20.0 1.0

*createmark surfs 1 7 9 10 33 34  
*createmark surfs 2 4 19 25 
*createdoublearray 16 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 20.0 1.0 
*feature_replace surfs 1 surfs 2 1 16 0.5 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1499,*features_add,"Description
Creates elements or lines between a list of nodes.
","Inputs

node_list
The number of the desired list of nodes.
0
1


lines


0 - Create plot elements connecting the nodes in the list. These elements are
                created in the component named ^open features. Next, elements in the ^open features
                component that create closed chains (loops) of elements are moved to a component
                named ^feature.
1 - Creates a line in the ""^feature"" component.


smooth


0 - Do not smooth the lines. 
1 - Smooth the line created through the nodes of the feature.



","Example
To create a smooth line between the nodes in node_list
        0:*features_add(0,1,1)
",
1500,*features_move_all_opened,"Description
No arguments are required. All the plot elements in the ^feature component are analyzed and
        those that do not create closed chains are moved into a component named ^open features.
","Example
To locate all elements in the ^feature group that to no form closed chains and move them to
        ^open features:*features_move_all_opened
",,
1501,*feinputinteractive,"Description
 Inputs an ASCII analysis input deck and for certain import
        translators invokes a Part Browser to allow selecting various options
        while importing the chosen model.
","Inputs

programname
The name of the translator program. 
filename
The file name containing an input deck. 
overwrite


1 - If HyperMesh should overwrite any existing
                IDs,
0 - If HyperMesh should offset. 


min_edge_length
Not used.
cleanup_tolerance


If < 0, use automatic cleanup tolerance. 
If = 0, do not cleanup topology. 
If > 0, use this as cleanup tolerance.


blanked_component


1 - Create an empty component for data. 
0 - Do not create an empty component.


offsetflag
Apply a user-defined offset.

","Example
To read the Abaqus input file named model:
        *feinputinteractive ""feinput/abaqus"" ""model"" 0 0 -0.01 10.0 0
",
1502,*feinputoffsetid,"Description
Sets the value to offset the IDs of the entity type during feinput.
","Inputs

entity_type
The entity type to be offset.
offsetvalue
The number added to each entity of the type passed to HyperMesh during feinput.

",,
1503,*feinputpreserveincludefiles,"Description
After the next call to *feinputwithdata2, HyperMesh will revert to the default behavior of reading and merging
        include files. For behavior other than the default behavior, this command must be called
        each time.
",,,
1504,*feoutput_select,"Description
This command exports an ASCII analysis file of selected
        entities, formatted based on the specified export_template. 
Only the selected entities are exported. 
The following entities will be fully exported, if selected for export:
assems
contactsurfs
loadsteps
outputblocks
sets


For example, if a set type is element, it will be exported whether or not its referenced
        elements are also selected. Note that individual entities must be marked. This command does
        not export any dependent or container entities. For example, elements will not be exported
        if either a component or a group is exported.
","Inputs

export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
mark_id
The mark ID containing the entities to output. Valid values are 1 and 2. 
Only the entities on the specified mark will be output. This is valid for all
            supported entity types.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To export only elements with IDs
        1-5:*createmark elems 1 1-5
*feoutput_select $tmplFileName $outputFileName 1 0 0
To export the nodes of component with ID
        1:*createmark nodes 1 ""by component id"" 1
*feoutput_select $tmplFileName $outputFileName 1 0 0
To export the elements in components with IDs
        1-3:*createmark elems 1 ""by component id"" 1 2 3
*feoutput_select $tmplFileName $outputFileName 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1505,*feoutputincludes,"Description
Exports selected includes which were modified since the last export.
","
Inputs


template=<value>
Syntax.
filename=<value>
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
includeids=<value>
The IDs of the includes to consider for export.  Only the ones modified since the last
            export will be exported.
options=<value>
The string of additional export options.

","Examples
Export all entities of the modified includes using the Ls-Dyna template to
        C:/temp/test.key:set ids [hm_getincludes_modified_since_last_export]
*feoutputincludes template=""C:/Program Files/Altair/2020/templates/feoutput/ls-dyna971/dyna.key"" filename=""C:/temp/test.key"" includeids=$ids type=1 options={HMBOMCOMMENTS_XML HMMATCOMMENTS_XML}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1506,*feoutputwithdata,"Description
This command exports an ASCII analysis file, formatted based
        on the specified export_template. 
The additional output parameters are defined using the
          *createstringarray command and the string_array and
          number_of_strings options. For a list of strings that are supported by
        each reader, refer to the See Also list. 
To determine the proper options and strings to use for this command, it is best to first
        perform the import action using the HyperMesh workspace and then
        look at the values written to the command file.
","Inputs

export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
export_type
Flag indicating which entities will be output:
0 - Only the displayed entities will be output.
1 - All entities will be output.
2 - Entities will be output based on their/their parent collector’s output bit
                (custom output). This bit can be set using the
                *allsuppressoutput, *includesuppressoutput and
                  *setvaluecommands or using the Entity State Browser.


string_array
The string array ID that contains the additional output parameters. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented as subtopics.
            Not all templates support all strings.

","Example
To output all entities using the OptiStruct template, to a file
          named
        C:/model.fem:set template [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]
*feoutputwithdata ""$template/optistruct/"" ""C:/model.fem"" 0 0 1 1 0
To output all entities using the OptiStruct template, to a file
        named C:/model.fem, but do not export any connector
        data:set template [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]
*createstringarray 1 ""CONNECTORS_SKIP""
*feoutputwithdata ""$template/optistruct/"" ""C:/model.fem"" 0 0 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1507,*fetosurfs,"Description
Generates surfaces from shell elements.
","Inputs

mark_id_2d
The mark ID that contains the input 2D shell elements, which are used to construct the
            surface.
mark_id_1d (optional)
The mark ID that contains edge/feature elements, which are used to split shell
            elements into separate surfaces.
options
Specifies options for creating the surfaces. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 +
              64*Bit6).
Bit0
0 - Use given tolerance to control accuracy. 
1 - Use automatic calculation of approximation tolerance from input
                  elements.
Bit1
0 - Do not attempt automatic shell splitting in cases where surface
                  approximation could not be calculated for given tolerance and complexity limit. 
1 - Split shell in cases where surface approximation could not be calculated for
                  given tolerance and complexity limit.
Bit2
0 - Ignore failure on some patches and calculate the remainder. 
1 - Stop on failure
Bit3
0 - Ignore sharp features unless specified by input feature edges. 
1 - Automatically split shell along sharp features even if not specified by
                  input feature edges.
Bit4
0 - Ignore element component information. 
1 - Use element component information to split shell and create surfaces in the
                  same component as corresponding elements.
Bit5
0 - Do not associate nodes to created surfaces. 
1 - Associate nodes to created surfaces.
Bit6
0 - Do not use automatic feature detection. 
1 - Use automatic feature detection, based on twice the value defined in the
                  feature angle setting of the options panel.


complexity
A number controlling the maximum complexity of a single surface patch. This sets the
            maximum number of control points for a surface.
tolerance
Geometry simplification tolerance. Defines the maximum distance between original and
            simplified geometries.
reserved
Reserved for future use. Must be set to 0.

","Example
To construct a surface from all quad4 elements, using a tolerance of 0.1, limiting the
        number of control points to 900, no automatic shell splitting, stop on failures, split
        surfaces by sharp features, split surfaces according to element components, associate nodes,
        and no automatic feature detection (options = 1*0 + 2*0 + 4*1 + 8*1 + 16*1 + 32*1 +
          64*0 =
        60):*createmark elems 1 ""by config"" quad4
*fetosurfs 1 0 60 900 0.1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1508,*filewriteentities,"Description
Saves a BINARY file with only the contents of selected
        modules/parts. This is useful for shattering a large BINARY
        file into smaller ones. 
There are certain rules and limitations:
There can be only one module on the input mark. That module may have multiple
            children. 
Only the entities listed below are saved, and all other entities are ignored:
All components in the module hierarchy.
All elements in those components.
All nodes in those components.
Materials referred by those components.
Properties referred by those components.
Materials referred by those properties.


Components being exported must not be topologically connected to components in modules
            not part of the hierarchy being exported.


","Inputs

entity_type
The entity type to export. Only supported for modules.
mark_id
The mark ID of modules. Valid values are 1 and 2. Only one module may be on the mark.
filename
The full name and ID of the file to write.
reserved
Reserved for future use. Must be set to 0.

","Example
To write module 10 and all of its children modules to the file
          C:/temp/shatter10.hm:*filewriteentities modules 1 C:/temp/shatter10.hm 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1509,*fill_fe_gaps_elems,"Description
Fills gaps in FE from elements selected on both sides of the gap.
","Inputs

mode
0 - The input elements are the shell elements defining the boundary, and the gap
            boundaries are.
1 - The input elements are 1D elements defining directly the gap boundaries.
mark_id1
The mark ID containing the elements at the first boundary. Valid values are 1 and 2.
mark_id2
The mark ID containing the elements at the second boundary. Valid values are 1 and 2.
max_width
Maximum allowed gap width to be filled.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements.
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fi.
DefineMaxWidth
0 - Ignore max_width for gap filling.
1 - Consider max_width for gap filling.
GuideNodePairs
Specifies an optional list of node IDs in the form ""M1 M2 N1 N2 O1 O2 ..."" where
                  (M1, M2), (N1, N2) and (O1, O2) are node pairs. These pairs are used to divide the
                  gap to be filled into smaller loops. When provided, gaps are filled ensuring that
                  the loops are split at the specified pairs. This aids in filling complex hole
                  shapes by guiding the filling process correctly.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To fill gaps less than 100 between elements in comps 1 and 5, including
        remeshing:*createmark elems 1 ""by comp id"" 1
*createmark elems 2 ""by comp id"" 5
*createstringarray 2 ""Remesh: 1"" ""DefineMaxWidth: 1""
*fill_fe_gaps_elems 0 1 2 100.0 1 2
To fill gaps between features of two sets of elements using a gap width of 50, and using
        guide node pairs for correct
        triangulation:*createmark elems 1 12-18 55-100
*createmark elems 2 45-50 101-166
*createstringarray 4 ""ByFeature:1"" ""Remesh:0"" ""DefineMaxWidth:1"" ""AdjacentComp:1"" ""GuideNodePairs:17 18 25 66""
*fill_fe_gaps_elems 0 1 2 10 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1510,*fill_fe_gaps_nodeid,"Description
Fills gaps in FE from a node selected on both sides of the gap.
","Inputs

node_id1
The node ID on the first boundary.
node_id2
The node ID on the secondary boundary.
max_width
Maximum allowed gap width to be filled.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements.
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fill.
DefineMaxWidth
0 - Ignore max_width for gap filling.
1 - Consider max_width for gap filling.
GuideNodePairs
Specifies an optional list of node IDs in the form ""M1 M2 N1 N2 O1 O2 ..."" where
                  (M1, M2), (N1, N2) and (O1, O2) are node pairs. These pairs are used to divide the
                  gap to be filled into smaller loops. When provided, gaps are filled ensuring that
                  the loops are split at the specified pairs. This aids in filling complex hole
                  shapes by guiding the filling process correctly.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To fill gaps less than 100 between gaps defined by nodes 50 and 70, including
        remeshing:*createstringarray 2 ""Remesh: 1"" ""DefineMaxWidth: 1""
*fill_fe_gaps_nodeid 50 70 100.0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1511,*fill_fe_holes,"Description
Fills FE holes by automatic or manual detection.
","Inputs

mode
The mode to identify FE holes:
0 - Do automatic hole detection using elements on mark_id. 
1 - Do manual hole detection using nodes on mark_id. The nodes
                should be part of a free boundary. 
2 - Do manual hole detection using given the closed 1D elements on
                  mark_id.


mark_id
The mark ID containing either nodes or elements, based on mode type.
max_width
Maximum allowed hole width.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements.
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fill.
DefineMaxWidth
0 - Ignore max_width for hole filling.
1 - Consider max_width for hole filling.
GuideNodePairs
Specifies an optional list of node IDs in the form ""M1 M2 N1 N2 O1 O2 ..."" where
                  (M1, M2), (N1, N2) and (O1, O2) are node pairs. These pairs are used to divide the
                  gap to be filled into smaller loops. When provided, gaps are filled ensuring that
                  the loops are split at the specified pairs. This aids in filling complex hole
                  shapes by guiding the filling process correctly.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To fill the holes defined by the closed 1D elements 10-30, using a max width of 20.5,
        remeshing filled elements, and create the elements in the adjacent
        component:*createmark elems 1 10-30
*createstringarray 3 ""Remesh: 1"" ""AdjacentComp: 1"" ""DefineMaxWidth: 1""
*fill_fe_holes 2 1 20.5 1 3
To smoothly fill a feature hole using a set of
        nodes:*createstringarray 4 ""ByFeature:1"" ""Remesh:1"" ""DefineMaxWidth:0"" ""CurvedFill:1""
*createmark nodes 1 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
*fill_fe_holes 1 1 0 1 4
Fill a feature hole using guide pairs (12,18) and
        (25,13):*createstringarray 3 ""ByFeature:1"" ""Remesh: 0"" ""GuideNodePairs: 12 18 25 13""
*createmark nodes 1 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
*fill_fe_holes 1 1 0 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1512,*fill_fe_holes_nodelist,"Description
Fills FE holes from a node list defining the hole.
","Inputs

list_id
The list ID containing the nodes on the hole boundary.
max_width
Maximum allowed hole width.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name: value"". Valid strings are:
AdjacentComp
0 - Fill elements should be created in a new component.
1 - Fill elements should be created in the adjacent component.
ByFeature
0 - Features should not be considered.
1 - Features should be considered.
CurvedFill
0 - Gaps are filled without taking into consideration the shape of adjacent
                  elements. 
1 - Gaps are filled taking into consideration the shape of adjacent elements,
                  ensuring a smooth fill.
DefineMaxWidth
0 - Ignore max_width for hole filling.
1 - Consider max_width for hole filling.
GuideNodePairs
Specifies an optional list of node IDs in the form ""M1 M2 N1 N2 O1 O2 ..."" where
                  (M1, M2), (N1, N2) and (O1, O2) are node pairs. These pairs are used to divide the
                  gap to be filled into smaller loops. When provided, gaps are filled ensuring that
                  the loops are split at the specified pairs. This aids in filling complex hole
                  shapes by guiding the filling process correctly.
Remesh
0 - Fill elements should not be remeshed.
1 - Fill elements should be remeshed.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To fill the hole defined by node list 1, using a max width of 20.5, remeshing filled
        elements, and create the elements in the adjacent
        component:*createlist nodes 1 1 2 3 4 5
*createstringarray 3 ""Remesh: 1"" ""AdjacentComp: 1"" ""DefineMaxWidth: 1""
*fill_fe_holes_nodelist 1 20.5 1 3
Use guide node pairs (17,22) and (45,16) for complex hole
        loops:*createstringarray 4 ""DefineMaxWidth:0"" ""Remesh:0"" ""AdjacentComp:0"" ""GuideNodePairs: 17 22 45 16""
*createlist nodes 1 22 23 27 17 66 34 88 26 22 1 99 4 45 12 43 16 99 
*fill_fe_holes_nodelist 1 0 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1513,*fillplot,"Description
Generates a fill plot.
","Inputs

title
The fill plot title.
mesh_color
The color of the mesh. Valid values are 1 through 64.
-1 - Uses the elements color. 
0 - Uses the background color.


fill_color
The color of the center of the elements. Valid values are 1 through 64, or -1 to use
            the element colors.
full_size
Determines whether the fill plot fills the entire screen. Valid values are:
0 - Use normal size. 
1 - Use full screen. Click a mouse button to return.


blocks
This option is ignored and should be set to 0.

","Example
To generate a normal size fill plot with the title ""This is the title"", a mesh color of
        black, and a fill color equal to that of each
        element:*fillplot ""This is the title"" 0 -1 0 0
",
1514,*find_holes_in_3d_body,"Inputs

entity
The entity type in which the holes reside. Valid options are surfs and solids. 
input_mark
A mark containing the desired surfaces or solids.
output_mark
A mark that will contain the surfaces recognized as sides of the holes in 3D
            body.
mode
Selects the search algorithm to use (see the comments section below for known
            limitations of each mode):
1 - Recognize all circular holes passing through the entire solid. Recognizes
                filleted ends/rims. Ignores all other parameters. 
2 - Recognize elongated or circular holes that do not pass through the entire
                solid. Does not recognize holes with filleted ends/rims.


flags
Sets a filter for the shape of holes to be recognized:
0 - No filtering (arbitrary shapes allowed). 
1 - Only round holes are found. 
2 - Only rounded slots are found. 
3 - Round holes and round slots are found.


min_diam
Smallest diameter of holes to be found.
0 - No limit


max_diam
Largest diameter or width of the holes to be found.
0 - HyperMesh uses no upper limit.


max_lensize
Maximum length for elongated holes/slots. 
0 - To allow any length (no limit).



","Example
To take the surfaces from the input mark 1, find the holes using algorithm 1 (from the
        midsurface tool) and put the result into mark
        2:*find_holes_in_3d_body (surfaces 1 2 1 0 0 0 0)
To take the surfaces from the input mark 1, use algorithm 2 to find round holes ranging
        from 1-5mm, and up to 10mm deep, and put the result into mark
        2:*find_holes_in_3d_body (surfaces 1 2 2 1 1 5 10)
Mode=1 does not utilize the arguments for flags, min_diam,
          max_diam, and max_lensize. Thus, these are each
        treated as being zero.
 Mode=2 utilizes all arguments, but only locates holes with sharp edges. 
Both modes assume that the element normals around holes face outward. If this is not so,
        the results may be unpredictable and unsatisfactory. Note: This command also does not clean
          the surfaces mark output after completion, so holes are added to the surfaces
        mark.

",,
1515,*findattachedelementfaces,"Description
Returns information to a table about solid elements attached to quad/tria element. The
        table must be created with 6 integer columns using the *tablecreate
        command. The output to each column is as follows:
Input element IDs 
Attached element IDs 
Attached element face IDs 
Attached element configs 
Input element collector  IDs 
Input element normal reversed flags


","Inputs

mark_id
The mark ID containing the input quad/tria elements. Valid values are 1 and 2.
table_id
The table ID to output the results to. The table must have 6 integer columns.

","Example
To find the elements attached to all tria3 and quad4
        elements:*createstringarray 6 int int int int int int
*tablecreate ""attachedelementtable"" 1 1 1 6
set table_id  [hm_getvalue tables name=attachedelementtable dataname=id]
*createmark elems 1 ""by config"" 104 103
*findattachedelementfaces 1 $table_id
array unset faceTable
set numOfRows [hm_getvalue tables id=$table_id dataname=rows]
for {set r 0} {$r < $numOfRows} {incr r} {
    lappend faceTable(shlList)   [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=0 ROW=$r]
    lappend faceTable(solList)   [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=1 ROW=$r]
    lappend faceTable(solFaceId) [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=2 ROW=$r]
    lappend faceTable(solCfg)    [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=3 ROW=$r]
    lappend faceTable(shlCmp)    [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=4 ROW=$r]
    lappend faceTable(shlRevNrm) [hm_getvalue tables id=$table_id dataname=cellvalue COLUMN=5 ROW=$r]
}

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1516,*findedges,"Description
This command finds and displays element free or T-connected edges as plot elements a new
        component named ^edges.
","Inputs

entity_type
The entity types to find edges for. Valid values are comps and elems.
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
edge_type
The type of edges to find:
0 - Free edges. 
1 - T-connected edge



","Example
To check the free edges on all of the elements contained in the component fender:
        *createmark comps 1 fender
*findedges comps 1 0
To check the T-connectes edges on all of the
        elements:*createmark elems 1 all
*findedges elems 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1517,*findfaces,"Description
Finds the free faces in a group of elements. 
","Inputs

entity type
The entity type contained on the mark. The valid types are components and elements. 
mark
The mark ID. 

","Example
To check the free faces on all of the elements contained in the component fender:
        *createmark(components,1) fender
*findfaces(components,1)
",
1518,*findmark,"Description
This command finds and displays entities or finds and displays adjacent entities.
","Inputs

entity_type
The entity types to find or to use for finding entities adjacent to.
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
function
A flag that indicates the find function to perform. Bit values are used and the value
            is calculated as (1*Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6
              + 128*Bit7).
Bit0
Find mode.
0 - Find the entities on the mark.
1 - Find entities attached to those on the mark.
                    attached_entity_type must be specified.
Bit1
Find connectors and realized FE. 
0 - Find connectors only.
1 - Find both connectors and realized FE.
Bit2
Find tied contact entities.
0 - Do not find tied contact entities.
1 - Find tied contact entities.
Bit3
Unused
Bit4
Find free surface edges when finding lines. 
0 - Do not find free surface edges. 
1 - Find free surface edges
Bit5
Find shared surface edges when finding lines. 
0 - Do not find shared surface edges. 
1 - Find shared surface edges.
Bit6
Find non-manifold surface edges when finding lines. 
0 - Do not find non-manifold surface edges. 
1 - Find non-manifold surface edges.
Bit7
Find suppressed surface edges when finding lines. 
0 - Do not find suppressed surface edges. 
1 - Find suppressed surface edges.
Bit8
Exclude group elements when finding elements. 
0 - Also find group elements. 
1 - Exclude group elements.


adjacent
0 - Add both entities on mark_id and those found to
              output_mark_id. 
1 - Do not add entities on mark_id to
              output_mark_id. 
This is ignored when function is set to 0.
adjacent_entity_type
If function is 0, this should be the same as
              entity_type. Otherwise, it is the type of entity to find. The found
            entities will also be displayed. If set to undefined, all supported adjacent entities
            will be found.
numbers
0 - Do not turn on numbers for the found entities. 
1 - Turn on numbers for the found entities.
output_mark_id
The mark ID to put the found entities on. 
If specified as 0 and attached_entity_type is set to nodes,
            temporary nodes are created at the found node locations. 
For other entity types, valid values are 1 and 2.

","Example
To find the elements adjacent to element
        12:*createmark elements 1 12
*findmark elements 1 1 1 elements 0 2
To find all
        connectors:*createmark connectors 1 all
*findmark connectors 1 0 1 connectors 0 2
To find all surface edges (free, shared, non-manifold and
        suppressed):*createmark lines 1 all
*findmark lines 1 240 1 lines 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1519,*fix_surfaces_orientation,"Description
The direction in which reoriented normals point can then be collectively reoriented based
        on treating the group of 2D surfaces as if they were surfaces of a 3D entity. For example,
        three adjacent triangular surfaces might define a tetrahedral space even if they are not
        actually faces of a tetrahedral entity.
","Inputs

surfaces
The surfaces you want to make normals consistent. 
orientation
1 - Normals point away from the center of the hypothetical 3D element. 
0 - All normals point toward the center of the hypothetical 3D element.

","Example
If a surface with ID 72 has two adjacent surfaces, and all three of these surfaces form
        three adjacent sides of a cubic space, then this example will orient all three surfaces such
        that their normals point toward the center of the
        cube:*fix_surfaces_orientation(72,1)
If the selection includes T-intersections, the results will be unpredictable. Similarly, if
        the selected surfaces do not define a 3D space (such as in the case of coplanar surfaces)
        then the final swap of normals determined by the orientation argument may be
        unpredictable.
",
1520,*flanges_detect,"Description
This command detects flanges within a minimum/maximum width range from the surfaces
        contained in the selected components. The flange surfaces are then placed on a mark.
","Inputs

comp_mark_id
The mark of input components. Valid values are 1 and 2..
max_width
The maximum width of the flanges to detect.
min_width
The minimum width of the flanges to detect.
flange_mark_id
The mark of the output surfaces defining the detected flanges. Valid values are 1 and 2.

","Example
To find flanges between 5 and 20 for all components in the model, and to place the surfaces
        on surface mark
        2:*createmark comps 1 all
*flanges_detect 1 5 20 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1521,*freesimulation,"Description
Ends the post-processing display, and frees memory used by a contour or assigned plot, a
        deformed plot, a vector plot, or an animation.
","Example
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements (c) data type, using a 10.0 model unit
        scaling:*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements (c)""
*complexanimatemodal """" 10.0 4
*freesimulation
",,
1522,*freeshapedesvarupdatewithmethod,"Description
Updates a free shape design variable.
","Inputs

entity_type
The type of entity used in creating the design variable.  Valid values are nodes,
            elements, sets (nodal only), or properties.
mark_id
The ID of the mark of entities used to update the design variable. Valid values are 1
            and 2.
name
The name of the design variable.
method
0 - CLASSIC
1 - GRID
2 - BLANK

","Example
To update a free shape design variable fsh1 comprised of nodes, with method
        BLANK:*createmark nodes 1 2110 3292
*freeshapedesvarupdatewithmethod nodes 1 ""fsh1"" 2
To update  a free shape design variable fsh2 comprised of a node set, with method
        CLASSIC:*createmark sets 1 ""set1""
*freeshapedesvarcreatewithmethod sets 1 ""fsh2"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1523,*gapelement,"Description
Creates a gap element. 
","Inputs

node1
The ID of the first node of the gap element.
node2
The ID of the second node of the gap element.
property name
The property name which should be assigned to the gap element. 
vectorid
The orientation vector ID associated with the gap element.

","Example
To create a gap element between node 5 and node 245 with property gapprop, without an
        orientation vector: *gapelement(5,245,gapprop,0)
",
1524,*geomexport,"Description
Exports geometry to various CAD formats.
","Inputs

translator_type
The translator to use for export. Valid values are:
iges_altair
jt_jtopen
parasolid_parasolid
step_ct


output_file_name
The name of the file to output.
<name>=<value>
The name=value options that define the export behavior. The actual
            options usable depend on the translator. The allowed options correspond to those
            supported in the .ini files, in terms of both name and
            possible values. All options specified in the command line and .ini files are fully synchronized, i.e. every option is available
            in both the command line and the .ini file. The full list of
            options and values can be found in the CAD Export Options documentation.
          
Options passed via the command line prevail over options mentioned in the .ini file; options in the .ini file are
            effective only when the corresponding option is not used in the command line. Options
            mentioned neither in the command line nor in the .ini file
            assume values taken from a default option value set internally.
 Case insensitivity is supported for option values, but not option names. For example:
            ""OptimizeforCAD=Off"" ""OptimizeforCAD=OFF"" ""OptimizeforCAD=off"" will all provide the same
            result.
 The order of these options does not matter.

","Example
To export the displayed geometry in Parasolid v27.0 format,
        to the file C:/temp/sample.x_t, using various
        options:*geomexport ""parasolid_parasolid"" ""C:/temp/sample.x_t"" ""Version=27.0"" ""Export=Displayed"" ""Units=Meters"" ""GeometryMode=Standard"" ""TopologyMode=Solid/Shell"" ""AssemblyMode=Hierarchy"" ""WriteNameFrom=Component"" ""OptimizeforCAD=Off""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1525,*geommatchtopology,"Description
This command fixes gaps between stitched edges and vertices to make the actual geometry of
        the surfaces consistent with the model topology. It checks the topology of the model for
        gaps that are larger than a given tolerance between shared, non-manifold or suppressed
        edges. If the gap is found to be bigger than the tolerance, the surface and edge geometries
        are morphed parametrically and in 3D, if necessary, to make the gap smaller than the
        tolerance. In addition, non-essential degenerate edges are removed. 
This command preserves the original geometric entity ID’s.
","Inputs

entity_type
The entity type selected for cleanup. Valid values are:
Solids
Surfaces
Lines (topological)


mark_id
The mark ID containing the entities. Valid values are 1 and 2. If no entities are on the mark, or if no mark value is given, all
            entities of entity_type in the model are processed.
stitch_tol
The tolerance value for gaps. The gap between edges and vertices are targeted to be
            smaller than this value after the command is run. 
If no tolerance value is given, or a value that is less than or equal to 0.0 is given,
            the value is taken as the model geometry cleanup tolerance.

","Examples
To fix the gap for the edges and vertices of all the surfaces in the model with the model
        geometry cleanup tolerance:*geommatchtopology surfs
To fix the gap for the edges and vertices of surfaces 11, 12 and 15 so that the gap is
        smaller than the model cleanup
        tolerance:*createmark surfs 1 11 12 15
*geommatchtopology surfs 1
To fix the gap for the edges and vertices of all the surfaces in the model so that the gap
        is smaller than
        0.001:*createmark surfs 1 """"
*geommatchtopology surfs 1 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1526,*geomvectorcreate,"Description
This command creates vectors on input set of nodes in such a way that vector direction
        coincides with line tangent or surface normal at closest to the node point on geometry.
","Inputs

geom_type
The input geometry type. Valid values are:
lines - If specified, then tangent at selected line is used for created vector
                direction. 
surfs - If specified, then normal at selected surface is used for created vector
                direction.


geom_mark_id
The mark of input lines or surfaces.
node_mark_id
The mark of input nodes. The nodes are used as a base for created vector and to find
            closest point on geometry to calculate vector direction.
node_tol
If positive, then use as proximity tolerance for geometry points. This means that
            vector is not created unless closest point of selected geometry is found within the
            distance specified by node_tol. 
If the value of node_tol is negative, then allowed distance to
            closest point is not limited.
magnitude
Parameter that specifies the length of resulted vector (except for the case when
            parameter parlen is not zero).
parlen
Parameter that specifies the method to calculate resulted vector length. Valid values are:
0 - The value specified by magnitude parameter is used. 
1 - Parametric value is used. For curve tangent this is the value of parametric
                curve derivative. For surface normal the value is defined by the length of cross
                product of surface parametric derivatives. Parameterization of curves and surfaces
                is normalized from 0 to 1.


reverse
Parameter that specifies direction of resulted vector. Valid values are:
0 - Direction coincides with parametric direction of curve or surface normal. 
1 - Direction is opposite to parametric direction of curve of surface
                normal.



","Example
To create a unit vector having node with ID 1 as its base and tangent to curve with ID 4 at
        point closest to specified
        node:*createmark nodes 1 1
*createmark lines 1 4
*geomvectorcreate lines 1 1 -1.0 1.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1527,*GetLatitudeLineHandles,"Description
This command finds and shows in HyperMesh the handles of
        latitude lines stored into mark_id1. Valid
          entity_type1 value for latitude lines is LINES, and valid
          selection_type value is 1. If you want to see the handles of a latitude
        lines group, you need to select two ribs that are stored into mark_id2.
        Valid entity_type2 value for ribs is LINES and valid
          selection_type value is 2.
","Inputs

entity_type1
Entity type LINES.
mark_id1
Mark ID. It can be 1 or 2.
entity_type2
Entity type LINES.
mark_id2
Mark ID. It can be 1 or 2.
selection_type
Integer value.
1 - For single latitude lines selection.
2 - For group latitude lines selection.



","Example
To see the handles of the latitude lines 1418, 1419, and
        1550:*createmark lines 1 1418 1419 1550
*createmark lines 2
*GetLatitudeLineHandles lines 1 lines 2 1 
To see the handles of the all latitude lines attached to 1418 enclose the ribs 1344 and
        1335:*createmark lines 1 1418
*createmark lines 2 1344 1335
*GetLatitudeLineHandles lines 1 lines 2 2 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1528,*getqualitysummary,"Description
Computes the quality index for the specified selection of shell elements and writes the
        quality summary to the specified text file. Optionally places the failed elements to the
        specified mark.
","Inputs

elementmark
The mark of elements to be evaluated. 
Does not need to be a contiguous block. Must be 1 or 2.
summary_file
The path to the quality summary destination file (a quoted string).
failedmark
The mark for failed elements. It must be 0, 1, or 2, and different from
              elementmark. 
0 - Failed elements are not marked.
criteria_use_model
The mode for using and controlling the quality criteria. It must be one of the
            following: 
0 - The computation is performed regardless of whether or not the quality
                criteria was previously set. If the criteria is not specified, the default criteria,
                adjusted to the selection element size, is set as current.
1 - The computation requires the quality criteria to be pre-set using one of the
                commands listed above. An error is returned, if the quality criteria does not exist.
                If the criteria exists, the computation is performed regardless. This is the most
                common value for this parameter. 
2 - The computation requires the quality criteria to be pre-set. An error is
                returned, if the quality criteria does not exist. If the criteria exists, the
                command checks to see if the size criteria matches the selection element size and
                returns an error, if there is a mismatch. 
3 - The computation requires the quality criteria to be pre-set. An error is
                returned, if the quality criteria does not exist. If the criteria exists, the
                command checks to see if the size criteria matches the selection element size,
                adjusts the size criteria to the selection element size, and performs the
                computation.



","Example
To evaluate elements 100 through 110 using the quality criteria file,
          c:/mycriteria/durability.txt, to write the quality summary to
          c:/myres/dur_sum.txt and to mark the failed
        elements:*readqualitycriteria ""c:/mycriteria/durability.txt""
*createmark elements 1 100 101 102 103 104 105 106 107 108 109 110
*getqualitysummary 1 ""c:/myres/dur_sum.txt"" 2 1
The example above using the default criteria if the criteria were not set before using any
        of the corresponding
        commands:*createmark elements 1 100 101 102 103 104 105 106 107  108 109 110
*getqualitysummary 1 ""c:/myres/dur_sum.txt"" 2 0
",
1529,*getunmeshedsurfstomark2,"Description
Places displayed, unmeshed surfaces on the specified mark. This takes the surfaces found
        using *getunmeshedsurfstomark and performs advanced processing to better
        detect unmeshed surfaces. BatchMesher can move nodes off of
        surfaces or surface edges, thus causing small surfaces to be considered unmeshed by
          *getunmeshedsurfstomark. This command also does advanced filtering to
        find nodes/elements close to these small surfaces and thus not detect them as unmeshed.
","Inputs

mark_id
The mark ID that should contain the unmeshed surfaces on output. Valid values are 1 and 2.

","Example
To find all unmeshed surfaces:*getunmeshedsurfstomark2 1
",
1530,*graphicfont,"Description
Sets the size of the graphics font.
","Inputs

size
The font size to use. Valid values are 1 (smallest) through 4 (largest).

","Example
To set the graphic font size to 2:*graphicfont 2
",
1531,*graphuserwindow_byXYZandR,"Description
Re-centers the graphics display to center on a specified point, and resizes (zooms) the
        display based on a specified view radius.
","Inputs

x
The x coordinate of the specified point.
y
The y coordinate of the specified point.
z
The z coordinate of the specified point.
r
The radius of a sphere that defines the zoom level of the user’s view. The display is
            zoomed in or out so that a sphere of this radius originating at the specified point fits
            within the display.

","Example
To re-center the view on a point with coordinates (20, 15.3, and 72) and zoom to display
        entities within 24.2 units of this
        point:*graphuserwindow_byXYZandR(20,15.3,72,24.2)
",
1532,*group_matches,"Description
Groups parts into partsets based on matching shapes.
Similar shapes are grouped into to a single partset.  A parent partset is created for all
        different partsets. Unmatched partsets can optionally be put in a new partset. Also see
          hm_getmatching to find and group but not create partsets.
","
Inputs


entity_type
The type of entity to group.  Must be set as modules/parts.
mark_id
The ID of the mark containing the entities to group.  Valid values are 1 and 2.
reference_entity_type
The type of entity to use as reference.  Must be set as modules/parts.
reference_mark_id
The ID of the mark containing the reference entities, if any.  Valid values are 1 and
            2.  If the mark is empty, grouping is done by finding similar shapes within all input
            entities.
string_array
The string array ID that contains the additional input parameters. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
Strings are indicated using the format ""name=value"". Valid strings are:
areaCalcMethod=<value>
Specifies how the matching area percentage is calculated when
                    searchMethod=ByArea:
ByLowestId - Calcualte with respect to the entity with the lowest ID
                  (default)
ByHighestId - Calcualte with respect to the entity with the highest ID
compareType=<value>
Specifies with what entities the comparison happens when
                    searchMethod=ByEncoding:
0 - Use both CAD and FE from the input selection
1 - Prefer CAD over FE. This will pick FE only if the input has only FE.
2 - Use only CAD
3 - Prefer FE over CAD. This will pick CAD only if the input has only CAD.
4 - Use only FE
deformationTolerance=<value>
The tolerance value to check matching. Default is global node tolerance when
                    searchMethod=ByArea or
                  searchMethod=ByTopo, and 0.5 when
                    searchMethod=ByEncoding.


encoding_algorithm=<value>
The optional encoding algorithm to use when
                    searchMethod=ByEncoding. Valid values are:
0 - Spherical harmonics (default)


matchingPercentThreshold=<value>
The matching area threshold above which matching pairs are returned (default is
                  node tolerance).
When searchMethod=ByEncoding, this is reported as (1 –
                    differenceinencoding/deformationTolerance=<value>)
parentpartsetname=<value>
The name for the parent partset. This can have format strings for substituting
                  searchMethod, matchingPercentThreshold and deformationTolerance.  Default is
                  ""%searchMethod_%matchingPercentThreshold_%deformationTolerance"".  When the command
                  is rerun with the same settings, part sets can get overwritten if the same
                    parentpartsetname is provided.
partsetname=<value>
The name for the partset containing matching parts. This can have format strings
                  for introducing representative part names. Default ""Matched_%partname"" will
                  substitute %partname with the representative (among matches in the group) part
                  name of the group. When the partset is created the name will also have the parent
                  partset ID at the end regardless of the name given here. When the command is rerun
                  with the same settings, part sets can get overwritten if the same
                    partsetname is provided.
partsetforunmatched=<value>
If set to 1, creates a separate partset for unmatched parts. Default 0.
searchMethod=<value>
The method to perform the comparison:
ByArea - Use area of entities (default)
ByEncoding - Use shape encoding
ByTopo - Use topology comparison


sphai:sphhar_bandwidth=<value>
Optional, valid for encoding_algorithm 0, default 16.


sphai:sphhar_fallof=<value>
Optional, valid for encoding_algorithm 0, default
                  2.828427.


sphai:sphhar_radii=<value>
Optional, valid for encoding_algorithm 0, default 32.


sphai:resolution=<value>
Optional, valid for encoding_algorithm 0, default 64.


unmatchedpartsetname=<value>
The name for the unmatched partset when
                  partsetforunmatched=1.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To group all parts by area without any
        reference:*createmark parts 1 all
*createmark parts 2
*group_matches parts 1 parts 2
To group all parts by area using part 232 as the
        reference:*createmark parts 1 all
*createmark parts 2 232
*group_matches parts 1 parts 2
To group all parts by shape without any reference, using a custom parent partset
        name:*createmark parts 1 all
*createmark parts 2 
*createstringarray 1 ""method=Shape parentpartsetname=%searchMethod_%deformationTolerance""
*group_matches parts 1 parts 2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1533,*groupcreatesameas,"Description
Creates a new group using an existing group’s dictionary/attribute data and type
        information. 
","Inputs

newname
The name of the group to be created.
existingname
The name of the group to copy dictionary/attribute information from.
color
The color of the group.

","Example
To create a new group back using the information in the group front, and color 12:
        *groupcreatesameas(""back"",""front"",12)
Slave and Master elements and/or other definition methods/information are not copied to the
        new group when you use this command. Only the attributes/dictionary information and the type
        information are copied.
",
1534,*grouppreviewunused,"Description
Identifies the unused elements within a group.
","Inputs

mark
The mark ID containing the groups.
f_displayed
Searches groups contained unused elements.
0 - Searches all groups. 
1 - Searches only displayed groups.



","Example

*interfacecreate(""one"",1,2,1)
*createmark(groups,2) ""one""
*createmark(elements,2)
*interfaceadd(""one"",0,elements,2,0)
*createmark(elements,1) 124 158 246 366
*interfaceadd(""one"",1,elements,1,0)
*createmark(elements,2) 130 136 364
*interfaceadd(""one"",0,elements,2,0)
*createmark(elements,1) 124 130 136 158 246 364 366
*deletemark(elements,1)
*grouppreviewunused(1)
*interfacecreate()

*interfacecreate() creates group one. Add master elements 124, 158, 246
        and 366 and slave elements 130, 136 and 364. *grouppreviewunused()
        highlights the seven elements.
",
1535,*hf_Addendum_UpdateSlide,"Description
This command updates the position of handle with ID handle_id from its
        current position, to the new position with coordinate x_coord,
          y_coord, and z_coord.
","Inputs

handle_id
Handle ID.
x_coord
X coordinate of the new handle position.
y_coord
Y coordinate of the new handle position.
z_coord
Z coordinate of the new handle position.
tol
Dummy double value. Should always be 1.0.

","Example
To update the position of the handle with ID
        5:*hf_Addendum_UpdateSlide 5 1982.39933 287.781925 -36.9308916 1. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1536,*hf_CheckDieModuleElementsRES,"Description
This command creates and visualizes the contour of draw depth, trim angle and undercut of
        the elements part with respect to the binder surface. The draw depth, the trim angle and the
        undercut value are evaluated with respect to the stamping direction.
","Inputs

entity_type_part
The entity type of the part. Must be set to elems.
mark_id_part
The mark ID containing the part entities. Valid values are 1 and 2.
entity_type_binder
The entity type of the binder. Must be set to surfs.
mark_id_binder
The mark ID containing the binder entities. Valid values are 1 and 2.
vector_id
The temporary vector ID created using the *createvector command
            that defines the stamping direction.
flag
A flag that indicates what to visualize. Valid values are:
-2 - Trim angle on trim line. 
-1 - Draw depth between part and z=0 plane. 
1 - Draw depth between part and binder. 
2 - Trim angle on the part. 
3 - Undercut on the part.



","Example
To visualize the contour of the draw depth between the part and the binder with respect to
        the
        z-axis:*createmark elems 1 displayed
*createmark surfs 1 displayed
*createvector 1 0.0 0.0 1.0
*hf_CheckDieModuleElementsRES elems 1 surfs 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1537,*hf_ClearLLHandles,"Description
This command deletes all the handles and the handles node pointer from the model.
","Inputs

int_flag
Integer dummy value. Should always be set to 0.

","Example
To delete the handles:*hf_ClearLLHandles 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1538,*hf_CreateBinderSectionAndHandles,"Description
This command creates a section on a binder surface. The section can be identified in
        different ways. 
First, it is possible to use a cutting plane. In this case plane_flag is
        1 and the cut plane is stored into plane and all the other arguments are ignored. 
Second, it is possible to use two nodes. In this case plane_flag is 0
        and the nodes are stored into node_mark_id,
          entity_type is set to nodes, and all the other arguments are ignored. 
Finally, it is possible to select a line. In this case plane_flag is 0
        and the line is identified by line_id while all the other arguments are
        ignored.
","Inputs

plane_flag 
Flag indicating how the selection is being made. Valid values are:
1 - User-defined cutting plane. 
0 - All other cases.


plane
The ID of the temporary plane created with the *createplane
            command. Ignored when plane_flag is 0.
entity_type
Must be set to nodes.
node_mark_id
The mark ID containing the nodes. Valid values are 1 and 2. Ignored when plane_flag is 1.
line_id
The ID of the selected line. Ignored when plane_flag is 1.

","Examples
To create a section on the current binder by cutting plane with normal Y and base point
        (7097.5495,-1339.4592
        1424.5666):*createplane 1 0.0000 1.0000 0.0000 7097.5495,-1339.4592 1424.5666
*hf_CreateBinderSectionAndHandles 1 1 nodes 1 0
To create a section on the current binder by the selection of the two nodes 4615
        4614:*createmark nodes 1 4615 4614
*hf_CreateBinderSectionAndHandles 0 1 nodes 1 0
To create a section on the current binder by the selection of the line
        6721:*createmark nodes 1
*hf_CreateBinderSectionAndHandles 0 1 nodes 1 6721
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1539,*hf_CreatePol,"Description
This command creates POL from the current trim line, with the specified offset.
","Inputs

offset
The offset specified for the POL.

","Example
To create POL from the current trim line with offset of
        100:*hf_CreatePol 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1540,*hf_DiePartPositioning,"Description
This command repositions the model to avoid an undercut for the die module. 
","Inputs

entity_type
Must be set to elems. This is currently ignored.
mark_id
The mark ID containing the elements. Valid values are 1 and 2.
The entities on the mark are currently ignored.
vector_id
The temporary vector ID created using the *createvector command
            that defines the normal direction. Must be set to 1. 
The vector is currently ignored.
symmetry_flag
0 - No symmetry plane defined. 
1 - Symmetry plane defined by plane_id.
plane_id
The temporary plane ID created using the *createplane command that
            defines the symmetry plane. Must be set to 1. 
Use only when symmetry_flag is 1.
reduce_depth
0 - Do not reduce the draw depth. 
1 - Reduce the draw depth.
reduce_undercut
0 - Do not reduce the undercut. 
1 - Reduce the undercut.
alignment_flag
0 - Do not optimize the blank area. 
1 - Optimize the blank area.
reposition_stamping
-1 - Do not tip the part in the stamping direction. 
1 - Tip the part in the stamping direction.
reposition_CAD
-1 - Do not tip the part in the CAD system. 
0 - Tip the part in the CAD system.

","Example
To reposition the
        model:*createmark elems 1
*createvector 1 0.0 0.0 1.0
*createplane 1 -0.586757294 -0.809460681 -0.022119755 -130.806 8.053 26.519
*hf_DiePartPositioning elems 1 1 0 1 1 1 0 1 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1541,*hf_FeatureFromSurfaces,"Description
This command creates the feature line from selected surfaces. It stitches together all the
        surfaces to extract a single free edge.
","Inputs

entity_type
Must be set to surfs.
mark_id
The mark ID containing the surfaces. Valid values are 1 and 2.

","Example
To create the feature from surface
        644:*createmark surfaces 1 644
*hf_FeatureFromSurfaces surfaces 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1542,*hf_LevelElementsOnOff,"Description
This command controls the display/masking state of eroded elements.
","Inputs

state
The state of the eroded elements. 
0 - On (currently only On is supported)
1 - Off



","Example
To show eroded elements:*hf_LevelElementsOnOff 0
",
1543,*hf_ResetDFRibs,"Description
This command resets the rib attribute. All the ribs that you modify, dragging the latitude
        lines, are checked with two attribute: 
fixed
drag


","Inputs

int_flag
Integer dummy value. Should always be set to 0.

","Example
To reset all the rib attributes:*hf_ResetDFRibs 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1544,*hf_ScaleBinderSurf,"Description
This command increases and decreases the binder dimension. The binder is scaled relative to
        an origin node. The scaling can be uniform or not. If uniform scaling is requested, the
        scale factor in all directions should be set equal. Otherwise, it is possible to give
        different value to these factors in other to obtain a non-uniform scaling.
","Inputs

base_point_id
The node ID to use as the base point for the scaling. 
scale_factor_x
Scale factor in x.
scale_factor_y
Scale factor in y.
scale_factor_z
Scale factor in z.

","Examples
To increase the binder dimension uniformly by a factor of 5 with respect to node ID
        1434:*hf_ScaleBinderSurf 1434 5 5 5
To decrease the binder dimension by a factor of 5 in the x, 10 in the y and 20 in the z
        with respect to node ID
        1434:*hf_ScaleBinderSurf 1434 0.2 0.1 0.05
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1545,*hf_setdiestampingdirection,"Description
This command sets the stamping direction for the die module.
","Inputs

x_coord
x-coordinate of the vector direction.
y_coord
y-coordinate of the vector direction.
z_coord
z-coordinate of the vector direction.
reserved
Reserved for future use. Must be set to 0.

","Example
To set the stamping direction in the die module to (1, 0,
        0):*hf_setdiestampingdirection 1.0 0.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1546,*hf_setformingdirection,"Description
This command sets the draw direction for 1-step solver.
","Inputs

x_coord
x-coordinate of the vector direction.
y_coord
y-coordinate of the vector direction.
z_coord
z-coordinate of the vector direction.

","Example
To set the drawing direction to the vector defined by (0, 0, 0) and (7214.46,-2031.49418
        1206.14793):*hf_setformingdirection 7214.46,-2031.49418 1206.14793
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1547,*hf_setpartflangecomponent,"Description
This command moves the specified entities to the specified component and sets them as
        flange or part.
","Inputs

suffix
The component suffix.
color
The component color. Valid values are 1 through 64.
entity_type
The type of entities to consider. Must be set to elems.
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
flag_FL
Flag that indicates whether to set the elements as a flange. Valid values are:
0 - Do not set as a flange. 
1 - Set as a flange.


flag_part
Flag that indicates whether to set the elements as a part. Valid values are:
0 - Do not set as a part. 
1 - Set as a part.



","Example
To set elements 50-100 like a flange into a component with suffix
        ""FL"":*createmark elems 1 50-100
*hf_setpartflangecomponent ""FL"" 11 elems 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1548,*hf_SlideHandleptrOnSectionPlane,"Description
This command updates the position of handle with ID handle_id from its
        current position, to the new mouse position with coordinate (x_mouse and
          y_mouse).
","Inputs

handle_id
The ID of the handle to position.
x_mouse
Mouse x-coordinate of the new handle position.
y_mouse
Mouse y-coordinate of the new handle position.
reserved
Reserved for future use. Must be 1.0.

","Example
To update the position of the handle with ID
        5:*hf_SlideHandleptrOnSectionPlane 5 1982.39933 287.781925 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1549,*hf_trim_multi,"Description
This command trims the selected elements with the selected lines, optionally maintaining
        selected nodes.
","Inputs

entity_type
The entity type to define the elements. Valid values are comps and elems.
mark_id
The mark ID containing the entities. Valid values are 1 and 2.
line_list
The line list ID to use for trimming. Valid values are 1 and 2.
vector_ID
The temporary vector ID created using the *createvector command
            that defines the trimming direction.
node_list
The list ID containing any nodes to maintain. Valid values are 1 and 2.
trim_flag
Flag that indicates the trim type. Valid values are:
-1 - Trim outside. 
1 - Trim inside.


reserved
Reserved for future use. Must be set to 0.

","Example
To trim elements 1-100 along the z-axis using lines 10, 20 and
        30:*createmark elems 1 1-100
*createlist lines 1 10 20 30
*createlist nodes 1
*createvector 1 0.0 0.0 1.0
*hf_trim_multi elems 1 1 1 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1550,*hf_TrimElementsOnOff,"Description
This command controls the display/masking state of trim elements.
","Inputs

state
The state of the trim elements.
0 - On (currently only On is supported)
1 - Off



","Example
To show trim elements:*hf_TrimElementsOnOff 0
",
1551,*hiddenlinemethod,"Description
Selects the algorithm used to perform hidden line removal. 
","Inputs

method
Key indicating the method of hidden line algorithm to use.
0 - Centroidal
1 - Zbuffer



",,
1552,*hideentity ,"Description
Turns off the display of an entity.
","Inputs

entity_type
The type of entity to display.
search_type
The method used to specify the entity. The entity is specified using the
              id_name argument. Valid values are: 
""by name"" - Entity is specified using the entity name.
""by id"" - Entity is specified using the entity ID.
id_name
The ID or name of the entity, depending on search_type.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To hide geometry and elements for component with ID 3:
*hideentity comps ""by id"" 3
To hide elements only for component with ID 3:
*createstringarray 2 geometry_off
*hideentity comps ""by id"" 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1553,*hideview,"Description
Hides the entities with respect to a view saved using *saveviewmask.
","
Inputs


name
The name of the view to hide.
entity_type_id
The entity type ID to hide.

","Examples
Hide the components (entity type ID 3) in view
        View2:*hideview View2 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1554,*hm_batchmesh2 ,"Description
Performs interactive BatchMeshing. 
","Inputs

entity_type
The entity type to perform the BatchMeshing for. Valid values are surfs and
            comps.
mark_id
The ID of the mark containing the entities to mesh. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each string must be space and/or = separated between the name and value. Strings can
            be grouped in any manner, and can appear in any order. 
Valid strings are:

","Examples
BatchMesh surfaces 36 and 79 using the criteria file
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param, with all other default
        parameters:*createmark surfs 1 36 79
*hm_batchmesh2 surfs 1 1 0 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
BatchMesh surfaces 36 and 79 using the criteria file
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param, breaking mesh connectivity, with all other
        default
        parameters:*createmark surfs 1 36 79
*createstringarray 1 ""breakconnectivity = 1""
*hm_batchmesh2 surfs 1 1 0 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
 BatchMesh surfaces 36 and 79 with element size 8.0 and minimum size 3.75. Use
        auto-generated shell criteria and parameters. Allow internal reject steps via temp
        files:*createmark surfs 1 36 79
*createstringarray 2 ""elem_size = 8 min_elem_size = 3.75 params_generate_mode = shell"" ""batchtempfilesmode = 1""
*hm_batchmesh2 surfs 1 1 2 ""dummy"" ""dummy""
BatchMesh surfaces 36 and 79 with element size 7.0, using scaling of the criteria
          C:/crit/10mm.criteria and parameters file
          C:/crit/10mm.param::*createmark surfs 1  36 79
*createstringarray 2 ""elem_size = 7.0 params_generate_mode = scale""
*hm_batchmesh2 surfs 1 1 2 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1555,*hm_meshutils_cutelements_2points ,"Description
Cut elements with a box defined by 2 diagonal points. 
","Inputs

element_mark
The mark of the elements that needs to be cut.
c1x, c1y, c1z
The coordinates of the point 1.
c1x, c1y, c1z
The coordinates of the point 2.
spc_collector_name
The name of the collector in which the spcs will be created for constraining cut
            elements. 
No entities will be created if the name is an empty string.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox. 
No entities will be created if the name is an empty string.

","Example
Only linear shell elements will be cut properly. For any other type of element, it will
        simply be deleted if it is completely or partially inside the cut box.
","Errors
None.
"
1556,*hm_meshutils_cutelements_predefined,"Description
Cuts elements with a predefined box. 
","Inputs

element_mark
The mark of the elements that needs to be cut.
predefined_cut
A predefined cut name which might be one of the following:
left 
right 
front 
rear 
frontleft 
frontright 
rearleft 
rearright 


limit
The x value of the box for cut types front, rear, frontleft, frontright, rearleft,
            rearright.
spc_collector_name
The name of the collector in which the spcs will be created for constraining cut
            elements. No entities will be created if the name is an empty string.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox. No
            entities will be created if the name is an empty string.

","Example
Only linear shell elements will be properly cut. For any other type of element, it will
        simply be deleted if it is completely or partially inside the cut box.
","Errors
None.
"
1557,*hm_trim_elements_with_predefined_box ,"Description
Trims shell elements using a predefined box. Shell elements inside the box are kept with
        the elements along any cuts re-meshed. Solid elements with all nodes inside the box are
        kept, while all others are deleted.
","Inputs

mark_id
The ID of the mark containing the elements to cut. Valid values are 1 and 2.
cut_type
A predefined cut name. Valid values are left, right, front, rear, frontleft,
            frontright, rearleft or rearright.
limit
The x value of the box for cut types front, rear, frontleft, frontright, rearleft or
            rearright.
spc_collector_name
The name of the collector in which the SPCs will be created for constraining cut
            elements.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox.
remesh_params
The parameters of re-meshing along the cut, defined as ""keyword value"" format. 
For example: ""angle 30.0 min_elem_size_rate 0.6 comp_remainder_area_rate 1.0"" 
Valid keywords and values are:
angle
Values used to define feature edges on mesh. Default if not specified is
                  30.0.
min_elem_size_rate
Defines the minimum element size locally. The valid range is between 0.0 and
                  1.0. The minimum element size is calculated locally on the mesh area being
                  re-meshed. The element size is computed for the mesh area and the minimum element
                  size is then the product of min_elem_size_rate and the element
                  size of the area. 
min_elem_size_value
Defines the minimum element size globally.
comp_remainder_elem_numb
Defines the minimum number of elements in a component. After box trimming, any
                  component with an element count less than this value is deleted.
comp_remainder_area_rate
Define the limit of shell element area of components. After box trimming, any
                  component with element areas less than this percent of its original area is
                  deleted. The valid range of the value is between 0.0 and 100.0. 



","Example
To trim displayed elements using a left box, with limit of 50:
*createmark elements 1 ""displayed""
*hm_trim_elements_with_predefined_box 1 ""left"" 50.0 ""abc"" ""efg"" ""min_elem_size_rate 0.6 comp_remainder_elem_rate 0.01 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1558,*hmmeshdrag,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *drag...toformsurface commands. 
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
To drag six nodes -100 units in the direction of the y-axis and create 50 elements without
        creating a surface: 
*surfacemode 3
*createlist nodes 1 5 10 6 11 12 7
*createvector 1 0.0000 1.0000 0.0000
*dragnodestoformsurface 1 1 -100.0000
*set_meshedgeparams 0 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshdrag 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1559,*hmmeshskin,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm that approximates a skin surface. Can only be used together with
          *surfacemode 3 and *skinsurface. 
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
This example identifies a region in the shape of a skin surface across lines 1, 2, 3, and 4
        and then creates 50 quad elements: 
*surfacemode 3
*createlist lines 1 1 2 3 4
*skinsurface 1 1
*set_meshedgeparams 0 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshskin 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1560,*hmmeshspline,"Description
Within the automeshing module, generates quad or tria elements using a flexible surfaceless
        algorithm. Can only be used together with *surfacemode 3 and
          *splinesurface. 
","Inputs

quads
If nonzero, specifies that the created elements should be quads. 

","Example
To generate elements with densities of 10, 11, 10, and 10 along the given edges: 
*surfacemode 3
*createmark lines 1 1 2 7 8
*createplane 1 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000
*splinesurface lines 1 0 1
*set_meshedgeparams 0 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 11.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 10.0 0 0 0 0 0 0 0
*hmmeshspline 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1561,*hmmeshsurfaceplane,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and
          *surfaceplane. 
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
To create a square, planar surface normal to the x axis with the center at the origin, of
        size 10.0, and create 45 elements: 
*surfacemode 3
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*surfaceplane 1 10.0
*set_meshedgeparams 0 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 9.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 9.0 0 0 0 0 0 0 0
*hmmeshdrag 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1562,*hmmeshsurfacetorus,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *surfacetorus... commands. 
","Inputs

quads
If nonzero, specifies that the created elements should be quads. 

","Example
This example identifies a region that corresponds to the upper half of a torus, and without
        making a surface, creates 400 elements with a density of 40 around the major circumference
        of the torus and 10 across the upper half. 
*surfacemode 3
*surfacetorus 17 19 18 20.0 115.0 0.0 360.0 0.0 180.0
*set_meshedgeparams 0 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 40.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 10.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 40.0 0 0 0 0 0 0 0
*hmmeshsurfacetorus 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1563,*hmplysmoothing,"Description
This command allows you to create smoothed geometry contour lines and surfaces for ply
        entities, with various options.
","Inputs

mark_id
The ID of the mark containing the plies for smoothing. Valid values are 1 and 2.
num_iters
The number of smoothing iterations to be run ≥ 0.
region_type
Flag indicating method used for very local and small ply coverage regions (element
            patch or hole) detection. Valid values are: 
0 - Detect small regions by area ratio 
1 - 1etect small regions by element count
small_tol
Threshold value to identify local and small ply regions for elimination. The value
            depends on the region_type. 
0 (area ratio) - Value indicates the area ratio (calculated by local region area /
            total design area, ≥ 
0.0 and < 1.0). 
1 (elem count) - Value indicates the number of elements (≥ 0, default = 15).
split_ply
0 - Do not create separate ply entities from disconnected ply coverage regions 
1 - Create separate ply entities from disconnected ply coverage regions

","Example
To smooth all plies using 20 iterations, eliminating small ply regions with area less than
        0.05 of the total design, and finally splitting disconnected ply coverage regions into
        separate ply entities:
*createmark plys 1 all
*hmplysmoothing 1 20 0 0.05 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1564,*hwCfdCreateMeshControlsFromSolverOptions,"Description
This command is used to create mesh control entities from the solver option entities
        created inside the CFD profile. These mesh controls will be used both for surface mesh as
        well as volume mesh.
","
Inputs



mesher

The name of the meshing application to create the mesh controls for.  Must be set to
            hm.

","Examples
To generate mesh controls for HM from the solver options:
*hwCfdCreateMeshControlsFromSolverOptions ""hm""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1565,*hwCfdSceneShowAll,"Description
This command is used to turn on all entities.
This should be used in conjunction with the
          *hwCfdSceneShowHideIsolateEntity and
          *hwCfdSceneReverseAll commands.
This command is valid only for the CFD profile.
","
Inputs



consider_geom

0 - Do not consider the associated geometry
1 - Consider the associated geometry (default)

consider_elems

0 - Do not consider the associated elements
1 - Consider the associated elements (default)

","Examples
To hide surfaces 1-10, reverse the display, then show all entities:
*createmark surfaces 1 1-10
*hwCfdSceneShowHideIsolateEntity hide surfaces 1 1 1 1
*hwCfdSceneReverseAll surfaces 1 1
*hwCfdSceneShowAll 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1566,*hwct_addrepsfromlibrary,"Description
Adds representations from a connected library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
rep_alias_list
The list of representation alias names to load.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Valid parameters are:
load=<value>
0 - Do not load the rep alias for the subsystem
1 - Load the rep alias for the subsystem
overwrite=<value>
0 - Do not overwrite the session information
1 - Overwrite the session information
repfolder=<value>
The folder in which the representation exists.



","Examples
Load a crash representation for subsystem 2 from C:/temp/subsystems:
*createmark subsystems 1 2
*hwct_addrepsfromlibrary subsystems 1 crash ""overwrite=1, repfolder=c:/temp/subsystems""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1567,*hwct_closelibrary,"Description
Closes a currently open library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.

","Examples
Close the currently connected subsystem library:
*hwct_closelibrary subsystems
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1568,*hwct_openlibrary,"Description
Opens a library.  Once the library is connected all entities are updated with information
        present in the library.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Valid parameters are:
libraryname=<value>
The name of the library to open.
overwriteattributes=<value>
0 - Do not overwrite the attributes when merging
1 - Overwrite the attributes when merging
password=<value>
The library password.
user=<value>
The library user name.
usersettingsfilepath=<value>
The path of the user settings file for connecting to the library.
workspacename=<value>
The local in-work repository name.



","Examples
Open SubsystemLibrary1:
*hwct_openlibrary subsystems ""usersettingsfilepath=c:/Users/me/.Altair/AltairSubsystemLibrarySettings2020.xml, libraryname=SubsystemLibrary1, workspacename=SubsystemWorkspace1, user=me""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1569,*hwct_synclibrary,"Description
Synchronizes library information from a connected library.  This includes information such
        as Major Revision, Study Revision and Library Revision.
","
Inputs


entity_type
The type of connected library.  Currently only supported for subsystems.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
params
A quoted, comma separated string, containing additional optional name=value
            parameters.  Currently not supported.

","Examples
Synchronize library related information for subsystem 2:
*createmark subsystems 1 2
*hwct_synclibrary subsystems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1570,*idmgrshowhide,"Description
Show/hide submodel or exclusive entities.
","Inputs

submodel_type
The type of submodel to compact the IDs for. Valid values are includes and
            includefiles.
id
The ID of the submodel.
short_name
The short name of the submodel.
show_hide_flag
0 - Hide 
1 - Show
show_hide_type
exclusive - Show/hide exclusive entities 
submodel - Show/hide submodel entities 

","Examples
To hide include 1 submodel entities:
*idmgrshowhide includes 1 """" 0 ""submodel""
To hide excluded entities:
*idmgrshowhide includes 0 """" 0 ""exclusive""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1571,*imprint_elements,"Description
Imprints, connects and optionally remeshes source 1D/2D elements onto target 2D
        elements.
","Inputs

entity_type_target
The type of entity to use as the target (destination) for the imprint. Valid values
            are components and elements.
mark_id_target
The ID of the mark containing the target entities to imprint onto. Valid values are 1 and 2.
entity_type_source
The type of entity to use as the source for the imprint. Valid values are components
            and elements.
mark_id_source
The ID of the mark containing the source entities to imprint. Valid values are 1 and 2.
options
Additional strings defining extended parameters/options. Options are defined in ""name
            value(s)"" format. Valid options are:
projection_vector xyz
3 doubles defining the vector direction. If not defined, normal projection is
                  used.
remain value
1 - Source remains, source node coordinates are kept (default if not provided). 
2 - Destination remains, node coordinates projected to destination are used. 
3 - Both remain, source entities are projected and a copy is imprinted to
                  destination.
max_distance value
The command will exit with an error if the distance between source and
                  destination exceeds this value. If not specified, this is ignored.
to_dest_component value
0 - Do not organize imprinted elements to destination component (default if not
                  provided). 
1 - Organize imprinted elements to destination component.
angle value
The angle used to define feature edges on the mesh. If not defined, 25.0 is
                  used.
remesh_mode value
-1 - No remesh. Element connectivity is maintained by recovery of the imprinting
                  element edges. 
0 - Do not remesh destination. Destination mesh is stitched to maintain element
                  connectivity. 
1 - Remesh all input destination elements. 
2 - Remesh destination elements defined by
                  remesh_layers.
remesh_layers value
Must be defined if remesh_mode is 2. 
0 - Remesh only the elements attached to the border of the imprinted element
                  image. 
> 0 - Remesh additional layers in addition to the elements attached to the
                  imprinted element image.
mesh_type value
Automatically detected from input mesh if not provided. 
0 - tria 
1 - quad 
2 - mixed 
3 - R-tria 
4 - quad only
mesh_size value
Automatically detected from input mesh if not provided.
create_joint_elems value
Only valid when remain is 3. 
0 - Do not generate patch elements between source and destination elements
                  (default if not provided). 
1 - Generate patch elements between source and destination elements.



","Example
To imprint elements from component named ""conn_imprint"" to component named ""auto1"", using a
        normal projection, a feature angle of 30, keeping the source, and remeshing the destination
        using 2 layers:
*createmark components 2 ""auto1""
*createmark components 1 ""conn_imprint""
*imprint_elements components 2 components 1 ""remain 1 remesh_mode 2 remesh_layers 2 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1572,*imprint_nodelist,"Description
Imprints, connects and optionally remeshes source segments defined by a node list onto
        target 2D elements.
","Inputs

list_id_source
The ID of the list containing the source nodes defining the segments to imprint. Valid values are 1 and 2.
entity_type_target
The type of entity to use as the target (destination) for the imprint. Valid values
            are components and elements.
mark_id_target
The ID of the mark containing the target entities to imprint onto. Valid values are 1 and 2.
options
Additional strings defining extended parameters/options. Options are defined in ""name
            value(s)"" format. Valid options are:
projection_vector xyz
3 doubles defining the vector direction. If not defined, normal projection is
                  used.
remain value
1 - Source remains, source node coordinates are kept (default if not provided). 
2 - Destination remains, node coordinates projected to destination are used. 
3 - Both remain, source entities are projected and a copy is imprinted to
                  destination.
max_distance value
The command will exit with an error if the distance between source and
                  destination exceeds this value. If not specified, this is ignored.
to_dest_component value
0 - Do not organize imprinted elements to destination component (default if not
                  provided). 
1 - Organize imprinted elements to destination component.
angle value
The angle used to define feature edges on the mesh. If not defined, 25.0 is
                  used.
remesh_mode value
-1 - No remesh. Element connectivity is maintained by recovery of the imprinting
                  element edges. 
0 - Do not remesh destination. Destination mesh is stitched to maintain element
                  connectivity. 
1 - Remesh all input destination elements. 
2 - Remesh destination elements defined by
                  remesh_layers.
remesh_layers value
Must be defined if remesh_mode is 2. 
0 - Remesh only the elements attached to the border of the imprinted element
                  image. 
> 0 - Remesh additional layers in addition to the elements attached to the
                  imprinted element image.
mesh_type value
Automatically detected from input mesh if not provided. 
0 - tria 
1 - quad 
2 - mixed 
3 - R-tria 
4 - quad only
mesh_size value
Automatically detected from input mesh if not provided.
create_joint_elems value
Only valid when remain is 3. 
0 - Do not generate patch elements between source segments and destination
                  elements (default if not provided). 
1 - Generate patch elements between source segments and destination
                  elements.
close_node_list value
0 - Do not generate a segment between the last node and the first node to close
                  the list as a loop (default if not provided). 
1 - Generate a segment between the last node and the first node to close the
                  list as a loop.



","Example
To imprint the segments defined by a list of nodes 1-4 onto the elements in component
        ""destination"":
*createlist nodes 1 1 2 3 4
*createmark components 1 ""destination""
*imprint_nodelist 1 components 1 ""remain 1 to_dest_component 0 remesh_mode 2 remesh_layers 2 angle 30.000000""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1573,*includesuppressactive ,"Description
This command sets the active/inactive state of all supported entities contained within the
        include file (but not the include file itself) with include_id and
          include_shortname. Only one of these two options need to be specified,
        however include_id will take precedence if specified. Double quotes """"
        must be used for an argument that is not specified.
Include files do not have an active/inactive state, only the entities contained within
        them. 
","Inputs


include_id


include_shortname


state
The state argument indicates the active/inactive status for the
              supported entities contained in the include. 
0 - Indicates to set the entities to active and turn on their display.
1 - Indicates to set the entities to inactive and remove them from the display. 
2 - Indicates to set the entities to active but not to re-display them.




","Example
To set all supported entities contained within include file ID 5 to active and
        re-display:
*includesuppressactive 5 """" 0
To set all supported entities contained within include file shortname include
          .txt to inactive:
*includesuppressactive """" include.txt 1
To set all supported entities contained within include file ID 5 to active and not
        re-display:
*includesuppressactive 5 """" 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1574,*inputsimulation ,"Description
Sets the current simulation and data type for contour and assigned plots, vector plots, and
        animations. The results file must be loaded before executing this command.
","Inputs

simulation
The name of the simulation contained in the results file.
data_type
The name of the data type for the simulation.

","Example
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements data type, using a 10.0 model unit
        scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*animatemodal """" 10.0 4 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1575,*interactivemeshsurf ,"Description
Brings a surface into the automeshing module and prepares it for processing, enabling the
        use of all the restricted module commands.
","Inputs

markmask
The surfaces to be meshed. 
elementsize
The default element edge size used to calculate element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


forcing
If nonzero, any saved surface parameters generated previously with the automesher are
            ignored.
size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created. 
1 = yes 
0 = no



","Example
In this example, the automeshing module processes a surface with four faces and ten edges.
        To generate a mesh for each face, the module sets up values for element densities and
        biasing with the *set_meshedgeparams command. Automeshing parameters for
        each face are specified with the *set_meshfaceparams command. Each face
        is sent to the *automesh command so it can determine the appropriate
        meshing algorithm and create an all-quads mesh. You then direct HyperMesh to smooth the meshes for ten iterations each. Next, the mesh
        for face two is rejected and a new mesh is created with slightly different element
        densities. The four meshes are saved to the HyperMesh database.
        The automeshing module clears from its memory any information regarding the current surface
        so that a new surface can be processed.
*surfacemode 1
*createmark surfaces 1 1
*interactivemeshsurf 1 1 1 1 1 0 0
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 6.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0 1 1
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 4.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 4.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 2 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 9 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 10 7.0 0 0 2 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 3 1 1 0 0 0 0.1 0 0
*automesh 3 1 1
*smoothelements 0 1 10
*smoothelements 1 1 10
*smoothelements 2 1 10
*smoothelements 3 1 10
*rejectmesh 2
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*storemeshtodatabase 0
*ameshclearsurface()
","Errors
None.
"
1576,*interactiveremeshsurf,"Description
Brings a surface into the automeshing module and prepares it for processing, enabling the
        use of all the restricted module commands. All elements previously attached to the surface
        are deleted.
","Inputs

markmask
The surfaces to be meshed. 
elementsize
The default element edge size used to calculate element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


forcing
If nonzero, any saved surface parameters generated previously with the automesher are
            ignored 
size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created. 
1 = yes 
0 = no

","Example
In this example, the automeshing module processes a surface with four faces and ten edges.
        To generate a mesh for each face, the automeshing module sets up values for the element
        densities and biasing with the *set_meshedgeparams command. Automeshing
        parameters for each face are specified with the *set_meshfaceparams
        command. Each face in sent to the *automesh command so it can determine
        the appropriate meshing algorithm and create an all-quads mesh. You then direct HyperMesh to smooth the meshes for ten iterations each. The mesh for
        face two is rejected and a new one is created with slightly different element densities. The
        four meshes are saved to the HyperMesh database. The automeshing
        module clears from its memory any information regarding the current surface so that a new
        surface can be processed.
*surfacemode 1
*createmark surfaces 1 1
*interactivemeshsurf 1 1 1 1 1 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 6.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0 1 1
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 4.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 4.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 2 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 9 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 10 7.0 0 0 2 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 3 1 1 0 0 0 0.1 0 0
*automesh 3 1 1
*smoothelements 0 1 10
*smoothelements 1 1 10
*smoothelements 2 1 10
*smoothelements 3 1 10
*rejectmesh 2
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
1577,*interfaceaddsolidface,"Description
Creates interface elements on shell elements and faces of solid elements. 
","Inputs

name
The name of the group into which the interface elements should be placed. 
master
Use 1 for master; 0 for slave. 
element mark
The ID of the mark containing the solid elements. 
node mark
The ID of the mark containing nodes that define the face of a solid element. 
break angle
The angle used to define a ""sharp corner"".

","Example
HyperMesh will use the node mark to find the face of a solid
        element. All adjacent faces will then be found until a sharp corner (defined by a break
        angle) is found. Finally, master/slave elements will be created on these faces. 
","Errors
None.
"
1578,*intersectmark2,"Description
Creates nodes/lines by intersecting 1D/2D elements with a plane. For 1D elements, nodes are
        created at each intersection location. For 2D elements, a series of line segments are
        created at the specified plane that matches the profile of the selected elements that span
        that plane. These segments are then joined together according to the values selected for
          combine_flag, break_angle and smooth.
","Inputs

entity_type
The type of entities to intersect. Valid values are elems and comps (only elems in
            comps are considered).
mark_id
The ID of the mark containing the entities to intersect. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the cut. This is defined using the
              *createplane command.
combine_flag
0 - Do not combine generated lines. 
1 - Combine generated lines.
break_angle
The break angle used when combining lines. Ignored if combine_flag
            is 0.
smooth_flag
0 - Do not smooth combined lines. 
1 - Smooth combined lines. Ignored if combine_flag is 0.
comp_mode
Parameter specifying how lines are organized into components: 
0 - Lines are created in the current component. 
1 - All created intersection lines will be placed in the original element
            component(s), splitting the lines where necessary if the elements selected are connected
            and in different components.

","Example
To create intersection lines for the xy-plane with a base node of 0,10,0 with the displayed
        elements, with lines organized to the element components:
*createmark elems 1 displayed
*createplane 1 0 0 1 0 10 0
*intersectmark2 elems 1 1 0 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1579,*isolateentitybymark,"Description
Turns on the display of a mark of entities and turns off the display of all others of the
        same type.
","Inputs

mark_id
The ID of the mark containing the entities. Valid values are 1 and 2. All entities with a display state on the specified mark,
            regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To isolate geometry and elements for components 1-3:
*createmark comps 1 1-3
*isolateentitybymark 1
 To isolate all comps and load collectors, considering only elements:
*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*isolateentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1580,*isolateonlyentitybymark ,"Description
 Turns on the display of a mark of entities and turns off the display of all others across
        types.
","Inputs

mark_id
The ID of the mark containing the entities. Valid values are 1 and 2. All entities with a display state on the specified mark,
            regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To isolate only geometry and elements for components 1-3:
*createmark comps 1 1-3
*isolateonlyentitybymark 1
To isolate only all comps and load collectors, considering only elements:
*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*isolateonlyentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1581,*jointelement_sixnoded ,"Description
Creates a six-noded joint element.
","Inputs

type
The type of the element (6 or 7 ONLY)
n1, n2, n3, n4, n5, n6
The six nodes of the element.
orientation
Orientation option for the element. Use:
0 - None 
1 - Systems


system1
The orientation systems’ IDs for the element.
property
The property to which the element points.

","Example
To create a six-noded joint element:
*jointelement_sixnoded(7,464,457,456,455,463,462,1,1596,1592,"""")

","Errors
None.
"
1582,*jpegfile ,"Description
Captures the graphics area to a JPEG image in the current working directory. Each image is
        automatically assigned a unique name and number starting from 0 (e.g.
          image0.jpg, image1.jpg, etc...). 
The color and background settings can be specified using the
          *graphicsfilecolor and *graphicscolorblankbackground
        commands.
","Example
To capture the graphics area to a JPEG image:
*jpegfile
","Errors
None.
",
1583,*laminaterealizewithoptions,"Description
Realizes a laminate to create solver entities (properties, components, and so on) for
        updating layer information.
These additional steps must be followed to complete laminate realization specific to the
        list user profile.
ANSYS
Valid ET types like shell91/shell99/shell131/shell181 should be attached to
              component.
Abaqus
Assign a composite property to all the elements before realization.
OptiStruct/Nastran
Assign a PCOMPP property to all the elements before realization.


","Inputs

laminate_id
The ID of the laminate to be realized. 
drape_flag
0 - Do not consider drape data during realization 
1 - Include drape data during realization
thickness_tol
The tolerance value for thickness during realization. Valid only used
              if drape_flag is set to 1.
orientation_tol
The tolerance value for orientation angle during realization. Valid only used
              if drape_flag is set to 1.
create_sequence
Reserved for future use. Must be set to 0.
reserved2
0 - Do not create the sequences/zones for laminates (default)
1 - Create the sequences/zones for laminates
reserved3
Reserved for future use. Must be set to 0.
reserved4
Reserved for future use. Must be set to 0.
reserved5
Reserved for future use. Must be set to 0.
reserved6
Reserved for future use. Must be set to 0.

","Example
To realize a laminate with ID 3 including any drape information, with thickness tolerance 4
        and orientation tolerance 15:
*laminaterealizewithoptions 3 1 4 15 0 0 0 0 0 0 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1584,*legendcoloredit,"Description
Edits a color in the legend. 
","Inputs

color
The color in the legend to be edited. 
red
The amount of red in the color (0 to 255). 
green
The amount of green in the color (0 to 255). 
blue
The amount of blue in the color (0 to 255). 

","Example
 To change the top color on the legend in an eight-color legend to blue: 
*legendcoloredit(7,0,0,255)

","Errors
None.
"
1585, *legenddisplay,"Description
This command controls the display of the legend.
","Inputs

state
The legend display state: 
0 - Off 
1 - On

","Example
To set the legend off:*legenddisplay 0
","Errors
None.
"
1586,*legendmove ,"Description
 Moves the legend. 
","Inputs

x
The new x location for the legend. 
y
The new y location for the legend. 

","Errors
None.
",
1587,*legendsavecolors ,"Description
Saves the colors of a legend to a file. 
","Inputs

filename
Save the color information to this file name. 

","Errors
None.
",
1588,*legendsetcolor,"Description
 Sets the color used to display the legend. 
","Inputs

color 
The color used to display the legend. 

","Errors
None.
",
1589,*legendsetfont,"Description
Sets the font used to display the legend. 
","Inputs

font
The font ID to be used to display the legend (1 - 4). 

","Errors
None.
",
1590,*lightswitch,"Description
Turns the lights on or off.
","Inputs

on
A flag that indicates if the lights should be turned off (0) or on (1). 
plot
A flag that indicates if the screen should be replotted after this command is
            executed.

","Example
To switch the lights off and replot the screen:
*lightswitch(0,1)
 To turn the lights back on, but leave the screen as-is (no refresh):
*lightswitch(1,0)
","Errors
None.
"
1591,*line_mesh_decimator,"Description
Decimate 1D elements to user given element size.
","
Inputs



entity_type

The type of entity containing the 1Ds to coarsen.  Valid values are elems and
            comps.

mark_id

The ID of the mark containing the input entities.  Valid values are 1 and 2.

element_size

The size to use for coarsening.
options
List of input options, passed as a space separated string enclosed in quotes. Valid
            options are:
AnchorNodeMarkId=<mark_id>
The ID of the mark containing nodes to use as anchors.  Valid values are 1 and
                  2.
ChordalDeviation=<value>
The chordal deviation value to use for decimation.
ConsiderEdgeConformal2DElems=<value>
0 - If 2D elements are also selected along with the 1D elements, the attached
                  2Ds will be not modified to maintain mesh conformality.
1 - If 2D elements are also selected along with the 1D elements, the attached
                  2Ds will be modified to maintain mesh conformality.
FeatureAngle=<value>
The face deviation cutoff for decimation.  Useful when 2D elements are selected,
                  in addition to edge/1D elements.
IgnoreDiameter=<value>
If any isolated connected cluster is contained within this size it will be
                  deleted.
PerChainMinEdgeCount=<value>
Controls the number of edges to be retained per chain in the given edge/1D
                  element input.
TurningAngle=<value>
A node will be anchored if only two 1D elements that are connected to the node
                  make an angle greater than this value.



","Examples
To coarsen component 100 to size 10, using nodes 1-10 as anchors, and several other
        options:
*createmark comps 1 10
*createmark nodes 1 1-10
*line_mesh_decimator comps 1 10 ""AnchorNodeMarkId = 1 ChordalDeviation = 0.15 TurningAngle = 30 IgnoreDiameter = 4""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1592,*linearmesh,"Description
Within the automeshing module, generates quad or tria elements using a flexible surfaceless
        algorithm that approximates a ruled surface. Can only be used together with
          *surfacemode(3) and one of the *linearsurface...()
        commands. 
","Inputs

quads
If nonzero, specifies that the created elements should be quads. 

","Example
Identifies a region in the shape of a ruled surface and sends it into the automesher to
        create quad elements:
*surfacemode 3
*createlist nodes 1 1581 77 83 88 95
*createlist nodes 2 225 228 232 235 262
*linearsurfacebetweennodes 1 2 1
*set_meshedgeparams 0 8 1 0 0 0 0 0 0
*set_meshedgeparams 1 4 1 0 0 0 0 0 0
*set_meshedgeparams 2 8 1 0 0 0 0 0 0
*set_meshedgeparams 3 4 1 0 0 0 0 0 0
*linearmesh 1
*storemeshtodatabase 0
*ameshclearsurface

","Errors
None.
"
1593,*linearsolidsbynodelist,"Description
Creates solid elements between two groups of plane elements, with the layers identified by
        nodes in a node list.
","Inputs

mark1
The ID of the mark containing the first group of plate elements.
mark2
The ID of the mark containing the second group of plate elements.
align1
The ID of the node to be used as an alignment node for the first group of
            elements.
align2
The ID of the node to be used as an alignment node for the first group of
            elements.
align3
The ID of the node to be used as an alignment node for the first group of
            elements.
align4
The ID of the node to be used as an alignment node for the second group of
            elements.
align5
The ID of the node to be used as an alignment node for the second group of
            elements.
align6
The ID of the node to be used as an alignment node for the second group of
            elements.
nodelist
The node list to be used to specify the locations of the layers.

","Example
To create 8 layers of solids between plates 10, 11, 12, 13 and 20, 21, 22, 23 using, as
        alignment nodes, nodes 5 and 13, and as layer-specifying nodes, 5, 6, 7, 8, 9, 10, 11, 12,
        13:
*createmark(element,1) 10 11 12 13
*createmark(element,2) 20 21 22 23
*createlist(nodes,1) 5 6 7 8 9 10 11 12 13
*linearsolidsbynodelist(1,2,5,0,0,13,0,0,1)
The nodelist nodes should begin with one belonging to an element on the first element mark
        and end with a corresponding one belonging to an element on the second element mark.
","Errors
None.
"
1594,*linearsurfacebetweennodes,"Description
Creates a ruled surface between two node lists. Optionally it can immediately be use within
        the auto mesher. It can also identify a region in the shape of a ruled surface for the auto
        mesher to use under the mesh without surface option.
","Inputs

list1
The ID of the first list of nodes forming one side of the surface.
list2
The ID of the second list of nodes forming one side of the surface.
reverse
Indicates whether the nodes should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no).

","Example
Identifies a region in the shape of a ruled surface and sends it into the automesher to
        create quad elements:
*surfacemode 3
*createlist nodes 1 1581 77 83 88 95
*createlist nodes 2 225 228 232 235 262
*linearsurfacebetweennodes 1 2 1
*set_meshedgeparams 0 8 1 0 0 0 0 0 0
*set_meshedgeparams 1 4 1 0 0 0 0 0 0
*set_meshedgeparams 2 8 1 0 0 0 0 0 0
*set_meshedgeparams 3 4 1 0 0 0 0 0 0
*linearmesh 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1595,*linecombine,"Description
Combines two free lines into one.
","Inputs

line_id1
The ID of the first free line.
line_id2
The ID of the second free line.
smooth
A flag that determines whether the lines should be combined with a straight line
            segment (0) or a smooth line segment (1) if the end points of the lines are not
            coincident. 

","Example
To combine lines 10 and 20 with a smooth segment:
*linecombine 10 20 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1596,*linecombinemarkall,"Description
The command joins a selection into a single line. The decision of which of the endpoints of
        the given lines to join depends only on the end points’ proximity: the lines with closest
        end points are joined together first.
","
Inputs



mark_id

The ID of the mark containing the lines to combine. Valid values are 1 and 2.

smooth

0 - Join with straight segments
1 - Join with smooth curves

keep_original_lines

0 - Do not keep
1 - Keep

","Examples
To join the lines with IDs 10,20,30 into a single line, joining them smoothly and deleting
        the input lines:
*createmark lines 1 10 20 30
*linecombinemarkall 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1597,*linecreateatsurfacefeatures,"Description
This command detects locations of internal surface features defined as high curvature areas
        or discontinuities on input surfaces, and splits surfaces at those locations to provide
        improved meshing conditions.
","
Inputs



mark_id

The ID of the mark containing the input surfaces.  Valid values are 1 and 2.

reserved

Reserved for future use.  Must be set to 0.

radius

The minimal curvature radius value. If set to negative or zero, then the radius is
            estimated automatically from the input surface size.

","Examples
Example 
*createmark surfs 1 displayed
*linecreateatsurfacefeatures 1 0 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1598,*linecreateconic ,"Description
This command creates a conic section curve segment (hyperbola, parabola, ellipse or
        circular arc) for given segment endpoints, given endpoint tangent lines intersection point,
        and a parameter that defines the curve type.
","Inputs

sx sy sz
Coordinates of conic curve segment start point.
ex ey ez
Coordinates of conic curve segment end point.
tx ty tz
Coordinates of a point at intersection between straight lines tangent to created conic
            curve segment at start and end points.
ratio
Parameter that defines the created conic curve segment ""altitude"". Consider the
            segment that connects the tangents’ intersection point with the midpoint between the
            start and end points of the curve. If the length of this segment is used as the unit
            length, then the ratio is defined as the length of the portion of the segment that
            connects the midpoint with the point where the segment is intersected by created curve
            (see figure below). Valid values for ratio are in the range 0 to 1. For the value of
            0.5, the conic curve is a parabolic segment. For the values between 0 and 0.5, the conic
            curve is an ellipse. For the values between 0.5 and 1, the conic curve is a hyperbolic
            segment.
A ratio of -1 can also be used to invoke automatic circle calculation. A circular arc
            is then created, provided the length of the tangent segments are equal.

Figure 1. 


","Examples
To create a parabolic segment with the start point at (1,2,3), the end point at (4,2,3) and
        the endpoint tangent lines intersection point at (3,10,3):
*linecreateconic 1 2 3 4 2 3 3 10 3 0.5
To create a 90 degree circular arc that lies in the plane z=0 and connects points (0,0,0)
        and (1,0,0):
*linecreateconic 0 0 0 1 0 0 0.5 0.5 0 -1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1599,*linecreatefromcoords,"Description
Create a line passing through a list of 3D points.
","
Inputs


type
The type of line to generate. Valid values are:
0 - Linear
1 - Standard
2 - Smooth
3 - User controlled
When type is 3, input values for break_angle,
              aspect and linear_angle are used.
Adding 8 to any of the values above will create a closed line of that type.
break_angle
Specifies the minimum angle allowed between three points in a line. If the angle
            between a point and the two adjacent points is less than the angle specified, this point
            is considered to be a point of discontinuity in the line and a joint is placed (the
            start of a new NURBS) at this location.
Used when type is 3.
aspect
Specifies the maximum ratio allowed for the distance between a point and the previous
            point in the line and the distance between the same point and the next point in the
            line.  If the ratio of the distance between the two adjacent segments exceeds the aspect
            ratio defined, a joint is placed between the segments.
Used when type is 3.
linear_angle
Defines the angle at which the line is considred a straight line. For example, if the
            line angle between three consecutive points along the line is greater than the linear
            angle specified, the center point is removed from the line.
Used when type is 3.
double_array
The ID of the double array that contains the values. The double array is created using
            the *createdoublearray command. This should always be set to 1
number_of_doubles
Integer indicating the size (number of doubles) in the array created using
              *createdoublearray.

","Examples
To create a line that passes through 3
        points:*createdoublearray 9 -2.50392465 6.43642072 0 1.04395604 5.9811617 0 4.56043956 5.71428571 0
*linecreatefromcoords 0 150 5 179 1 9
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1600,*linecreatefromnodesandprojecttobinder ,"Description
 Create a specific type of line from a list of nodes and project it along a direction onto
        a surface. 
","Inputs

list id
The ID of the list containing the nodes.
type
The type of line being generated.
1 linear 
2 standard 
3 smooth 
4 user-controlled


break angle
Specifies the minimum angle allowed between three points in a line. If the angle
            between a point and the two adjacent points is less than the angle specified, HyperMeshconsiders this point to be a point of discontinuity in the
            line and places a joint (starts a new NURBS) at this location. 
aspect
Specifies the maximum ratio allowed for the distance between a point and the previous
            point in the line and the distance between the same point and the next point in the
            line. If the ratio of the distance between the two adjacent segments exceeds the aspect
            ratio defined, HyperMesh places a joint between the
            segments.
linear angle
Defines the angle at which HyperMesh should consider a
            line straight. For example, if the line angle between three consecutive points along the
            line is greater than the linear angle specified, HyperMesh
            removes the center point from the line. 
pro_dir
The vector of direction along which the line is projected after it is created from the
            node list.
binder_surf
The surface onto which the line is projected.

","Example
*createlist(nodes, 1) 1 2 3 4
*createvector(1, 0.0, 0.0, 1.0)
*linecreatefromnodesandprojecttobinder(0, 1, 179.0, 5, 179.0, 1, 24)

*linecreatefromnodesandprojecttobinder() has two more parameters than *linecreatefromnodes().
","Errors
None.
"
1601,*linecreatenormal2d,"Description
This command creates a straight segment line of the specified length. The line lies on the
        specified plane, beginning closest to the specified input point, and normal to the specified
        line/surface edge.
","Inputs

line_id
The ID of the reference line or surface edge.
point_type
Type of entity representing input point. Valid values are nodes or points.
point_id
The ID of the node or point to use as the reference starting location.
plane
ID of the temporary reference plane created using
            *createplane.
length
The length of the generated line.
?mode?(optional)
Indicates different modes. Bit values are used and the value is calculated as (Bit0 + 2*Bit1).
Bit0
 0 - The normal direction is used, which is the default value. 
1 - The direction opposite to the normal direction is used to create the
                  segment.
Bit1
Specifies how entities are organized into components. Valid values are:
0 - Line is created in the current component, which is the default value. 
1 - Line is created in the input line component.



","Example
To create straight segment normal to line 5, starting closest to node 15, in the x-y plane
        with base node (0,0,0) with length 10:

*createplane 1 0 0 1 0 0 0
*linecreatenormal2d 5 nodes 15 1 10

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1602,*linecreatenormaltogeom,"Description
This command creates straight segment lines from a given set of points or nodes normally to
        a given set of geometric entities. The segment is created for each pair of point and
        geometry. 
","Inputs

point_type
Type of entities representing input points. Valid values are nodes or points.
point_mark_id
The mark of input points or nodes.
geom_type
Type of geometry entities. Valid values are lines, surfs, faces or solids.
geom_mark_id
The mark of input geometry entities.
mode
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).
Bit0
Parameter that specifies the behavior in ambiguous cases. Valid values are:
0 - For each pair of point and geometry, a single segment is created
                      between the point and the closest geometry point. The segment must be normal
                      to the geometry otherwise it is not created. 
1 - For each pair of point and geometry, a single segment is created
                      between the point and the closest geometry point. The segment does not have to
                      be normal to the geometry.


Bit1
Specifies how entities are organized into components. Valid values are:
 0 - Line is created in the current component, which is the default value. 
1 - Line is created in the original geometry component.





","Example
To create a straight segment normally from node with ID 10 to surface with ID 21:
*createmark nodes 1 10
*createmark surfs 1 21
*linecreatenormaltogeom nodes 1 surfs 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1603,*linecreateoffsetalongcurvature,"Description
This command creates a line by offsetting the input lines in line_list
        along their curvature direction. The input lines must form a connected line; otherwise an
        error is given. The first line in the line_list determines the direction
        of the combined line, hence the start point, from which the offsetting starts. If the
        opposite direction for the combined line is desired, the corresponding value of the flags
        must be set. 
If the offset value is negative, the direction opposite to curvature direction is used for
        offset.
In the case where there is a discontinuity in the curvature direction at some point between
        the input lines, a link is inserted if link_type is chosen to be 2.
        However, if the change in the curvature direction is 180 degrees, then no link is inserted
        and the offset continues without any jump. In this case, after the discontinuity point, the
        offset follows the opposite direction of the curvature direction.
","Inputs

line_list
The list ID of lines to be offset. Input lines must form a connected line when
            combined.
start_offset
The offset distance at the start of the combined line.
end_offset
The offset distance at the end of the combined line.
link_type
The type of link that is inserted between offset lines in the case where there is a
            discontinuity (other that 180 degrees) in the direction of the curvature:
0 - The offset direction is interpolated on both sides of the discontinuity to
                allow a smooth transition. In this case, along the interpolation region, the offset
                direction is going to be different than the curvature direction. Amplified
                fluctuations, which would occur in the offset because of little ripples in the input
                curve, are smoothed out with this option. 
1 - A straight line segment is inserted as a link between offset of input lines,
                if there is a jump in offset direction at points where input lines meet. 
2 - No link is inserted, if there is a jump in offset direction at points where
                input lines meet. In this case, the offset lines might become disconnected.


flags
Flags that indicate different modes for the offset. Bit values are used and the value
            is calculated as (Bit0 + 2*Bit1 + 4*Bit2).
Bit0
0 - Keep original lines after drag. 
1 - Delete original lines after drag. Applies only to free lines (not surface
                  edges).
Bit1
0 - The direction of the combined line is the same as the direction of the first
                  line in the line_list. 
1 - The direction of the combined line is opposite to the direction of the first
                  line in the line_list.
Bit2
Specifies how entities are organized into components. Valid values are:


0 - Line is created in the current component, which is the default value. 
1 - Line is created in the most common input lines component.





","Example
To create an offset line by dragging lines 4 and 5 by an amount of 3.2 units at start and
        5.0 at end. 
*createlist lines 1 4 5
*linecreateoffsetalongcurvature  1 3.2 5.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1604,*linecreatestraight ,"Description
This command creates a straight segment line between the given input end point coordinates.
        The distance between the input points must be not smaller than the global value of the
        geometry cleanup tolerance set by *setoption cleanup_tolerance.
","Inputs

x1 y1 z1
Coordinates of segment start point.
x2 y2 z2
Coordinates of segment end point.

","Example
To create straight segment with endpoints (1, 2, 3) and (4, 5, 6):
*linecreatestraight 1 2 3 4 5 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1605,*linedraglinetoformsurface ,"Description
Drags a trimmed line along a trimmed line to create a surface, and optionally, prepares it
        for immediate use within the automesher. It can also identify a region in the shape of a
        line-dragged surface for the automesher to use under the mesh without surface option. 
","Inputs

sectionlinelist
The ID of the list of lines to be dragged.
sectionnodelist
The list ID of the list of zero or two nodes which lie on the lines in the
            sectionlinelist which will be used to trim the line during surface creation. 
draglinelist
The ID of the list of lines to drag along. 
dragnodelist
The list ID of the list of zero or two nodes which lie on the lines in the
            draglinelist which will be used to trim the line during surface creation. 
refplane
The orientation plane used to orient the section lines to the drag lines. 
using_default_vector
0 - Use plane normal vector 
1 - Use default normal vector

","Example
To drag lines 3 and 4 along lines 2 and 1 using the given plane, creating a surface but no
        elements: 
*surfacemode(4)
*createlist(lines,1) 3 4
*createlist(nodes,1)
*createlist(lines,2) 2 1
*createlist(nodes,2)
*createplane(1,0.0000,1.0000,0.0000,0.0000,0.0000,100.0000)
*linedraglinetoformsurface(1,1,2,2,1)

The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
*createlist() and *createplane() are required for
        this command. 
","Errors
None.
"
1606,*lineeditlength ,"Description
This command is applied to a single free line to change its length. If a closed line is
        selected, one can only make its new length shorter. If the new length is chosen to be less
        than 1 tenth of the cleanup tolerance of the model, the line is deleted to avoid creating
        lines that are too short to be compatible with the model tolerance.
","Inputs

id
The ID of the free line to edit.
length
The new length of the line. 
If a closed line is selected, one can only make its new length shorter. 
If the new length is chosen to be less than 1 tenth of the cleanup tolerance of the
            model, the line is deleted to avoid creating lines that are too short to be compatible
            with the model tolerance. 
A negative length is interpreted as first making the length of the line 0.0, in the
            direction given, and the extending in the opposite direction with the absolute value of
            the given length.
derivative
This option is used only when the new length is longer than the current length of the
            line. 
1 - A straight line extension is made that is tangent to the line 
2 - The extension follows the curvature of the line as well
direction
1 - The change is made at the end point of the line, considering 0.0 length as the
            start point of the line. 
-1 - The change is made at the start point of the line, that is in the reverse
            direction to the direction of the line. 

","Example
Edit the length of line 1142, so that its new length is 80.0. If the line is made longer by
        this change, the extension is made only tangentially. The change is made at the start point
        of line:
*lineeditlength 1142 80.0 1 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1607,*lineextendtoline ,"Description
 Extends line1 to line2.
","Inputs

line1
The ID of the line to extend.
line2
The ID of the line to which line1 is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of line2, then force the end
            point to be on line2.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
1608,*lineextendtopoint ,"Description
Extends the specified line to a point.
","Inputs

line
The ID of the line to extend.
point
The ID of the point to which the line is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of the point, then force the end point to have the
            same coordinates as the point.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
1609,*linefromsurfedgecomp,"Description
This command takes selected surface edges or edges of selected surfaces and makes their
        copy as free lines. This command replaces the command *linefromsurfedge
        which only creates a copy of edges in the component of the surfaces.
","Inputs

entity_type
Type of selected entity, can be SURFS or LINES. 
If surfaces are selected, then a copy of all surface edges is created.
mark_id
The ID of the mark containing the selected entities. Valid values are 1 and 2.
comp_flag 
Flag to specify whether copied lines are created in current component (1) or in the
            component of surfaces they were copied from (0).

","Example
To copy all surface edges of surface with ID 12 into the current component:
*createmark surfs 1 12
*linefromsurfedgecomp surfs 1 1

","Errors
This command does not return any errors that can be handled.
"
1610,*linelistbypath ,"Description
Creates a line path from the starting line to the ending line.
","Inputs

line_id1
The ID of the first line.
line_id2
The ID of the second line.
list_id
The ID of the line list to populate. Valid values are 1 and 2.
flag
0 - If both line_id1 and line_id2 lie are free
            edges, the path will follow free edges where possible. Otherwise, the shortest path is
            returned. 
1 - Always return the shortest path.

","Example
To determine the path between lines 100 and 110 using the shortest path:
*linelistbypath 100 110 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1611,*linemarkremovepinholes,"Description
Removes 2D holes in the geometry. The holes are supposed to have only one boundary line.
        The command removes these holes by filling it with surface. When possible, the new surface
        is created without any boundary, thus the surrounding surface just extends to fill the hole.
        Otherwise, the boundary of the new surface is suppressed so that it becomes a single surface
        together with its surrounding surface.
","
Inputs



mark_id

The ID of the mark containing the input lines defining the hole perimiters.  Valid
            values are 1 and 2.

exclude_point

0 - Create a point at the center of the hole.
1 - Do not create a point at the center of the hole.

","Examples
To remove the holes that are bounded by lines 20 and 21,  creating a vertex point at their
        center:
*createmark lines 2 20 21
*linemarkremovepinholes 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1612,*linemesh_preparenodeslist1 ,"Description
Prepares the selected node list for 1D meshing. 
Each call to this command must be paired with a call to
          *linemesh_savedata1 or *linemesh_savedata_bar1 to
        clean up memory.
","Inputs

list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
config
If configuration of the element to create. Only 1D configs are valid.

","Example
To mesh between nodes 16, 17, and 2 with 3 rigid elements between nodes 16 and 17 and with
        2 rigid elements between nodes 17 and 2, with no property assignment:
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
","Errors
None.
"
1613,*linemesh_savedata1 ,"Description
Creates 1D elements and cleans up memory. 
Each call to this command must be paired with a previous call to
          *linemesh_preparedata1 or
          *linemesh_preparenodeslist1.
","Inputs

create_flag
0 - Do not generate elements. 
1 - Generate elements.
config
The 1D element config ID of the elements to create. If creating bar2 elements (config
            60) the command *linemesh_savedata_bar1 should be used.
property_id
The ID of the property to assign to the 1D elements.
organize
0 - Organize new 1D elements to current component. 
1 - Organize new 1D elements to input lines component(s).

","Examples
To mesh lines 15 and 18 with a 30 degree break angle, creating rigid elements with no
        property:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
To mesh between nodes 16, 17, and 2 with 3 rigid elements between nodes 16 and 17 and with
        2 rigid elements between nodes 17 and 2, with no property assignment, organizing to the
        input line component(s):
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 1
To mesh between nodes 16, 17, and 2 without creating elements:
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1 5
*linemesh_savedata1 0 5 0 0
","Errors
None.
"
1614,*lineplot,"Description
Generates a line plot.
","Inputs

title
The title of the line plot.
full_size
Determines whether the line plot fills the entire screen. Valid values are: 
0 - Use normal size. 
1 - Use full screen. Press a mouse button to return. 

","Example
To generate a normal size line plot with the title ""This is the title"":
*lineplot ""This is the title"" 0
","Errors
None.
"
1615,*lines_approximate ,"Description
 Simplifies curved free lines.
","Inputs

mark_id
The ID of the mark containing the free lines. Valid values are 1 and 2.
type
1 - Each curved line will be replaced with a parabola (2nd degree) that has the same
            end points as the line, and is closest to it. 
2 - Each curved line will be simplified by removal of all internal knots but one
            (known as Bezier simplification).
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To simplify lines 1 and 2 using Bezier simplification:
*createmark lines 1 1 2
*lines_approximate 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1616,*linescreatemidline ,"Description
Creates a line that approximates the middle path between two roughly parallel, roughly
        planar, lines.
","Inputs

linelist1
The ID of a list of lines forming one side of the path.
trimnodelist1
The ID of a list of 0 or 2 nodes that mark the endpoints to use to trim the lines
              in linelist1.
linelist2
The ID of a list of lines forming the other side of the path.
trimnodelist2
The ID of a list of 0 or 2 nodes that mark the endpoints to use to trim the lines
              in linelist2.

","Example
The four *createlist() directives are required for this command. 
To create a midline between lines 22 and 23:
*createlist(lines,1) 22
*createlist(nodes,1)
*createlist(lines,2) 23
*createlist(nodes,2)
*linescreatemidline(1,1,2,2)
","Errors
None.
"
1617,*linesplitatline,"Description
Splits a group of lines at a line.
","Inputs

mark
The ID of the mark which contains the lines to be cut. 
cut line
The line to which the selected lines should be cut. 

","Example
To cut lines 14, 15, and 16 to line 12: 
*createmark(lines,1) 14 15 16
*linesplitatline(1,12)

*createmark() is required. 
","Errors
None.
"
1618,*linesplitatpoint,"Description
Splits a line at an arbitrary point. 
","Inputs

line
The line to be split. 
node
A node which represents the location on the line where it should be split. 

","Example
To split line 10 at node 3: 
*linesplitatpoint(10,3)

","Errors
None.
"
1619,*linessmoothtotol,"Description
Smooths a line based on a give tolerance. 
","Inputs

mark
The ID of the mark containing the lines to smooth.
tol
Tolerance used to smooth the lines. 

","Example
To smooth line 1 to within a tolerance of .1
*createmark(lines,1) 1
*linessmoothtotol(1,.1)


","Errors
None.
"
1620,*loadcreate,"Description
Creates a load (force, moment, pressure or constraint) at a node or element. 
","Inputs

mark
The ID of the mark. 
config
The type of load to apply to the entity.
1 - Force 
2 - Moment 
3 - Constraints 
4 - Pressure


type
Solver dependent types of the referenced load config.
component 1-6
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z axis, respectively. When applying a
            moment, the active components are also 1, 2, and 3, and represent the moment about the
            x, y, and z axis, respectively. For constraints, all of the components are active unless
            they are set equal to -999999.0. All of the other components of the constraints are
            active in the respective directions. Finally, for pressures the active components are 1,
            2, and 3 which represent the x, y, and z axis, respectively. To create a pressure which
            is normal to the element, set all components to zero.

","Example
To apply a force of magnitude 10.0 along the x axis to node 5 and 25: 
*createmark(nodes,1) 5 25
*loadcreate(1,1,1,10.0,0.0,0.0,0.0,0.0,0.0)
To apply a constraint of zero in the 1, 3, 5, directions to nodes 12, 13, and 14: 
*createmark(nodes,1) 12 13 14
*loadcreate(1,1,3,0.0,-999999.0,0.0,-999999.0,0.0,
   -999999.0);

","Errors
None.
"
1621,*loadcreateonentity_curve,"Description
Create loads on nodes using Tcl variables for the load components.
","Inputs

entity_type
The type of entity the load is applied to. Valid values are nodes, points, lines,
            elems, surfs, comps and sets.
mark_id
The ID of the mark containing the entities.
config
The config of the load to create:
1 - force 
2 - moment 
3 - constraint 
4 - pressure 
5 - temperature 
6 - nodal flux 
8 - velocity 
9 - acceleration


type
Solver-dependent type of the specified config.
comp[1-6]
The components of the load being applied. 
For constraints, all of the components are active unless they are set equal to
            -999999.0. All the other components of the constraints are active in the respective
            directions. 
For other configs, the active components are 1, 2, and 3, which
            represent the x, y, and z-direction, respectively.
x_loc, y_loc, z_loc
For loads on components or sets, this is the display location where the graphical
            image for the load is drawn. If these three values are 999999, or more than one entity
            is selected, the display location is automatically generated.
curve_id
The ID of the curve defining the magnitude of the load.
x_scale
A scale factor applied to the x-axis (or time-axis) of the curve.

","Example
To apply a temperature of 140.0 to all the nodes of a set, using the curve with ID 9 to
        vary this magnitude over time:
*createmark sets 1 ""temperaturenodes""
*loadcreateonentity_curve sets 1 5 1 140 0 0 0 0 0 0 0 0 0 9 1.0
","Errors
None.
"
1622,*loadcreatewithsystemonentity ,"Description
Creates a load (forces, temperature, moment, velocity, acceleration, or constraints) on
        nodes, fixed points (surface vertices or weld points), surface edges, and surfaces, defined
        in a local coordinate system.
","Inputs

geomtype
the type of entity that the load is applied to (e.g. SURFS)
markmask
the entity ID
config
the load configuration
type
Solver dependent types of the referenced load config. 
1 force 
2 moment 
3 constraint 
4 pressure 
5 temperature 
6 nodal flux 
8 velocity 
9 acceleration
 component[1-6]
components of the load being applied. 
When applying a force, the active components are 1, 2, and 3, which represent a force
            x, y, and z-axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z-axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            -999999.0.  All the other components of the constraints are active in the respective
            directions. 
For pressures, the active components are 1, 2, and 3, which represent the x, y, and
            z-axis, respectively.  To create a pressure that is normal to the element, set all
            components to zero.
system
the ID of the local system to use
transformflag
Indicates which system supplies component values. 
0 - if the component values are supplied in the global coordinate system. 
1 - if the component values are supplied in the local coordinate system

","Example
To apply a force of magnitude 10.0 along the x axis of system 4 to nodes 5 and 25:
*createmark(nodes,1) 12 13 14
*loadcreatewithsystemonentity(nodes,1,1,3,0.0,999999.0,0.0,-999999.0,0.0,   -999999.0, 4,0)
This command is applicable only to files created with HyperMesh
        6.0 and higher. For older HyperMesh files, use
          *loadcreate() instead.
","Errors
None.
"
1623,*loadcreatewithsystemonentitywithvars ,"Description
Create loads on nodes using Tcl variables for the load components, using a local
        system.
","Inputs

entity_type
The type of entity the load is applied to. Currently only nodes are supported.
mark_id
The ID of the mark containing the entities.
config
The config of the load to create: 
1 - force 
2 - moment 
3 - contraint 
5 - temperature 
6 - nodal flux 
8 - velocity 
9 - acceleration
type
Solver-dependent type of the specified config.
comp1_var - comp6_var
Tcl variables containing the components of the load for each node. Each variable is an
            array with its indices as node IDs and its value the component for that direction. If
            the variable or index does not exist, the component will be set to zero. These variables
            must be fully qualified when passed in (e.g. ::data::comp1).
system_id
The ID of a system that will transform the first three components before creating the
            load. An ID of zero indicates use of the global system.

","Example
To create a force on node 50 with a value of 100 in the x-direction and on node 51 with a
        value of 200 in the y-direction, relative to system 5:
set ::comp1(50) 100
set ::comp2(51) 200
*createmark nodes 1 50 51
*loadcreatewithsystemonentitywithvars nodes 1 1 1 ::comp1 ::comp2 ::comp3 ::comp4 ::comp5 ::comp6 5
","Errors
None.
"
1624,*loadsupdate ,"Description
Updates the magnitude, direction, and coordinate system of selected loads. 
","Inputs

markmask
ID of the mark containing the loads to update.
config
The configuration of the load: 
1 - Force 
2 - Moment 
3 - Constraints 
5 - Temperature 
6 - Flux 
8 - Velocity 
9 - Acceleration
type
The type assigned to the load (as defined on the Load Types panel).
updatevector
A variable that controls if the direction of the load should be updated.
component[1-6]
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z-axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z-axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            -999999.0. 
All of the other components of the constraints are active in the respective
            directions. For pressures, the active components are 1, 2, and 3, which represent the x,
            y, and z-axis, respectively. To create a pressure that is normal to the element, set all
            components to zero.
updatemag
An integer variable that controls if the magnitude is updated.
magnitude
The new value of magnitude of the load.
update_system
A variable that controls if the system is updated.
system_id
The ID of the local system.
transform_flag
A simple integer variable that controls if the load is created in the local system. 

","Example
To update a force of 10 N along the y axis to a force of 20 N along the y axis:
*createmark(loads,1) 4
*loadsupdate(1,1,1,0,0,1,0,0,0,0,1,20,0,0,1)

*loadsupdate() is the update command for all loads.
","Errors
None.
"
1625,*loadsupdatefixedvalue ,"Description
Updates the fixed constraint value on SPC and SPCD constraint loads forOptiStruct.
","Inputs

mark_id
The ID of the mark containing the SPC and SPCD constraints to update. Valid values are 1 and 2.
fixed_value
0 - Do not retain the deformed boundary resulting from a preceding nonlinear subcase 
1 - Retain the deformed boundary resulting from a preceding nonlinear subcase 

","Example
To update a fixed value for SPC load 4:
*createmark loads 1 4
*loadsupdatefixedvalue 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1626,*lockallentities,"Description
Lock all entities with the same entity type and ID pool across includes.
","
Inputs



entity_type

The type of entity to lock.

pool_id

The ID of the solver pool.

dataname

Must be set to id.

","Examples
Lock all elements with ID pool 2:
*lockallentities elems 2 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1627,*lockview,"Description
Saves the current view orientation and visible entities with the name ""Lock"".
","
Inputs

 None.
","Examples
To save the ""Lock"" view:*lockview
","Errors
 None.
"
1628,*makesecondarymodeleditable,"Description
Sets the editable state of secondary models.
","
Inputs



model_name

The name of the secondary model.

edit_state

0 - Not editable
1 - Editable

","Examples
To make the secondary model MyModel editable:
*makesecondarymodeleditable ""MyModel"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1629,*manualsplit_applypatterns,"Description
Splits shell elements with specific patterns, and automatically splits attached 1Ds.


Pattern Name
Pattern ID
Image




Quad0000
10



Quad0000
85



Quad0000
86



Quad0000
89



Quad1000
17



Quad1000
59



Quad1000
87



Quad1010
15



Quad1100
13



Quad1110
66



Quad1111
19



Quad2000
72



Quad2020
77



Quad2200
73



Quad2220
79



Quad2222
78



QuadN000
101



QuadN0N0
103



QuadNN00
102



QuadNNN0
104



QuadNNNN
105



Tria000
68



Tria000
88



Tria100
32



Tria110
33



Tria111
80



Tria111
81



Tria200
82



Tria220
83



Tria222
84



TriaN00
106



TriaNN0
107



TriaNNN
108





","
Inputs


edge_split_count
The number of split points on element edges. Valid values are >= 0.
This is valid only for tria patterns 106, 107, and 108, and quad patterns 101, 102,
            103, 104, and 105.
triplets
Uniquely determines a split pattern to be applied on a given element.  This is a space
            separated and quoted list of triplets, with each triplet consisting of 3 colon separated
            values Ai:Bi:Ci.  These values are:
Ai - The element ID
Bi - The split pattern ID. Valid tria patterns are 32, 33, 68, 80, 81, 82, 83, 84, 88,
            106, 107, 108. Valid quad patterns are 10, 13, 15, 17, 19, 59, 66, 72, 73, 77, 78,79,
            85, 86, 87, 89, 101, 102, 103, 104, 105.
Ci - The shell element side ID.  Valid values are [0, n] where n = element edge/sides
            count.

","Examples
To split element 100 with 4 edge splits, using pattern 106 and side
        2:*manualsplit_applypatterns 4 ""100:106:2""
To split multiple elements with 1 edge split, using different patterns and
        sides:*manualsplit_applypatterns 1 ""4:17:1 14:89:0 47:86:0 61:17:3""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1630,*mapgroupelementsfromshellstosolids,"Description
Maps base elements of group master/slave elements from shells to associated solids. 
","Inputs

mark_id
The ID of the mark of groups to map. Valid values are 1 and 2.

","Example
Shell elements 1-4 completely overlap with a face of solid elements 5-8, each sharing 4
        common nodes. The group ""test"" has master elements created on shell elements 1 2 3 4.
To map master elements in group ""test"" from shell elements to associated solid
        elements:
*createmark groups 1 ""by name"" test
*mapgroupelementsfromshellstosolids 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1631,*mark_preserved_edges,"Description
Use this command to highlight edge lines that have been flagged for preservation by means
        of *set_preserved_edges() . 
","Inputs

hmlinesmark
Lines with the ""preserved"" flag are placed into this mark. Three hmlinesmark marks are
            possible: 
1 - hmlinesmark #1 
2 - hmlinesmark #2 
0 - lines are marked by the USERSAVE mark, and can be retrieved normally. 
highlight
1 - Highlight the lines 
0 - do not highlight the lines

","Example
To place ""preserved"" lines into hmlinesmark 2 and highlight them:
*mark_preserved_edges(2,1)

","Errors
None.
"
1632,*markdifference ,"Description
This command determines the difference between the entity IDs that exist on
          mark_idA on those on mark_idB. The results are then
        placed on mark_idA.
Both entity_typeA and entity_typeB must be the
        same.
","Example
To delete the difference between the elements on marks 1 and 2:
*createmark elems 1 1 2 3 4
*createmark elems 2 4 5 6 7
*markdifference elems 1 elems 2
*deletemark elems 1
This will delete elements 1, 2, and 3. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1633,*markersupdate,"Description
This command updates MBD analysis markers.
","Inputs

mark_id
The ID of the mark containing the markers to be updated. Valid values are 1 and 2.
node_id
The ID of the node that defines the location of the markers.
syst_id
The ID of the orientation coordinate system.
syst_flag
A flag for the coordinate system. A value of 0 indicates that the coordinate system
            will be blank.
color
The color of the markers.
update_node
A flag indicating if the node will be updated. 
0 - do not update the node 
1 - update the node
update_syst
A flag indicating if the system will be updated. 
0 - do not update the system 
1 - update the system
update_color
A flag indicating if the color will be updated. 
0 - do not update the color 
1 - update the color

","Example
To update markers m1 and m2 to both use orientation system ID 25:
*createmark sensors 1 ""m1"" ""m2""
*markersupdate 1 0 25 1 0 0 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1634,*markintersectplane ,"Description
Selects a chain of elements and nodes cut by a given section plane.
","Inputs

EntityMark
The mark containing the elements or components to be intersected.
Plane
The ID of the plane to use for intersection calculations.
ElemOutMark
The mark to contain the intersected elements
NodeOutMark
The mark to contain one row of nodes along the intersected elements.

","Example
To find the nodes and elements inside of the components mark cut by a user-defined plane,
        and place these nodes/elems into mark 2:
*createmark elements 1 displayed
*createplane 1 0.0002 -0.3832 0.0004 850.3620 237.5095 349.0000
*markintersectplane components 1 1 2 2

","Errors
None.
"
1635,*markmovetoincludewithcontents ,"Description
This command organizes entities into an include file.
","Inputs

entity_type
The type of entity to organize. Valid values are comps, groups, loadcols, vectorcols,
            systcols, beamsectcols and multibodies.
mark_id
The ID of the mark containing the entities to organize. Valid values are 1 and 2.
include_id
The ID of the include file to organize the entities into.
child_entity_types
The type/types of the child entities to organize. Multiple types can be specified at a
            time. 

","Example
To move system collector systcol1 along with all of its systems into include file number 2: 
*createmark systcols 1 systcol1
*markmovetoincludewithcontents systcols 1 2 ""systems""
To move component comp1 along with all of its nodes and elements into include file number
        2: 
*createmark comps 1 comp2
*markmovetoincludewithcontents comps 1 2 ""nodes elements""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1636,*markmovetosubmodel,"Description
Organizes entities into a solver submodel.
","
Inputs



submodel_type

Use solversubmodel to organize into a solver submodel or includefile to organize into
            an include file.

entity_type

The type of entity to organize.

mark_id

The ID of the mark containing the entities to organize.  Valid values are 1 and
            2.

parent_id

The ID of the solver submodel or include file to organize into.

","Examples
To move systems 4, 8, and 12 into solver submodel 10:
*createmark systems 1 4 8 12
*markmovetosubmodel ""solversubmodels"" systems 1 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1637,*marknotintersection,"Description
This command determines the intersection between the entity IDs that exist on
          mark_idA on those on mark_idB. It then places all
        entity IDs except those that are part of the intersection on
        mark_idA.
Both entity_typeA and entity_typeB must be the
        same.
","Example
To delete the elements not shared by marks 1 and 2:
*createmark elems 1 1 2 3 4
*createmark elems 2 4 5 6 7
*marknotintersection elems 1 elems 2
*deletemark elems 1
This will delete elements 1, 2, 3, 5, 6, and 7. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1638,*markprojectnormallytosurface,"Description
Project nodes, elems, points, or lines onto the surface along the surface normal.
","Inputs

entities
The type of entity being projected.
markmask
The mark which contains the entities to project.
surfptr
The ID of the surface to which the entities will be projected

","Example
To project nodes 22, 23, 24, and 25 to the surface along the normal to the surface 14:
*createmark(nodes,1) 22 23 24 25
*markprojectnormallytosurface(nodes,1,14)
","Errors
None.
"
1639,*markprojecttomanysurfaces,"Description
Projects entities to multiple surfaces.  The entities are projected to the surface closest
        to it along a given vector, or normal to the surface.
All options may be specified in any order.
","
Inputs



ProjectionType=<value>

1 - Project by vector
To project along a vector given its 3 components along x, y and z directions,
              VectorXComp, VectorYComp, and
              VectorZComp are used.
To project along a vector defined by 2 nodes VectorNode1Id and
              VectorNode2Id are used.
To project along a vector normal to the plane defined by 3 nodes
              VectorNode1Id, VectorNode2Id and
              VectorNode3Id are used.
2 - Project normal to surfaces

SourceEntityType=<value>

The entity type to project.  Valid values are elements, nodes and points.  This is a
            mandatory option.

SourceEntityTypeMarkId=<value>

The ID of the mark of entities to project.  Must be set to 1.  This is a mandatory
            option.

TargetEntityType=<value>

The entity type to project onto.  Valid values are surfaces.  This is a mandatory
            option.

TargetEntityTypeMarkId=<value>

The ID of the mark of entities to project onto.  Must be set to 2.  This is a
            mandatory option.

VectorNode1Id=<value>

The ID of the first vector node.  Valid only when
            ProjectionType=1.

VectorNode2Id=<value>

The ID of the second vector node.  Valid only when
            ProjectionType=1.

VectorNode3Id=<value>

The ID of the third vector node.  Valid only when
            ProjectionType=1.

VectorXComp=<value>

The x component of the vector.  Valid only when
            ProjectionType=1.

VectorYComp=<value>

The y component of the vector.  Valid only when
            ProjectionType=1.

VectorZComp=<value>

The z component of the vector.  Valid only when
            ProjectionType=1.

","Examples
Project nodes 1575-1674 to surfaces 17-19 along the vector (5.7, 0, 9.5):
*createmark nodes 1 1575-1674
*createmark surfaces 2 17-19
*markprojecttomanysurfaces SourceEntityType=nodes SourceEntityTypeMarkId=1 TargetEntityType=surfs TargetEntityTypeMarkId=2 ProjectionType=1 VectorXComp=5.7 VectorYComp=0 VectorZComp=9.5
Project elements 123-168 to surfaces 7-10 along the vector given by nodes 1798 and
        1820:
*createmark elements 1 123-168
*createmark surfaces 2 7-10
*markprojecttomanysurfaces SourceEntityType=elems SourceEntityTypeMarkId=1 TargetEntityType=surfs TargetEntityTypeMarkId=2 ProjectionType=1 VectorNode1Id=1798 VectorNode2Id=1820
Project points 136-140 to surfaces 15 and 16 normal to the plane given by nodes 1200, 1208
        and 1210:
*createmark points 1 136-140
*createmark surfaces 2 15 16
*markprojecttomanysurfaces SourceEntityType=points SourceEntityTypeMarkId=1 TargetEntityType=surfs TargetEntityTypeMarkId=2 ProjectionType=1 VectorNode1Id=1200 VectorNode2Id=1208 VectorNode3Id=1210
Project nodes 136-140 normally to surfaces 15 and 16:
*createmark nodes 1 136-140
*createmark surfaces 2 15 16
*markprojecttomanysurfaces SourceEntityType=points SourceEntityTypeMarkId=1 TargetEntityType=surfs TargetEntityTypeMarkId=2 ProjectionType=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1640,*marksmoothelements,"Description
Applies a smoothing algorithm to a mark of elements for a given number of iterations.
        Optionally, one or more nodes may be specified as being anchored in place and not movable. 
","Inputs

tosmoothmark
The mark of elements to be smoothed. Need not be a contiguous block. 
toanchormark
The mark of nodes on those elements that are not adjustable. 
smoothmethod
The smoothing method to use. 
1 - autodecide 
2 - size corrected 
3 - shape corrected 
4 - angle corrected
iterations
The number of times to apply the smoothing operator. 

","Example
To smooth elements 100 through 110 twelve times with no nodes fixed: 
*createmark(elements,1)100 101 102 103 104 105 106 107 108
   109 110
*createmark(nodes,2)
*marksmoothelements(1,2,1,12)
Both of the *createmark() directives are required for this command. 
","Errors
None.
"
1641,*marktousermark,"Description
This command stores the IDs of entity_type that exist on
          mark_id on the user mark. Valid mark_ids are 1 and
        2. Only one user mark exists for each entity_type. 
The user mark is accessed either through the command hm_getusermark or
        through panel input collectors, *createmark and
          *appendmark via the ""retrieve"" option.
","Example
To save the user mark of properties 1, 3 and 5:
*createmark props 1 ""by id only"" 1 3 5
*marktousermark props 1
To create a mark of elements 1-3, save it to the element user mark and retrieve it
        later:
hm_createmark elems 1 1 2 3
*marktousermark elems
*clearmark elems 1
…
*createmark elems 1 ""retrieve""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
1642,*maskall2,"Description
Masks all supported entities. This includes: 
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors


","Example
To mask all supported entities:
*maskall2
","Errors
None.
",
1643,*maskentitymark,"Description
This command masks the entities of entity_type that are on
          mark_id. Valid mark_ids are 1 and 2. Only entities
        in displayed collectors may be masked.
To mask connectors and the realized FE, a flag of 1 must be passed. To
        mask only connectors (excluding realized FE) and all other entity types, a
          flag of zero must be passed.
Currently supported entity_types for this command are:
connectors 
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
ellipsoids 
mbjoints 
mbplanes 
equations 
loads 
systems 
vectors 
tags 
handles 
domains 
symmetries 
morphconstraints 
comps (connectors, points, lines, surfaces, solids, elements) 
groups (master/slave elements) 
loadcols (equations, loads) 
multibodies (ellipsoids, mbjoints, mbplanes) 
systcols (systems) 
vectorcols (vectors)
","Example
To mask all of the displayed connectors and the realized FE:
*createmark connectors 1 displayed
*maskentitymark connectors 1 1
To mask all elements in components but not elements in groups:
*createmark comps 1 all
*createmark elems 1 ""by comps on mark"" 1
*maskentitymark elems 1 0
To mask all entities in all components:
*createmark comps 1 all
*maskentitymark comps 1 0

","Errors
This command does not return any errors that can be handled.
",
1644,*masknotshown2,"Description
Masks all supported entities not in the current view window. Only entities in displayed
        collectors are affected. This includes:
points
lines
surfaces
solids
elements (both in components and groups)
connectors
ellipsoids
mbjoints
mbplanes
loads
equations
systems
vectors


","Example
 To mask all supported entities in the displayed collectors that are not in the current
        view window:
*masknotshown2
","Errors
None.
",
1645,*maskreverseall ,"Description
Reverses the masking state of supported entities. For collected entities, only entities in
        displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
To reverse the masking of all supported entities in the displayed collectors:
*maskreverseall
","Errors
None.
",
1646,*masselement,"Description
Creates a mass element. 
","Inputs

mark
The mark ID which contains nodes which should have mass elements created on them. 
mass
The mass of the mass elements. 
property name
The name of the property to which the elements should point. 
system id
The ID of the system in which the mass elements are built. 

","Errors
None.
",
1647,*mbjointcreate,"Description
 Creates a new mbjoint entity.
","Inputs

name
The name of the mbjoint collector.
joint_color
The color of the created joint.
type
Not used.
parent_body
The parent multibody collector.
child_body
The child multibody collector.
parent_system
The parent coordinate system.
child_system
The child coordinate system.
organize_system_toggle
1 - place parent and child coordinate system in new system collectors at time of
            mbjoint creation 
0 - do not place parent and child coordinate system in new system collectors at time
            of mbjoint creation
parent_joint_system_color
The color of the created system collector for the parent coordinate system when
              organize_system_toggle is set. 
child_joint_system_color
The color of the created system collector for the child coordinate system when
              organize_system_toggle is set. 

","Errors
None.
",
1648,*mbplanecreatewithcoords,"Description
Creates a new mbplane entity.
","Inputs

name
The name of the mbplane.
color
The color value of the mbplane.
type
The MADYMO type definition to be used later.
origin
ID of an array containing the coordinates of the the mbplane’s origin node.
origin_size
Size of the origin node array.
xaxis
ID of an array containing the mbplane’s x-axis node.
xaxis_size
Size of the xaxis node array.
yaxis
ID of an array containing the mbplane’s y-axis node.
yaxis_size
Size of the yaxis node array.
multibodyid
The ID of the multibody to which the mbplane is attached.

","Example
To create an MB plane with the name ""kneebolsterplane"":
*createdoublearray(3) 7 0 20
*createdoublearray(3) 0 0 20
*createdoublearray(3) 0 20 0
*mbplanecreatewithcoords(""kneebolsterplane"",29,0,1,3,1,3,1,3,1)
","Errors
None.
"
1649,*ME_ModuleExport ,"Description
Exports the contents of a module to an ASCII export file
        based on an output template.
","Inputs

id
The ID of the part or part assembly to export.
recursive
Specifies option for whether the module hierarchy should be traversed recursively to
            identify all of the entities to be exported. 
If set to 0, only the entities from the specified module will be exported. 
If 1 (or any non-zero), the entities from the specified module and all of its child
            modules will be exported.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes.
string_array
The ID of the string array that contains the additional output parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented as subtopics
            to *feoutputwithdata. Not all templates support all strings.

","Example
To output using the OptiStruct template, to a file named
          C:/model.fem for all entities in part with ID 10:
*ME_ModuleExport 10 0 ""C:/model.fem"" [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/optistruct/optistruct"" 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1650,*ME_ModuleOccurrenceClone,"Description
Create a module as a copy of another. Module contents are copied unless specified
        otherwise.
","
Inputs



me_id

The ID of the part or part assembly to clone.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
copy_contents=<value>
0 - Do not copy contents. 
1 - Default. Copy contents. 
matrix=<values>
A list of 16 doubles that describe the 4x4 relative transformation matrix.
name=<value>
The name of the new module. If not specified, the new module will get a default
                  name <orignal name>.i.<number of instances of the same prototype>.



","Examples
Create a copy of module 3 with a default name and without copying the contents:
*ME_ModuleOccurrenceClone 3 ""copy_contents=0""
Create a copy of module 3 named ""MyClone"" copying all contents, and specifiying a unit
        transformation matrix:
*ME_ModuleOccurrenceClone 3 ""name=MyClone, copy_contents=1, matrix=1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1651,*ME_ModuleOccurrenceCreate ,"Description
 Creates a module part or part assembly.
","Inputs

name
The name of the module to create.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
parent_id=<id>
The ID of the module part or part assembly you wish to make this module a child
                  of. If not specified, the new module is placed underneath the root model
                  module.
structural_type=<type>
part or assembly. A part is the default if not specified, and can coverts to a
                  part assembly. A part assembly cannot be converted to a part.
udm_id=<string>
The string ID from a UDM XML file for this part, if necessary.



","Example
Create a new Part module named ""mypartname"" as a child of the module with ID 2:
*ME_ModuleOccurrenceCreate mypartname ""parent_id=2, structural_type=part""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1652,*ME_ModuleOccurrenceInstancesDetach,"Description
Breaks a list of module occurrences from their current prototype and re-assigns them to new
        prototypes.
Every module occurrence in a model has an associated module prototype that it came from. A
        single module prototype may provide the base for multiple module occurrences, i.e. a
        prototype of a wheel, might have four occurrences in a vehicle.
This command is applied to a list of occurrences that are a subset of all the instances of
        a common, original prototype, i.e. the 2 right side wheels of the vehicle. It will break the
        existing links with the original prototype for the specified occurrences so they can have
        their own, unique definition. A new, cloned version of the original prototype will be
        created, and the specified occurrences will be re-linked to the new prototype, which
        provides the basis of this new definition.
In the case of a multi-level instanced assembly, the command will also appropriately handle
        the assembly instances to create and re-link additional prototype clones of assemblies as
        required. Finally, based on the options provided, the command will perform additional
        operations (i.e. copying attributes) between the original structure and the new cloned
        entities.
","Inputs

me_ids
The IDs of the modules to detach, within quotes if more than one.
options
The list of input options, passed as a comma separated string enclosed in quotes.
            Valid options are:


copyprotoattribs=<value>
NONE - Do not copy any attributes from original prototypes to newly created
                  cloned prototypes
HW_PDM - Copy the PDM attributes from original prototypes to newly created
                  cloned prototypes



","Example
Break the module occurrences with IDs 22 and 24 from their current prototype and re-assigns
        them to newly created prototypes which are assigned the PDM attributes from the original
        prototypes:
* ME_ModuleOccurrenceInstancesDetach ""22 24"" ""copyprotoattribs=HW_PDM""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1653,*ME_ModuleOccurrencePurge ,"Description
Empty the contents of a module part or part assembly.
","Inputs

id
The ID of the module to purge. The module must be an occurrence.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
excluded_entity_types=type1 type2 … typeN
A space separated list of module entity types to not remove.
reset_representation=<flag>
0 - Keep representation reference information.
1 - Remove representation reference information.
resursive=<flag>
0 - Purge only the local module’s contents. Do not touch the child module’s
                  contents (in the case of a part assembly). 
1 - Recursively purge the module, as well as any child modules.
udm_id=<string>
The string ID from a UDM XML file for this part, if necessary.



","Example
Purge part assembly 168 and any of its children recursively:
*ME_ModuleOccurrencePurge 168 ""recursive=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1654,*ME_ModuleOccurrenceRepresentationLoad,"Description
Loads a representation of a part or part assembly using options. The definition will
        typically result in the use of HyperMesh readers to import
        either CAD, solver or HM files.
","Inputs

id
The ID of the module to load.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
usecase=<label>
The label of the use case to load, with default being a
                  typical value.



","Example
To load the representation for part with ID 10 for its default use case:
*ME_ModuleOccurrenceRepresenationLoad 10 ""usecase=default""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1655,*ME_ModuleOccurrencesLink,"Description
Links a set of specified module occurrences to a master module occurrence to allow all of
        them to share the master occurrence’s underlying definition (including its prototype).
Every module occurrence in a model has an associated module prototype. A single module
        prototype may provide the base definition for multiple module occurrences, i.e. a prototype
        of a wheel might have four occurrences in a vehicle. In some models, the original model
        definition does not have this modelling structure and each module occurrence has its own
        prototype when they could share a common prototype definition. This command provides a
        method to link these similar module occurrences to obtain the desired instanced model
        structure.
When this command is applied to a list of occurrences, it will update the model structure,
        handle the cleanup of the discarded prototype definitions, and handle any matrix updates
        required by the specified options.
","
Inputs


master_id

The ID of the source module occurrence which provides the underlying definitions
            (i.e. the prototype) to be shared.
ids
The IDs of the module occurrences to be linked to the master module occurrence, within
            quotes if more than 1.
?options?
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
updatematrices=<value>
none - Do not update the structural matrices of the linked module occurrences
                  (default)
calcoffset - Update the structural matrices for each linked module occurrences
                  by calculating the offset in positions of the current contents of each linked
                  module occurrence relative to the master module occurrence



","Examples
To link the modules 24, 26 and 28 to share the definition of master module 22. As a result
        of the command, all of these modules will now share the same prototype and representations.
        In this operation, the matrices for the linked modules will be updated with any required
        offsets between each module and the master module:
*ME_ModuleOccurrencesLink 22 ""24 26 28"" ""updatematrices=calcoffset""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1656,*ME_ModuleOccurrencesReparent,"Description
Move a list of module parts or part assemblies underneath another part assembly in the
        model hierarchy.
This is only allowed in cases where it does not break sub-assembly instancing.
","Inputs

child_ids
The IDs of the modules to move, space separated in quotes.
parent_id
The ID of the module part (if empty and convertible to a part assembly) or module part
            assembly to become the parent.
?options?
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
matrix_mode=<mode>
0 - Retain the relative position of the child module (default). This may cause
                  the part to translate if there are matrices stored at different levels in the
                  hierarchy. 
1 - Retain the absolute position of the child module.



","Example
Place the module part assemblies 100, 101 and 102 under part assembly 8 in the hierarchy.
        No translation should take place since the parts positions are not changing relative to
        their parents.
*ME_ModuleOccurrencesReparent ""100 101 102"" 8 ""matrix_mode=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1657,*ME_ModulePopulate,"Description
Moves entities from one module to another.
","Inputs

id
The ID of the module part to move the entities to.
reserved
Reserved for future use. Must be set as """".
entity_type
The type of entity to move.
mark_id
The ID of the mark containing the entities to move. Valid values are 1 and 2.

","Example
Move comps 22-24 to module part 168:
*createmark comps 1 22-24
*ME_ModulePopulate 168 """" comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1658,*ME_ModulesHierarchyLibrarySync,"Description
Finds library related information for a part from a connected part library.  Library
        related information such as Major Revision, Study Revision and Library Revision are then
        updated in Part Browser and Property Area.
","Inputs

id
The ID of the module/part for which information is needed.
options
The list of input options, passed as a comma separated string enclosed in quotes.
            Valid options are:


libraryname=<value>
The name of the currently connected part library.
updatesignal=<value>
0 - Part Browser and Property Area refresh is not done
1 - Part Browser and Property Area refresh is done



","Example
Update library related information for part 100 using library MyLibrary and updated Part
        Browser and Property Area:
*ME_ModulesHierarchyLibrarySync 100 ""updatesignal=1, libraryname=MyLibrary"";
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1659,*mechadjustballjoint,"Description
Actuates a ball joint to reach a new value. The mechanism must have the enabled flag set to
        true for this to be possible.
","Inputs

name
The name of the joint to adjust.
x
The desired x Euler angle value of the joint (double).
y
The desired y Euler angle value of the joint (double).
z
The desired z Euler angle value of the joint (double).
tolerance
The tolerance allowed when adjusting (double).
lock
1 - All joints in the mechanism which are not part of the cycle of the given joint are
            locked.
angle_step
The size of the iterative steps used to solve for the new value of the joint. Only
            used for rotation.

","Example
To move a joint named TORSO_to_RIGHT_UPPER_LEG to x=20, y=0, z=0 with a tolerance of 0.001,
        locking other joints and angle step =
        0:*mechadjustballjoint ""TORSO_to_RIGHT_UPPER_LEG"" 20.0 0.0 0.0 0.001 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1660,*mechapplybodymovements ,"Description
Moves the bodies of a mechanism to the specified matrix orientation. 
The mechanism must have the enabled flag set to true for this to be possible. 
This is used internally for solver operations and is not recommended for end-users.
","Inputs

bodies_array
The ID of the string array that contains the names of the bodies to update. The array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_bodies
Integer indicating the size (number of bodies) in the array created using
              *createstringarray. This must be the same as
              number_of_matrices.
matrices_array
The ID of the double 2D array that contains the 4x3 matrices. The array is created
            using the *createdoublearray2d command. This should always be set to
            1. 
The matrix elements are given in the following order:
xaxis1 xaxis2 xaxis3 yaxis1 yaxis2 yaxis3 zaxis1 zaxis2 zaxis3 position1 position2
            position3
number_of_matrices
Integer indicating the rows (number of matrices) in the array created using
              *createdoublearray2d. This must be the same as
              number_of_bodies.
number_of_matrix_elements
Integer indicating the columns (number of elements per matrix) in the array created
              using *createdoublearray2d. This must be set to 12.

","Examples
To apply position with ID 3 on mechanism with ID 1:
*mechconstructfromedi 2 3
*mechapplybodymovements 1 0
To move 7 bodies with a matrix orientation:
*createstringarray 7 ""Fix_Rail"" ""Move_Rail"" ""Roller"" ""Front_Lever"" ""Rear_Lever""   ""Seat_Cushion"" ""Back_Seat""
*createdoublearray2d 7 12 \
1 0 0 0 1 0 0 0 1 -1905.69155 354.020211 364.071702 \
0.999999114 -0.000727765047 -0.00111450131 0.000727161917 0.999999589 -0.000541475532 0.00111489492 0.000540664629 0.999999232 -1831.77992 339.826305 396.010172 \
0.999999996 -8.52472731e-005 6.68843529e-006 8.52472333e-005 0.999999996 5.95670407e-006 -6.68894306e-006 -5.95613387e-006 1 -1906.86575 353.204386 367.817282 \
0.78961924 -0.00116572455 -0.613596038 0.00088450914 0.999999319 -0.000761573242 0.613596507 5.86215809e-005 0.789619733 -1678.57592 327.008703 476.854454 \
0.581245504 -0.00107812242 -0.813727535 0.000811882833 0.999999393 -0.000744989557 0.813727844 -0.000227629586 0.581246027 -2000.582 334.362031 476.908588 \
0.994393674 -0.0008628871 -0.105737772 0.000748529572 0.999999091 -0.00112120052 0.105738643 0.00103576685 0.994393416 -1782.50488 333.097311 547.540308 \
0.994393672 -0.000863464035 -0.105737788 0.000749102696 0.999999091 -0.00112126678 0.10573866 0.00103577213 0.994393415 -2112.46025 320.887101 909.524211
*mechapplybodymovements 1 7 1 7 12
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1661,*mechapplyediposition ,"Description
Applies a position to a mechanism. This will be always used in conjunction with
          *mechcontructfromedi. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

mode
The mode for the position: 
0 - Initial position 
1 - Active position
run_solver
0 - Directly apply the position to bodies without considering constraints and joints. 
1 - Run the solver to apply the position along with constraints and joints.

","Examples
To apply position with ID 3 on mechanism with ID 1:
*mechconstructfromedi 2 3
*mechapplyediposition 1 0
To apply the initial position on a mechanism:
To apply the initial position on a mechanism:
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1662,*mechexportdaf,"Description
Exports the dummy angle file for the current dummy. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

filename
The full name and path of the file to export.

","Example
To export the current dummy DAF file as C:/temp/dummy.daf:
*mechexportdaf ""C:/temp/dummy.daf""

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1663,*mechjointlimits ,"Description
Sets the type of limits to use on joints for the current dummy. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

limits
0 - Hard limits (default) 
1 - Soft limits

","Example
To activate soft limits on the current dummy:
*mechjointlimits 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1664,*mechplanetranslatebody ,"Description
Moves a body such that the source point on the body reaches the target point, while
        satisfying joints and constraints defined in the mechanism. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the body of the mechanism.
sx
The x-coordinate of the source point on the body.
sy
The y-coordinate of the source point on the body.
sz
The z-coordinate of the source point on the body.
tx
The x-coordinate of the target point.
ty
The y-coordinate of the target point.
tz
The z-coordinate of the target point.
rx
The x-direction rotation angle.
ry
The y-direction rotation angle.
rz
The z-direction rotation angle.
tolerance
The tolerance allowed during the placement.

","Example
To move body Seat_Cushion from (-1447.3297618988, 263.83727318711, 562.87391867592) to
        (-1400.3297618988, 263.83727318711, 562.87391867592) with tolerance 0.001, with no rotation
        angles:
*mechplanetranslatebody ""Seat_Cushion"" -1447.3297618988 263.83727318711 562.87391867592 -1400.3297618988 263.83727318711 562.87391867592 0 0 0 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1665,*menufilterdisable,"Description
Disables filtering. 
","Errors
None.
",,
1666,*menufilterset,"Description
Sets the filter to the filter string.
","Inputs

string
The string to which the filter is set. 

","Example
*menufilterset ""beams*""
","Errors
None.
"
1667,*mergefile,"Description
Merges a HyperMesh binary file into the current model. Any
        entity names or IDs in the incoming file are renamed/renumbered with the least disruption
        possible.
","Inputs

filename
The full path and filename of the database file.
geom_merge
A flag indicating whether to import and merge geometry from the incoming model. If
              both geom_merge and fe_merge are 0, this behaves
            like *readfile. 
0 - Do not merge geometry 
1 - Merge geometry
fe_merge
A flag indicating whether to import and merge FE from the incoming model. If both
              geom_merge and fe_merge are 0, this behaves like
              *readfile. 
0 - Do not merge FE 
1 - Merge FE

","Example
To merge the file named C:/mymodel.hm into the current session:
*mergefile C:/mymodel.hm 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1668,*meshdragelements2 ,"Description
Creates solid elements by dragging 2D elements along a vector.
","Inputs

mark_id
The ID of the mark containing the elements to be dragged. 
vector_id
The ID of the vector along which the elements should be dragged, created
              using *createvector.
distance
The distance which the elements should be dragged. 
on_drag
The number of elements to create along the drag. 
bias_style
0 - Linear
1 - Exponential
2 - Bell curve
biasing
The biasing intensity value.
organize
0 - Elements to current component 
1 - Elements to original component

","Example
To create 5 elements by dragging elements 10 and 11 along a vector defined by (1.0, 0.0,
        0.0) a length of 50 units, and have the resulting elems in the original comp: 
*createvector 1 1.0 0.0 0.0
*createmark elements 1 10 11
*meshdragelements2 1 1 50.0 5 1 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1669,*meshline_create_from_plot_elements,"Description
This command creates meshlines from selected plot elements.
","Inputs

mark_id
The ID of the mark containing the plot elements. Valid values are 1 and 2.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.
reserved3
 Reserved for future use. Must be set to 0.
reserved4
Reserved for future use. Must be set to 0.
reserved5
Reserved for future use. Must be set to 0.
reserved6
Reserved for future use. Must be set to 0.

","Example
To create meshlines from all displayed plot elements:
*createmark elems 1 displayed
*meshline_create_from_plot_elements 1 0 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1670,*meshline_delete ,"Description
This command deletes meshlines.
","Inputs

mark_id
The ID of the mark containing the meshlines. Valid values are 1 and 2.

","Example
To delete meshlines 100-200:
*createmark lines 1 100-200
*meshline_delete 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1671,*meshline_end,"Description
This command cleans up meshline internal structures and memory.
","Inputs

reserved
Reserved for future use. Must be set to 0.

","Example
 To clean up meshline structures and memory:
*meshline_end 0
","Errors
None.
"
1672,*meshline_mark_entity_inside_class ,"Description
This command marks entities as being inside a meshline class.
","Inputs

entity_type
The type of entity to mark. Valid values are nodes and elements.
mark_id1
The ID of the mark containing the new entities to add. Valid values are 1 and 2.
mark_id2
The ID of the mark containing the previous entities. Valid values are 1 and 2.

","Example
To add element 500 inside a meshline class:
*createmark elems 1 500
*meshline_mark_entity_inside_class elems 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1673,*meshline_reject ,"Description
This command synchronizes meshline internal structures.
","Inputs

reserved
Reserved for future use. Must be set to 0.

","Example
To synchronize the meshline structures:
*meshline_reject 0
","Errors
None.
"
1674,*meshline_update_surface,"Description
This command creates surfaces on closed meshline loops.
","Inputs

flag
0 - Disable creating surfaces on closed meshline loops. 
1 - Enable creating surfaces on closed meshline loops.
reserved
Reserved for future use. Must be set to 0.

","Example
To turn on creating surfaces for closed meshline loops:
*meshline_update_surface 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1675,*meshspinelements2,"Description
Creates solid elements by spinning 2D elements around a plane normal.
","Inputs

mark_id
The ID of the mark containing the elements to be dragged. 
plane_id
The ID of the plane normal about which the elements should be spun, created
              using *createplane.
angle
The angle which the elements should be spun. 
on_spin
The number of elements to create along the spin. 
bias_style
The style of biasing to use.
biasing
The biasing intensity value.
organize
0 - Elements to original component 
1 - Elements to current component

","Example
To create 5 elements by spinning elements 10 and 11 about the plane normal defined by (0.0,
        0.0, 1.0) and based at (20.0, 20.0, 0.0) by an angle of 90.0, and have the resulting elems
        in the original comp: 
*createplane 0.0 0.0 1.0 20.0 20.0 0.0
*createmark elements 1 10 11
*meshspinelements2 1 1 90.0 5 1 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1676,*messagefilefilter,"Description
Sets a filter on the type of messages written when using the
          *messagefileset command.
","Inputs

type
The type of message to filter. This should match with the value set in
              *messagefileset. Valid values are: 
FEINPUT - any messages passed to 
HM by an FE-input processes. HM - all supported type values.
filter
A list consisting of the messages to filter to the file. Multiple values can be
            specified. The list should be enclosed in quotes. Valid values are: 
ERROR - error messages 
INFORMATION - information messages 
WARNING - warning messages

","Example
To save all FE-input error messages to a file named C:/test.dat:
*messagefileset ""feinput"" ""C:/test.dat""
*messagefilefilter ""feinput"" ""error""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1677,*metadatamarkdate ,"Description
Creates date metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model
            itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The date value assigned to the metadata. This is the number of seconds since the epoch
            (i.e., January 1st 00:00:00 1970).

","Example
To add metadata named Date with the current time in seconds since the epoch:
*createmark undef 1 
*metadatamarkdate undef 1 ""Date"" [clock seconds]
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1678,*metadatamarkdoublearray ,"Description
Creates double array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. The undef entity type is used to store
            metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
double_array
The ID of the double array that contains the values. The array is created using
              the *createdoublearray command. This should always be set to
            1.
number_of_doubles
Integer indicating the size (number of doubles) in the array created using
              *createdoublearray. 

","Example
To add metadata named Real_Vals with the values 17.54 and 31.88 to elements 1-100:
*createmark elems 1 1-100
*createdoublearray 2 17.54 31.88
*metadatamarkdoublearray elems 1 ""Real_Vals"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1679,*metadatamarkentityidtypearray ,"Description
Creates entity ID type array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
entity_type_2
The type of entity which the metadata references.
entity_id_array
The ID of the integer array that contains the entity IDs. The array is created using
              the *createarray command. This should always be set to 1.
number_of_entities
Integer indicating the size (number of entity IDs) in the array created using
              *createarray.

","Example
To add metadata named Surfaces with surface 100 and 110 to elements 1-100:
*createmark elems 1 1-100
*createarray 2 100 110
*metadatamarkentityidtypearray elems 1 ""Surface"" surfs 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1680,*metadatamarkintarray,"Description
Creates integer array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. The undef entity type is used to store
            metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
integer_array
The ID of the integer array that contains the values. The array is created using
              the *createarray command. This should always be set to 1.
number_of_integers
Integer indicating the size (number of integers) in the array created using
              *createarray.

","Example
To add metadata named Int_Vals with the values 5 and 7 to elements 1-100:
*createmark elems 1 1-100
*createarray 2 5 7
*metadatamarkintarray elems 1 ""Int_Vals"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1681,*metadatamarkstring,"Description
Creates string metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
value
The string value assigned to the metadata.

","Example
To add metadata named String_Val with the value ""Warped elements"" to elements 1-100:
*createmark elems 1 1-100
*metadatamarkstring elems 1 ""String_Val"" ""Warped elements""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1682,*midmesh_extract,"Description
longDescription
","
Inputs



entity_type

The type of input geometry.  Valid values are solids, surfs, comps and elems.

mark_id

The ID of the mark of input entities.  Valid values are 1 and 2.

string_array

The ID of the string array that contains the additional optional input parameters. The
            string array is created using the *createstringarray command. This should always be set
            to 1.
Note: All parameters are case insensitive, and order insensitive. All parameters are
            optional, if not supplied, the mentioned defaults will be used.
Valid parameters and their syntax are:



CombineNonManifoldEdgesDistance=<value>

If two non-manifold/sharp edges are in proximity with another edge within the
                  distance given for this argument, they will be merged together at the
                  mid-location.

CombineNonManifoldEdgesFactor=<value>

Triggers the same option as CombineNonManifoldEdgesDistance,
                  but the distance is expressed as a factor of MinimumSize.
A value of 1.0 means the CombineNonManifoldEdgesDistance is
                  same as MinimumSize. A value of 0.5 means the
                    CombineNonManifoldEdgesDistance is half of
                    MinimumSize.
Default 0.5, range [0.0, 1.0].

DefeatureOpeningsFactor=<value>

Triggers the same option as DefeatureOpeningsWidth, but the
                  distance is expressed as a factor of MinimumSize.
A value of 1.0 means DefeatureOpeningsWidth is same as
                    MinimumSize. A value of 0.5 means the
                    DefeatureOpeningsWidth is half of
                    MinimumSize.
Default 0.5, range [0.0, 1.0].

DefeatureOpeningsWidth=<value>

If a hole/opening is of lesser width than the given value, it will be
                  closed.

DefeatureRibsWidth=<value>

If a rib's width is lesser than the given value, it will be removed.

DefeatureRibsWidthFactor=<value>

Triggers the same option as DefeatureRibsWidth, but the
                  distance is expressed as a factor of MinimumSize.
A value of 1.0 means DefeatureRibsWidth is same as
                    MinimumSize. A value of 0.5 means the
                    DefeatureOpeningsWidth is half of
                    MinimumSize.
Default 0.5, range [0.0, 1.0].

DestinationComponent=<value>

Midmesh - All output mesh goes to Midmesh component or to the component whose
                  name is specified in the DestinationComponentName argument.
                  This is the default.
Midmesh.# - For each input geometry, the generated midmeshes are organized into
                  a new Midmesh.# component. # denotes a unique incremental number.
Original - For each input geometry, the generated midmesh is organized back into
                  the input components.
Original.# - For each input geometry, the generated midmeshes are organized into
                  new Orignal.# components.
Current - All generated midmeshes go to the current component.

DestinationComponentName=<name>

The prefix to be used for the new shell element components created for the
                  output mesh.  Default is Midmesh

ExtractionSize=<value>

The size at which the midmesh is extracted.  Default 2.0.

FlattenConnections=<value>

0 - The default Y shaped connections are retained (default)
1 - The output will be flattened at the connections. Y shaped connections are
                  flattened to T shape. Stepped geometry (One side continuous surface, and opposite
                  side steps) will be captured as continuous surface there by deviating from
                  middle.

IgnoreFlatEdges=<value>

 0 - No specific treatment done to remove flat bottom edges
1 - Flat bottom edges are not retained in the output

MinimumSize=<value>

The value used for defeaturing the topology based on the factors
                  SupressProximityEdgesFactor, CombineNonManifoldEdgesFactor and
                  DefeatureOpeningsFactor. It is recommended to set this value the same as the
                  minimum allowable element length for your final target mesh. Default is
                    ExtractionSize.

StepOffsetMode=<value>

This option allows finer control of how stepped geometry (one side continuous
                  surface, and opposite side steps) is captured. This option is valid only when
                    FlattenConnections=1.  This option also deprecates
                    FlattenConnections=2.  For the sake of backwards
                  compatibility, if FlattenConnections=2 is defined,
                    StepOffsetMode is ignored.  Valid values are:
Automatic - Steps of different thickness across a common base surface are
                  automatically offset to a uniform distance from the base surface
                    (default).MidEverywhere - Each step will be placed in the
                    middle.
MidThinnest - All steps that share a common base are moved to the
                    middle of the thinnest step.
MidThickest - All steps that share a common
                    base are moved to the middle of the thickest step.  This might place parts of
                    the midmesh outside the solid.


SuppressProximityEdgesDistance=<value>

If a manifold edge is in proximity with another edge within the distance given
                  for this argument, it will be suppressed. Sharp edges are not considered for this
                  operation.

SuppressProximityEdgesFactor=<value>

Triggers the same option as SuppressProximityEdgesDistance,
                  but the distance is expressed as a factor of MinimumSize.
A value of 1.0 means the SuppressProximityEdgesDistance is
                  same as MinimumSize. A value of 0.5 means the
                    SuppressProximityEdgesDistance is half of
                    MinimumSize.
Default 0.5, range [0.0, 1.0].

TargetElementSize=<value>

This value is used for fine tuning certain internal computations to go well with
                  the expectations according to the final target element size. It affects the
                  suppression of flat edges, and edges in proximity. Default is
                    ExtractionSize.



number_of_strings

Integer indicating the size (number of strings) in the string array created using
            *createstringarray.

","Examples
To extract the midmesh of all solids present in the model with element size as 2.0 with
        SuppressProximityEdgesFactor and CombineNonManifoldEdgesFactor as 0.5:
*createmark solids 1 all
*createstringarray 3 {ElementSize: 2.0} {SuppressProximityEdgesFactor: 0.5} {CombineNonManifoldEdgesFactor: 0.5}
*midmesh_extract solids 1 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1683,*midmesh_inspect_end,"Description
Clears memory and ends the midmesh inspection module.  This must be preceded by any calls
        to *midmesh_inspect_init and other *midmesh_inspect_*
        APIs. 
","
Inputs

None.
","Examples
To detect and correct nodes off mid, delete empty sets, and shut down the inspect
        module:*createmark components 1 ""shell""
*createmark components 2 ""MidmeshEdges"" ""Mid""
*midmesh_inspect_init SourceEntityType=components SourceMark=1 TargetEntityType=components TargetMark=2 MinNodeOffMidDeviation=0.2
*midmesh_inspect_fix_problems nodes 2 ProblemType=NodeOffMid SmoothClusters=1 SmoothMethod=Auto
*midmesh_inspect_delete_sets 2
*midmesh_inspect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1684,*midmesh_inspect_init,"Description
Initializes the midmesh inspection module. This must precede any calls to other
          *midmesh_inspect_* APIs, and must be followed by a call to
          *midmesh_inspect_end.
This tool detects problem clusters in midmeshes as follows:
Nodes off middle
Nodes off solid sides
Nodes out of solid
Element edges off of solid sides
Element centers off middle


","
Inputs


SourceEntityType=<value>
The source entity type, which must define the solid.  Valid values are components,
            elements, solids, and surfaces.  This is a mandatory option.
SourceMark=<value>
The ID of mark of source entities.  Valid values are 1 and 2.  This is a mandatory
            option.
TargetEntityType=<value>
The target entity type defining the midmesh.  Valid values are components and
            elements.  This is a mandatory option.
TargetMark=<value>
The ID of mark of target entities.  Valid values are 1 and 2.  This is a mandatory
            option.

At least one of the following options must also be provided.

CheckMinElemSize=<value>
Checks the minimum element size criteria while fixing the element center off mid and
            edge off solid edge problems.  Valid values are 1 and 2.
MinEdgeOffEdgeDeviation=<value>
Detects element edges off solid sides with its value as minimum deviation.  Valid
            values are > 0.0.
MinElemCenterDeviation=<value>
Detects element centers off middle with its value as minimum deviation.  Valid values
            are > 0.0.
MinNodeOffMidDeviation=<value>
Detects nodes off middle with its value as minimum deviation.  Valid values are >
            0.0.
MinNodeOffSolidEdgeDeviation=<value>
Detects nodes off solid sides with its value as minimum deviation.  Valid values are >
            0.0.
MinNodeOutOfSolidDeviation=<value>
Detects nodes out of solid with its value as minimum deviation.  Valid values are >
            0.0.

","Examples
To detect all problem
        types:*createmark components 1 ""shell""
*createmark components 2 ""MidmeshEdges"" ""Mid""
*midmesh_inspect_init SourceEntityType=components SourceMark=1 TargetEntityType=components TargetMark=2 MinNodeOffMidDeviation=0.2 MinNodeOffSolidEdgeDeviation=0.2 MinNodeOutOfSolidDeviation=0.2 MinEdgeOffEdgeDeviation=0.2 MinElemCenterOffMidDeviation=0.3 CheckMinElemSize=1
*midmesh_inspect_end
To detect and correct nodes off mid, delete empty sets, and shut down the inspect
        module:*createmark components 1 ""shell""
*createmark components 2 ""MidmeshEdges"" ""Mid""
*midmesh_inspect_init SourceEntityType=components SourceMark=1 TargetEntityType=components TargetMark=2 MinNodeOffMidDeviation=0.2
*midmesh_inspect_fix_problems nodes 2 ProblemType=NodeOffMid SmoothClusters=1 SmoothMethod=Auto
*midmesh_inspect_delete_sets 2
*midmesh_inspect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1685,*midsurface_accept_edge_target_by_number ,"Description
Assigns targets for the surface edge. Once assigned, targets can be used to offset a
        midsurface.
","Inputs

face
The index of the surface to offset.
e1_edge_number
The index of a line, which must be an edge of the surface to
            offset.
e2_line
The index of a pilot line.
is_opposite
0 - The target is the e2_line. 
1 - The target is a line located in between e1_line and
              e2_line.

","Example
You cannot manually employ this command, because HyperMesh must
        internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
1686,*midsurface_clear_plate_info,"Description
Deletes the plate and thickness information from selected surfaces, which was created via
        previous midsurface runs, or via plate edit commands.
","
Inputs



mark_id

The ID of the mark containing the surfaces to clear.  Valid values are 1 and 2.

reserved1

Reserved for future use.  Must be set to 0.

reserved2

Reserved for future use.  Must be set to 0.

","Examples
To delete the plate and thickness information from surfaces with ID 5-7:
*createmark surfs 1 5-7
* midsurface_clear_plate_info 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1687,*midsurface_combine_all_targets,"Description
Combines the targets for all the vertices of the surface to offset
","Inputs

face
The index of the surface to offset.
display_only
0 The combined targets are displayed and assigned to their corresponding vertices. 
1 The combined targets are displayed but not assigned.

","Example
Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in). 
","Errors
None.
"
1688,*midsurface_display_plates,"Description
The command creates components that show the plate information present in the model. The
        plate information is drawn for the following surfaces:
All surfaces of the currently active components (i.e., with geometry display turned
            on).
All surfaces of non-active components (i.e. with geometry display turned off) that
            possess an active (i.e. geometry display turned on) middle surface.


","Inputs

use_base_surfaces
This specifies whether the user-defined base surfaces will be taken into account when
            displaying the plate information. Valid values are: 
0 - Base surface information is not taken into account. The existing plate information
            is left intact and displayed as is. 
1 - Base surface information is taken into account. The existing plate information is
            displayed, however all the surfaces of all plates (planar or sweep) that contain a base
            surface are turned into offset plates.
plate_type
Specifies which plate information to display. Valid values are: 
0 - Draw plates of all type (as well as non-plates, like plate edge, transition,
            not-a-trim surfaces, etc...) This was the default behavior pre-14.0. 
1 - Display planar plates only 
2 - Display sweep plates only 
3 - Display offset plates only

","Example
To show the plate information on all currently displayed components, without taking base
        surface information into account:
*midsurface_display_plates 0 0
To show the plate information about only sweep plates from all currently displayed
        components, taking base surface information into account:
*midsurface_display_plates 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1689,*midsurface_extract_10,"Description
This command extracts mid-surfaces from a selection of surfaces or solids. 
","Inputs

entity_type
The type of entity selected for mid-surface extraction. Valid values are surfaces and
            solids.
mark_id
The ID of the mark containing the input entities.
outbound_normals
If entity_type is surfaces:
 -1 - If surfaces selected on mark_id form a closed solid (but
                  entity_type parameter is not set to solid). In this case the
                surfaces will be re-oriented, if needed, to have the normals go outside the solid
                they form. 
0 - If the normals go inside the selected surfaces. 
1 - If the normals go outside the selected surfaces.


If entity_type is solids:
3 - The parameter must be set to this value.


thickness_bound
Limits on midsurface thickness: 
0 - No limit. Max ratio set using max_thickness_ratio. 
1 - User-defined thickness limits. Limits set using min_thickness
            and max_thickness.
align_steps
Determines how steps are aligned for solids with discrete sections. This parameter
            also determines whether any specified base surfaces are taken into account when
            constructing the middle surface. If the values are 0, 1, or 2, the base surfaces are not
            used. In order to take the base surfaces into account, the value should be increased by
            3.
0 - Steps are not aligned at the thickness jumps (jumps maintained). Base surfaces
            will not be used. 
1 - Steps aligned at the thickness jumps. Mid-surface position set automatically. Base
            surfaces will not be used. 
2 - Steps aligned at the thickness jumps. Mid-surface position set using
              mid_position. Base surfaces will not be used. 
3- Steps are not aligned at the thickness jumps (jumps maintained). Base surfaces
            specified by you will be taken into account. 
4 - Steps aligned at the thickness jumps. Mid-surface position set automatically. Base
            surfaces specified by you will be taken into account. 
5 - Steps aligned at the thickness jumps. Mid-surface position set using
              mid_position. Base surfaces specified by you will be taken into
            account.
extract_by_comp
0 - Extraction of the mid-surfaces can occur between any matching pair of the
            surfaces. 
1 - Extraction of the mid-surfaces can occur only between the surfaces that belong to
            the same component. 
Adding 10 to this value will result in the input geometry components maintaining their
            original transparency.
Adding 100 to this value will result in creating plate information only, without
            midsurfaces.
rerun_type
Used to specify one of the mid-surface extraction methods: offset, offset+planes,
            offset+planes+sweeps or skin offset. 
0 - Extracts the mid-surface using the ""offset"" method. 
1 - Extracts the mid-surface using the ""offset"" method, and at the same time copies
            the lines that collapsed into ""Collapsed Lines"" component. 
2 - Extracts the mid-surface using the ""offset"" method, by collapsing only the lines
            that are in the ""Collapsed Lines"" and ""Just added Collapsed Lines"" components.
            Additionally, it moves lines from ""Just added Collapsed Lines"" component into ""Collapsed
            Lines"" component. 
3 - Extracts the mid-surface using the ""offset+planes"" method. 
4 - Extracts the mid-surface using the ""offset+planes"" method, and at the same time
            copies the lines that collapsed into ""Collapsed Lines"" component. 
5 - Extracts the mid-surface using the ""offset+planes"" method, by collapsing only the
            lines that are in the ""Collapsed Lines"" and ""Just added Collapsed Lines"" components.
            Additionally, it moves lines from ""Just added Collapsed Lines"" component into ""Collapsed
            Lines"" component.
6 - Extracts the mid-surface using the ""skin offset"" method. 
9 - Extracts the mid-surface using the ""offset+planes+sweeps"" method. 
10 - Extracts the mid-surface using the ""offset+planes+sweeps"" method, and at the same
            time copies the lines that collapsed into ""Collapsed Lines"" component. 
11 - Extracts the mid-surface using the ""offset+planes+sweeps"" method, by collapsing
            only the lines that are in the ""Collapsed Lines"" and ""Just added Collapsed Lines""
            components. Additionally, it moves lines from ""Just added Collapsed Lines"" component
            into ""Collapsed Lines"" component.
stitch_tol_mode
Defines the mode for performing mid-surface stitching. Valid values are: 
0 - Final stitching of the mid-surfaces is performed using a local tolerance of 1/5 of
            the local surface thickness (default in prior versions). 
1 - Final stitching of the mid-surfaces is performed using the geometry cleanup
            tolerance. This is recommended when extensive manual editing of the auto mid-surfacing
            result is expected, because having ""far"" stitching may misrepresent the geometry of the
            model and affect subsequent geometry operations.
max_R_t_ratio 
This is a ratio between the fillet radius and plate thickness analyzed at T, X and
            similar junctions. If the calculated ratio is greater than this parameter, the fillet
            does not collapse. In previous releases the ratio was a default value of 2 and could not
            be changed.
reserved_1
Reserved for future development. Value = 0.
reserved_2
Reserved for future development. Value = 0.
max_thickness_ratio
This is a ratio between a plate thickness found during the midsurfacing and the
            minimum plate thickness found during the midsurfacing.  If the ratio is exceeded the
            corresponding midsurface will be ignored. The parameter is used  when
              thickness_bound is 0. It can be any real number > 1.
min_thickness
Sets the minimum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number >= 0.
max_thickness
Sets the maximum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number >
            min_thickness.
mid_position
Sets the midsurface position for step alignment case when
              align_steps is set to 2. This can be any number between 0 and
            1.
reserved_3
Reserved for future development. Value = undefined.
reserved_4
Reserved for future development. Value = 0.
reserved_5
Reserved for future development. Value = 0.
new_or_curr_comp
0 - Midsurface will be created in the current component. 
1 - Midsurface will be created in a new component named ""Middle Surface"". 
-1 - Applies immediate sorting during midsurface extraction. Corresponds to a value of
            0 for *sort_midsurfaces. 
-2 - Applies immediate sorting during midsurface extraction. Corresponds to a value of
            1 for *sort_midsurfaces. 
-3 - Applies immediate sorting during midsurface extraction. Corresponds to a value of
            2 for *sort_midsurfaces. 
-4 - Applies immediate sorting during midsurface extraction. Corresponds to a value of
            3 for *sort_midsurfaces. 
-5 - Applies immediate sorting during midsurface extraction. Corresponds to a value of
            4 for *sort_midsurfaces. 


","Example
To extract the midsurface of solids ID 5 through 7, no thickness bounds, align the steps at
        0.39, only extract surfaces between the same component, max thickness ratio of 10, and
        organize them into the ""Middle Surface"" component:
*createmark solids 1 5 6 7
*midsurface_extract_10 solids 1 3 0 2 1 0 0 2 10 0 0 0.39 undefined 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1690,*midsurface_merge_into_one_plate,"Description
The command changes the plate information for every surface on the input mark by putting
        them all into a single plate. The plate component, for visualizing the newly created plate
        and containing copies of the original model’s surfaces, is also created if necessary. If the
        surfaces on the input mark previously had different plate attributes, their copies in the
        temporary plate components are deleted. 
If the base surface information is set to be taken into account, the command will also do a
        preliminary check whether the given set of surfaces includes any base surfaces or not. If
        there is any base surface present and the intended merged plate type is ""planar"" or ""sweep"",
        the command will not do anything.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
plate_type
This parameter specifies the type of merged plate to create. Valid values are: 
0 - Create plate of type ""auto"" 
1 - Create plate of type ""planar"" 
2 - Create plate of type ""offset"" 
3 - Create plate of type ""sweep""
use_base_surfaces
This specifies whether the user-defined base surfaces will be taken into account when
            displaying the plate information. Valid values are: 
0 - Base surface information is not taken into account. There is no restriction as to
            which surfaces can be used to merge into a single plate. 
1 - Base surface information is taken into account. If the input mark contains a base
            surface, the command will not do anything in cases when the intended plate type is
            planar or sweep.
reserved
Reserved for future use. Must be set to 0.

","Example
To merge the surfaces with ID 5-7 to form a single plate of type sweep, without including a
        check for the input mark to contain base surfaces:
*createmark surfaces 1 5 6 7
*midsurface_merge_into_one_plate 1 3 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1691,*midsurface_offset_by_targets_11 ,"Description
Offsets a surface according to the targets that are attached to its vertices and edges.
","Inputs

surface
The ID of the surface to offset.
mode
The mode for the selected surfaces. Valid values are: 
1 - Preserves the planarity of the surfaces that were planar before the offset 
Any other value - A planar surface might become curved if the targets set to offset
            the surface are not in one plane.

","Example
To offset the mid-surface from a surface with ID 109:
*midsurface_offset_by_targets_11 109 1
","Errors
None.
"
1692,*midsurface_remove_display_plates ,"Description
The command deletes components that show the plate information present in the model. The
        command can also be used to delete all the plate and thickness information present in the
        model.
","Inputs

delete_plate_info
This specifies whether, besides deleting the plate information components, the plate
            information itself should be deleted. Valid values are: 
0 - Delete all components showing plate information, and retain the plate and
            thickness information present on relevant surfaces. 
1 - Delete all components showing plate information, and delete the plate and
            thickness information present on relevant surfaces.
remove_from_all_comps
Specifies whether to delete the plate information from the entire model or just from
            specific components where the plate edit is performed. Valid values are: 
0 - Delete display plates from all components for which temporary comps are drawn.
            This was the default behavior pre-14.0. 
1 - Delete display plates from all components (even inactive).
reserved1
Reserved for future use. Must be set to 0.

","Examples
To delete the components showing plate information, as well as the plate and thickness
        information:
*midsurface_remove_display_plates 1 0 0

To delete the components showing the plate information, as well as the plate information
        itself, from all components:
*midsurface_remove_display_plates 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1693, *midsurface_remove_edit_bodies ,"Description
No arguments are required for this command.
","Errors
None.
",,
1694,*midsurface_remove_plate_base_conflicts,"Description
Removes conflicts between base surface information and planar or sweep plate information on
        all surfaces by changing the type of all relevant planar and sweep plates into offset
        plates.
If a surface is marked both as a base surface and as part of a planar or sweep plate, there
        is a conflict about how to create the corresponding midsurface. On one hand, it is marked to
        be base surface, which means the corresponding midsurface should be created by offset with a
        user-specified distance.  On the other hand, it is marked as part of a planar or sweep
        plate, which means the corresponding midsurface should be inserted in the middle of the
        plate in a form of a piece of plane or sweep surface. These often contradict each other as
        only offset plates can contain base surfaces.
","Inputs

reserved1
Reserved for future use.  Must be set to 0.
reserved2
Reserved for future use.  Must be set to 0.
reserved3
Reserved for future use.  Must be set to 0.
reserved4
Reserved for future use.  Must be set to 0.

","Example
To turn all planar and sweep plates that contain base surfaces into offset plates:
*midsurface_remove_plate_base_conflicts 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1695,*midsurface_set_not_a_plate_side,"Description
This command changes the plate information for every surface on the input mark. The command
        can be used to set the surfaces to be:
Plate edge (known as ""not a plate side"" in 12.0)
Transition surface
Not a trim surface


If the base surface information is to be taken into account, the command will also do a
        preliminary check whether the given set of surfaces includes any base surfaces or not. If
        there is any base surface present, the command will exit without doing anything. Note: Base
          surfaces can only be parts of offset plates. They cannot be a part of planar plates, sweep
          plates, plate edges, transitions, or not-a-trim surfaces.

","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
use_base_surfaces
This specifies whether the user-defined base surfaces will be taken into account or
            not to specify the surface type. Valid values are: 
0 - Base surface information is not taken into account. There is no restriction as to
            which surfaces can become plate edges, transition surfaces or not-a-trim surfaces. 
1 - Base surface information is taken into account. If the input mark contains a base
            surface, the command will not do anything.
functionality
Specifies what non-plate are the surfaces in the input mark turned into: 
0 - Set all surfaces on the input mark to become transition surfaces 
1 - Set all surfaces on the input mark to become plate edges 
2 - Reserved for future development, do not use 
3 - Set all surfaces on the input mark to become not-a-trim surfaces

","Example
To set the surfaces with IDs 5 through 7 to be transition surfaces, including a check for
        the input mark to contain base surfaces:
*createmark surfaces 1 5 6 7
*midsurface_set_not_a_plate_side 1 1 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1696,*midsurface_switch_sides_within_plate,"Description
Deletes the two components that contain copies of the model surfaces belonging to two sides
        of a given plate. 
Switches the side number to which the surfaces on the input mark belong to the opposite
        side. If the selected surfaces happen to include surfaces from more than one plate, or
        surfaces that do not have plate information, the command will not do anything.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To set the surfaces with IDs 5-7 to belong to the opposite of their current side, assuming
        the input surfaces belong to the same plate:
*createmark surfaces 1 5 6 7
*midsurface_switch_sides_within_plate 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1697,*midsurface_update_from_plate_edit ,"Description
The command removes relevant pre-existing midsurfaces and plate display components,
        extracts mid-surfaces corresponding to the existing plate edit information, and re-draws the
        plate display components. This command replicates and expands upon the functionality
        available in the *midsurface_extract_10 command, and all parameters have
        the same meaning as for *midsurface_extract_10.
","Inputs

entity_type
The type of entity selected for mid-surface extraction. Valid values are surfaces and
            solids.
mark_id
The ID of the mark containing the input entities.
outbound_normals
If entity_type is surfaces:
 -1 - If surfaces selected on mark_id form a closed solid (but
                  entity_type parameter is not set to solid). In this case the
                surfaces will be re-oriented, if needed, to have the normals go outside the solid
                they form. 
0 - If the normals go inside the selected surfaces 
1 - If the normals go outside the selected surfaces


If entity_type is solids:
3 - The parameter must be set to this value.


thickness_bound
Limits on midsurface thickness: 
0 - No limit. Max ratio set using max_thickness_ratio. 
1 - User-defined thickness limits. Limits set using min_thickness
            and max_thickness.
align_steps
Determines how steps are aligned for solids with discrete sections. This parameter
            also determines whether any specified base surfaces are taken into account when
            constructing the middle surface. If the values are 0, 1, or 2, the base surfaces are not
            used. In order to take the base surfaces into account, the value should be increased by 3.
0 - Steps are not aligned at the thickness jumps (jumps maintained). Base
                surfaces will not be used. 
1 - Steps aligned at the thickness jumps. Mid-surface position set automatically.
                Base surfaces will not be used. 
2 - Steps aligned at the thickness jumps. Mid-surface position set using
                  mid_position. Base surfaces will not be used. 
3 - Steps are not aligned at the thickness jumps (jumps maintained). Base
                surfaces specified by you will be taken into account. 
4 - Steps aligned at the thickness jumps. Mid-surface position set automatically.
                Base surfaces specified by you will be taken into account. 
5 - Steps aligned at the thickness jumps. Mid-surface position set using
                  mid_position. Base surfaces specified by you will be taken into
                account.


extract_by_comp


0 - Extraction of the mid-surfaces can occur between any matching pair of the
                surfaces. 
1 - Extraction of the mid-surfaces can occur only between the surfaces that
                belong to the same component.


rerun_type
Used to specify one of the midsurface extraction methods: offset, offset+planes and
            offset+planes+sweeps. If the value is 0, 1, or 2 the extraction method is ""offset"". If
            you want to use extraction method ""offset+planes"" instead, the value should be increased
            by 3. If you want to use the extraction method ""offset+planes+sweeps"", the value should
            be increased by 6.
0 - Simply extracts the mid-surface. Midsurface extraction method is ""offset"". 
1 - Extracts the mid-surface and at the same time copies the lines that collapsed
                into ""Collapsed Lines"" component. Midsurface extraction method is ""offset"". 
2 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset"". 
3 - Simply extracts the mid-surface. Midsurface extraction method is
                ""offset+planes"". 
4 - Extracts the mid-surface and at the same time copies the lines that collapsed
                into ""Collapsed Lines"" component. Midsurface extraction method is ""offset+planes"". 
5 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset+planes"". 
9 - Simply extracts the mid-surface. Midsurface extraction method is
                ""offset+planes+sweeps"". 
10 - Extracts the mid-surface and at the same time copies the lines that
                collapsed into ""Collapsed Lines"" component. Midsurface extraction method is
                ""offset+planes+sweeps"". 
11 - Extracts the mid-surface by collapsing only the lines that are in the
                ""Collapsed Lines"" and ""Just added Collapsed Lines"" components. Additionally, it
                moves lines from ""Just added Collapsed Lines"" component into ""Collapsed Lines""
                component. Midsurface extraction method is ""offset+planes+sweeps"".


stitch_tol_mode
Defines the mode for performing mid-surface stitching. Valid values are:
0 - Final stitching of the mid-surfaces is performed using a local tolerance of
                1/5 of the local surface thickness (default in prior versions). 
1 - Final stitching of the mid-surfaces is performed using the geometry cleanup
                tolerance. This is recommended when extensive manual editing of the auto
                mid-surfacing result is expected, because having ""far"" stitching may misrepresent
                the geometry of the model and affect subsequent geometry operations.


max_R_t_ratio 
This is a ratio between the fillet radius and plate thickness analyzed at T, X and
            similar junctions. If the calculated ratio is greater than this parameter, the fillet
            does not collapse. In previous releases the ratio was a default value of 2 and could not
            be changed
reserved_1
Reserved for future use. Must be set to 0.
reserved_2
Reserved for future use. Must be set to 0.
max_thickness_ratio
This is a ratio between a plate thickness found during the midsurfacing and the
            minimum plate thickness found during the midsurfacing.  If the ratio is exceeded the
            corresponding midsurface will be ignored. The parameter is used  when
              thickness_bound is 0. It can be any real number > 1.
min_thickness
Sets the minimum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number ≥ 0.
max_thickness
Sets the maximum plate thickness bound. This parameter is used when
              thickness_bound is 1. It can be any real number >
              min_thickness.
mid_position
Sets the midsurface position for step alignment case when
              align_steps is set to 2. This can be any number between 0 and
            1.
reserved_3
Reserved for future development. Value = undefined.
reserved_4
Reserved for future use. Must be set to 0.
reserved_5
Reserved for future use. Must be set to 0.
new_or_curr_comp


0 - Midsurface will be created in the current component. 
1 - Midsurface will be created in a new component named ""Middle Surface"".



","Example
To extract the midsurface of solids ID 5 through 7, no thickness bounds, align the steps at
        0.39, only extract surfaces between the same component, max thickness ratio of 10, and
        organize them into the ""Middle Surface"" component:
*createmark solids 1 5 6 7
*midsurface_update_from_plate_edit solids 1 3 0 2 1 0 0 2 10 0 0 0.39 undefined 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1698,*midsurfmesh,"Description
This command creates a mesh on the mid-surface extracted from a solid body. The mesh is
        created using the BatchMesher approach, with optional
        application of geometry and elements cleanup steps. The command also optionally assigns
        thickness to the created mesh. 
The mid-surface must already exist, and must be organized in a component with the name
        ""Middle Surface"". The mesh is applied only to surfaces in this component. 
The parameters controlling mesh creation are set using specified criteria and parameters
        file, or can be set using flexible string input. 
The assignment of thickness is available only through the string input. The thickness
        assignment is supported for the following user profiles: 
Abaqus, LS-DYNA, Nastran, OptiStruct, Radioss
","Inputs

entity_type
The type of input geometry to use when assigning thickness. Valid values are surfaces
            and solids. This is ignored, if thickness assignment is not requested.
mark_id
The ID of the mark containing the input geometry for thickness calculations. Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
The optional input parameters can be grouped arbitrarily in any order. Each string may
            comprise input for any number of the parameters. 
The data for each input parameter consists of a predefined parameter keyword and the
            parameter value, separated by space characters and/or the equality
            symbol:parameter_keyword = parameter_value
or

parameter_keyword parameter_value

The supported input parameters grouped by type are as below. 
Mesh and geometry cleanup parameters (auto-generation):
elem_size
The mesh element size. If a positive value is given, then the
                    criteria_file and param_file arguments are
                  ignored. The criteria and parameters are auto-generated inside the command using
                  default values adjusted to the given element size.


The remaining mesh and geometry cleanup parameters have effect only if
              elem_size is given and has a valid value. They are used for tuning
            the auto-generation.


elem_type
0 - trias 
1 - quads 
2 - mixed (default)
elem_order
1 - First order (default) 
2 - Second order
min_elem_size
The minimum element size used for auto-generated criteria. Default value is
                    0.3*elem_size.
max_elem_size
The maximum element size used for auto-generated criteria. Default value is
                    1.75*elem_size.
elem_feature_angle
The element feature angle, in degrees, used for detection of features in
                  post-mesh smoothing and cleanup. Default value is 25.0.
no_geomcleanup
0 - Apply geometry cleanup (default) 
1 - Do not apply geometry cleanup
no_node_move_across_edges
0 - Nodes are allowed to move across non-feature geometry edges in post-mesh
                  smoothing and cleanup (default) 
1 - Nodes are not allowed to move off geometry edges
no_remove_holes
0 - Small holes are removed during geometry cleanup (default). The default hole
                  diameter for removal is the maximum of 0.4*elem_size and
                    0.8*min_elem_size.

1 - Do not remove small holes
no_seed_holes
0 - Seed holes with fixed points in geometry cleanup (default) 
1 - Do not seed holes
do_washer
0 - Do not create washers around holes (default) 
1 - Create washers around holes


Handling of existing elements associated with surfaces in the ""Middle Surface"" component:
keep_midsurf_elems
0 - Delete existing elements 
1 - For completely meshed connected surfaces, the mesh is kept. Partially meshed
                  connected surfaces are remeshed (default). 
2 - All existing elements are kept. This may result in a break in connectivity
                  of the mesh.


Thickness assignment:
thickness_mode
0 - Do not assign thickness (default) 
1 - Assign thickness
thickness_min
The minimum thickness to use. Ignored if thickness_mode is 0,
                  if omitted, or if provided as 0.0.
thickness_max
The maximum thickness to use. Ignored if thickness_mode is 0,
                  if omitted, or if provided as 0.0.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
criteria_file
The full path and file name of the element quality criteria file to use. If the
            criteria are set by a preceding command, ""dummy"" should be used as the file name. 
This is ignored, if the criteria and parameter auto-generation mode is set in the
            string input.
param_file
The full path and file name of the geometry cleanup parameters file to use. If the
            parameters are set by a preceding command, ""dummy"" should be used as the file name. 
This is ignored, if the criteria and parameter auto-generation mode is set in the
            string input.

","Examples
To mesh a mid-surface using element quality criteria
          C:/crit/10mm.criteria and cleanup parameters file
          C:/crit/10mm.param, with no additional input parameters:
*midsurfmesh solids 1 1 0 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""
To mesh a mid-surface using element quality criteria
          C:/crit/10mm.criteria and cleanup parameters file
          C:/crit/10mm.param, with element thickness assignment using all solid
        geometry (no limits on the minimum and maximum thickness):
*createmark solids 1 all
*createstringarray 1 ""thickness_mode = 1""
*midsurfmesh solids 1 1 1 ""C:/crit/10mm.criteria"" ""C:/crit/10mm.param""

The same as the previous example, but using elements quality criteria explicitly
        preset:
*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
*createmark solids 1 all
*createstringarray 1 ""thickness_mode = 1""
*midsurfmesh solids 1 1 1 ""dummy"" ""C:/crit/10mm.param""
To mesh a mid-surface with element size 12.0 (mixed elements type) using auto-generated
        element quality criteria and cleanup parameters, a minimum element size of 5.0, an elements
        feature angle of 15.0, and assigning element thickness using all solid geometry (no limits
        on the minimum and maximum thickness):
*createmark solids 1 all
*createstringarray 3 ""elem_size = 12.0 min_elem_size = 5.0"" ""elem_feature_angle = 15.0"" ""thickness_mode = 1""
*midsurfmesh solids 1 1 3 ""dummy"" ""dummy""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1699,*min_size_node_movement,"Description
This command moves nodes along feature edges in a shell mesh to solve minimum element size
        failures. The mesh topology is not modified. The minimum element size is given by ""Min Size""
        ( fail ) in the criteria file settings. The node movement is restricted to be along existing
        surfaces. The command expects that the criteria and parameter files are set. It honors the
        following fields from the parameter file to specify the maximum allowable node movement distance:
Move across shared edges
Move across free edges
Move across non-manifold edges


Feature edges are constructed as:
A set of 1D elements along FE edges
If no 1D element is present in the model, using the feature angle given in the
            paramter file
Node - geometry association


Node - geometry association is maintained after feature node are moved, however, free edge
        nodes may move tangential away from the surface and lose association.
Feature node movement is attempted in decreasing order of priority for:
Internal low curvature shared edges
Internal high curvature edges
Free edges
Non-manifold edges


Node movement is also part of the *rebuild_mesh command.
","Inputs

mark_id
The ID of the mark containing the elements to correct.  Valid values are 1 and 2.

","Example
To move feature nodes of selected shell elements with 5 mm criteria and parameter file
        settings:
*createstringarray 14 "" 0 penalty value              0.00    0.00    0.50    1.00    5.00"" \
  ""  1 min length        1 2.0   5.000   4.333   3.666   3.000   2.833    2"" \
  ""  2 max length        1 1.5   5.000   6.200   7.320   9.000  11.290    0"" \
  ""  3 aspect ratio      1 1.0   1.000   2.000   4.000   5.000  10.000    0"" \
  ""  4 warpage           1 2.0   0.000   5.000  15.000  20.000  40.000    0"" \
  ""  5 max angle quad    1 1.0  90.000 110.000 140.000 150.000 165.000    0"" \
  ""  6 min angle quad    1 1.0  90.000  70.000  40.000  30.000  15.000    0"" \
  ""  7 max angle tria    1 1.0  60.000  80.000 120.000 130.000 155.000    0"" \
  ""  8 min angle tria    1 1.0  60.000  50.000  30.000  20.000  10.000    0"" \
  ""  9 skew              1 1.5   0.000  10.000  50.000  60.000  75.000    0"" \
  "" 10 jacobian          1 2.0   1.000   0.900   0.600   0.500   0.350    0"" \
  "" 11 chordal dev       0 0.0   0.000   0.300   0.800   1.000   2.000    0"" \
  "" 12 taper             0 1.0   0.000   0.200   0.500   0.600   0.900    0"" \
  "" 13 % of trias        1 2.0   0.000   3.000   4.500   6.000   9.000    0""
*setqualitycriteria 1 14 0
*elementchecksettings -1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
*createstringarray 106 ""fileversion 20180"" ""geometry_cleanup_flag             1"" \
  ""meshing_flag                      5"" ""element_size                      5.0"" \
  ""element_type                      2"" ""mesh_align                        3"" \
  ""element_order                     1"" ""surf_component                    1"" \
  ""feature_angle                     30.0"" ""holes_table_begin"" ""appl_surf(1)"" \
  ""appl_solid(0)"" ""appl_cordsfiles(0)"" ""appl_flanged_suppr(1)"" ""flanged_suppr_height(1.4)"" \
  ""narrow_slots_type(1)"" ""appl_rmv_washer_loops(1)"" ""abs_fixed_nodes_count_max(-8)"" \
  ""rad(0.0,2.2) do action(1) washer(0) "" ""rad(2.2,3.01) do action(0) elems(4) washer(0) "" \
  ""rad(3.01,4.7) do action(0) elems(6) washer(1) layers(3.5) "" ""rad(4.7,9.0) do action(0) elems(8) washer(1) layers(0.75*radius) "" \
  ""rad(9.0,11.0) do action(0) elems(8) washer(1) layers(7.0) "" ""rad(11.0,20) do action(0) elems(8) washer(1) layers(auto) "" \
  ""rad(0.0,2.2) solid(1) do action(1) "" ""rad(2.2,3.01) solid(1) do action(0) elems(4) "" \
  ""rad(3.01,20) solid(1) do action(0) elems(6) "" ""holes_table_end"" ""edge_fillet_recognition           1"" \
  ""max_fillet_radius                 5.0"" ""surface_fillet_table_begin"" ""surface_fillet_recognition(1)"" \
  ""minimize_transitions(1)"" ""rad(0,2.2) wid(3.0,6.2) do split(suppress_on)"" \
  ""rad(2.2,15) wid(3.4,6.2) do elems(1)"" ""rad(0,25.0) wid(6.2,9.2) do elems(2)"" \
  ""rad(0,35.0) wid(9.2,12.5) do elems(3)"" ""rad(0,40.0) wid(12.5,25.0) do chordal_deviation(0.2)"" \
  ""surface_fillet_table_end"" ""del_dupl_surfs_flag               2"" ""del_dupl_surfs_tol                -1"" \
  ""edges_stitch_flags                0"" ""max_edges_stitch_tol              -1.0"" \
  ""fix_overlapsurfs_flag             1"" ""overlapsurfs_maxtangangle         -1.0"" \
  ""merge_narrow_surfs                1"" ""narrow_surfs_merge_width          Lmin*0.67"" \
  ""beads_suppression                 1"" ""beads_recognition                 1"" \
  ""minimal_beads_height              1.4"" ""beads_treat_flags                 1"" \
  ""flange_recognition                1"" ""flange_elements_across            3"" \
  ""flange_max_width                  30.0"" ""flange_min_width                  8.0"" \
  ""flanges_treat_flags               1"" ""flange_max_remove_width           -1.0"" \
  ""appl_tria_reduction               1"" ""common_mesh_flow                  0"" \
  ""extract_thinsolids                1"" ""midsurf_method                    3"" \
  ""thinsolid_ratio                   0.3"" ""max_thickness                     10.0"" \
  ""extract_feature_angle             25.0"" ""pre_midsurf_cleanup               1"" \
  ""direct_midmesh                    0"" ""ignore_flat_edges                 1"" \
  ""flatten_connections               0"" ""defeat_open_width_on              1"" \
  ""defeat_open_width                 1.0"" ""supp_proxim_edges_on              1"" \
  ""supp_proxim_edges                 0.9"" ""combine_nonmanifold_on            1"" \
  ""combine_nonmanifold               0.7"" ""midmesh_extract_elem_size         2.0"" \
  ""remove_logo                       1"" ""logo_max_size                     30.0"" \
  ""logo_max_height                   1.4"" ""logo_min_concavity                1.0"" \
  ""threads_removal                   0"" ""threads_toremove_max_depth        5.0"" \
  ""threads_replacediametertype       -2"" ""folded_elems_angle                150.0"" \
  ""smooth_elems_target               0.2"" ""fillets_mesh_flow                 0"" \
  ""failed_elems_cleanup_flgs         8"" ""move_nodes_across_feature_edges   1"" \
  ""featureedge_nodes_moveacross_max  L*0.1"" ""move_nodes_across_free_edges      1"" \
  ""freeedge_nodes_moveacross_max     L*0.05"" ""move_nodes_across_t_edges         1"" \
  ""tedge_nodes_moveacross_max        L*0.05"" ""move_normal_flag                  1"" \
  ""move_normal_dist                  0.8"" ""divide_warped_quads               1"" \
  ""ignore_comps_boundary             0"" ""gen_topology_prepare_flags        7"" \
  ""cleanup_comp_flag                 0 "" ""comp_select                        "" \
  ""use_wildcards_for_compsnames      0"" ""cleanup_tolerances                auto"" \
  ""suppress_features_rate            1"" ""feat_charsize_method              1"" \
  ""custom_feat_suppr_maxangle        25.0"" ""uncond_constr_lines_suppress      0"" \
  ""aggressive_fillet_lines_suppress  0""
*createbatchparamsfromstrings 1 106
*createmark elements 1 all
*min_size_node_movement 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1700,*minmaxtitlesetcolor,"Description
Sets the color of a minimum or maximum title. 
","Inputs

color
The color to which the title should be set.
type
0 - Node title (contour plot) 
1 - Element title (assigned plot)
minmax
0 - Minimum title 
1 - Maximum title

","Errors
None.
",
1701,*mode ,"Description
Sets the operations performed when a full-size plot is generated in a command file. 
","Inputs

type
Defines the mode or operations performed when a full-size plot is generated from a
            command file. 
0 - This is the default action; HyperMeshwill wait for a
            key on the mouse to be struck before continuing. 
1 - Generates a screen copy or a paper plot of the picture generated on the screen. 
2 - Generates a file containing the contents of the screen buffer. 
3 - Generates a PostScript paper copy of the currently displayed screen. 
4 - Generates a PostScript file of the currently displayed screen. 
5 - A value of five or greater causes HyperMesh to pause
            for that number of seconds before continuing. 

","Example
To pause for 10 seconds after a full-size plot is performed, place the following command
        before the full-size plot request: 
*mode(10)
","Errors
None.
"
1702,*modelcheck_applyautocorrectiononmark,"Description
Runs auto correction on specific entities for a given check, if checks are run.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.

mark_id

The ID of the mark of entities for which model checker is to be run. Valid values are
            1 and 2.

correction_display_name

The GUI name of the correction. This is case sensitive.
If not provided, the then default auto correction associated with the check is
            applied.

","Examples
To run the ""Delete unused materials"" auto correction for all ""Unused materials"":
*createmark mats 1 all
*modelcheck_applyautocorrectiononmark ""Unused materials"" 1 ""Delete unused materials""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1703,*modelcheck_clearresults,"Description
Clears model checker results.
","
Inputs
None.","Examples
To clear the model checker results:
*modelcheck_clearresults
",ErrorsNone.
1704,*modelcheck_loadconfigfile,"Description
Loads the default model check config file associated with the current profile and creates
        check and correction entities. Any user specified custom config file takes precedence.
","
Inputs
None.","Examples
To load the default config file:
*modelcheck_loadconfigfile
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1705,*modelcheck_runchecks,"Description
Runs model checker checks.
If executed with no arguments, then all checks for all entity types in the profile are
        run.
","
Inputs



check_display_name

The GUI display name of the check. This is case sensitive.
If not provided or set to ""ALL"", then all the checks of the
              entity_type for the profile are run.

entity_type

The type of entity to be checked.
If not provided or set to ""ALL"", then all checks of all entity types are run.

error_type

The type of errors to check, ERROR, WARNING, INFO or ALL.
If not provided or set to ""ALL"", then all checks of all error types are run.

mark_id

The ID of the mark of entities for which model checker is to be run. Valid values are
            1 and 2.

","Examples
Run the check named ""checkname"":
*modelcheck_runchecks checkname
Run all checks on properties 1-10 :
*createmark props 1 1-10
*modelcheck_runchecks """" props """" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1706,*modent_addcontentsbymark,"Description
Adds entities to a modular entity via a mark.
Include contents will be merged.
","
Inputs


modular_entity_type
The type of modular entity to update.  Valid values are subsystemconfigurations,
            subsystems and subsystemsets.
modular_entity_id
The ID of the modular entity to update.
content_entity_type
The type of entity to add.
content_mark_id
The ID of the mark containing the entities to add.  Valid values are 1 and 2.
representation_key
The representation key of the subsystem to populate.  This defaults to the only
            realized representation and can be omitted.

","Examples
Add components 4, 6 and 8 under subsystem
        2:*createmark comps 1 ""by id only"" 4 6 8
*modent_addcontentsbymark subsystems 2 comps 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1707,*modent_deletebymark,"Description
Deletes a mark of modular entities.
","
Inputs


entity_type
The type of modular entity to delete.  Currently only supported for subsystems.
mark_id
The ID of the mark of modular entities to delete.  Valid values are 1 and 2.
keep_contents
0 - Delete all contained entities
1 - Keep all contained entities and move them under the master include

","Examples
Delete subsystems 4, 6 and 8 and move the contents under the master
        include:*createmark subsystems ""by id only"" 4 6 8
*modent_deletebymark subsystems 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1708,*modent_export,"Description
Exports a modular entity and its contents using the currently loaded solver template.
","
Inputs


entity_type
The type of modular entity to export.  Currently only supported for subsystems.
entity_id
The ID of the modular entity.
file_name
The full path and file name of the file to export.
options
Optional list of quoted, comma separated option strings.


exporttype=<value>
The type of exported file:
solverdeck - An FE solver



","Examples
Export the contents of subsystem 2 into an Ls-Dyna deck named
        ""C:/export/Subsystem2_Crash5mm.k"":*modent_export subsystems 2 ""C:/export/Subsystem2_Crash5mm.k""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1709,*modent_registerconstraintruleoptions,"Description
Registers a list of options that control the behavior of add/move/remove operations for a
        modular entity.  Valid entity combinations are:
Table 1. 

Independent Entity Types
Dependent Entity Types




beamsectcols
beamsects


components
elements


components
materials


components
nodes


components
properties


loadcols
loads


materials
curves


properties
materials


systcols
systems


vectorcols
vectors




","
Inputs


modular_entity_type
The type of modular entity.  Currently only supported for subsystems.
modular_entity_action
The type of modular entity action:
1 - Reset to defaults
2 - Add/move/remove
independent_entity_type
The type of independent entities to add/move/remove to/from modular entities.
dependent_entity_type
The type of dependent entities to add/move/remove to/from modular entities.
add_behavior_for_dependent_entity_type
0 - Do not add/move/remove to modular entities
1 - Add/move/remove to modular entities
add_behavior_for_shared_dependent_entity_type
0 - Do not add/move/remove independent entities to modular entities if they have any
            dependent entities shared with other modular entities
0 - Do not add/move/remove dependent entities to modular entities if they are shared
            with other modular entities
1 - Add/move/remove dependent to modular entities if they are shared with other
            modular entities

","Examples
When adding/moving/removing components to subsystems, add/move/remove properties and shared
        properties:*modent_registerconstraintruleoptions subsystems 2 components properties 1 2
When adding/moving/removing components to subsystems, add/move/remove nodes, but prevent
        the action if there are any nodes shared with other
        subsystems:*modent_registerconstraintruleoptions subsystems 2 components nodes 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1710,*modent_removecontentsbymark,"Description
Removes entities from a modular entity via a mark.
","
Inputs


modular_entity_type
The type of modular entity to update.  Valid values are subsystemconfigurations,
            subsystems and subsystemsets.
modular_entity_id
The ID of the modular entity to update.
content_entity_type
The type of entity to remove.
content_mark_id
The ID of the mark containing the entities to remove.  Valid values are 1 and 2.

","Examples
Remove the subsystems with IDs 4, 6 and 8 from the contents of subsystem set 2:
        *createmark subsystems 1 ""by id only"" 4 6 8
*modent_removecontentsbymark subsystemsets 2 subsystems 1 

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1711,*modent_unrealizerepresentation,"Description
Unloads the contents of a modular entity representation.
All entities that were brought into the session by loading the representation get deleted
        except for parts, partassemblies, partsets, and partconfigurations.
","
Inputs


entity_type
The type of modular entity to unload the representation from. Currently supported only
            for subsystems.
entity_id
The ID of the modular entity.
representation_key
The representation key to unload. This is unqiue per subsystem.

","Examples
Unload the contents of the representation with key ""crash5"" from subsystem
        3:*modent_unrealizerepresentation subsystems 3 ""crash5""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1712,*ModifySectionHandle ,"Description
This command updates the section shape updating the handle position.
","Inputs

xold_coord
x-coordinate of the old handle position.
yold_coord
y-coordinate of the old handle position.
zold_coord
z-coordinate of the old handle position.
xnew_coord 
x-coordinate of the new handle position.
ynew_coord 
y-coordinate of the new handle position.
znew_coord 
z-coordinate of the new handle position.

","Example
To modify the section position updating the handle position:
*ModifySectionHandle 7345.06626 -1077.25964 1419.12497 7334.93373 -1077.05694 1382.59689
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1713,*morphaltercurvectr ,"Description
Alter the radius, curvature, or arc angle of edge or 2D domains on mark.
","Inputs

domtype
DOMAINS
dommark
Domain mark number
nodetype
NODES
holdnode
Node mark number
type
The type of alteration to be made: 
0 - Alter radius 
1 - Alter curvature 
2 - Alter arc angle
curve
Numerical value by which to alter the curve; actual effect depends on the type
            previously specified and the value of the add flag listed at the end of the command: 
If type = 0 - New radius 
type = 1 - Curvature multiplier 
type = 2 - New arc angle 
add =1 and type = 0 - Number added to radii 
add =1 and type = 2 - Number added to arc
            angle
sym
0  - Do not use symmetry (only option)
con
Flag to use/not use constraints: 
0 - Do not use constraints 
1 - Use constraints
hold
Specifies which part of the curve to anchor: 
0 - Hold angle 
1 - Hold ends 
2 - Hold center
mode
Method of determining center or edges of curve: 
0 - Edge approximation, use symmetry 
1 - Use axis for center 
2 - Use line for center 
3 - Infer center using normals 
4 - Use node for center 
5 - Edge approximation, do not use symmetry
node
ID of node
plane
Mark number of plane
line
ID of line
project
Flag to project curve edges to a plane: 
0 - Do not project edges to plane 
1 - Project edges to plane
force
Flag to force circular edges when using edge approximation (mode option 5): 
0 - Do not force edges to be circular (edge approximation only) 
1 - Force edges to be circular (edge approximation only)
add
Determines whether the value specified for curve is added to the existing curve’s
            value, or replaces it: 
0 - Use 'curve' as target value 
1 - Add 'curve' to current value(s)

","Example
*morphaltercurvectr (DOMAINS,1,NODES,1,1,5.0,0,1,0,0,32,1,43,0,0,0)
The domains on the marks will have either their radius, curvature, or arc angle altered
        depending on 'type'. If add is set to 1, 'curve; will be added to the
        current radii or arc angle of the selected domains, otherwise the radii or arc angle will be
        set to 'curve'.
This command allows you to choose the mode used to determine the center for the selected
        domains. Only one of 'node', 'plane', or 'line' needs to be filled in depending on mode (or
        none if 0, 3, or 5 is selected).
Setting project to 1 will force the nodes for an edge to lie in a plane
        as part of the altered curve. Setting force to 1 will force the
        calculated center for each node of an edge to be the same point, thus forcing the edge to be
        circular after the curve is altered.
If constraints are used they will be applied to the perturbations. Symmetry is not
        supported for *morphaltercurvectr().
","Errors
None.
"
1714,*morphapplyfesolver ,"Description
This command will invoke a finite element solver, specified by the
          fesolver parameter, and solve for the internal perturbations for all
        domains which have fewer elements than that specified by the fesolverlimit parameter using
        enforced displacements applied at the domain handles, edges, and/or faces. The command will
        either use the properties and materials specified for the mesh or generate properties and
        materials automatically depending on the feuser parameter. 
This command has no arguments but uses several parameters when it is executed which are
        described below. These parameters can be updated using the
          *morphupdateparameter command.
","Inputs

fesolver
0 - Linear solver (OptiStruct) 
1 - Nonlinear solver (Radioss)
fesolverlimit
Domains containing less than this number of elements will be updated.
feuser
0 - Use automatically generated properties and materials 
1 - Use properties and materials currently for the mesh

","Example
To invoke the FE solver:
*morphapplyfesolver
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1715,*morphbeziershape ,"Description
Create polynomial or spline based shapes for handles on the domains on mark.
","Inputs

dtype
Domains
dmark
Domain mark number
etype
Elemsn
emark
Element mark number
shapeid
ID of shape
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
vvec
Mark number of vector
mag
Magnitude of perturbation
type
1 - Use vector for handle perturbations 
2 - Use element normals for handle perturbations 
3 - Use shape for handle perturbations
meth
0 - Polynomial 
1 - Spline
umark
0 - Use all elements to determine normals 
1 - Use elements on emark to determine normals

","Example
*morphbeziershape (DOMAINS,1,ELEMS,1,12,0,1,1,5.0,3,1,0)
A shape is created for each handle on each domain on the mark using the selected type to
        determine the perturbations. 
If type is 1 or 2, mag will be used as the magnitude
        of the handle perturbations. If type is 3, the perturbations on the shape
        will be used. 
If symmetry is used, all handles linked to marked handles by symmetry will also be
        perturbed. If constraints are used, they will be applied to the perturbations.
","Errors
None.
"
1716,*morphbiasupdate ,"Description
Updates the bias factor for the specified handle.
","Inputs

hptr
ID of handle
bias
New bias value

","Example
*morphbiasupdate (1,2.0)
Updates the specified handle to have the given bias factor.
","Errors
None.
"
1717,*morphbiasupdateretroactive,"Description
Applies updated biases retroactively to existing perturbations.
","Inputs

htype
Must be set to ""handles""
hmark
Number of the mark containing the desired handles
bias
New bias value desired
con
0 - Do not use constraints 
1 - Use constraints

","Example
*morphbiasupdateretroactive (handles, 1, 2.0, 1)
Recalculates and reapplies all morphs on the morph list in terms of the updated biasing
        factors.
","Errors
None.
"
1718,*morphcombinemorphvolumes ,"Description
Combines the specified morph volumes and propagates the combination. 
","Inputs

h1
ID of first morph volume.
h2
ID of second morph volume.
hand
0 - Do not create handles for morph volumes 
1 - Create handles for morph volumes
tangent
0 - No tangency 
1 - Make neighboring morph volume edges continuously tangent

","Example
*morphcombinemorphvolumes (21,22,1,1)
This command will combine the specified morph volumes and propagate the effect through the
        entire morph volume ""matrix"" so that it remains consistent. 
Newly combined morph volumes can optionally have handles and tangency automatically
        applied.
","Errors
None.
"
1719,*morphconstraintapply ,"Description
Applies all morph constraints to the model.
","Example
*morphconstraintapply 

This command applies the current constraints to the model. When constraints are created
        they are applied to the model so this command does not need to be called after creation of a
        morph constraint.Note: Constraints are applied via a morph, which can be undone. Undoing
          such a morph does not reject the constraint. 

If the model no longer obeys the constraints, for instance, if the constraints are turned
        off and the model is morphed, this command can be used to restore compliance.
","Errors
None.
",
1720,*morphconstraintcreatearcrad ,"Description
Creates a model type constraint based on the radius or arc length of an edge domain.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
atype
NODES or LINES
amark
Mark number of node or line used for radius measurement
type
0 - Measure radius or arc angle using domain 
1 - Measure radius or arc angle using axis 
2 - Measure radius or arc angle using line 
3 - Measure radius or arc angle using node
name
Name of morph constraint
plane
Mark number of plane for axis
dptr
ID of edge domain
radius
Constrained radius or arc angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
arc
0 - Radius 
1 - Arc angle
color
The color of the constraint. Valid values are 1 through 64.

","Example

*morphconstraintcreatearcrad (SHAPES,1,NODES,1,0,""radius"",1,21,5.0,0,0,32)

This command creates a model type constraint for the selected domain with the option of
        having the radius or arc angle measured in the plane of the domain, about an axis, about a
        line or about a node, and the option of having the radius or arc angle forced to be greater
        than, less than, or equal to the specified value. 
If arc is 0, the radius will be constrained. If arc
        is 1 the arc angle will be constrained. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible 
","Errors
None.
"
1721,*morphconstraintcreatedof,"Description
This command creates a constraint which fixes one or more translational degrees of freedom
        for the selected nodes relative to either the global coordinate system or a specified local
        coordinate system. 
A degree of freedom for a coordinate system is one of the three translational directions.
        For a rectangular coordinate system the three degrees of freedom are along each axis: the
        x-axis, the y-axis, and the z-axis. For a cylindrical coordinate system the three degrees of
        freedom are in the radial direction, the theta direction, and the z direction. For example,
        for a rectangular coordinate system, if the y-axis degree of freedom is fixed for a node, it
        will be allowed to move only in the x and z directions, remaining in a plane perpendicular
        to the y axis. Similarly, for a cylindrical coordinate system, if the theta degree of
        freedom is fixed for a node, it can move only in the radial and z directions. Note that
        fixing the radial and z degrees of freedom for a cylindrical coordinate system will force a
        node to move in a circle about the axis of that system.
","Inputs

entity_type
Must be set to nodes.
mark_id
The mark ID for the constrained nodes. Valid values are 1 and 2.
dof1
0 - Allow the nodes to move in the x (or radial) direction 
1 - Constrain the nodes from moving in the x (or radial) direction
dof2
0 - Allow the nodes to move in the y (or theta) direction 
1 - Constrain the nodes from moving in the y (or theta) direction
dof3
0 - Allow the nodes to move in the z direction 
1 - Constrain the nodes from moving in the z direction
system_id
The ID of the local coordinate system. Use 0 for the global coordinate system.
options
0 - Does not affect nodes near constrained nodes 
1 - Enable mesh stretching around constrained nodes
name
The name of morph constraint.
color
The color of the constraint. Valid values are 1-64.

","Example
To create a DOF constraint named ""mconsystem5"" for nodes 1-100 in the radial direction of a
        local coordinate system with ID 5 and mesh stretching enabled:
*createmark nodes 1 1-100
*morphconstraintcreatedof nodes 1 1 0 0 5 1 ""mconsystem5"" 22
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1722,*morphconstraintcreateelems ,"Description
This command creates a mesh type morphconstraint for the selected nodes with the option of
        having those nodes either move along the specified mesh or be bounded by it. 
The extended edges option is available for bounded type morphconstraint (types 1, 3, and 5)
        by adding 8 to the type (9, 11, and 13). This option will extend the edges of the mesh by
        roughly two element lengths so that the nodes which project close to the edges of the mesh
        will project on to the extended edges. 
The depenetration option is available for bounded type morphconstraint (types 1, 3, and 5)
        by adding 16 to the type (17, 19, and 21). This option will treat the center of any element
        attached to the constrained nodes as a constrained node and push the element away from the
        mesh if it is within the specified distance. 
To enable both extended edges and depenetration for a morphconstraint, add 24 to the type
        (thus 1, 3, and 5 become 25, 27, and 29).
","Inputs

ntype
Must be set to nodes.
nmark
The mark ID for the constrained nodes. Valid values are 1 and 2.
etype
Must be set to elems.
emark
The mark ID for elements to which the nodes are constrained. Valid values are 1 and 2.
type
0 - moves along mesh 
1 - bounded by mesh 
3 - remains a set distance from mesh 
5 - maintains its original distance from mesh 
+8 - extend edges of mesh 
+16 - depenetration of elements attached to constrained nodes (+24 - extend edges and
            enable depenetration) 
+32 - enable mesh stretching around constrained nodes
name
The name of the morphconstraint.
p_vec
The ID of the projection vector created using *createvector. Must
            be set to 1.
dist
Distance between node and mesh (types 1 and 3).
ivec
0 - Mesh normal is used for projection. The nodes will be moved normally to the mesh
            when constraining them or measuring the distance the nodes are away from the mesh 
1 - Use p_vec for projection. The nodes will be moved along
              p_vec when constraining them or measuring the distance the nodes
            are away from the mesh
color
The color of the constraint. Valid values are 1-64.

","Example
To create a morphconstraint for nodes to move along a mesh and projected normally to the
        mesh:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateelems nodes 1 elems 1 0 ""mcon"" 1 0.0 0 13
To create a morphconstraint for nodes to be bounded by a mesh at a distance of 5.0 and
        projected along a vector to the mesh with both depenetration and extended edges:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateelems nodes 1 elems 1 27 ""mcon"" 1 5.0 1 13
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1723,*morphconstraintcreatefc,"Description
This command creates either a fixed type morphconstraint or a cluster type morphconstraint
        for the selected nodes with the option of having mesh stretching around those nodes.
        Rotation options are also available for cluster type morphconstraints.
There are three options for rotation: in-plane, out-of-plane, and full rotation. In-plane
        will limit rotation of the cluster to the plane in which the cluster lies (spinning) while
        out-of-plane limits the rotation of the cluster to take place normal to the plane of the
        cluster (tilting). Full rotation allows both in-plane and out-of-plane rotation. For cluster
        constraints where the nodes do not lie in a discernable plane any rotation option results in
        full rotation.
","Inputs

ntype
 Must be set to nodes.
nmark
 The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Fixed type constraint without mesh stretching 
6 - Fixed type constraint with mesh stretching 
7 - Cluster type constraint with mesh stretching (no rotation) 
9 - Cluster type constraint without mesh stretching (no rotation) 
+10 - (types 17 and 19) enables out-of-plane rotation for clusters 
+20 - (types 27 and 29) enables in-plane rotation for clusters 
+30 - (types 37 and 39) enables full rotation for clusters
name
The name of the morphconstraint.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To create a cluster morphconstraint with mesh stretching and full rotation:
*createmark nodes 1 ""all""
*morphconstraintcreatefc nodes 1 37 ""rivet"" 12
To create a cluster morphconstraint without mesh stretching and with in-plane rotation:
*createmark nodes 1 ""all""
*morphconstraintcreatefc nodes 1 29 ""rivet"" 12

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1724,*morphconstraintcreatelength ,"Description
Creates a model type constraint based on the length of a list of nodes.
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure length node to node 
1 - Measure length using vector
name
Name of morph constraint
nodes
Mark number of node list
vec
The ID of the vector created using *createvector. Must be set to
            1.
length
Constrained length of node list
bound
-1 - Greater than specified length 
0 - Equal to specified length 
1 - Less than specified length
color
The color of the constraint. Valid values are 1 through 64.

","Example
*morphconstraintcreatelength (SHAPES,1,0,""length"",1,1,43.5,0,32)
This command creates a model type constraint for the selected node list with the option of
        having those nodes measured node to node or along a vector and the option of having the node
        list forced to be greater than, less than, or equal to the specified length. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
1725,*morphconstraintcreatematch ,"Description
This command will create a match type morphconstraint between two marks of elements such
        that they maintain a similar shape if the elements of either one mark or both marks are
        morphed. The two meshes do not have to be identical but the more similar they are the better
        the constraint will work.
This type of constraint can be used multiple times on the same set of elements in order to
        make three or more meshes match each other. Note that only shell elements can be matched
        using this constraint.
","Inputs

a_entity_type
Must be set to elems.
a_mark_id
The ID of the mark containing the first set of elems. Valid values are 1 and 2.
b_entity_type
Must be set to elems.
b_mark_id
The ID of the mark containing the second set of elems. Valid values are 1 and 2.
type
0 - Allow to slide normal to the mesh 
1 - Allow sliding normal to the specified vector vec 
2 - Match the shape between the two meshes 
+4 - Stretch mesh around the constrained elements
name
The name of the morphconstraint.
vec
The ID of the projection vector created using *createvector. Must
            be set to 1. Only used for type 1 and 5.
dist
The distance to be maintained between the meshes. Not used for type
            2 and 6.
node_basea
ID of the base node of a local system oriented to the mesh specified by
              a_mark_id. Only used for type 2 and 6.
node_xa
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by a_mark_id. Only used for type 2 and
            6.
node_xya
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
              by b_mark_id. Only used for type 2 and 6.
node_baseb
ID of the base node of a local system oriented to the mesh specified by
              b_mark_id. Only used for type 2 and 6.
node_xb
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by b_mark_id. Only used for type 2 and
            6.
node_xyb
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
              by a_mark_id. Only used for type 2 and 6.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a match constraint which matches the shape between two meshes
          (type = 2) and uses mesh stretching (type +4 for a
        total of 6):
*createmark elements 1 83 84 86-90 93 95 96 98-102 105 107 *createmark elements 2 50-54 57 62-66 69 74-78 81
*createvector 1 1 0 0
*morphconstraintcreatematch elements 1 elements 2 6 ""mcon"" 1 0 133 135 110 60 62 86 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1726,*morphconstraintcreatesmooth ,"Description
This command creates a smooth type morphconstraint for the selected nodes. During morphing,
        the perturbations of the nodes or dependent handles will be modified using a spline based
        approximation so that edge domains running along the selected entities will have smooth
        contours.
","Inputs

nlist
The ID of the list containing the nodes. Valid values are 1 and 2.
type
0 - Apply to nodes. All handles on the node list serve as anchors for the spline curve
            and nodes are adjusted to the curve based on influences 
1 - Apply to dependent handles. Only the independent handles on the node list serve as
            anchors and the dependent handles are adjusted to the curve based on influences
closed
0 - Open ended 
1 - Loop. The first node on the list will be added to the end to form a loop.
name
The name of the morph constraint.
color
The color of the constraint. Valid values are 1 through 64. 

","Example
To create a smooth morphconstraint for nodes 1-5 with a closed loop:
*createlist nodes 1 1 2 3 4 5
*morphconstraintcreatesmooth 1 0 1 ""smooth"" 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1727,*morphconstraintcreatevec ,"Description
This command creates a vector type morphconstraint for the selected nodes with the option
        of having those nodes bounded to move no closer than a given distance from the specified
        plane.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the vector 
1 - Moves along the vector and is bounded by the plane 
3 - Moves along the vector, at a set distance from the plane 
5 - Moves along the vector and remains its original distance from the plane 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
plane
The ID of the plane created using *createplane. Must be set to
            1.
dist
The minimum distance from the bounding plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a vector and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*morphconstraintcreatevec nodes 1 0 ""vec"" 1 1 0.0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1728,*morphconstraintupdateangle ,"Description
Updates a model type constraint based on the angle between three nodes. 
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure angle node to node 
1 - Measure angle using vector
mcon
ID of morph constraint
n1
First end of angle
n2
Vertex of angle
n3
Second end of angle
vec
The ID of the vector created using *createvector. Must be set to
            1.
angle
Constrained angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
color
The color of the constraint. Valid values are 1 through  64.

","Example
*morphconstraintupdateangle (SHAPES,1,0,5,21,22,23,1,45.0,0,32)

This command updates a model type constraint for the three selected nodes with the option
        of updating those nodes to be measured in the plane that they lie in or to be perpendicular
        to a vector and the option of having the angle forced to be greater than, less than, or
        equal to the specified angle. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
1729,*morphconstraintupdateavm,"Description
This command updates a model type constraint for the elements on the mark with the option
        of having the area, volume, or mass forced to be greater than, less than, or equal to the
        specified value. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
etype
Must be set to elements.
emark
The ID of the mark containing the elements. Valid values are 1 and 2.
type
0 - Area 
1 - Volume 
2 - Mass
mcon
The ID of morph constraint to update.
target
The constrained value for area, volume, or mass.
bound
-1 - Greater than specified target 
0 - Equal to specified target 
1 - Less than specified target
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a constraint named ""area"" where the area is specified to be exactly 3600:
*morphconstraintupdateavm shapes 1 elements 1 0 5 3600.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1730,*morphconstraintupdateedge ,"Description
This command updates a tangency type constraint either between two edge domains or 2D
        domains or at the end of one edge domain. For the master type, dptr1 is
        the master and dptr2 is the slave. For the slave type,
          dptr2 is the master and dptr1 is the slave. For the
        attached type, dptr1 follows dptr2.
","Inputs

mcon
The ID of morph constraint to update.
dptr1
The ID of the edge or 2D domain.
dptr2
The ID of the edge or 2D domain.
end
The ID of node at fixed end (for fixed type).
type
1 - Fixed (edge domains only) 
2 - Master (edge domains only) 
3 - Slave (edge domains only) 
4 - Continuous 
5 - Attached (edge domains only)
vec
The ID of the vector created using *createvector. Must be set to
            1.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a continuous tangency constraint with ID 5 between domains 12 and 14:
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateedge 5 12 14 1 4 1 44
To update a master tangency constraint with ID 12 where domain 14 is forced tangent to
        domain 12:
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateedge 12 12 14 1 2 1 44
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1731,*morphconstraintupdateeq,"Description
This command will update a constraint for the nodes on the mark which positions the nodes
        on or a specified distance away from the surface of the function. The function can contain
        x, y, and z variables but should not contain an equals sign. The surface of the function is
        located where the value of the function equals zero. The function will be positioned at the
        global origin if meth is set to 0. If meth is set to
        1, oid will specify the origin node and the global system will be used
        for the x, y, and z directions. If meth is set to 2,
          oid will specify the local system to be used for the origin and x, y,
        and z.
type determines if the nodes move along the surface of the function, are
        bounded by the surface of the function, remain a set distance from the surface of the
        function, or maintain their original distance from the surface of the function.
To enable mesh stretching, add 32 to the type (thus 1, 3, and 5 become 33, 35, and 37).
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark containing the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface of the function 
1 - Bounded by the surface of the function 
3 - Remains a set distance from the surface of the function 
5 - Maintains its original distance from the surface of the function 
+32 - Enables mesh stretching around constrained nodes
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
function
String containing a surface definition function f(x,y,z)
distance
Distance nodes must remain away from the surface of the function (type 1 and 3
            only).
ivec
0 - Project normal to function 
1 - Project along vector vector
meth
0 - Use global origin and system 
1 - Use global system with node ID oid as the origin 
2 - Use local system with ID oid as the origin and system
oid
ID of node or system specified in meth.
color
The color of the constraint. Valid values are 1-64. 

","Examples
To update a constraint where all nodes move along the surface of a sphere and are projected
        normal to the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateeq nodes 1 0 12 1 ""x*x+y*y+z*z-100.0"" 0.0 0 0 0 11
To update a constraint where all nodes are bounded by the sphere by a distance of 2.0,
        projected along a vector, and use a local system to orient the sphere:
*createmark nodes 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateeq nodes 1 1 12 1 ""x*x+y*y+z*z-100.0"" 2.0 1 2 1 11
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1732,*morphconstraintupdatelayer ,"Description
This command will update a layer type morphconstraint for the selected nodes such that they
        move relative to the selected elements, effectively mapping nodes in layers to those on the
        selected elements. This option works best for nodes that were created in identical layers,
        such as with the element offset or drag elements functionalities used to create a stack of
        solid elements with a shell mesh. It is intended for use with CFD boundary layer meshes.
The nodes will maintain their original distances relative to the elements when the elements
        are morphed. The nodes will also match the movements of the elements in translation,
        translation and rotation, or be allowed to slide parallel to the normal direction of the
        elements based on the type selected. Also, mesh stretching may be enabled to smooth the
        transition between the constraint and the rest of the mesh.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the nodes to be constrained. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the elements to which the nodes will be constrained. Valid values are 1 and 2.
type
0 - Force inner layers to always be normal to the outer layer 
1 - Allow sliding normal to the outer layer 
2 - Fix only translations between the elements and the layers 
3 - Fix both translation and rotation between the elements and the layers 
+8 - Stretch mesh around the constrained nodes 
+16 - Use ""cfd corners"" method to calculate normals 
morphconstraint_id
The ID of the morphconstraint to be updated.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a layer constraint to be fixed in both rotation and translation
          (type = 3), with mesh stretching enabled (type +8)
        and using the CFD corners method (type +16 for a total of 27):
*createmark nodes 1 ""all""
*createmark elements 1 207 213 217 218 220 221 223 225 226
*morphconstraintupdatelayer nodes 1 elements 1 27 1 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1733,*morphconstraintupdateline ,"Description
This command updates a line type morphconstraint for the selected nodes with the option of
        having those nodes either move along the line or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - moves along the line 
1 - bounded by the line 
3 - remains a set distance from the line 
5 - remains its original distance from the line 
+32 - enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
line
The ID of the line.
dist
The minimum distance from the bounding line.
ivec
0 - The line normal is used for distance and projection. The nodes will be moved
            normally to the line when constraining them or measuring the distance the nodes are away
            from the line. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            line.
color
The color of the constraint. Valid values are 1-64.

","Example
To update a morphconstraint for nodes to move along a line and projected normally to the
        line:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateline nodes 1 0 12 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1734,*morphconstraintupdateplane,"Description
This command updates a plane type morphconstraint for the selected nodes with the option of
        having those nodes either move along the plane or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the plane 
1 - Bounded by the plane 
3 - Remains a set distance from the plane 
5 - Remains its original distance from the plane 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
plane
The ID of the plane created using *createplane. Must be set to
            1.
dist
The minimum distance from the bounding plane.
ivec
0 - The plane normal is used for distance and projection. The nodes will be moved
            normally to the plane when constraining them or measuring the distance the nodes are
            away from the plane.
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a morphconstraint for nodes to move along a plane and projected normally to the
        plane:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*morphconstraintupdateplane nodes 1 0 12 1 1 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1735,*morphconstraintupdatesurf,"Description
This command updates a surface type morphconstraint for the selected nodes with the option
        of having those nodes either move along the surface or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface 
1 - Bounded by the surface 
3 - Remains a set distance from the surface 
5 - Remains its original distance from the surface 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
surface
The ID of the surface.
dist
The minimum distance from the bounding surface.
ivec
0 - The surface normal is used for distance and projection. The nodes will be moved
            normally to the surface when constraining them or measuring the distance the nodes are
            away from the surface. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            plane.
color
The color of the constraint. Valid values are 1-64.

","Example
To update a morphconstraint for nodes to move along a surface and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintupdatesurf nodes 1 0 12 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1736,*morphconvertmv ,"Description
Converts the morph volumes on the mark to hexa elements or vice-versa. 
","Inputs

ctype
HYPERCUBES or ELEMS
cmark
Mark number of morph volumes or elements
han
0 - Do not create handles for morph volumes 
1 - Create handles for morph volumes
ord
Order of morph volumes
tan
0 - No tangency 
1 - Make neighboring morph volume edges continuously tangent
mode
0 - Morph volumes to hexas 
1 - Hexas to morph volumes
nauto
0 - Do not register all nodes found inside morph volumes 
1 - Register all nodes found inside morph volumes

","Example
*morphconvertmv (HYPERCUBES,1,1,1,1,0,1)
This command will either convert the morph volumes on the mark to hexa elements or convert
        the hexa elements on the mark to hypercubes with the given options for handles, order,
        tangency, and node registration. 
Morph volumes will always get converted to second order hexa elements.
","Errors
None.
"
1737,*morphcreatedomainedge,"Description
Creates a domain from node list. 
","Inputs

nodes
Node list number

","Example
*morphcreatedomainedge 1
A new edge domain is created from the node list. The new edge domain will run along the
        nodes in the list sequentially. Handles will be created at the ends of the domain and
        possibly in the middle depending on angles, curvature, and selected portioning options.
","Errors
None.
"
1738,*morphcreateline,"Description
This command is used to create a line from a list of nodes for use with several morphing
        operations.
","Inputs

node_list
The ID of the list containing the nodes. Valid values are 1 and 2.

","Example
To create a line using nodes 534, 538 and 542:
*createlist nodes 2 534 538 542
*morphcreateline 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1739,*morphcreateresultsfile,"Description
Creates and loads a results file named autodv.animate from the
        selected shapes. This file contains a simulation for each shape with a displacement data
        type and is located in the working directory.
","Inputs

entity_type
Must be set to shapes.
mark_id
The ID of the mark containing the shapes. Valid values are 1 and 2.

","Example
To create a results file for the shape shape:
*createmark shapes 1 shape1
*morphcreateresultsfile shapes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1740,*morphdeleteall ,"Description
Deletes all morphing entities. 
","Example
*morphdeleteall ()
Deletes all handles, domains, shapes, symmetries, morph volumes, and morph constraints in
        the model. 
","Errors
None.
",
1741,*morphdeletemvedgenodes,"Description
This command will remove the specified mid-edge nodes which govern the shape of a morph
        volume edge. The edges will then be refit to follow the shape of the remaining nodes, which
        may change the shape of the morph volume. Nodes at the ends of edges may not be deleted and
        will be ignored by this command. The nodes to be removed may be specified either by the
        nodes or the handles on those nodes. Note: Updating the nodes for a morph volume will not
          morph the registered nodes. 

","Inputs

 entity_type
Valid values are nodes or handles.
mark_id
The mark ID containing either nodes or handles. Valid values are 1 and 2.

","Examples
To delete all mid-edge nodes in the model:
*createmark nodes 1 ""all""
*morphdeletemvedgenodes nodes 1
To delete a handle and the underlying node from an edge:
*createmark handles 1 13
*morphdeletemvedgenodes handles 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1742,*morphdisplayconstraintvector,"Description
Draw vector to the screen.
","Inputs

xp
x value of vector base
yp
y value of vector base
zp
z value of vector base
xv
x value of vector distance
yv
y value of vector distance
zv
z value of vector distance
vv
Length of vector
opt
0 - Erase drawn vectors 
1 - Draw vector

","Example
EXAMPLE
*morphdisplayconstraintvector (1.0,2.0,3.0,4.0,5.0,6.0,10.0,1)
A vector is drawn to the screen for the given values. If opt is set to
        0, all vectors are erased. 
For HyperMesh versions 8.0 and higher this command is no longer
        used because constraints now always display.
","Errors
None.
"
1743,*morphdisplaysymmetries ,"Description
Displays dependencies for handles on mark.
","Inputs

entities
Handles or Symmetries
markmask
Handle or symmetry mark number

","Example
*morphdisplaysymmetries (HANDLES,1)
For handles, all handles symmetric to the selected handles are displayed as vectors.
          Note: For symmetry types which link multiple handles, only one handle (the keystone
          handle) will point to the others. The other handles will point back to the keystone
          handle.

For symmetries, all handles linked via the symmetries on the mark are displayed as
        vectors.
If the mark is blank, the vectors are cleared from the screen.
","Errors
None.
"
1744,*morphdomainsetcolor,"Description
This command will set the color of a domain to the specified color.
","Inputs

domain_id
The ID of the domain to update.
color
The color of the domain. Valid values are 1 through 64. 

","Example
To assign color 45 to domain 33:
*morphdomainsetcolor 33 45
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1745,*morphdoshape,"Description
Apply undo, redo, undo all, or redo all.
","Inputs

option
1 - Undo most recent morph 
2 - Redo most recent morph undone 
3 - Undo all morphs 
4 - Redo all morphs

","Example
*morphdoshape (2)
""Morphs"" are applied sequentially to the model and stored in a stack. You can move through
        the stack using the various undo and redo commands to morph and unmorph the model. 
","Errors
None.
"
1746,*morphfitfaces,"Description
This command fits the faces placed on the specified mark (using the
          *morphmanagefacemark command) to the selected nodes or elements by
        sliding them, tilting them, or adjusting the curvature of the faces. The faces can be fit
        through the selected nodes or elements or just moved towards or away from the nodes or
        elements to meet a target buffer percentage (offset). The number of handles per edges of the
        fitted faces can be updated when using this command to get a more precise fit.
","Inputs

fmark
The mark ID of the morph volume faces to be fitted. Valid values are 0, 1, 2 and
            3.
etype
Valid values are nodes and elems.
emark
The mark ID of the nodes or elements to which the faces will be fit. Valid values are 1 and 2.
offset
The target buffer zone value for the nodes or elements inside the morph volumes to be
            met during fitting. When fitting through nodes or elements this value is not used and
            can be set to 0.0.
nproj
0 - Project faces along vector specified by p_vec

1 - Project faces normal to their current orientation
p_vec
The ID of vector used for the projection direction. Must be set to 1.
nhand
Number of mid-handles per edge for each face to be fit. HyperMorph will update the number of mid-handles for each edge if
            necessary. No more than 5 mid-handles can be specified for an edge. To keep the existing
            number of handles per edge, set to -1.
mode
0 - Fit using the buffer zone method (buffer zone is specified using offset). 
1 - Fit through the selected nodes or elements.
method
0 - Slide faces 
1 - Tilt faces 
2 - Fit faces - smooth 
3 - Fit faces - wavy 
4 - Fit faces - approximate
smooth
Amount of smoothness desired for the fitted face. The value of smooth must be between
            0 and 10 inclusive with the higher numbers resulting in smoother faces. This value only
            applies for face fitting, not sliding or tilting.
regnodes
0 - Do not register nodes to morph volumes after fitting faces. 
1 - Register nodes to morph volumes after fitting faces.

","Examples
To slide two faces normally to all the nodes displayed with a buffer of 10% and keeping the
        number of handles constant with a smoothness value of 6 and no registration of nodes:
*morphmanagefacemark 3 0 0 3
*morphmanagefacemark 2 2 0 1
*morphmanagefacemark 3 2 0 1
*createmark nodes 1 ""displayed""
*createvector 1 0.0000 0.0000 0.0000
*morphfitfaces 0 nodes 1 10 1 1 -1 0 0 6 0
To fit two faces smoothly along a vector through all the nodes displayed and enforcing
        three handles per edge with a smoothness value of 4 and registering the nodes:
*morphmanagefacemark 3 0 0 3
*morphmanagefacemark 2 5 0 1
*morphmanagefacemark 3 5 0 1
*createmark nodes 1 ""displayed""
*createvector 1 0.0000 1.0000 0.0000
*morphfitfaces 0 nodes 1 0 0 1 3 1 2 4 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1747,*morphhandlecreatenodes ,"Description
Creates handles at nodes on mark on domain.
","Inputs

nodetype
Nodes
marknode
Node mark number.
dhandletype
Handles
dmarkhandle
Dependent handle mark number.
domainptr
ID of domain.
name
Name of handle(s) to be created.

","Example
*morphhandlecreatenodes (NODES,1,HANDLES,1,1,""bob"")
Handles are created on the specified domain at the nodes on the mark with dependencies on
        the handles on the mark. The handle mark may be empty. 
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
1748,*morphhandlecreatexyz ,"Description
Creates handle at x,y,z, location for the given system. 
","Inputs

dhandletype
Handles
dmarkhandle
Dependent handle mark number.
domainptr
ID of domain.
name
Name of handle(s) to be created.
xx
X coordinate of handle to be created.
yy
Y coordinate of handle to be created.
zz
Z coordinate of handle to be created.
sys
System to create handle in (default = global).

","Example
*morphhandlecreatexyz (HANDLES,1,1,""bob"",1.0,2.0,3.0,3)
 Handle is created on the specified domain at the x, y, and z coordinates for the given
        system with dependencies on the handles on the mark. The handle mark may be empty. 
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
1749,*morphhandlepertxyz,"Description
All handles on the mark will be given a perturbation equal to the x, y, and z values for
        the given system. If symmetry is used, all handles linked to marked handles by symmetry will
        also be perturbed. If constraints are used they will be applied to the perturbations.
","Inputs

entity_type
The type of entity to perturb. Only supported for handles.
mark_id
The ID of the mark containing the handles. Valid values are 1 and 2.
x_val
The X value of the perturbation.
y_val
The Y value of the perturbation.
z_val
The Z value of the perturbation.
system_id
ID of the coordinate system used to determine perturbation direction. To use the
            global system, set this value to 0.
symmetry_flag
0 - Do not use symmetry links. 
1 - Use symmetry links
constraint_flag
0 - Do not use constraints, perform auto qa 
1 - Use constraints, perform auto qa 
2 - Do not use constraints, do not perform auto qa 
3 - Use constraints, do not perform auto qa

","Example
To perturb handles by 2.0 in the x direction, 1.0 in the y direction, and 0.1 in the z
        direction using the global system:
*createmark handles 1 1 2 3 4
*morphhandlepertxyz handles 1 2 1 0.1 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1750,*morphhandleprojectline ,"Description
This command will move each of the selected handles onto the line defined by the lines and
        nodes on the lists along a direction defined by the projection type. Applying symmetry links
        and constraints is optional. All domains influenced by the selected handles will be morphed
        accordingly. 
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions. 
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to other lines in the model. 
Constraints may move the perturbed handles off of the selected line after the handles are
        moved to the line.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
line_list
ID of the line list for line. Valid values are 1 and 2.
node_list
ID of the node list for the line. Valid values are 1 and 2.
nproj
0 - Project along vector proj

1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
Temporary projection vector ID
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a line along a vector:
*createmark handles 1 ""all""
*createmark elems 1
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 0 1 1 1
To project handles to a line normal to the line:
*createmark handles 1 ""all""
*createmark elems 1
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 1 1 1 1
To project handles to a line normal to the elements:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Could not create line from data."" - occurs if insufficient or contradictory line and node
        data are placed on the lists. If multiple lines are selected they should connect and
        selected nodes should be on those lines.
"
1751,*morphhandlerotate,"Description
Rotates handles on mark. 
","Inputs

entities
Handles
markmask
Handle mark number
plane
Mark number of plane defined by base point and vector of rotation.
angle
Angle of rotation
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
vari
Type of rotation (see comments): 
0 - Constant 
1 - Linear

","Example
*morphhandlerotate(HANDLES,1,1,30.0,1,1,0)
All handles on the mark will be rotated about the axis defined by the plane. This command
        differs from *morphrotatetrue() by the behavior of the influenced nodes.
        With this command the nodes follow the handles linearly. 
If vari is 0, all the handles will be rotated by the given angle. If
          vari is 1, the handle farthest from the base point of the plane will be
        rotated by the given angle and the other handles will be rotated by the given angle times
        the distance of each handle to the base point of the plane divided by the distance of the
        farthest handle to the base point of the plane. The distances are measured normal to the
        plane. 
If symmetry is used, all handles linked to marked handles by symmetry will also be rotated.
        If constraints are used, they will be applied to the rotations.
","Errors
None.
"
1752,*morphhandleupdatemulti ,"Description
Updates dependencies for handles on mark. 
","Inputs

handletype
Handles
markhandle
Handle mark number.
dhandletype
Handles
dmarkhandle
Dependent handle mark number.

","Example
*morphhandleupdatemulti (HANDLES,1,HANDLES,2)
Handles on the first mark are updated to be dependent on the handles on the second
        mark.
","Errors
None.
"
1753,*morphhypermorph,"Description
Create shapes with xyz perturbations for handles on mark.
","Inputs

typehand
Handles
markhand
Handle mark number
xi
0 - Do not create x perturbation 
1 - Create x perturbation
yi
0 - Do not create y perturbation 
1 - Create y perturbation
zi
0 - Do not create z perturbation 
1 - Create z perturbation
xx
x perturbation magnitude
yy
y perturbation magnitude
zz
z perturbation magnitude
sys
System to create perturbations in (default = global)
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints

","Example
*morphhypermorph (HANDLES,1,0,0,1,1.0,1.0,5.0,3,1,1)
A shape is created for each handle on the mark for each specified direction at the given
        magnitudes for the specified system. If symmetry is used, all handles linked to marked
        handles by symmetry will also be perturbed. If constraints are used, they will be applied to
        the perturbations. 
","Errors
None.
"
1754,*morphhypermorphvector,"Description
Create shapes in the direction of a vector for handles on mark.
","Inputs

typehand
Handles
markhand
Handle mark number
vec
Vector mark number
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
mag
Magnitude of perturbation

","Example
*morphhypermorphvector (HANDLES,1,1,1,1,5.0)

A shape is created for each handle on the mark in the direction of the specified vector at
        the given magnitude. If symmetry is used, all handles linked to marked handles by symmetry
        will also be perturbed. If constraints are used, they will be applied to the
        perturbations.
","Errors
None.
"
1755,*morphhyperpreviewbezier,"Description
Draws vectors for shapes to be created using morphbeziershape if a shape is being used. 
","Inputs

dtype
Domains
dmark
Domain mark number
shape
ID of shape

","Example
A vector is drawn for each handle on the mark according to the shape. This is used to
        preview the shapes that will be created in the autoshape panel before creating them. If
        symmetry is used, all handles linked to marked handles by symmetry will also be perturbed.
        If constraints are used, they will be applied to the perturbations. 
*morphhyperpreviewbezier (DOMAINS,1,12)
","Errors
None.
"
1756,*morphkrigmanual,"Description
This command will do one of the following things depending on the selected mode: 
Initialize the mesh for manual Kriging
Apply the current handle perturbations to the nodes in the Kriging domains (local
            domains, global domains, and/or morph volumes - see
              *morphupdateparameter krigtype)
Reject the manual Kriging previously applied
Clear the current initialized manual Kriging state.


Initializing must be done before apply can be used. Applying will take the difference
        between the current handle locations and those when the manual Kriging was initialized when
        calculating the Kriging result. Reject will return the mesh to the pre-applied state and
        will only Kork after Kriging has been applied. Reject will allow you to continue Kriging
        from the initialized state. Clearing is not necessary as subsequent calls to
          *morphkrigmanual will clear the memory, but it is recommended to do so,
        if manual Kriging is initialized and not subsequently applied.
","Inputs

mode
0 - Initialize mesh for manual Kriging 
1 - Apply kriging to current handle perturbations 
2 - Reject the applied Kriging and allow continued manual Kriging 
3 - Clear the initialized state from memory

","Examples
To initialize manual Kriging:
*morphkrigmanual 0

 To apply manual Kriging:
*morphkrigmanual 1

To reject (undo) Kriging:
*morphkrigmanual 2

To clear the initialized manual Kriging state:
*morphkrigmanual 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Kriging not set to manual."" - occurs if the Kriging parameter is not set to manual (1
        uninitialized or 2 initialized). Use *morphupdateparameter Kriging 1 to
        set this parameter prior to manual Kriging. 
""No nodes in model."" - occurs during initialization if there are no nodes in the model. 
""No nodes found."" - occurs during applying if there are no initialized nodes.
"
1757,*morphloaddata,"Description
Loads handle and/or shape data from a file. 
","Inputs

morphdatafile
name of data file written using *morphsavedata().
mode
0 - Append to model. 
1 - Overwrite existing entities.
hand
0 - Ignore handles in file. 
1 - Read handles in file.
shape
0 - Ignore shapes in file. 
1 - Read shapes in file.

","Example
Overwriting handles will force the deletion of all handles in the global domain. 
Overwriting shapes will delete all shapes in the model. 
Appending for either handles or shapes will cause any existing handle shape with that name
        to be renamed. The handles and shapes read in will retain their names. 
Appending for handles will create a new global domain.

*morphloaddata (""global.dat"",1,1,1)
","Errors
None.
"
1758,*morphloadshape ,"Description
A shape stored as either grid perturbations (filetype 0) or as a local
        shape (filetype 1) is read in to HyperMesh
        and optionally applied to the model. 
filetype 1 gives you the option of reading the local shapes into
          HyperMesh as elements with the shapes acting on those
        elements. Your can then use *morphtranslateshapemark,
          *morphpositionshapemark, or *morphreflectshapemark
        to apply the shape to the rest of the model. 
filetype 1 requires a value for tolerance, the envelope for shapes to be
        applied to the model if the apply flag is on.
","Inputs

filename
Full name and path of the file containing the shapes.
apply_shapes
0 - Do not apply shapes to model 
1 - Apply shapes to model
filetype
0 - OptiStruct/Radioss
.fem or .grid format, or
              *morphsaveshape ""as grids"" 
1 - *morphsaveshape ""as shapes""
create_elems
0 - Do not re-create elements from file (filetype 1 only) 
1 - Recreate elements from file (filetype 1 only)
tolerance
Envelope for application of local shapes. The envelope is the range of influence that
            an imported shape will have on the new mesh. Since the original mesh (where the shape
            was when the shape file was saved) and target mesh may not match exactly, the envelope
            must be large enough to include nodes that may lie outside the bounds of the original
            mesh were it to be positioned on to the target mesh. Nodes inside the envelope will be
            perturbed proportional to how close they are to the bounds of the original mesh. Set the
            tolerance to -1.0 to use the default value, which is equal to the average length of the
            sides of the elements in the shape. Type in a larger value to capture more nodes within
            the envelope. Similarly, if too many nodes are being affected, try using a smaller
            envelope. You may also use a very large envelope (a million times the size of an average
            element) to make sure that the shape is applied to nearby nodes at full value.

","Example
To load and apply the shapes found in file C:/Temp/save.shp in file
        format 1 using the default tolerance:
*morphloadshape ""C:/Temp/save.shp"" 1 1 0 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1759,*morphmanagefacemark ,"Description
This command allows you to add a face, subtract a face, or clear all faces from a specified
        morph volume face user mark. Because morph volumes can share faces, the morph volume ID for
        the face must also be specified when adding or subtracting a face. When clearing a mark the
        morph volume ID field can hold any value. Since morph volume faces are not treated as
        independent entities, marks containing faces can only be managed through this external
        command. For commands that require face marks as input, this command must be used to place
        faces on the mark. The mark should be cleared before and after use to ensure clean
        operation.
","Inputs

mvol_id
The ID of the morph volume. Can be any value when clearing the mark.
face_id
The ID of the morph volume face.
mlist
The ID of the user mark. Valid values are 0-3.
mode
1 - Add face to mlist

2 - Subtract face from mlist

3 - Clear all faces from mlist

","Examples
To add a face to the mark:
*morphmanagefacemark 2 4 0 1
To clear the first user mark:
*morphmanagefacemark 0 0 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1760,*morphmanualinit ,"Description
Stores the current node locations for the model so that node movements done through any
        means (morphing or otherwise) can be recorded and saved as a morph after using the
          *morphmanualapplyenvelope command. 
Manually morphed nodes can later be undone and redone, or saved as a shape.
","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
None.
",
1761,*morphmapdifference,"Description
This command creates two lines and maps selected nodes from one to the other optionally
        following the curvature differences (rotate) between the lines and/or mapping about an axis
        (axis and plane) or using a number of linear mapping options.
If blend is set to 1, no fixed nodes have been selected, and no mapped
        nodes are a part of any domain, this command will automatically assign all non-mapped nodes
        as fixed nodes.
If blend is set to 2, the blending will only be applied to nodes which
        lie along the mesh between the fixed nodes and the mapped nodes.
The axis option allows you to apply section mapping for sections that
        apply about an axis (option 1). Section lines should lie in one or more radial planes or lie
        in planes normal to the axis of rotation.
The axis option is also used to select the type of projection for the
        nodes to the section lines. This projection determines how the section lines influence the
        nodes. Option 0 projects each node normal to the plane of each section line which is best
        when the lines lie in the same plane. Option 2, the preferred option, approximates the
        section line as a straight line and projects the nodes normal to the line, which is better
        for non-planar lines. Option 3 projects the nodes along a specified vector. Option 4 is like
        Option 2, but the projection line is forced to be in the specified plane, which is better
        for non-planar lines which you want to behave like planar lines. Option 5 does not project
        the nodes to the lines, but instead uses kriging to determine the morphing of the nodes. 
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The mark ID for mapped nodes. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID for fixed nodes. Valid values are 1 and 2.
i_line_list
Line list ID for initial position line. Valid values are 1 and 2.
i_node_list
Node list ID for initial position line. Valid values are 1 and 2.
f_line_list
Line list ID for final position line. Valid values are 1 and 2.
f_node_list
Node list ID for final position line. Valid values are 1 and 2.

r_plane
Plane used for axis of rotation. Valid values are 1 and 2.
rotate
0 - Linear point to point mapping between lines. 
1 - Rotate nodes along with curvature difference between lines
axis
0 - Project nodes to line normal to the plane of the line (preferred) 
1 - Apply mapping about axis defined by r_plane

2 - Project nodes to line normal to the axis of the line 
3 - Project nodes to line along vector (r_plane normal) 
4 - Project nodes to line in plane (r_plane) 
5 - Use kriging to map nodes
sym
0 - Do not use symmetry (only option).
con
0 - Do not use constraints. 
1 - Use constraints
blend
0 - Do not blend unselected nodes. 
1 - Blend all nodes other than mapped and fixed nodes 
2 - Blend only nodes on mesh between mapped and fixed nodes
mbias
Bias factor of mapped nodes.
fbias
Bias factor of fixed nodes.

","Examples
To map nodes from one line to another using rotation:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createlist lines 1 31
*createlist nodes 1
*createlist lines 2 32
*createlist nodes 2
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifference nodes 1 nodes 2 1 1 2 2 1 1 0 0 1 0 1.0 1.0
To map nodes from one line to another about an axis with no rotation, blending through the
        mesh, and biasing factors of 2.0:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createlist lines 1 31
*createlist nodes 1
*createlist lines 2 32
*createlist nodes 2
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifference nodes 1 nodes 2 1 1 2 2 1 1 1 0 1 2 2.0 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Not enough memory."" - occurs if there is not enough memory to complete the command.
"
1762,*morphmapedgestoequationoffset ,"Description
This command maps the handles on the marked morph volume edges to a function along the
        specified vector, equation surface normal, or normal to any attached shell elements (unusual
        for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
equation
String containing an equation f(x,y,z). The equation can contain x, y, and z variables
            but should not contain an equals sign. The surface of the function is located where the
            value of the function equals zero.
origin
0 - Use global origin and system 
1 - Use global system with node ID = origin_id as the origin 
2 - Use local system with ID = origin_id as the origin and
            system
origin_id
The ID of node or system specified in origin. Ignored if origin is
            0.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to surface of equation 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the equation for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Examples
To map edges on mark 0 to an equation (sphere of radius 10) with an offset of 1.2 using the
        global system along a vector leaving the handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestoequationoffset 0 ""x*x+y*y+z*z-100.0"" 0 0 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to an equation (sphere of radius 10) using a local system along the
        line normal with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestoequationoffset 1 ""x*x+y*y+z*z-100.0"" 2 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1763,*morphmapedgestolineoffset,"Description
This command will fit (evenly distribute) or project (along a vector or normal to the line)
        the handles on the marked morph volume edges to a line calculated from the specified lines
        and nodes. If an offset is specified and nproj is not set to 2, the edges
        will be offset from the given line.
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
line_list
The ID of the list containing the input lines. Valid values are 1 and 2.
node_list
The ID of the list containing the input nodes.Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to line 
2 or 12 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target. Not used if project is 2.
The offset will be measured from the closest point on the line for values of project
            of 0 and 1. The offset will be measured along the projection vector normal for values of
              project of 10 and 11.

","Examples
To map edges on mark 0 to a line along a vector with offset of 1.2 and leaving the handles
        unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createlist lines 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestolineoffset 0 1 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to a line along the line normal with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createlist lines 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestolineoffset 1 1 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1764,*morphmapedgestoplaneoffset,"Description
This command will project the handles on the marked morph volume edges to the specified
        plane along the specified vector, plane normal, or normal to any attached shell elements
        (unusual for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
plane_id
The ID of the plane created using *createplane. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id 
1 or 11 - Project normal to surfaces 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the plane for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the plane for values of project
            of 0, 1, and 2. The offset will be measured along the projection vector normal for
            values of project of 10, 11, and 12.

","Examples
To map edges on mark 0 to a plane along a vector with offset of 1.2 and leaving the handles
        unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createplane 1 1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphmapedgestoplaneoffset 0 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to a plane along the plane normal with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphmapedgestoplaneoffset 1 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1765,*morphmapedgestotacitoffset ,"Description
This command will project the handles on the marked morph volume edges to the elements on
        the specified mark along the specified vector, target element normal, or normal to any
        attached shell elements (unusual for morph volume edges).
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
entity_type
Must be set to elems.
mark_id
 The ID of the mark containing the input elements. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to target elements 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces for values of
            project of 0, 1, and 2. The offset will be measured along the projection vector normal
            for values of project of 10, 11, and 12.

","Examples
To map edges on mark 0 to a mark of elements along a vector with offset of 1.2 and leaving
        the handles unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createmark elems 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestotacitoffset 0 elems 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3

To map edges on mark 1 to a mesh along the element normals with 3 mid-handles per edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createmark elems 1 ""all""
*createvector 1 1.0 0.0 0.0
*morphmapedgestotacitoffset 1 elems 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1766,*morphmapnormaloffset,"Description
Offset elements on mark in normal direction.
","Inputs

typeelem
Elems
markelem
Mark number of elements to map
typefix
Nodes
markfix
Mark number of fixed nodes
sym
0 - Do not use symmetry (only option)
con
0 - Do not use constraints 
1 - Use constraints
blend
0 - Do no blend unselected nodes 
1 - Blend nodes between mapped and fixed nodes
offset
Distance to offset elements
umark
0 - Use all elements to calculate normals 
1 - Use selected elements to calculate normals 
2 - Use CFD corners 
Adding 10 to any value use only elements on mark for normal calculation. Otherwise,
            all elements are used.

","Example
*morphmapnormaloffset (ELEMS,1,NODES,1,0,1,0,10.0,1)
If blend is on, no fixed nodes have been selected, and no mapped nodes
        are a part of any domain, this command will automatically assign all non-mapped nodes as
        fixed nodes. 
","Errors
None.
"
1767,*morphmapsections ,"Description
Map elements on mark to section lines.
","Inputs

typeelem
Elems
markelem
Mark number of elements to map
typenode
Nodes
marknode
Mark number of follower nodes
typeline
Lines
markline
Mark number of section lines
typefix
Nodes
markfix
Mark number of fixed nodes
plane
Plane mark number
rotate
0 - L point to point mapping between lines 
1 - Rotate nodes along with curvature difference between lines
blend
0 - Do no blend unselected nodes 
1 - Blend nodes between mapped and fixed nodes
axis
0 - Apply mapping in x, y, z coordinates 
1 - Apply mapping about axis defined by plane
sym
0 - Do not use symmetry (only option)
con
0 - Do not use constraints 
1 - Use constraints

","Example
*morphmapsections (ELEMS,1,NODES,1,LINES,1,NODES,2,1,0,0,0,0,1)
This command maps selected elements to an interpolated cross section given the section
        lines optionally following the curvature differences (rotate) or mapping about an axis (axis
        and plane). 
This command interpolates a number of *morphmapdifference() calls
        between line pairs. The initial lines are found by intersecting a plane normal to each
        section line with the selected elements. Thus, the selected elements should match up closely
        with the selected lines. 
If blend is on, no fixed nodes have been selected, and no mapped nodes
        are a part of any domain, this command will automatically assign all non-mapped nodes as
        fixed nodes. 
","Errors
None.
"
1768,*morphmaptoextendedvecoffset,"Description
Maps nodes to, or offset from, a mark of extended surfaces or elements using the temporary
        shape created by *morphmaptshp and *morphmaptshpedge
        as a guide. Selected handles can optionally follow behind the morphing operation.
Nodes can be projected on to the target extended surfaces or elements along a vector,
        normal to the surfaces or elements, or normal to the shell elements attached to the
        nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
entity_type_map
The type of entity to map to. Valid values are surfs and elems.
mark_id_map
The ID of the mark containing the entities to map to. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links (only option)
use_constraints
0 - Do not use constraints
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id
1 or 11 - Project normal to target surfaces or elements
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new
            influences
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces or elements for
            values of project of 0, 1, and 2. The offset will be measured along the projection
            vector normal for values of project of 10, 11, and 12.

","Example
To map all nodes to extended elements 1-100 with an offset of 1.2 when not using
          *morphmaprecalc():
*createmark nodes 1 ""all""
*createmark elems 1 1-100
*morphmaptoextendedvecoffset nodes 1 handles 1 elems 1 0 1 2 1 1 1.2

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1769,*morphmaptolinevecoffset ,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created
          by *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the input nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
line_list
The ID of the list containing the input lines. Valid values are 1 and 2.
node_list
The ID of the list containing any nodes to define input lines. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target. Not used if project
            is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on mark 1 normal to the lines on list 1 with an offset of 1.2 when not
        using *morphmaprecalc:
*morphmaptolinevecoffset nodes 1 handles 1 1 1 0 1 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1770,*morphmaptonodesnodelistoffset,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains). 
In the map to geom tool, the line used in this command is created from a node list.
","Inputs

list_id_nodes
The ID of the list containing the input nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
node_list_id
The ID of the list containing the target nodes. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 to 11 - Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
offset
The distance to offset nodes from the target. Not used if project
            is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on list 1 normal to a line with ID 23 with an offset of 1.2:
*morphmaptonodesnodelistoffset 1 handles 1 23 0 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1771,*morphmaptosurfacevecoffset,"Description
Maps nodes to, or offset from, the specified plane using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the plane along a vector, normal to the plane, or projected
        normal to the elements touching the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
entity_type_surfaces
Must be set to surfaces.
mark_id_surfaces
The ID of the mark containing the surfaces to map to. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to the surfaces 
2 or 12 - Project normal to shell elements touching nodes
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10, 11 and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Example
To map nodes on mark 1 to surfaces on mark 1 with an offset of 1.2 when not using
          *morphmaprecalc:
*morphmaptosurfacevecoffset nodes 1 handles 1 surfs 1 0 1 2 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1772,*morphmaptshp,"Description
Adds a handle perturbation to the current temporary shape.
","Inputs

hptr
ID of handle.
x
x perturbation of handle
y
y perturbation of handle
z
z perturbation of handle
clear
0 - Add perturbation 
1- Clear temporary shape and add perturbation 
2 - Unapply temporary shape
sym
0 - Do not use symmetry (only option)
con
1 - Use constraints (only option)

","Example
*morphmaptshp (21,1.0,2.0,3.0,0,0,1)
This command is part of the map to geometry function which consists of multiple commands.
        This command is called any number of times, first with clear set to 1,
        then subsequently set to 0, followed either by one of the many
          *morphmapto…() commands. If clear is set to 2 then
        the last *morphmaptshp() command is rejected.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1773,*morphmaptshpface,"Description
This command maps a 2D domain to a plane, a mark of surfaces, or a mark of elements either
        normal to the target or along a vector. When mapping to surfaces or a mesh the option to fit
        the domain to the entities is available.
This command is part of the map to geometry function which consists of multiple commands.
        This command may be called any number of times, first with clear set to
        1, then subsequently set to 0, followed either by one of the many
          *morphmapto... commands. If clear is set to 2 then
        the last *morphmaptshpface command is rejected.
","Inputs

d_entity_type
Must be set to domains.
d_entity_mark
The ID of the mark containing the domains to be mapped. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The ID of the mark containing the elements to which the domains are mapped. Valid values are 1 and 2.
s_entity_type
Must be set to surfaces.
s_entity_mark
The ID of the mark containing the surfaces to which the domains are mapped. Valid values are 1 and 2.
plane
The ID of the plane created using *createplane to which the nodes
            will be projected. Must be set to 1.
nproj
0 - Project along vector given by c_vec

1 - Project normal to geometry 
2 - Project normal to elements of the domain 
3 - Fit to target
c_vec
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
clear
Determine if/how to delete perturbations: 
0 - Add perturbation 
1 - Clear temporary and add perturbation 
2 - Reject last *morphmaptshpface operation
sym
0 - Do not use symmetry
co
1 - Use constraints
type
The type of target to be mapped to: 
2 - Plane 
3 - Surface 
4 - Elements

","Example
To map a 2D domain to a surface using the fitting option:
*createmark domains 2 10
*createmark elements 1
*createmark surfaces 1 3
*createplane 1 1 0 0 0 0 0
*createvector 1 1 0 0
*morphmaptshpface domains 2 elements 1 surfaces 1 1 3 1 1 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1774,*morphnodesequaoffset ,"Description
This command will move the selected nodes to the surface of the function either normal to
        the surface of the function, along a vector, or normal to the elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3, 6 or 7) are stretched according to the value of
          integ.
The function can contain x, y, and z variables but should not contain an equals sign. The
        surface of the function is located where the value of the function equals zero. The function
        will be positioned at the global origin if ori is set to 0. If
          ori is set to 1, oid will specify the origin node
        and the global system will be used for the x, y, and z directions. If ori
        is set to 2, oid will specify the local system to be used for the origin
        and x, y, and z. 
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6, all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes willb e offset from the surface
        of the equation by the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The ID of the mark containing the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID of the fixed nodes. Valid values are 1 and 2.
equation
String containing an equation f(x,y,z).
ori
0 - Use global origin and system 
1 - Use global system with node ID = oid as the origin 
2 - Use local system with ID = oid as the origin and system
oid
ID of node or system specified in ori.
nproj
0 - Project along vector given by c_vec

1 - Project normal to surface of function. 
2 - Project normal to attached shell elements 
5 - Project normal to attached elements using smoothed normals 
6 - Project normal to elements using CFD corners
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor for moving nodes on affected elements.
fbias
Bias factor for fixed nodes on affected elements.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.

","Example
To morph nodes to be offset 1.2 from the surface of a sphere of radius 10.0 normal to the
        surface of the sphere using partitioned edges:
*createmark nodes 1 ""all""
*createmark elems 1 ""all""
*createmark nodes 2 ""all""
*createvector 1 1.0 0.0 0.0
*morphnodesequaoffset nodes 1 elems 1 nodes 2 ""x*x+y*y+z*z-100.0"" 0 0 1 1 4 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1775,*morphnodeslineoffset ,"Description
This command will move the selected nodes to a line. The moving nodes may be projected to
        the line along a vector, normal to the line, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be
          offset from the line by the specified amount.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_line_list
The ID of the line list for the line to which the nodes will be moved. Valid values are 1 and 2.
t_node_list
The ID of the node list for the line to which the nodes will be moved. Valid values are 1 and 2.
m_node_list
The ID of the node list for the moving nodes. Valid values are 1 and 2.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to lines 
2 or 12 - Fit nodes to line
If offset is non-zero, the offset will be measured from the closest
            point on the lines for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. If negative, all nodes beyond a distance calculated by multiplying the total
              perturbation of each moving node by the absolute value of the envelope and extended
              away from each moving node will be fixed.

If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the lines for values of nproj of
            0 and 1. The offset will be measured along the projection vector normal for values of
              nproj of 10 and 11.

","Example
To move a mark of nodes to be offset 1.2 from a line normal to the line and stretch all the
        elements in the model using the existing domains:
*createmark elems 1 ""all""
*createmark nodes 1 21 22 23
*createlist lines 1 2
*createlist nodes 1 31 32
*createlist nodes 2 51 52 53 54
*createvector 1 1.0 0.0 0.0
*morphnodeslineoffset elems 1 nodes 1 1 1 2 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1776,*morphnodesmeshoffset ,"Description
This command will move the selected nodes to a mesh. The moving nodes may be projected to
        the mesh along a vector, normal to the mesh, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6 all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_entity_type
Must be set to elems.
t_mark_id
The mark ID of the target elems. Valid values are 1 and 2.
nproj
0 or 10 - Project normal to vector 
1 or 11 - Project along c_vec

2 or 12 - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 to 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the mesh for values of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the target mesh for values of
              nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes to be offset 1.2 from a mesh normal to the mesh and stretch all the
        elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 1-100
*createmark nodes 2 21 22 23
*createmark elems 2 101-200
*createvector 1 1.0 0.0 0.0
*morphnodesmeshoffset nodes 1 elems 1 nodes 2 elems 2 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1777,*morphnodesnormalenvelope,"Description
This command will move the selected nodes the specified distance normal to the selected
        elements. The fixed nodes are held in place and the affected elements (or all unfixed nodes
        in the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3 then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected
        elements and the 2D domains are partitioned. Any handles created due to partitioning are
        moved based on their distance from the moving and fixed nodes. If integ
        is 6, then handle influences are applied using the Kriging algorithm. If
          integ is 7, then handle influences extend only up to a given distance
        (if envelope is positive) or a given multiple of the applied
        perturbations (if envelope is negative) away from the moving nodes.
If 100 is added to the value of integ, the normals of the elements
        selected for determining the direction of morphing will be averaged with their neighbors,
        resulting in a smooth distribution of vectors around sharp corners.
If 200 is added to the value of integ, the normals of the elements
        selected for determining the direction of morphing will be calculated using the ""CFD
        corners"" method, resulting in a very smooth distribution of vectors around sharp corners
        which should prevent mesh folding.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
n_entity_type
Must be set to elems.
n_mark_id
The mark ID of the element used to determine the normal direction. Valid values are 1 and 2.
dist
The distance the nodes will be moved.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes 
+100 - Smooth the calculated element normals by averaging 
+200 - Use the ""CFD corners"" method to calculate the normals
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing

","Example
To move a mark of nodes normal to their attached elements by 5 units and stretch all the
        elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createmark elems 2 ""all""
*createvector 1 1.0 0.0 0.0
*morphnodesnormalenvelope nodes 1 elems 1 nodes 2 elems 2 5.0 1 1.0 1.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1778,*morphnodesrotateenvelope,"Description
This command will rotate the selected nodes by a given angle about the specified axis. The
        fixed nodes are held in place and the affected elements (or all unfixed nodes in the model
        if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
r_plane
The ID of the plane created using *createplane about which the
            nodes will be rotated. Must be set to 1.
angle
The angle of rotation in degrees.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. If negative, all nodes beyond a distance calculated by multiplying the total
              perturbation of each moving node by the absolute value of the envelope and extended
              away from each moving node will be fixed.
If integ is set to
              7, the calculated distance defines an envelope around the moving nodes within which
              the morphing of those nodes will linearly taper from fully matching the nearest moving
              node to zero at the edge of the envelope. If any fixed nodes are within the envelope
              they will also reduce the morphing of nearby nodes.

undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled:
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing

","Example
To rotate a mark of nodes 45 degrees and stretch all the elements in the model using the
        existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createplane 1 1.0 0.0 0.0 1.0 0.0 0.0
*morphnodesrotateenvelope nodes 1 elems 1 nodes 2 1 45.0 1 1.0 1.0 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1779,*morphnodessurfoffset,"Description
This command will move the selected nodes to the specified surfaces. The moving nodes may
        be project to the surfaces along a vector, normal to the surfaces, or normal to any elements
        attached to the nodes. The fixed nodes are held in place and the affected elements (or all
        unfixed nodes in the model if integ is 3 or 6) are stretched according to
        the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6 all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
s_entity_type
Must be set to surfaces.
s_entity_mark
The mark ID of the target surfaces. Valid values are 1 and 2.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to target mesh 
2 or 12 - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0, 1, 2, 5 and 6. The offset will be measured along
            the projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the
            morphing of nearby nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the surfaces for values of
              nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes to be offset 1.2 from a surface normal to the surface and stretch
        all the elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createmark surfs 1 1
*createvector 1 1.0 0.0 0.0
*morphnodessurfoffset nodes 1 elems 1 nodes 2 surfs 1 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1780,*morphnodesvectoroffset ,"Description
This command will move the selected nodes to a line extending from
          a_node to b_node and extrapolated to infinity in
        both directions. The moving nodes may be projected to the line a long a vector, normal to
        the line, or normal to any elements attached to the nodes. The fixed nodes are held in place
        and the affected elements (or all unfixed nodes in the model if integ is
        3 or 6) are stretched according to the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements, but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is positive) or a given
        multiple of the applied perturbations (if envelope is negative) away from
        the moving nodes.
The bias factors function as they would for handles, except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6, all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
a_node
The ID of the base node for the vector onto which the nodes will be projected.
b_node
The ID of the pointer node for the vector onto which the nodes will be projected.
nproj
0 or 10 - Project along vector given by c_vec
1 or 11 - Project normal to target mesh 
2 or 12  - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point along the target vector for values of 0, 1, 2, 5 and 6. The offset will be
            measured along the projection vector or normal for values of 10, 11, 12, 15, and
            16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope, they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point along the target vector for values
            of nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes normal and offset 1.2 from a vector defined by nodes 52 and 53 and
        stretch all the elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createvector 1 1.0 0.0 0.0
*morphnodesvectoroffset nodes 1 elems 1 nodes 2 52 53 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1781,*morphorganizedomainsplit ,"Description
Splits edge domain at given node.
","Inputs

node
ID of node.
dptr
ID of domain.

","Example
*morphorganizedomainsplit 12 32
This command splits the given edge domain into two edge domains at the given node.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1782,*morphpositionshapemark,"Description
This command will position the shapes on s_mark_id from an orientation
        defined by n1, n2, and n3 to an
        orientation defined by n4, n5, and
          n6, scale them in the x, y, and z directions using either the local or
        global system, and affect only the nodes on a_mark_id. The shapes may be
        applied to the mesh, created as new shapes, added to existing shapes, or may replace
        existing shapes.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The mark ID of the shapes. Valid values are 1 and 2.
a_entity_type
Must be set to nodes.
a_mark_id
The mark ID for target nodes. Valid values are 1 and 2.
n1 n2 n3
IDs of nodes defining initial position of shape.
n4 n5 n6
IDs of nodes defining final position of shape.
xs ys zs
Scaling factors for the shapes in the x, y, and z directions.
mode
0 - Apply each shape to the mesh 
1 - Apply each shape and add the perturbations to the original shape 
2 - Apply each shape and overwrite the original shape 
3 - Apply each shape and create a new shape or shapes 
4 - Create a new shape or shapes but do not apply them to the mesh
scale
0 - Do not scale shapes 
1 - Scale shapes
tol
The ""envelope"" or distance around the translated shape inside which nodes are
            affected.
system_id
ID of system used for scaling factors.
0 - Global 
con
0 - Do not use constraints 
1 - Use constraints

","Examples
To position a shape from one part of the mesh to another and apply it to the mesh:
*createmark shapes 1 1
*createmark nodes 2 ""all""
*morphpositionshapemark shapes 1 nodes 2 11 12 13 21 22 23 1.0 1.0 1.0 0 0 3.0 0 1
To position all shapes from one part of the mesh to another, double them in size, and
        create new shapes, but only on selected nodes:

*createmark shapes 1 ""all""
*createmark nodes 2 1 2 3 4 5 6 7 8 9 10 11 12
*morphpositionshapemark shapes 1 nodes 2 11 12 13 21 22 23 2.0 2.0 2.0 4 1 3.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""The original set of nodes do not define a plane."" - occurs if n1, n2, and n3 are collinear 
""The new set of nodes do not define a plane."" - occurs if n4, n5, and n6 are collinear
"
1783,*morphrecalculateconstraints,"Description
Recalculates out-of-date morph constraints.
This may be necessary either because they have been edited or because the entities they
        reference have been changed. Once recalculated, the morph constraints will be applied to the
        model with respect to the current state of the model rather than a previous state.
HyperMorph keeps track of which morph constraints need to be recalculated and recalculates
        them at the appropriate times. However, HyperMorph may call this command as part of internal
        calculations and so it may get written out to the command file. Thus, scripts which emulate
        steps taken from the command file should contain this command in order to ensure proper
        execution.
","
Inputs


type
0 - Recalculate all morph constraints
1 - Recalculate only pinned type constraints
2 - Recalculate only tacit type constraints
3 - Recalculate only pinned and tacit type constraints
4 - Recalculate only CFD type constraints
5 - Recalculate only CFD and pinned type constraints
6 - Recalculate only CFD and tacit type constraints
7 - Recalculate only CFD, pinned, and tacit type constraints
8 - Recalculate only match type constraints
9 - Recalculate only match and pinned type constraints
10 - Recalculate only match and tacit type constraints
11 - Recalculate only match, pinned, and tacit type constraints
12 - Recalculate only match and CFD type constraints
13 - Recalculate only match, CFD, and pinned type constraints
14 - Recalculate only match, CFD, and tacit type constraints
15 - Recalculate only match, CFD, pinned, and tacit type constraints

","Examples
Recalculate all morph constraints in the model:
*morphrecalculateconstraints 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1784,*morphregistergeometry,"Description
This command allows you to control which geometric entities can be morphed and which type
        of morphing affects them. Currently only the geometry associated with point and line
        connectors can be morphed and they can only be morphed by morph volumes. Area connectors
        cannot be morphed nor can line and surface entities, and morphing operations that do not
        involve morph volumes will not affect any geometric entities.
Connectors should be reregistered whenever their relative positions inside the morph
        volumes change, such as, if they are translated and the morph volumes are not. This will
        ensure that they are not reverted to their previous locations inside the morph volumes when
        those morph volumes are morphed. Note that any registered connectors are automatically
        reregistered if morph volumes are made “inactive,” morphed, and then made “active”
        again.
When the morphing of connectors is saved as a shape, applying the shape will morph those
        connectors even if the morph volumes have been deleted or the connectors have been
        unregistered. Shapes saved along with the model file will still affect connectors when the
        file is reloaded. However, shapes written using *morphsaveshapeand read
        using *morphloadshape will no longer affect connectors.
","
Inputs


entity_type
The type of entity to register.  Must be set to connectors.
mark_id
The ID of the mark of entities to register.  Valid values are 1 and 2.
mode
Registers and unregisters connectors.  If any part of a line or point connector is
            registered to the morph volumes and are within a morph volume, they will be morphed
            along with the morph volumes, while unregistered connectors will be unaffected.
0 - Register connectors on mark_id and unregister connectors not on
              mark_id
1 - Register connectors on mark_id
2 - Unregister connectors on mark_id
3 - Reregister all registered connectors (mark_id is not used)
target
1 - Morph volumes

","Examples
Update all connectors in the model to be registered to morph
        volumes:*createmark connectors 1 all
*morphregistergeometry connectors 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1785,*morphremoveconstraint ,"Description
Remove constraint(s). 
","Inputs

nodetype
Nodes or morphconstraints 
marknode
Node or morphconstraint mark number.
option
0 - Remove nodes on mark from morph constraints. 
1 - Remove morph constraints on mark. 
2 - Remove all morph constraints.

","Example
*morphremoveconstraint (NODES,1,1)
If option is 0, any constraints on the nodes on the mark are removed. 
If option is 1, all constraints are removed. Note: The options have
          changed from HyperMesh versions prior to 8.0.

","Errors
None.
"
1786,*morphreparam ,"Description
Reparameterizes domains on the mark.
","Inputs

domaintype
Domains
markdomain
Domain mark number.

","Example
*morphreparam (DOMAINS,1)
Domains on the mark are reparameterized, which means that the influence coefficients for
        the nodes within that domain are recalculated for the handles on the domain. 
This command will trigger the update of any existing shapes which are affected by the
        recalculation.
","Errors
None.
"
1787,*morphsavedata ,"Description
Saves global handles and shapes to a file. 
","Inputs

morphdatafile
Name of file to be written.

","Example
*morphsavedata (""global.dat"")
Global handles and all shapes that use global handles are written to the specified file in
          ASCII format.
","Errors
None.
"
1788,*morphsaveshape ,"Description
Reads local shapes stored in the specified file. 
","Inputs

stype
Shapes
smark
Mark number of shapes.
savefile
Name of file to be saved.
filetype
0 - Grid IDs and perturbations 
1 - Grids, elements, and perturbations

","Example
*morphsaveshape (SHAPES,1,""morphing.shp"",1)

Saves the shapes on the mark as either nodes and perturbations
        (filetype=0), or as nodes, node perturbations, and elements
          (filetype 1). 
Shapes saved as filetype =0 will be saved in the same format as OptiStruct shape variables. 
Shapes saved as filetype =1 can later be read in and applied to a file
        with a completely different mesh with the saved shapes being applied to the nearest nodes in
        the new model. The saved shapes can also be read in as their original elements and
        perturbations (see *morphloadshape). 
","Errors
None.
"
1789,*morphsetactive ,"Description
Sets an active parameter for either morph constraints or symmetries.
","Inputs

etype
Symmetries or morphconstraints 
emark
Mark number.

","Example
*morphsetactive (SYMMETRYS,1)
All entities of the type selected on the mark will be set to active. Non-selected entities
        will be set to inactive. 
","Errors
None.
"
1790,*morphsetsmoothtests ,"Description
Sets the element test criteria used for shape combination checking via
          *morphshapesmooth. 
This command allows you to edit the element test criteria for shape combination checking
        used by the *morphshapesmooth command. You can make every supported test
        active or inactive for each of the six basic element types (trias, quads, tetras, pyras,
        pentas, and hexas) as well as set any thresholds for the warning, error, and invalid limits.
        Currently only aspect ratio, skew, minimum angle, maximum angle, warpage, tetra collapse,
        and jacobian tests are supported. 
","Inputs

mode
0 - Set all element tests to be inactive 
1 - Set all element tests to the default values 
2 - Set one individual test to be active or inactive and set limits for the test

","Example
To clear all tests and then assign values of 0.3, 0.2, and 0.1 for quad element
        Jacobian:
*morphsetsmoothtests 0 0 0 0 0.0 0.0 0.0
*morphsetsmoothtests 2 1 1 6 0.3 0.2 0.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1791,*morphshapeapplynodes ,"Description
Applies the shapes on the mark to only the selected nodes.
","Inputs

shtype
Shapes
shmark
Shape mark number.
ntype
Nodes
nmark
Node mark number.
mult
Multiplier to applied shapes.

","Example
*morphshapeapplynodes (SHAPES,1,NODES,1,2.0)
Shapes on the mark are applied to the model consecutively and scaled up or down by the
        multiplier. Shapes will only be applied to the selected nodes.
","Errors
None.
"
1792,*morphshapecreatecolorsystem,"Description
The specified shape will be created representing the difference between the current node
        and handle positions and the original node and handle positions.
If a shape is created which references a coordinate system the shape will be applied
        relative to that coordinate system when it is applied to the model. This can be very useful
        for circular shapes such as arc angle changes since shapes can be created for them which
        reference a cylindrical coordinate system and allow for fractional applications of those
        shapes to be relative to the system. For example, if an arc angle change of 60 degrees is
        created as a shape referencing a cylindrical system and it is applied with a multiplier of
        0.5, the result would be an arc angle change of 30 degrees with the nodes moving along their
        correct tangential paths. For shapes which reference rectangular coordinate systems their
        nodes will always move linearly as a factor of the multiplier and thus will not rotate about
        an axis, even if the shape was originally created using a rotational morphing method.
was originally created using a rotational morphing method. Saving as handle and node
        perturbations will try to save everything done as handle perturbations except where biasing
        factors have changed and constraints have been applied. Saving as pure node perturbations
        will save the shape exclusively as node perturbations. The difference comes into play when
        new handles are created. If a shape is saved as handles & nodes, a new handle will not
        move when the shape is applied, possibly changing the shape. If a shape is saved as pure
        nodes, a new handle will move along with its grid.
Saving as node perturbations without global handle nodes (option 2) will save the shape as
        node perturbations excluding the node perturbations for global handles.
","Inputs

name
The name of the shape.
option
The shape's save options. Valid values are:
0 - Save as handle and node perturbations 
1 - Save as pure node perturbations 
2 - Save as node perturbations without global handle nodes


color
The shape's color. Valid values are 1-64.
system_id
The ID of the reference system to use.

","Example
To create a shape with a specified color and system:
*morphshapecreatecolorsystem ""groovy"" 0 15 3
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:
if { [ catch {*morphshapecreatecolorsystem...} ] } {
   # Handle error
}
"
1793,*morphshapecreateorthogonal ,"Description
This command will convert all the shapes on the first mark into shapes, design variables,
        equations, and dlink2 entities when using the constraint and system
          methods. For the mid-shape v, only one shape may be
        converted at a time and each mark should contain one and only one unique shape.
For the constraint method, a non-linear shape will be deduced by applying each shape on
          the s_mark_id by a number of factors from 0.0 to 1.0 equal to the value
        of prec, enforcing any active constraints, and fitting a curve through
        the intermediate positions for each node.
For the mid-shape method, a non-linear shape will be deduced by fitting a shape through a
        curve beginning at the unperturbed position, traveling through the position attained when
        the shape on the md_mark_id is applied, and ending at the position
        attained when the shape on the s_mark_id is applied.
For the system method, each shape on s_mark_id will be assumed to rotate
        about the z-axis of the selected system instead of moving linearly in the xy plane. A
        non-linear shape will be deduced from the circular node paths.
For all methods, the non-linear paths of the nodes are represented by a
        pair of linear shape variables, plus a corrective shape variable, which are linked together
        via equations and dlink2 entities. The result is a single design variable which, when
        changed, applies the linear shape variables in such a way that the nodes move along
        non-linear paths.
For the constraint and system methods, if multiple shapes are selected,
        conflicts between each pair of shapes (such as when the application of one shape causes
        another to violate constraints) are detected and resolved by adding a corrective shape which
        is linked to those two shapes through an equation and a dlink2 entity.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The ID of the mark containing the shapes. Valid values are 1 and 2.
md_entity_type
Must be set to shapes.
mdmark
The ID of the mark containing the mid-shapes (for mid-shape method). Valid values are 1 and 2.
system_id
The ID of the system about which shapes are defined (for system method).
method
0 - non-linearity is due to constraints 
1 - non-linearity is deduced from mid-shape 
2 - non-linearity is due to rotation about a system
prec
Number of intermediate positions for non-linear approximation.
tol
Tolerance for establishing linear versus non-linear.

","Examples
To create non-linear shapes, equations, etc., for all the shapes in the model using the
        constraint method:
*createmark shapes 1 ""all""
*morphshapecreateorthogonal shapes 1 shapes 1 0 0 10 0.001
To create non-linear shapes, equations, etc., for shape ""full"" using shape ""mid"" as the
        mid-shape:
*createmark shapes 1 ""full""
*createmark shapes 2 ""mid""
*morphshapecreateorthogonal shapes 1 shapes 2 0 1 10 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1794,*morphshapelinkedapply ,"Description
This command will apply all the shapes on an internal list (generated by using the
          *morphshapelinkedpush command) at their stored multiplier values. It will also
        apply any shapes linked to the applied shapes via desvar, deqatn, and dlink2 cards, such as
        those created during non-linear design variable generation. The shapes will be applied to
        only the nodes on the specified mark. This command will clear the internal list of shapes
        and multipliers created using the *morphshapelinkedpush command.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the affected nodes. Valid values are 1 and 2.

","Example
To apply the stored shapes and linked shapes to all of the nodes in the model:
*createmark nodes 1 ""all""
*morphshapelinkedapply nodes 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1795,*morphshapepreview,"Description
Applies (with a multiplier of one) or unapplies selected shapes.
","
Inputs



entity_type

Must be set to shapes.

mark_id

The ID of the mark containing the shapes.  Valid values are 1 and 2.

mode

0 - Unsets the preview flag and unapplies the shape for shapes which have their
            preview flag set
1 - Sets the preview flag and applies the shape for shapes which have their preview
            flag unset
2 - Toggles the preview flags and applies or unapplies the shapes be set to
            shapes

","Examples
To set the preview flag for three shapes and apply them to the model:
*createmark shapes 1 11 12 13
*morphshapepreview shapes 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1796,*morphshapeupdatecolor ,"Description
Updates the color of a shape.
","Inputs

shape
ID of shape.
color
Integer between 0 and 63 inclusive.

","Example
*morphshapeupdatecolor (1,15)

 The color of the specified shape will be set to the new color. 
","Errors
None.
"
1797,*morphsmooth,"Description
Applies smoothing to selected domains.
","Inputs

dtype
Domains
dmark
Domain mark number.
method
The smoothing method to use:
1 - Autodecide 
2 - Size corrected 
3 - Shape corrected 
4 - Angle corrected 
5 - QI optimized


iter
Number of iterations of smoothing (methods 1-4 only).

","Example
*morphsmooth (DOMAINS,1,3,10)
This command applies the specified smoothing method to the selected domains as a morph.
        Thus, it can be undone or redone.
","Errors
None.
"
1798,*morphsplitmorphvolumes ,"Description
Splits the morph volumes in the model given the specified morph volume edge.
","Inputs

n1
ID of first end node of morph volume edge.
n2
ID of second end node of morph volume edge.
split
If > 1.0: number of splits 
If < 1.0: position along edge for split
hand
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
tangent
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent.

","Example
*morphsplitmorphvolumes (21,22,2.0,1,1)

 This command will propagate one or more splits along the specified morph volume edge
        through the entire morph volume ""matrix"" so that it remains consistent. 
Newly formed morph volumes can optionally have handles and tangency automatically applied. 
The higher the value of 'split' (if less than 1.0), the closer to n2 the split will
        occur.
","Errors
None.
"
1799,*morphstorematch ,"Description
This command allows you to predetermine which domains match with which surfaces when using
        the *morphfittosurface command and the one to one mapping option. There
        are two ways to use this command, one is to call it for each pair of domains and surfaces,
        passing in the IDs to store as matches; the other is to call it once and automatically match
        all the overlapping domains and surfaces in pairs. In the case of matching domains to
        surfaces automatically, a domain’s nodes must be associated to a surface for a match to be
        registered.
","Inputs

domain_id
ID of a 2D domain to map to a surface.
surface_id
ID of a surface to map to a 2D domain.
mode
0 - Clear the current list of matching domains and surfaces 
1 - Add the given domain and surface pair to the current list 
2 - Clear the list and fill it with all overlapping domain and surface pairs

","Example
To set the fitting list to have three pairs of domains and surfaces:
*morphstorematch 0 0 0
*morphstorematch 2 4 1
*morphstorematch 3 5 1
*morphstorematch 4 11 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1800,*morphsubdivide,"Description
Subdivides selected 3D domains.
","Inputs

dtype
Domains
dmark
Domain mark number of domains to be subdivided.
ftype
Domains
fmark
Domain mark number of divisible domains.
rethand
0 = do not retain handles 
1 = retain handles

","Example
*morphsubdivide (DOMAINS,1,DOMAINS,2,1)
This command subdivides the selected 3D domains into smaller domains while refraining from
        dividing any attached 2D domains that are not specified as being divisible. 
It is possible for 3D domains to be shaped in such a way that it is impossible to subdivide
        them without dividing 2D domains that aren't specified as being divisible. In this case the
        command will complete without the domain being subdivided. 
","Errors
None.
"
1801,*morphsymmetrycreateaxis ,"Description
Creates symmetry dependent on system.
","Inputs

name
Name of symmetry.
sysptr
ID of system.
domaintype
Domains
markdomain
Domain mark number.
enforce
0 = approximate 
1 = enforced
multilat
0 = unilateral 
1 = multilateral
type
Type of symmetry.
ucyc
Number of cycles for cyclical symmetry.
orient
0 = default 
1 = x-axis 
2 = y-axis 
3 = z-axis
mv
0 = do not apply to morph volumes 
1 = apply to morph volumes

","Example
*morphsymmetrycreateaxis (""mirror"",2,DOMAINS,1,1,1,10,3,1,0)

Creates a symmetry dependent on the specified system for the domains on the mark. The
        symmetry has the values given in ‘enforce’, ‘multilat’, type, ucyc, orient, and mv.
","Errors
None.
"
1802,*morphsymmetryupdateaxis,"Description
Update one symmetry.
","Inputs

symptr
ID of symmetry.
sysptr
ID of system.
domaintype
Domains
markdomain
Domain mark number.
enforce
0 = approximate 
1 = enforced
multilat
0 = unilateral 
1 = multilateral
type
Type of symmetry.
ucyc
Number of cycles for cyclical symmetry.
orient
0 = default 
1 = x-axis 
2 = y-axis 
3 = z-axis
mv
0 = do not apply to morph volumes 
1 = apply to morph volumes

","Example
*morphsymmetryupdateaxis (3,11,DOMAINS,1,1,1,10,3,0,0)

Symmetry will be updated to specified system and values. All domains on mark will be
        updated to use the selected symmetry. 
","Errors
None.
"
1803,*morphtranslateshapemark,"Description
This command will translate each shape on the mark by a vector measured from the basenode
        to each node on n_mark_id and affect only the nodes on
          a_mark_id. The shapes may be applied to the mesh, created as new
        shapes, added to existing shapes, or may replace existing shapes.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The mark ID of the shapes. Valid values are 1 and 2.
n_entity_type
Must be set to nodes.
n_mark_id
The mark ID for the translate final position nodes. Valid values are 1 and 2.
a_entity_type
Must be set to nodes.
a_mark_id
The mark ID for target nodes. Valid values are 1 and 2.
base_node_id
ID of the base node for translate initial positions.
mode
0 - Apply each shape to the mesh 
1 - Apply each shape and add the perturbations to the original shape 
2 - Apply each shape and overwrite the original shape 
3 - Apply each shape and create a new shape or shapes 
4 - Create a new shape or shapes but do not apply them to the mesh
tol
The ""envelope"" or distance around the translated shape inside which nodes are
            affected.
con
0 - Do not use constraints 
1 - Use constraints 

","Examples
To translate a shape from one node to another and apply it to the mesh:
*createmark shapes 1 1
*createmark nodes 1 12
*createmark nodes 2 ""all""
*morphtranslateshapemark shapes 1 nodes 1 nodes 2 11 0 3.0 1
To translate all shapes from one node to another and create new shapes, but only on
        selected nodes:
*createmark shapes 1 ""all""
*createmark nodes 1 12
*createmark nodes 2 1 2 3 4 5 6 7 8 9 10 11 12
*morphtranslateshapemark shapes 1 nodes 1 nodes 2 11 4 3.0 1

","Errors
Incorrect usage of *morphtranslateshapemark results in a Tcl error. To detect errors, you
        can use the catch
        command:if { [ catch {*morphtranslateshapemark shapes 1 nodes 1 nodes 2 11 0 3.0 1} ] } {
# Handle error
}

"
1804,*morphupdatedisplay ,"Description
Updates the display of morphing entities.
","Inputs

type
0 = all morphing entities 
1 = global handles and domains 
2 = local handles and domains 
3 = morphvolumes 
4 = morphconstraints 
5 = symmetries 
6 = shapes
mode
0 = turn off 
1 = turn on 
2 = turn on only for entities on displayed elements 

","Example
*morphupdatedisplay (0,0)
Note that if the type is set to zero (all morphing entities) the mode will be the same for
        all types.
","Errors
None.
"
1805,*morphupdatedomains ,"Description
Updates global domains.
","Inputs

mode
Always 0 global domains.

","Example
*morphupdatedomains (0)
This command updates any global domains which are not assigned any nodes (those created
        with versions of HyperMesh prior to 8.0) to be assigned all the
        nodes in the model. 
","Errors
None.
"
1806,*morphupdateendcondition ,"Description
Updates the end condition of one or two morph volume edges.
","Inputs

n1
Node at end of first edge.
n2
Node between first edge and second edge.
n3
Node at end of second edge (if necessary).
x
X component of vector for end direction
y
Y component of vector for end direction
z
Z component of vector for end direction
mode
0 = free 
1 = set to vector 
2 = master-slave tangency 
3 = slave-master tangency 
4 = continuous tangency

","Example
*morphupdateendcondition (21,22,23,1.0,0.0,0.0,1)
This command either frees the specified edge end, sets the direction of the edge end equal
        to the given vector, or enforces a tangency condition between two edges. The end of an edge
        which is affected by this command is marked by n1. 
","Errors
None.
"
1807,*morphupdatemvedgenodes ,"Description
Updates the mid-nodes of the specified morph volume edge.
","Inputs

nodes
Mark number of node list.
hand
0 = do not create handles for morph volumes 
1 = create handles for morph volumes

","Example
*morphupdatemvedgenodes (1,1)
This command changes the nodes for a given morph volume edge to be those of the node list.
        The first and last nodes on the node list should be the original end nodes of the morph
        volume edge.
","Errors
None.
"
1808,*morphupdatemvols ,"Description
Updates morph volumes on mark.
","Inputs

ctype
 Hypercubes
cmark
Mark number of morph volumes.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent

","Example
*morphupdatemvols (HYPERCUBES,1,1,1,1)
This command updates the order, handles, and tangency of the morph volumes on the mark. 
The order of the morph volumes (ord) refers to the number of mid-nodes along each edge with
        an order of one meaning there will be no mid-nodes, an order of two meaning that there will
        be one mid-node, and so forth.
","Errors
None.
"
1809,*morphupdateparameterstring,"Description
This command updates string morphing parameters.
","Inputs

parameter
The parameter of interest. Valid parameters are: 
iressimu: name of the simulation used in FEA results plotting 
iresdata: name of the data type used in FEA results plotting
value
The new value of the parameter.

","Example
To update the name of the FEA simulation for plotting:
*morphupdateparameterstring iressimu ""Cantilver loading""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1810,*morphvolumeconnect ,"Description
Joins the specified morph volumes. 
","Inputs

hcube1
ID of first morph volume.
hcube2
ID of second morph volume.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
mode
0 = join hcube2 to hcube1

1 = join hcube1 to hcube2

2 = join at midpoint
nauto
0 = do not register all nodes found inside morph volumes 
1 = register all nodes found inside morph volumes

","Example
*morphvolumeconnect (21,22,1,1,1)
This command will join the specified morph volumes provided that the process does not make
        the morph volume ""matrix"" inconsistent. Newly combined morph volumes can optionally have
        tangency automatically applied.
","Errors
None.
"
1811,*morphvolumecreateflex,"Description
This command will create one or more morph volumes starting from a profile defined by morph
        volumes, elements, lines, x-y densities, or rho-theta densities, and dragging them along a
        line, a nodelist, along a vector, about an axis, or through the element or nodes on the
        mark. It can also be used to generate a morph volume matrix using the global system or a
        local system although profile shrinking is not available for this option. 
After generation the matrix will be enlarged to fit the selected nodes or elements if the
        initial drag does not contain them. Thus, the edges of the morph volumes may not fit the
        initial profile or be limited by the specified drag distance or angle. 
Profile shrinking will shrink each profile along the drag direction in order to fit the
        morph volume matrix close to the mesh taking into account the specified buffer zone
        value.
","Inputs

e_entity_type
Valid values are nodes and elems.
e_mark_id
The ID of the mark containing the nodes or elements. Valid values are 1 and 2.
xd
Density of the profile mesh in the x or radial direction (for off-axis profiles, the x
            direction is the direction closest to either the global x axis or the global y axis if
            the global x axis is parallel to the drag direction).
yd
Density of the profile mesh in the y or tangential direction.
zd
Density of the morph volume matrix in the dragged direction.
buff
Percentage buffer zone between matrix and enclosed entities.
system_id
ID of system used to orient matrix (method 0). If the specified system is cylindrical,
            the matrix will be laid out in a cylindrical fashion.
han
0 - Do not create handles for morph volumes 
1 - Create handles for morph volumes
order
The order of morph volumes: 
1 - No mid-edge handles 
2 - One mid-edge handle 
3 - 6 - Two to five mid-edge handles
tan
0 - No tangency 
1 - Make neighboring morph volume edges continuously tangent
m_entity_type
Valid values are hypercubes and elems.
m_mark_id
The ID of the mark containing the hypercubes or elements for the profile. Valid values are 1 and 2.
a_lines_list
The ID of the list containing the lines used to create line to drag matrix. Valid values are 1 and 2.
a_points_list
The ID of the list containing the nodes used to create line to drag matrix. Valid values are 1 and 2.
m_lines_list
The ID of the list containing the lines used to create the profile. Valid values are 1 and 2.
m_points_list
The ID of the list containing the nodes used to create the profile. Valid values are 1 and 2.
plane
The ID of the plane created using *createplane for the dragging
            vector or the axis of rotation for dragging about an axis.
method
Select the dragging method and add the desired profile to calculate the method. 
Dragging method:
0 - Create matrix with densities x, y, and z in global system if sysid is 0
                otherwise use specified system 
1 - Drag profile along line 
2 - Drag profile along node list 
3 - Drag profile along vector 
4 - Drag profile about an axis 
5 - Drag profile through a mesh (profile must be defined by mvol, elements,
                lines, or a node list to use this option 
6 - Drag profile along vector, forcing the center to be the base point of the
                defined plane (for this method, the profile must be cylindrical fit to mesh and thus
                the method value must be either 36 or 1036)


Profile selection:
+0 - Rectangular profile fit to mesh 
+10 - Rectangular profile fit to lines 
+20 - Rectangular profile fit to node list 
+30 - Cylindrical profile fit to mesh 
+40 - Cylindrical profile fit to lines 
+50 - Cylindrical profile fit to node list 
+60 - Use morph volume faces for profile 
+70 - Use shell elements for profile 
+1000 add profile shrinking after creation


drag
Distance or angle for drag (useable for along vector and about axis
              method).

","Examples
To create a rectangular matrix 2x2x5 dragged along a line:
*createmark nodes 1 ""all""
*createmark elems 1
*createlist lines 1 3
*createlist nodes 1
*createlist lines 2
*createlist nodes 2
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphvolumecreateflex nodes 1 2 2 5 10.0 0 1 1 1 elems 1 1 1 2 2 1 1 0.0
To create a cylindrical matrix 1x4x5 dragged from morph volumes along a vector (note that
        the plane normal is used for the vector direction):
*createmark nodes 1 ""all""
*createmark hypercubes 1 ""all""
*createlist lines 1
*createlist nodes 1
*createlist lines 2
*createlist nodes 2
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphvolumecreateflex nodes 1 1 4 5 10.0 0 1 1 1 hypercubes 1 1 1 2 2 1 63 0.0
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphvolumecreateflex...} ] } {
   # Handle error
}
"
1812,*morphvolumecreateplus ,"Description
This command creates a matrix of morph volumes xd by
          yd by zd in number aligned with the specified
        coordinate system (or the global system if zero) and enclosing the elements on the mark.
","Inputs

etype
elems
emark
Mark ID of elements.Valid values are 1 and 2.
xd
Density of matrix in x direction.
yd
Density of matrix in y direction.
zd
Density of matrix in z direction.
buff
Percentage buffer zone around matrix.
sysid
ID of system used to orient matrix.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
 options
0 = do not apply shrinking 
1 = apply eight iterations of shrinking without internal face movement 
3 = apply eight iterations of shrinking with internal face movement

","Example
To create a morph volume matrix with three morph volumes on a side, a buffer zone of 10%,
        with handles at the corners only, continuously tangent, and shrink the matrix for eight
        iterations with internal face movement:
*createmark elems 1 ""all""
*morphvolumecreateplus elems 1 3 3 3 10.0 0 1 1 1 3
","Errors
None.
"
1813,*morphvolumeequivalence ,"Description
This command will join all morph volumes on the mark whose faces are within a set
        tolerance. Creating tangency between joined morph volumes and automatic registering of nodes
        inside reshaped morph volumes are optional features.
","Inputs

c_entity_type
Must be set to hypercubes.
c_mark_id
The mark ID of the hypercubes. Valid values are 1 and 2.
tol
Maximum distance between morph volumes for joining.
tan
0 - Do not create tangency between edges of joined morph volumes 
1 - Create tangency between edges of joined morph volumes
nauto
0 - Do not register new nodes 
1 - Register new nodes

","Example
To join all morph volumes which are within 10 model units of each other:
*createmark hypercubes 1 ""all""
*morphvolumeequivalence hypercubes 1 10.0 1 1
","Errors
 Incorrect usage of *morphvolumeequivalence results in a Tcl error. To detect errors, you
        can use the catch
        command:if { [ catch {*morphvolumeequivalence hypercubes 1 10.0 1 1} ] } {
# Handle error
}

"
1814,*morphwritenodes,"Description
This command will write out a file with the specified name and list the positions and
        perturbations of a number of nodes in the model according to the specified mode. 
The first three lines of the file will contain the filetype declaration, the maximum size
        of the model, and the maximum perturbation of any node in the model. The maximum model size
        is the length of the diagonal of the smallest box aligned with the global system which
        contains all of the nodes in the model. 
The format of the remaining lines will have ""Node"", followed by the node ID and the x, y,
        and z positions of the node on the first line and the x, y, and z perturbations on the
        second line.
","Inputs

file_name
The full path and name of the output file.
mode
0 - Write all nodes. 
1 - Write perturbed nodes only. 
2 - Write out nodes with perturbations larger than 1% of the tolerance parameter. The
            morphing tolerance parameter can be set using the command
              *morphupdateparameter with the handletolerance
            option.

","Examples
To write out a file containing all the nodes in the model:
*morphwritenodes ""nodefile.txt"" 0
To write out a file containing only the perturbed nodes:
*morphwritenodes ""nodemovefile.txt"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1815,*move_feature,"Description
Moves a selection of elements and pastes them onto the displayed shell elements at the
        target location.  The neighborhood of the pasted region will be remeshed.  If the selected
        entities are connected to another mesh at the source, they are detached from them. Any holes
        left behind are patched and remeshed. Doesn’t allow moving elements associated to
        geometry.
","Inputs

entity_type
The type of entity to copy.  Valid values are components and elements.  The selection
            may consist of shell or solid elements. Any 1D elements attached to shell elements are
            automatically included.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
All parameters are case insensitive, order insensitive and optional.  If not supplied,
            the default values will be used. Valid parameters and their syntax are:
NumLayers : <value>
The number of layers to remesh (default 2).
MappingMethod : <value>
The method in which the transformed feature's stitch boundary is mapped on to
                  the target mesh:
auto – (default) Decides the best method among extend, morph and none based on
                  the way the selected feature is connected to the the target mesh.
extend – The stitch boundary is extended till it meets the target mesh, or if it
                  already crosses the target mesh, the extended part of the mesh is trimmed out.
                  This is ideal for features that intersects sharply with the target mesh.
morph – The feature is morphed such that the stitch boundary conforms to the
                  target mesh. This is ideal for features that meet the target mesh
                  tangentially.
none - The transformed feature is kept as it is.
Rebuild : <value>
0 - Remesh using size and bias.
1 - Remesh using rebuild (default).
StitchBoundary : <node_id1> <node_id2> … <node_idN-1>
                  <node_idN>
The mesh edges that needs to be extended or trimmed from or morphed to the
                  target mesh, and subsequently be stitched with the target mesh. In most cases the
                  command can deduce which mesh edges are to be extended or morphed. But when it
                  comes to features which already cross the target mesh this needs to supplied so
                  that the command knows where to trim from.
This is a list of node IDs of the involved edges. It expects two node IDs per
                  mesh edge. If there are N edges to be supplied, there should be 2N node IDs in
                  this list. For example:
StitchBoundary: n1 n2 n2 n3 n3 n4.
TransformByMatrix : <tr11> <tr12> <tr13> <tr14> <tr21> <tr22>
                  <tr23> <tr24> <tr31> <tr32> <tr33> <tr34> <tr41> <tr42>
                  <tr43> <tr44>
The transformation specified as a 4x4 matrix.
TransformByNodes : <sn1> <sn2> <sn3> <tn1> <tn2> <tn3>
The transformation specified between two systems defined at source and target
                  locations. The system at source is defined by three nodes sn1, sn2 and s3. The
                  origin is defined by the node sn1. The x-axis is defined by the vector from sn1 to
                  sn2. The x-y plane is defined as the plane containing all three nodes sn1, sn2 and
                  sn3. Similarly, the system at target is defined by three nodes tn1, tn2 and tn3.
                


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To move elements 5100-5200 along the -y direction with a distance of 1, and remeshing 2
        layers with the rebuild algorithm:
*createstringarray 5 ""TransformByMatrix : 0 -1 0 0 1 0 0 0 0 0 1 0 0 0 0 1 "" ""MappingMethod : morph"" ""Rebuild : 1"" ""NumLayers : 2""
*createmark elements 1 5100-5200
*copy_feature elements 1 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1816,*moveinclude ,"Description
 Moves an include file to a new location in the include hierarchy.
","Inputs

filebeingmoved
The name of the file to be moved in the tree.
newparent
The name of the new parent file.

","Errors
None.
",
1817,*movemark ,"Description
Moves entities from one collector to another.
","Inputs

entity_type
The type of entity to move. Any collected entity type (aside from master/slave
            elements) is valid.
mark_id
The ID of the mark containing the entities to move. Valid values are 1 and 2.
name
The name of the collector to move the entities to. The collector type is determined by
            the entity_type.

","Example
To move all elements from comp1 to comp2:
*createmark elems 1 ""by collector name"" comp1
*movemark elems 1 comp2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1818,*movesubmodel,"Description
longDescription
","
Inputs



source_submodel_type

Use solversubmodel for a solver submodel or includefile for an include file.

source_filename

The name of the source file to move into the tree.

target_submodel_type

Use solversubmodel for a solver submodel or includefile for an include file.

target_filename

The name of the new target file.

","Examples
To move the solver submodel with name Part1 to include file with name EngineInclude:
*movesubmodel ""solversubmodels"" ""Part1"" ""includefiles"" ""EngineInclude""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1819,*nameview ,"Description
Gives a name to a view.
","Inputs

number
View number (1 - 5)
name
 Name of view (max 16 characters).

","Example
To assign the name primary to view 1:
*nameview(1,""primary"")


","Errors
None.
"
1820,*nodeaddtempmark ,"Description
Adds nodes to the temporary node mark. 
","Inputs

node
The node to be added to the temporary node mark. 

","Errors
None.
",
1821,*nodecloud2facet,"Description
Generate STL facets from a node cloud.
","
Inputs


entity_type
The type of input entity.  Must be set to nodes.
mark_id
The ID of the mark containing the input entities.  Valid values are 1 and 2.
reserved
Reserved for future use.  Must be set to 5.
""scanradius <radius>;fillholesize <size>""
A string containing extra parameters.
scanradius defines the average distance between input nodes.
fillholesize defines the maximum hole width to close/fill any
            remaining holes after constructing facets.

","Examples
To construct facets from all nodes with scan radius of 4 and post fill hole size of
        10:*createmark nodes 1 all
*nodecloud2facet nodes 1 5 ""scanradius 4;fillholesize 10""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1822,*nodecreateatlineparams ,"Description
This command creates nodes or points at points on given line for given parametric
        values.
","Inputs

line_id
Input line ID.
double_array
The ID of the double array that contains the parametric location values in the range 0
            to 1. The double array is created using the *createdoublearray
            command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
insert_count
Number of additional parametric values inserted between the values specified by the
            array in double_array.
mode
Specifies how parameters specified in double_array are used. Valid values are: 
0 - Line arc length parameterization is used. 
1 - Internal line parameterization is used.
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes (default) 
1 - Create points

","Examples
To create nodes on line 12 at arc length parametric values 0.2, 0.8 and 0.85:
*createdoublearray 3 0.2 0.8 0.85
*nodecreateatlineparams 12 1 3

To create 10 points on line 12 using the line’s internal parameterization with parameters
        equally distributed between 0 and 1:
*createdoublearray 2 0 1
*nodecreateatlineparams 12 1 2 8 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1823,*nodecreateatsurfparams,"Description
This command creates nodes or points at points on given surface for given parametric
        values.
","Inputs

surf_type
Input surface type. Valid values are surfs or faces.
surf_id
Input surface ID value.
u1
The lower bound of U parametric range. Must be within the range 0 to 1.
u2
The upper bound of U parametric range. Must be within the range 0 to 1.
ucount
The number of nodes to create in U parametric direction. Must be ≥ 1. If the value is
            1, then u1 is taken as U parametric value for created node.
v1
The lower bound of V parametric range. Must be within the range 0 to 1.
v2
The upper bound of V parametric range. Must be within the range 0 to 1.
vcount
The number of nodes to create in V parametric direction. Must be ≥ 1. If the value is
            1, then v1 is taken as V parametric value for created node.
mode
Specifies whether parameters are used relative to untrimmed surface parametric area or
            valid parametric area is scaled to visible region. Also used to specify whether created
            points must reside inside visible trimmed surface area. Valid values are: 
0 - Untrimmed surface parametric area is used. Created nodes must be inside visible
            surface area. 
1 - Surface parametric area is scaled to visible surface area. Created nodes must be
            inside visible surface area. 
2 - Untrimmed surface parametric area is used. Created nodes can be outside visible
            surface area. 
3 - Surface parametric area is scaled to visible surface area. Created nodes can be
            outside visible surface area.
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes (default) 
1 - Create points

","Example
To create 12 nodes (3 nodes in U, 4 nodes in V) on surface 11 between the U locations 0.5
        and 0.75, and the V locations 0.1 and 0.3:
*nodecreateatsurfparams surfs 11 0.5 0.75 3 0.1 0.3 4 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1824,*nodecreatebetweennodes ,"Description
This command creates nodes or points at points on given line or surface, between given
        nodes. The input nodes are first projected onto the line or surface. The nodes/points are
        created between these projected points.
","Inputs

entity_type
Valid types are ""line"" or ""surf"".
entity_id
ID of the surface or the line, on which nodes are going to be created.
node_list
List of nodes, between which additional nodes are going to be created.
num_intervals_array
Array containing the number of intervals to be created between each node in the
              node_list.
array_size
Size of the array num_intervals_array. Note that this size must be
            always one less than the number of nodes in the node_list.
biasstyle
The type of biasing to use:
0 - Linear biasing 
1 - Exponential biasing 
2 - Bell-curve biasing


biasintensity
The biasing intensity value. This value must be between -20 and 20.
options
Parameter specifying whether nodes or points are created. Valid values are:
0 - Nodes created. 
1 - Points created.



","Example
To create nodes on line 12, between nodes 8, 10 and 11, such that we want 20 intervals
        between nodes 8 and 10, and 5 intervals between nodes 10 and 11: 
*createlist nodes 1 8 10 11 
*createarray 2 20 5
*nodecreatebetweennodes lines 12 1 1 2 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1825,*nodecreateonlines ,"Description
This command creates nodes or points at locations of intersection between two sets of input
        geometries. Only intersections between entities from different sets are calculated and are
        used to create nodes or points. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a surface edge to a parent surface is
        undefined and can return unexpected or varied results.
","Inputs

entity_type
Must be set to lines.
mark_id
The ID of the mark containing the input lines. Valid values are 1 and 2.
number
The number of nodes to create.
bias_style
0 - Linear 
1 - Exponential 
2 - Bell curve
bias_intensity
The bias intensity value. A positive value indicates biasing along the line direction,
            while a negative value indicates biasing along the opposite direction. A value of 0
            indicates no biasing.

","Example
To create 5 nodes on lines 10, 11, 12, and 13 with linear biasing of 2.0:
*createmark lines1 10 11 12 13
*nodecreateonlines lines 1 5 1 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1826,*nodelistbypath2,"Description
Creates a node path from the starting node to the ending node.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
list_id
The ID of the node list to populate. Valid values are 1 and 2.
flag
0 - If both node_id1 and node_id2 lie on free
            edges, the path will follow free edges where possible. Otherwise, the shortest path is
            returned. This is the same as running *nodelistbypath. 
1 - Always return the shortest path.

","Example
To determine the path between nodes 100 and 110 using the shortest path:
*nodelistbypath2 100 110 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1827,*nodemarkbypath,"Description
Creates a node path from the starting node to the ending node. If both
          node_id1 and node_id2 lie on free edges, the path
        will follow free edges where possible. Otherwise, the shortest path is returned.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
mark_id
The ID of the node mark to populate. Valid values are 1 and 2.

","Example
To determine the path between nodes 100 and 110:
*nodemarkbypath 100 110 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1828,*nodemodify ,"Description
Modifies the location of a node in space. 
","Inputs

nodeid
The ID of the node to be modified. 
x
The new x coordinate of the node. 
y
The new y coordinate of the node. 
z
The new z coordinate of the node. 

","Example
To modify the location of node 1 to be x = 10.0, y = 20.0, z = 30.0: 
*nodemodify(1,10.0,20.0,30.0)

","Errors
None.
"
1829,*nodesandelemsclear ,"Description
This command will remove all numbers from the modeling window for
        all nodes and elements.
","Example
*nodesandelemsclear
","Errors
None.
",
1830,*nodetoelementgapscreate ,"Description

","Inputs

gaps_location
The ID of the mark containing the location of the gaps.
target_elems
The ID of the mark containing the elements to which the nodes are projected.
face_nodes
The ID of the mark containing nodes which lie on the face of one or more elements
            (solids only).
break_angle
The break angle of a solid face.
property_name
The name of the property to which the gap elements should point.
tolerance
The maximum distance allowed between the nodes (on gaps location mark) and the
            elements (on target elems mark).
vectorid
The ID of the orientation vector associated with the gap elements.
nodeid
The ID of the orientation node associated with the gap elements.
orient_x
X component of the orientation vector.
orient_Y
Y component of the orientation vector.
orient_Z
Z component of the orientation vector.
comps_flag
Flag to indicate if individual components are used in defining the orientation of the
            elements ( 1if components are used, 0 if they are not).
systemid
The ID of the coordinate system used for orienting the gap elements

","Example
In the example below, nodes 1 to 100 are projected to shell elements 30 to 75 within a
        tolerance of 1.0. The gap elements point to the property gapprop and use components
        (70,120,80) for their orientation:
*createmark(nodes,1) 1-100
*createmark(elements,2) 30-75
*createmark(nodes,2)
*nodetoelementgapscreate(1,2,2,0,""gapprop"",1,0,0,70,120,80,1,0)
Orientation of the gap elements may be specified using either a vector, node, coordinate
        system or individual components 
","Errors
None.
"
1831,*nonstructuralmasscreateall ,"Description
Creates a group with non-structural mass configuration for all properties of a specified
          card image.
","Inputs

name
The name of the non-structural mass group to create.
color
The color of the non-structural mass group. Valid values are 1 through 64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
card_image
The card image of the properties to create the non-structural
            mass for. Valid values are:
ELEMENT 
PBAR 
PBARL 
PBEAM 
PBEAML 
PCOMP 
PROD 
PSHEAR 
PSHELL 
PTUBE 
PSHELL



","Examples
To create a non-structural mass named nsm1 of type 1 (NSM1) for properties with PSHELL
          card image with mass value 2.4:
*nonstructuralmasscreateall ""nsm1"" 8 1 2.4 PSHELL
To create a non-structural mass named nsml1 of type 2 (NSML1) for properties with PBAR
          card image with mass value 3.5:
*nonstructuralmasscreateall ""nsml1"" 8 2 3.5 PBAR
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1832,*nonstructuralmassupdateall ,"Description
Updates a group with non-structural mass configuration for all properties of a specified
          card image.
","Inputs

name
The name of the non-structural mass group to update.
color
The color of the non-structural mass group. Valid values are 1-64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
card_image
The card image of the properties to update the non-structural
            mass for. Valid values are:
ELEMENT 
PBAR 
PBARL 
PBEAM 
PBEAML 
PCOMP 
PROD 
PSHEAR 
PSHELL 
PTUBE 
PSHELL



","Examples
To update a non-structural mass named nsm1 of type 1 (NSM1) for properties with PSHELL
          card image with mass value 2.4:
*nonstructuralmassupdateall ""nsm1"" 8 1 2.4 PSHELL
To update a non-structural mass named nsml1 from type 1 (NSM1) to type 2 (NSML1):
*nonstructuralmasscreateall ""nsm1"" 8 2 2.4 PSHELL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1833,*normalsadjustbynodes,"Description
Adjusts the normals of 3D elements according to nodes of a solid element.
","Inputs

entity_type
The type of entity to adjust normals for. Valid values are elements and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes that define the selected solid element face.
              Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn. If set to zero, the vector is
            drawn at 10% of the screen size.
display
0 - Display all elements normals upon command completion. 
1 - Display only adjusted element normals upon command completion.

","Example
To adjust the normals of elements 1-10 based on faces defined by nodes 5, 7 and 9 using a
        display size of 10.0:
*createmark elems 1 1-10
*createmark nodes 1 5 7 9 
*normalsadjustbynodes elems 1 1 10.0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1834,*normalsoff ,"Description
Turns off the display of element/surface normals.
","Example
To turn off the display of element/surface normals:
*normalsoff
","Errors
None.
",
1835,*numbers,"Description
Turns the numbers mark on or off. 
","Inputs

on
Determines whether the numbers mark is turned on or off (1 for on, 0 for off). 

","Errors
None.
",
1836,*numbersmark ,"Description
Places the entities in the mark on the numbers mark. This will display the ID of the
        entity. 
","Inputs

entity type
The type of entity contained on the mark. 
mark
The ID of the mark. 
on
Determines whether the entities will be placed on the numbers mark or removed from the
            numbers mark (1 to put on, 0 to remove). 

","Example
To place nodes 5, 6, and 7 on the numbers mark: 
*createmark(nodes,1) 5 6 7
*numbersmark(nodes,1,1)
","Errors
None.
"
1837,*offset_surfaces_display_offset ,"Description
The command will create segments in the component named ""^offset"" with the color pink if
        the surfaces or solids on mark_id are a result of an offset. The segments
        will point to the original position of the surfaces/solids (the position from which the
        offset was made). This is for visualization and review purposes.
There is an exception to this for the 9.0 release that will be removed in subsequent
        releases: If the surfaces are a result of the midsurface extraction or have a manually
        assigned thickness, then the command will always display the thickness even if an offset was
        made later.
","Inputs

entity_type
The type of entity to generate segments for. Valid values are surfs and solids.
mark_id
The mark of containing the surfaces or solids. Valid values are 1 and 2.
reserved_1
Reserved for future use. Should be set to 0.

","Example
To review the offset for the displayed surfaces:
*createmark surfs 1 displayed
*offset_surfaces_display_offset surfs 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1838,*optimized_mesh ,"Description
This command is used to create a mesh on a surface using saved or default parameters on
        surfaces and specifying various options. Any elements attached to the input surfaces are
        deleted before the meshing operation.
","Inputs

mark_id
The mark ID containing the surfaces to mesh. Valid values are 1 and 2.
criteria_file
The full path and filename for the user-defined quality index criteria file. If no
            file is given, ""dummy"" should be specified.
elem_size
The default element size used to calculate element densities along edges for topology
            cleanup operations.
elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


smooth_across
Flag indicating whether to ignore surface edges for element smoothing and cleanup
            operations. Valid values are:
0 - Honor surface edges for element smoothing and cleanup. 
1 - Ignore surface edges for element smoothing and cleanup.


feature_angle
The angle, in degrees, specifying the feature lines. This is approximately the minimum
            angle between the elements adjacent to a feature line.
algorithm
Determines the algorithm for surface meshing. Valid values are:
0 - Standard surface meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control


do_remesh
Flag indicating whether to keep or delete existing elements on the surfaces. Valid
            values are:
0 - Keep existing elements on selected surfaces. 
1 - Delete existing elements on selected surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. 
1 - Elements are created in the same components as their parent surfaces.



","Example
To start the optimization process with a criteria file named
          C:/criteria/mycriteria.txt for displayed surfaces, with tria
        elements, element size of 15, feature angle of 35 degrees, ignoring surface edges for
        smoothing and new elements created in their surface components:
*createmark surfaces 1 displayed
*optimized_mesh 1 ""C:/criteria/mycriteria.txt"" 15 0 0 1 35 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1839,*orderchangetofirst ,"Description
 Converts second order elements to first order. 
","Inputs

mark
The ID of the mark which contains the elements to be converted. 

","Example
*createmark() is required.

","Errors
None.
"
1840,*organizeRegionsAcrossModules,"Description
Organize selected regions to newly created modules per region.
On selecting modules with SolidBody or SurfaceBody regions, the regions will be organized
        across newly created modules. The rule for creating new modules is one module per region in
        the selected source module. As a result, there will be modules equivalent to the number of
        SolidBody and SurfaceBody regions. The valid regions are the ones whose usage is
        CFDPart_CheckEnclosure_SolidSurfaces or CFDPart_CheckEnclosure_OpenShellSurfaces.
","
Inputs



mark=<mark_id>

The ID of the mark of regions.  Valid values are 1 and 2.

source_part_name=<name>

The name of the source part.

Comment.
","Examples
To organize all SolidBody and SurfaceBody regions with a valid usage from part1 into new
        modules:
*createmark regions 1 all
*organizeRegionsAcrossModules mark=1 source_part_name=part1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1841,*ossmooth_12,"Description
Extract the final design geometry from OptiStruct topology,
        topography and shape optimization results, and achieve smoothed plies from free-size
        optimization results on composites.
","Inputs

modelsel
Model selection option. 
0 - Specify model file path to read. 
1 - Use current model in HyperMesh.
exemode
Flag indicating the execution mode of OSSmooth. Valid values are:
0 - Extract geometry only 
1 - Extract geometry and inherit boundary conditions for FEA reanalysis 
2 - Smoothing plies from free-sizing optimization results on composites


load_op
Execution/load option. Valid values are:
0 - Create .oss file only to be used in standalone version
                (do not execute ossmooth) 
1 - Do not load geom into HyperMesh. 
2 - Load geom intoHyperMesh.


outputcode
Output file format. Valid values are:
1 - Nastran

2 - IGES 
3 - STL 
4 - H3D 
5 - STEP 
6 - PARASOLID 
7 - IGES (advanced)


filepath_fem
The full name and path to the OptiStruct
.fem results file generated from the optimization.
filepath_sh
The full name and path to the OptiStruct
.sh results file generated from the optimization.
filepath_grid
The full name and path to the OptiStruct
.grid results file generated from the optimization.
isosurface
Flag indicating whether to create an isosurface.
1 - Yes
0 - No


autobead
Flag indicating whether to create an autobead design.
1 - Yes
0 - No


string_array
The ID of the string array that contains the additional parameters. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented below.
Each argument can be either space or comma separated. There will be at most five
            strings of parameters, depending on the operations selected. Each string is introduced
            as
            follows:""isosurf: surfacecode surfacemode densitythreshold detectbridge lowthreshold distancecoefficient optismoothboundary lapiteration lapfeatureangle lapsmoothboundary drawrecovery""
This sting is only required when isosurface = 1.
surfacecode
The method used for isosurface extraction. Valid values are:
0 - No smoothing, isosurface only 
1 - Optimization based smoothing 
2 - No smoothing, element threshold 
3 - Laplacian smoothing


surfacemode
Isosurface mode indicating how to process non-design
                  elements. Valid values are:
0 - Keep all non-design elements with half layer around 
1 - Split only intersected non-design elements 
2 - Split overlap non-design elements with half layer around 
3 - Split overlap non-design elements
4 - Extract shells with half layer around non-design
5 - Extract shells without half layer around non-design


densitythreshold
Threshold value for topology optimization (real value ≥ 0 and ≤ 1).
detectbridge
Flag indicating whether to detect connectivity in isosurface (1=yes, 0=no).
lowthreshold
The low density threshold for connectivity detection (real value ≥ 0 and ≤ 1).
                  Low threshold value must be smaller than density threshold value.
distancecoefficient
The distance coefficient to use in optimization based smoothing (real value ≥
                  -50 and ≤ 50).
optismoothboundary
Flag indicating whether to include the boundary or not in optimization based
                  smoothing (1=yes, 0=no).
lapiteration
The number of iterations to use in Laplacian smoothing (integer ≥ 0).
lapfeatureangle
The feature angle to use in Laplacian smoothing (real value ≥ 1 and ≤ 80).
lapsmoothboundary
Flag indicating whether to include the boundary or not in Laplacian smoothing
                  (1=yes, 0=no).
drawrecovery
Flag indicating whether to recovery draw constraints in topology optimization
                  (1=yes,
                  0=no).""autobead: shapeopt beadthreshold autobeadlayer""
This string is only required when autobead > 0.
shapeopt
Method used for topography or shape optimization interpretation. Valid values are:
1 - Create autobead 
2 - Update new coordinates to original mesh


beadthreshold
Threshold value for autobead (real value ≥ 0 and ≤ 1).
autobeadlayer
Layer value for autobead (integer value 1 or
                  2).""remesh: remeshsize meshtype attachtype remeshlayer remeshfeatureangle""
This string is only required when using remeshing.
remeshsize
The element size used in remeshing.
meshtype
Flag indicating the elements generated in remeshing. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias


attachtype
Flag indicating which elements will be remeshed. Valid values are:
0 - Remeshing a numer of layers elements around PLOT elements 
1 - Remeshing all elements


remeshlayer
The number of layers when attachtype = 0 (integer ≥ 0).
remeshfeatureangle
The feature angle used in
                  remeshing.""other_params: units tetrameshingcode createplot surfacereduction reductionfeatureangle""
This string is required when isosurface = 1 or
                    autobead = 1.
units
Units used for IGES and STEP output. Valid values are:
1 - inch 
2 - mm 
4 - foot 
6 - meter 
10 - cm


tetrameshingcode
Flag indicating whether to create tetramesh after creating isosurface (1=yes,
                  0=no).
createplot
Flag indicating whether to create PLOT elements (1=yes, 0=no).
surfacereduction
Flag indicating whether to use surface reduction (1=yes, 0=no).
reductionfeatureangle
The feature angle to used for surface reduction (real value ≥ 1 and ≤
                  80).""ply: plyfile plysmoothiteration smallregiontype smallregion splitdisconnected""
This string is required when exemode = 2.
plyfile
The full name and path to the .fem file to save the
                  smoothed result plies.
plysmoothiteration
The number of iterations to use in ply shape smoothing (integer ≥ 0).
smallregiontype
Flag indicating method used for small region (element patch or hole) detection.
                  Valid values are:
0 - Detect small regions by area ratio 
1 - Detect small regions by element count


smallregion
Threshold value to use for small region elimination. Small region depends on
                    smallregiontype: when smallregiontype = 0,
                  this indicates the area ratio (real value ≥ 0 and < 1, calculated by small
                  region area/total design area). When smallregiontype = 1, this
                  indicates the element count (integer, ≥0).
splitdisconnected
Flag indicating whether to split disconnected patches into new plies (1=yes,
                  0=no).



","Examples
To execute OSSmooth FEA reanalysis on the current model in HyperMesh (the C:/test/os1.fem and
          c:/test/os1.sh files), create isosurface with 0.3 density threshold,
        split all quads on non-design/design interface, Laplacian smoothing, with 10 iterations and
        30 degrees feature angle, do remeshing on 2 layers of elements around PLOT, with element
        size 0.5, and feature angle 30:
*createstringarray 3 ""isosurf: 3 3 0.3 0 -1 0 0 10 30 1 0"" ""remesh: 0.5 0 0 2 30"" ""other_params: 1 0 0 0 10""
*ossmooth_12 1 1 0 3 ""c:/test/os1.fem"" ""c:/test/os1.sh"" """" 1 0 1 2
To execute ply smoothing on C:/test/os2.fem, eliminate small element
        patches and holes with less than 20 elements, smoothing plies with 20 iterations, split
        disconnected patches into new plies, export smoothed result plies into
          C:/test/os2_smooth.fem:*createstringarray 1 ""ply: C:/test/os2_smooth.fem 20 1 20 1""
*ossmooth_12 0 2 0 1 ""C:/test/os2.fem"" """" """" 0 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1842,*ossmooth_geometry,"Description
Extract the final design geometry from OptiStruct topology,
        topography and shape optimization results. 
","Inputs

modelsel
Model selection option.
0 - Specify model file path to read. 
1 - Use current model in HyperMesh.


fem_filename
The full name and path to the OptiStruct
.fem results file generated from the optimization. Used only when
              modelsel = 1.
load_op
Execution/load option. Valid values are:
0 - Create .oss file only to be used in standalone version
                (do not execute ossmooth) 
1 - Do not load geom into HyperMesh. 
2 - Load geom into HyperMesh.


outputcode
Output file format. Valid values are:
1 - Nastran

2 - IGES 
3 - STL 
4 - H3D


tetrameshingcode
Flag indicating whether to create tetramesh after creating isosurface (1=yes,
            0=no).
units
Units to use for IGES output. Valid values are:
1 - inch 
2 - mm 
4 - foot 
6 - meter 
10 - cm


autobead
Flag indicating whether to create an autobead design (1=yes, 0=no).
autobeadthreshold
Threshold value for autobead (real value ≥ 0 and ≤ 1).
autobeadlayer
Layer value for autobead (integer value 1 or 2).
isosurface
Flag indicating whether to create an isosurface (1=yes, 0=no).
surfacecode
 The method to use. Valid values are:
0 - No smoothing, isosurface only 
1 - Optimization based smoothing 
2 - No smoothing, element threshold 
3 - Laplacian smoothing


densitythreshold
The density threshold for topology optimization (real value ≥ 0 and ≤ 1).
detectbridge
Flag indicating whether to detect connectivity in isosurface (1=yes, 0=no).
lowthreshold
The lower density threshold for connectivity detection (real value ≥ 0 and ≤ 1). 
Low threshold must be smaller than density threshold value.
distancecoefficient
The distance coefficient to use in optimization based smoothing (real value ≥ -50 and
            ≤ 50).
optismoothboundary
Flag indicating whether to include the boundary or not in optimization based smoothing
            (1=yes, 0=no).
lapiteration
The number of iterations to use in Laplacian smoothing (integer ≥ 0).
lapfeatureangle
The feature angle to use in Laplacian smoothing (real value ≥ 1 and ≤ 80).
lapsmoothboundary
Flag indicating whether to include the boundary or not in Laplacian smoothing (1=yes,
            0=no).
remesh
Flag indicating whether to remesh when creating an autobead design or/and isosurface
            (1=yes, 0=no).
surfacereduction
Flag indicating whether to use surface reduction (1=yes, 0=no).
reductionfeatureangle
The feature angle to use when requesting surface reduction (real value ≥ 1 and ≤
            80).
createplotel
Flag indicating whether to create PLOTEL elements (1=yes, 0=no). 

","Example
To execute OSSmooth on the C:/test/os1.fem, C:/test/os1.grid and
          C:/test/os1.sh files, loading geometry back to HyperMesh, requesting Nastran output,
        creating 1 layer autobead with remesh design with 0.3 bead threshold, no surface reduction,
        0.3 topology optimization threshold, detect connectivity in isosurface with 0.2 low
        threshold, Laplacian smoothing, 10 iterations, 30 degrees feature angle and include the
        boundary, create PLOTEL elements:
*ossmooth_geometry 0 ""C:/test/os1.fem"" 2 1 0 1 1 0.3 1 1 3 0.3 1 0.2 0 0 10 30 1 1 0 10 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1843,*ossmooth_savesurf,"Description
Exports the final design geometry from OptiStruct topology,
        topography and shape optimization results. 
","Inputs

mode
0 - Create .oss file only to be used in standalone version (do
            not execute OSSmooth) 
1 - Do not load geom into HyperMesh

2 - Load geom into HyperMesh.
filepath
The full name and path of the OptiStruct
.fem results file generated from the optimization.
units
Units used for IGES and STEP output. Valid values are:
1 - inch 
2 - mm 
4 - foot 
6 - meter 
10 - cm


output 
1 -Nastran

2 - IGES 
3 - STL 
4 - H3D 
5 - STEP 
6 - PARASOLID 
7 - IGES (advanced)

","Example
To execute OSSmooth to save surfaces to STEP file C:/test/os1.step,
        using mm as units:
*ossmooth_savesurf 2 C:/test/os1.fem 2 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1844,*panelcreation,"Description
Creates a panel entity.
","
Inputs


elemMark=<value>
The ID of the input elements.  Valid values are 1 and 2.
name=<value>
The name of the panel entity.
findPanel=<value>
0 - DIrectly create the panel entity using the input elements
1 - Find a panel consisting of these elements

","Examples
Create a panel named panel1 from elements
        1-10:*createmark elems 1-10
*panelcreation 1 panel1 0
Find panel entities from elements
        1-10:*createmark elems 1-10
*panelcreation 1 panel1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1845,*penetrationcheck ,"Description
Checks the given components for contact surface penetrations. To release the memory after
        completion, use the command *penetrationcheckend. 
A valid template must be loaded for the check to occur.
","Inputs

entity_type
The type of entity to check for penetration. Valid values are groups and elems.
mark_id
The ID of the mark containing the entities to check. Valid values are 1 and 2.
check_type
The type of penetration check to perform. Valid values are:
0 - groups 
3 - elems only



","Example
To check the elements in group E2E for penetration:
*createmark groups 1 E2E
*penetrationcheck groups 1 0
*penetrationcheckend
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1846,*PenetrationCheckSummary ,"Description
Command is used to generate a summary log file for last run penetration check. This file
        contains a flat list of intersected and penetrated components, followed by more detailed
        lists of each component-component pair data. If the last check’s input was specified by
        groups, then the above data is organized by groups, as well. 
","Inputs

filename
The name of the file, including its full path, to which the summary is written. The
            file is appended to if it already exists.
sort_intersections
A flag that indicates how to sort intersection data. Valid values are:
0 - No sorting 
1 - Ascending component ID 
-1 - Descending component ID 
2 - Ascending element count 
-2 - Descending element count 
3 - Ascending number of interfered components 
-3 - Descending number of interfered components


sort_penetrations
A flag that indicates how to sort penetration data. Valid values are:
0 - No sorting 
1 - Ascending component ID 
-1 - Descending component ID 
2 - Ascending element count 
-2 - Descending element count 
3 - Ascending number of interfered components 
-3 - Descending number of interfered components 
4 - Ascending maximum penetration depth 
-4 - Descending maximum penetration depth



","Example
Output results of the last penetration check (run using the command
          *checkpenetration) to the file
          C:\results\check.txt, with intersections sorted by ascending
        component ID and penetrations by descending maximum penetration depth:
*PenetrationCheckSummary ""C:/results/check.txt"" 1 -4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1847,*penetrationdisplay ,"Description
Displays the amount of penetration through nodes, vectors, or contour.
","Inputs

contact_thickness
Supplied value of the contact thickness.
part_thickness_scale
Supplied value of the part thickness scale.
display_mode
Type of mode used to display penetration.
0 - Nodes 
1 - Normal 
2 - Contour


normal_scale
Greater than zero - uniform size or % of magnitude of vectors.
label
The vector label option.
0 - Vector labels off 
1 - Vector labels on


segment_orientation
Flag for taking element normal into consideration for checking penetration.
0 - Elements normal will not be considered 
1 - Elements normal will be considered


magnitude_mode


0 - Uniform size 
1 - Percentage of magnitude



","Example
For displaying the amount of penetration if a contact thickness supplied is 1.5, part
        thickness scale supplied is 1.0, display mode is normal, percentage of magnitude used is 50,
        vector labels are on, and segment orientation and percentage of magnitude are used:
*penetrationdisplay(1.5, 1, 1, 0.5, 1, 1, 1) 
The *penetrationcheck(), penetrationchecktwo(), or
          penetrationrecheck() command is required.
","Errors
None.
"
1848,*permutemark ,"Description
Permutes the entities on a mark. 
","Inputs

entity type
The type of entities contained on the mark. 
mark
The ID of the mark which holds the entities to be permuted. 
type
The type of action which should be taken:
0 - Swap x with y 
1 - Swap x with z 
2 - Wwap y with z



","Example
To permute elements 10, 11, and 12 switching the x and y values: 
*createmark(elements,1) 10 11 12
*permutemark(elements,1,0)

*createmark() is required. 
","Errors
None.
"
1849,*perturbationshapeupdate,"Description
Updates a perturbation shape. 
","Inputs

name
The name of the shape.
vectorcolid
The ID of the vector collector that contains the perturbation vectors.

","Example
To create a shape ""sh1"" that has its perturbation vectors in a vector collector of ID 7: 
*perturbationshapeupdate(""sh1"",7)
","Errors
None.
"
1850,*plotaxisnodes ,"Description
 Plots a curve based on the values of marked nodes ordered along an axis.
","Inputs

mark
The active mark.
axis
The axis index (0 = X, 1 = Y, 2 = Z)

","Example
*createmark(nodes,1) 167 171 175
*plotaxisnodes(1,0)

In order to work, there must be an existing contour and at least one node on the mark.
        Values on the curve are ordered according to their distance along the selected axis.
","Errors
None.
"
1851,*plotinfotitlesetcolor ,"Description
Sets the color of the plot information title.
","Inputs

color 
Set the title to this color.

","Errors
None.
",
1852,*plotinfotitlesettext,"Description
Sets the text to be displayed in the plot information title.
","Inputs

text 
The text that is displayed in the plot information title.

","Errors
None.
",
1853,*plotnodelist ,"Description
Plots a curve based on the values of a contour along a list of nodes.
","Inputs

listid
The ID of the active node list.

","Example
*contourplot("""",0,0,0,0,0,1,0,0,""total disp"",1,0,0)
*xyplotsetcurrent(""untitled1"")
*createlist(nodes, 1) 1601 1600 1599 1598
*plotnodelist(1)
In order to work, there must be an existing contour and a list of nodes (not nodes on a
        mark).
","Errors
None.
"
1854,*plottitlesetcolor,"Description
Sets the color of the plot title. 
","Inputs

color
The color to which the title should be set.

","Errors
None.
",
1855,*plottitlesettext ,"Description
Sets the text for the plot title. 
","Inputs

text
The text which should be displayed in the plot title. 

","Errors
None.
",
1856,*plynormalsdisplay ,"Description
Controls the display of 2D element ply normals.
","Inputs

ply_name
The name of the ply to display normals for.
mark_id
The ID of the mark containing the elements whose normals are to be displayed. Valid values are 1 and 2.
If empty, all plies in the specified ply are considered.
size
Specifies the size of the graphic normal vector. If set to zero, the vector is drawn
            at 10% of the screen size.

","Example
To turn on the display of normals for elements 1-10 in Ply1, at 10% screen size:
*createmark elems 1 1-10
*plynormalsdisplay Ply1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1857,*plyrealization_option,"Description
Extracts/projects elements belonging to ply contours.
","Inputs

ply_mark_id
The ID of the mark containing the input plies. Valid values are 1 and 2.
entity_type
The type of entity to use to extract/project the plies. Valid values are comps and
            elems.
mark_id
The ID of the mark containing the entities to extract/project. Valid values are 1 and 2.
project


0 - Project normal to the contour plane 
1 - Project normal to the mesh 
2 - Project along an arbitrary direction using the x1, y1, z1 and x2, y2, z2
                arguments. 
3 - Drape map by proximity method (FiberSIM/CATIA
                composite link)


x1
The x coordinate of the direction base. Only used if project is set
            to 2.
y1
The y coordinate of the direction base. Only used if project is set
            to 2.
z1
The z coordinate of the direction base. Only used if project is set
            to 2.
x2
The x coordinate of the direction normal. Only used if project is
            set to 2.
y2
The y coordinate of the direction normal. Only used if project is
            set to 2.
z2
The z coordinate of the direction normal. Only used if project is
            set to 2.
reserved1
Reserved for future use. Must be set to 0.
search_option
Use the specified search criterion as:
0 - Centroid 
1 - All nodes inside 
2 - Shrinkage factor of border element edges


reserved2
Reserved for future use. Must be set to 0.
shrinkage
The shrinkage area factor. Only used if search_option is set to 2.
table_id
The ID of the table that holds core sample data. The table consists of 2 columns,
            ""ply"" and ""points"" that contain ply names and sampling points, of data type string and
            triples, respectively.
double_array
The ID of the double array that contains the x, y and z coordinates of sample points.
            The double array is created using the *createdoublearray command.
            This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.
reserved3
Reserved for future use. Must be set to 0.
reserved4
Reserved for future use. Must be set to 0.

","Examples
To project/extract plies for a ply named ""Ply3"" on elements 1-10, normal to the elements,
        with search criterion ""all nodes inside"":
*createmark plies 1 ""Ply3""
*createmark elems 1 1-10
*plyrealization_option 1 elems 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
To project/extract plies for a ply named ""Ply3"" on all elements, normal to the elements,
        with shrinkage factor of 0.25:
*createmark plies 1 ""Ply3""
*createmark elems 1 all
*plyrealization_option 1 elems 1 1 0 0 0 0 0 0 0 2 0 0.25 0 0 0 0 0
To project/extract plies for a ply named ""Ply2"" on elements 1-10, normal to the elements
        using core sample data:
Create a table to store core sample data, using ply names Ply1 and Ply2 and sample
            points (1.1, 2.1, 3.1) and (4.1, 5.1,
            6.1):*createstringarray 2 ""string"" ""triple"" 
*tablecreate ""coresample_table"" 1 1 1 2 0
*createstringarray 2 ""Ply1"" ""Ply2""
*tableinsertcolumn ""coresample_table"" ""string"" ""ply"" 1 2 1
*createstringarray 6 ""1.1"" ""2.1"" ""3.1"" ""4.1"" ""5.1"" ""6.1""
*tableinsertcolumn ""coresample_table"" ""triple"" ""points"" 1 6 2	
 Ply realization, assuming the table ID of coresample_table is
            2:*createmark plies 1 ""Ply2""
*createmark elems 1 1-10
*plyrealization_option 1 elements 1 1 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0


","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1858,*positiondummy,"Description
Positions the components of a dummy.
","Inputs

entities
The entity type selected that recognizes the dummy. Currently, only components are
            supported.
collectorid
The id of the entity recognizing the dummy.
x
The X coordinate to which the dummy is translated.
y
The Y coordinate to which the dummy is translated.
z
The Z coordinate to which the dummy is translated.

","Example
To translate a dummy, use any collector belonging to the dummy (and is part of the
        parent/child system) and select the x, y, and z coordinates to position it to:
positiondummy(components, 1, 0.0, 30.0, 0.0)

","Errors
None.
"
1859,*prepare_solid_holes_for_meshing ,"Description
This command takes as input a mark of surfaces or solids of a 3D body. It finds holes in
        the 3D body, and collects the found connected holes in ""tubes"". It also trim and merges hole
        surfaces to make more surfaces suitable for the mapping mesh algorithm. 
It sets element densities on surface edges. Moreover, independent holes can also be
        removed. 
Optionally, this command groups holes by diameter, and creates a component with auto
        generated name for each holes group and moves the surfaces of the tubes to the corresponding
        components. Blind and through holes are considered as different separation groups, so they
        are grouped separately. the surfaces of the detected holes can be put to an output mark. 
The command parameters have the following meaning
","Inputs

entity_type
The type of input entities. Valid values are surfaces or solids.
input_mark_id
The ID of the input mark. Valid values are 1 and 2.
output_mark_id
The ID of the output mark to put the surfaces of the detected holes. Valid values are
            0, 1 or 2. If set to 0, no surfaces are placed on the mark.
string_array
The ID of the string array that contains the fillet width and radius group
            information. The string array is created using the *createstringarray
            command. This should always be set to 1. 
The first string in quotations should contain the following parameters as keywords
            followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
cross_sect_size_max
Maximum length of the holes normal to the holes axes cross sections. This
                  applies only to elongated holes (rounded slots or elliptical holes). If
cross_sect_size_max
0 - Then no limitation is applied.
diams_ratio_max
Maximum ratio of diameters of adjacent co-axial cylindrical hole sections when
                  the sections are considered within the same tube.
elem_size
The element size used in meshing parameters.
min_elem_size
The minimum element size used in meshing parameters.
separate_holes
The values 0 and 1 are supported. 
1 - Means holes will be distributed into different groups.


All other strings may contain 4 quotes values:
min_diam 
(double) 
max_diam
(double) 
num_of_circumference_elems
(int) - used in seeding the circular edges of a hole.
elem_size_for_longitudinal_edges
(double) - used in seeding operation.


The intervals for min_diam and max_diam should
            not overlap between groups. 
If num_of_circumference_elems is set to 0, the holes in the group
            are removed when possible. In this case,
              elem_size_for_longitudinal_edges is not required. If some holes can
            not be properly removed, then they are seeded normally with
              num_of_circumference_elems set to 3 and elem_size_for
              longitudinal_edges set to elem_size. Currently, only
            independent holes can be removed.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To recognize and prepare holes with diameters in three different intervals 0 - 15, 15 - 20
        and 20.0 - 40.0, and separate them according to different seeding design:
*createmark surfaces 1 ""all""
*createstringarray 4 ""cross_sect_size_max = 100 diams_ratio_max = 2.5 min_elem_size = 2.0 seperate_holes = 1""  
""0 15 6 6.0"" ""15 20 6 8.0"" ""20 40 8 10.0""   
*prepare_solid_holes_for_meshing surfaces 1 2 1 4
To remove holes with diameter in the range 0 - 5.0: 
*createmark surfaces 1 ""all""
*createstringarray 2 ""cross_sect_size_max = 100 diams_ratio_max = 2.5 min_elem_size = 2.0 separate_holes = 1""  
""0 5 0""
*prepare_solid_holes_for_meshing surfaces 1 2 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1860,*pressures,"Description
Creates pressure loads on elements.
","Inputs

mark
The mark ID containing elements which should have pressures applied to them. 
face nodes
The mark ID containing nodes which lie on the face of one or more elements (solids
            only). 
x comp
The x component of the pressure. 
y comp
The y component of the pressure. 
z comp
The z component of the pressure. 
magnitude
The magnitude of the pressure. 
break angle
The break angle of a solid face. 
on face
A logical which determines whether pressures are being applied to faces.

","Example
If you set x comp, y comp, or z comp to zero, a pressure is applied. 
If you assign a value to x comp, y comp, or z comp, a traction is applied. 
",
1861,*pressuresonentity_curve,"Description
Creates a pressure load on a mark of elements, surfaces, components or sets, potentially
        with its magnitude defined by a curve.
","Inputs

entity_type
Type of entity the load is applied on. (e.g. surfs or elems).
mark_id
The ID of the mark of entities on which to apply the pressure.
facenodes
The ID of the mark containing nodes that lie on the face of one or more elements
            (solids only).
x_comp
The x-component of pressure.
y_comp
The y-component of pressure.
z_comp
The z-component of pressure.
magnitude
The magnitude of the pressure. 
breakangle
The break angle of a solid face. 
onface
A logical which determines whether pressures are being applied to faces:
0 - Consider the edge
1 - Consider the face
10 - Same as 0 but for shells.  Do not consider breakangle, and
            force all edge loads to have both nodes on facenodes
11 - Same as 1 but for solids.  Do not consider breakangle, and
            force all loads to have all nodes on facenodes
20 - Same as 0 but consider hidden entities
21 - Same as 1 but consider hidden entities
30 - Same as 10 but consider hidden entities
31 - Same as 11 but consider hidden entities
xlocation, ylocation, zlocation
For loads on components or sets, you may wish to supply a display location for where
              HyperMesh should draw the graphical image for the load. If
            these three values are 999999, or more than one entity is selected, HyperMesh will generate a display location from the contents of the
            components or sets.
magnitude
The magnitude of the pressure.
curve_id
The ID of a curve defining the magnitude of the load vs time.
x_scale
A scale factor applied to the x-axis (or time axis) of the curve. 

","Example
To apply a pressure of 4 to the elements of a component, using the curve with ID 9 to vary
        this magnitude over time:
*createmark(components,1) ""container""
*createmark(nodes,1)
*pressuresonentity_curve(comps,1,1, 0,0,0, 4,30,1, 0,0,0, 9, 1.0)
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1862,*projectmarktoplane ,"Description
 Projects a group of entities to a plane. 
","Inputs

entity type
The type of entities contained on the mark. 
mark
The ID of the mark containing the entities to be projected. 
plane
The ID of the plane to which the entities will be projected. 
vector
The vector along which the entities will be projected. 
toplane
A flag indicating if the entities should be projected to the plane or to the normal of
            the plane (1 for plane, 0 for normal).

","Example
To project elements 10, 11, 12, 13 to the plane with a normal of (1.0, 0.0, 0.0) based at
        the origin along the vector (1.0, 1.0, 1.0): 
*createmark(element,1) 10 11 12 13
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*createvector(1.0,1.0,1.0)
*projectmarktoplane(element,1,1,1,1)

*createmark() , *createplane() , and
          *createvector() are required. 
","Errors
None.
"
1863,*projectsystem ,"Description
References a vector that is projected on the element plane. Re-orients and visualizes the
        element (material) coordinate system for selected elements.
","Inputs

entities
Determines the selected entity, which can only be elements.
markmask
Determines the selected elements.
vectorptr
Determines the vector to be projected on the element plane to define the element
            orientation.
onlyorient
1 - The new x-element directions are shown as vectors starting from the element
            center. 
0 - The new x-element directions are shown as continuous gradient lines starting and
            ending on free edges.
normal_size
If onlyorient = 1, it determines the size of the vectors to be
            shown.
color
Determines the color of the vector or line. The color ID numbers range from 1 to
              64.

","Example
To project the created vector on the element plane of four selected elements and show the
        projection as blue vectors (color = 7) with size = 3:
*createmark(elements,2) 376 377 389 418
*createvector(1,2.4482,-0.7894,0.9774)
*projectsystem(elements,2,1,1,3,7)
*vectorsoff()

The *createmark() and *vectorsoff() commands are
        required.
","Errors
None.
"
1864,*propagatesplithexas,"Description
Given a hexa element and two nodes diagonally across a face of that element, splits the
        hexa according to a set pattern and propagates that split to any hexa adjoining the opposite
        face of the hexa and so on through the displayed elements of the database. 
","Inputs

splittype
A number between 1 and 6 identifying the splitting pattern to use.
1 - Two pentas (split along the diagonal formed by n1 and n2). 
2 - Penta & hexa (with the penta to the left of the diagonal). 
3 - Hexa & penta (with the penta to the right of the diagonal). 
4 - Two hexas (split from the right of n1 to the left of n2). 
5 - Three hexas (split from n1 to both sides adjacent to n2). 
6 - Four hexas (split in a plus pattern). 


startelement
The starting hexa element. 
n1
One of the nodes defining the starting face of the hexa. 
n2
The other node defining the starting face of the hexa. 

","Example
To split a column of hexas into paired pentas starting with element 205, where nodes 1015
        and 1017 are diagonally opposite from each other across one face of the hexa: 
*propagatesplithexas(1,205,1015,1017)
The hexa elements can be first or second order and need not all be the same order.
","Errors
None.
"
1865,*qismoothconstrained,"Description
This command tries to improve the selected elements' quality index by QI optimizing
        elements nodes positions. It tries to achieve the best possible quality index value by
        allowing nodes to move up to the specified absolute limits dependent on the position of
        nodes respect to feature edges.
The command parameters have the following meaning:
","Inputs

smoothmark
The elements selection mark (1 or 2).
anchormark
The mark of additional (to welds) nodes not allowed to move (1 or 2).
criteria_file
The path to the criteria file. If the criteria are set by a preceding command, ""dummy""
            can be used as a criteria file name.
feature_angle
Elements feature angle for defining of features in degrees (30 degrees is a commonly
            used value).
ignore_features
The flag defining permissions of node movement across the feature edges:
0 - Nodes are not allowed to move across feature edges. 
1 - Nodes are allowed to be moved across shared edges; free edges nodes, marked
                edges, edges of features (beads, washers, dimples, birdbeaks, fillets), all fixed
                nodes are forbidden for movement across. 
2 - The same as ""1"", but nodes on some of the features surfaces (beads, vertices)
                are unfixed + end vertices of fillet edge are unfixed. 
3 - The same as ""2"", but fillet edges are released and some curves sharp break
                vertices are unfixed. 
4 - All shared edges nodes,including recognized features boundary edges, all
                non-user marked edges and fixed vertices are released for movement across. 
5 - The same as ""4"" but free edges nodes are also released, those nodes are not
                allowed to move off the surfaces. 
6 - The same as ""5"" but free edges nodes are allowed now to move off surfaces
                breaking associativity with geometry.


constr_flags
The additive flags defining constraints to be applied:
0 - No constraints are applied. 
+1 - Constraints applied to nodes movement across feature edges. 
+2 - Constraints applied to fixed nodes movement along feature edges. 
+4 - Constraints applied to nodes across smooth (not feature) edges. 
+8 - Constraints applied to vertex nodes along feature edges. 
+16 - Constraints applied to all nodes along feature edges. 
+32 - Constraints applied to surface (not edge) nodes.


stifflimit
Maximum absolute movement of free edges nodes. 
toughlimit
Maximum absolute movement of nodes of shared feature edges or fixed nodes along
            feature edges.
midlimit
Maximum absolute movement for nodes movement of smooth (non feature) shared edges or
            non-corner nodes along feature edges.
looselimit
Maximum absolute movement for not-edge (surface) nodes. Each of the limits has effect
            if the corresponding flags are set, ignore_features has corresponding
            value and the limit has non-negative value.
max_iterations
Maximum number of algorithm iterations. Usually 3 to 5 can be used.
time_limit
The time limit in minutes. If 0 is passed - ignored.

","Example

*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
*createmark elements 1  ""displayed""
*createmark nodes 1  
*qismoothconstrained 1 1 ""dummy"" 30 0.2 6 3 0.5 1.0 1.5 2.0 5 0

","Errors
The command returns error codes for wrong quality criteria, no elements selected and
        internal optimization errors.
"
1866,*quad_split,"Description
Split warped quads into trias such that it does not create intersections.
","
Inputs


entity_type
The type of entity to modify.  Must be set to elements.

mark_id

The ID of the mark of quads to split.  Valid values are 1 and 2.

","Examples
To split displayed quads:
*createmark elems 1 displayed
*quad_split elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1867,*quit,"Description
Stops the execution of a command file. 
","Inputs

exit
Set to 1 if HyperMesh should exit when this command is
            executed. 

","Example
This command can be used to terminate the execution of a command file. Although HyperMesh writes this command to the command file when a session is
        quit, it will not terminate execution of HyperMesh when it is
        executed from a command file unless the parameter is set to 1. 
","Errors
None.
"
1868,*rbody_mesh,"Description
Creates a rigid body mesh on surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 1 and 2.
min_size
The minimum element size.
max_size
The maximum element size.
max_chordal
The maximum allowed chordal deviation.
max_angle
The maximum feature angle.
remesh
0 - Delete existing elements before mesh 
1 - Do not delete existing elements before mesh
mesh_type
0 - Trias 
1 - Mixed
elem_comp
0 - Organize elements in current component 
1 - Organize elements in surface component(s)
elem_order
1 - First 
2 - Second
shared_edge_flag
0 - Allow node movement across shared edges, and ignore chordal deviation 
1 - Do not allow node movement across shared edges, and ignore chordal deviation 
2 - Allow node movement across suppressed edges, and ignore chordal deviation 
3 - Allow node movement across shared edges, and keep chordal deviation 
4 - Do not allow node movement across shared edges, and keep chordal deviation 
5 - Allow node movement across suppressed edges, and keep chordal deviation

","Example
To create a first order rigid body mesh on surfaces 1-10, with minimum size of 0.5 and
        maxmium size of 30,0:
*createmark surfs 1 1-10
*rbody_mesh 1 0.5 30 0.1 15 1 1 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1869,*readfile ,"Description
Reads a HyperMesh database into the current session and deletes
        any existing model.
","Inputs

filename
The full path and filename of the database file.

","Example
To read the database named C:/mymodel.hm into the current session:
*readfile C:/mymodel.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1870,*readnodepositionsfromdynainfile,"Description
Moves nodes in the current model to positions given in a dynain file. Optionally, initial
        stress of elements may be read.
A valid LS-DYNA model must be loaded.
","Inputs

path
The full path and file name of the dynain file.
options
A string list of options that define which cards to read.  The string may include
            initial_stress_beam initial_stress_shell and initial_stress_solid.

","Example
To read node positions from C:/Users/default/dynain:
*readnodepositionsfromdynainfile ""C:/Users/default/dynain""
To read node positions and initial_stress_solid from C:/Users/default/dynain:
*readnodepositionsfromdynainfile ""C:/Users/default/dynain"" ""initial_stress_solid""
To read node positions and all initial_stress cards from C:/Users/default/dynain:
*readnodepositionsfromdynainfile ""C:/Users/default/dynain"" ""initial_stress_beam initial_stress_shell initial_stress_solid""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1871,*readqiviewsettings ,"Description
This command is related to the element quality view mode. It loads settings from a text
        file created by *writeqiviewsettings, and resets the current settings
        used in this view mode.
","Inputs

flag
The full name and path of the file to load containing the QI view settings.

","Example
To load the current settings from the file C:/settings/qiview.txt:
*readqiviewsettings ""C:/settings/qiview.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1872,*realizecontactsurfstosets,"Description
Realizes all contact surfaces of a given card image to segment sets.
","
Inputs


card_image
The card image of the contact surfaces to realize.

","Examples
Realize contact surfaces with cardimage surfSeg to segment sets:

*realizecontactsurfstosets surfSeg

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1873,*realizeengineeringentities,"Description
Realize engineering entities.
","Inputs

entity_type
The type of engineering entities to realize.
mark_id
The ID of the mark containing the engineering entities to realize.  Valid values are 1
            and 2.
reserved
Reserved for future use.  Must be set to 0.

","Example
Realize mass entities with IDs 1 and 2:
*createmark masses 1 1 2
*realizeengineeringentities masses 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1874,*realizeentity ,"Description
Realizes an engineering entity into solver data.
","Inputs

entity_type
The type of engineering entity to realize. Currently only supported for fields.
<select_type>=<selection>
The engineering entity to realize. There are several ways to provide the entity to be
            modified. Only one option can be used at a time:
id=<id>
The ID of the single entity to modify.
name=<name>
The name of the single entity to modify.


The remaining option=value strings are documented within the subtopics of each
            supported entity type.

","Example
Examples are provided within the subtopics of each supported entity type.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1875,*realizemasselementstosolvermasses,"Description
Creates nodal group solvermasses out of mass elements.
Currently used in solver conversion from OptiStruct/Nastran to LS-DYNA.
","
Inputs


mark_id
The ID of the mark of mass elements to convert.  Valid values are 1 and 2.

","Examples
Convert all mass elements in the model:
hm_createmark elems 1 ""by config type"" ""0 1 1""
 * realizemasselementstosolvermasses 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1876,*realizesolvermassestomasselements,"Description
Creates mass elements from solver mass entities.
This is mainly useful in solver conversion from LS-DYNA to other
        solvers that support nodal mass elements.
","
Inputs



mark_id

The ID of the mark of solver masses of type NODE or NODE_SET to realize.

","Examples
To convert all the nodal solver masses:
*createmark solvermasses 1 ""by config"" 105
*realizesolvermassestomasselements 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1877,*rebuild_mesh_advanced,"Description
Remesh/Improve selected shell elements with quality and flow considerations, and optional
        flow guide selections to guide the mesh directions.  It uses the same parameter and criteria
        files as used by BatchMesher to specify the quality criteria and mesh parameters.  The
        criteria and parameter files must be properly set and registered before execution. It
        utilizes the following fields from the parameter file:
1. Surface hole recognition table
2. Feature angle during element cleanup
3. Element type
4. Mesh type
1Ds attached to the input shell elements are used as features and they significantly impact
        the mesh quality and flow. If no 1Ds are present in the shells of the input elements, the
        specified feature angle is internally used to recognize features.
Rebuild/improve is currently supported for first-order shell elements that are not attached
        to solid elements.
","
Inputs



mark_id

The ID of the mark of elements to rebuild or improve.  Valid values are 1 and 2.

flow_guides=<value>

A set of lines that are used to guide the mesh directions. Each line is composed of a
            list of points, and it follows a format of  ""number_of_points p1_x p1_y p1_z p2_x p2_y
            p2_z ?p3_x? ?p3_y? ?p3_z? ... ?pN_x? ?pN_y? ?pN_z?"".

keep_selection=<value>

Flag to keep the element selection for selective rerun. Valid values are:
0 - Keep the full selection
1 - Keep only the failed selection (default)
2 - Do not keep the selection

Mode=<value>

The mode of the operation. Valid values are:
0 - Rebuild all selected elements (default)
1 - Detect and rebuild only elements that affect flow/quality the most

","Examples
To remesh the displayed shell elements with 5mm criteria and parameter file settings, with
        mesh flow guides, and keep the failed areas on selection:
*createstringarray 14 "" 0 penalty value              0.00    0.00    0.50    1.00    5.00"" \
""  1 min length        1 2.0   5.000   4.333   3.666   3.000   2.833    2"" \
""  2 max length        1 1.5   5.000   6.200   7.320   9.000  11.290    0"" \
""  3 aspect ratio      1 1.0   1.000   2.000   4.000   5.000  10.000    0"" \
""  4 warpage            1 2.0   0.000   5.000  15.000  20.000  40.000    0"" \
""  5 max angle quad    1 1.0  90.000 110.000 140.000 150.000 165.000    0"" \
""  6 min angle quad    1 1.0  90.000  70.000  40.000  30.000  15.000    0"" \
""  7 max angle tria    1 1.0  60.000  80.000 120.000 130.000 155.000    0"" \
""  8 min angle tria    1 1.0  60.000  50.000  30.000  20.000  10.000    0"" \
""  9 skew                1 1.5   0.000  10.000  50.000  60.000  75.000    0"" \
"" 10 jacobian           1 2.0   1.000   0.900   0.600   0.500   0.350    0"" \
"" 11 chordal dev       0 0.0   0.000   0.300   0.800   1.000   2.000    0"" \
"" 12 taper              0 1.0   0.000   0.200   0.500   0.600   0.900    0"" \
"" 13 % of trias        1 2.0   0.000   3.000   4.500   6.000   9.000    0""
*setqualitycriteria 1 14 0
*createstringarray 	105 ""geometry_cleanup_flag    1"" ""meshing_flag         5"" \
""element_size         5.0"" ""element_type      		 	2"" \
""mesh_align           3"" ""element_order         	 	1"" \
""surf_component       1"" ""feature_angle              30.0"" \
""holes_table_begin"" ""appl_surf(1)"" ""appl_solid(0)"" ""appl_cordsfiles(0)"" ""appl_flanged_suppr(1)"" \
""flanged_suppr_height(1.4)"" ""narrow_slots_type(0)"" ""abs_fixed_nodes_count_max(-8)"" \
""rad(0.0,2.2) do action(1) washer(0) "" ""rad(2.2,3.01) do action(0) elems(4) washer(0) "" \
""rad(3.01,4.7) do action(0) elems(6) washer(1) layers(3.5) "" ""rad(4.7,9.0) do action(0) elems(8) washer(1) layers(0.75*radius) "" \
""rad(9.0,11.0) do action(0) elems(8) washer(1) layers(7.0) "" ""rad(11.0,20) do action(0) elems(8) washer(1) layers(auto) "" \
""rad(0.0,2.2) solid(1) do action(1) "" ""rad(2.2,3.01) solid(1) do action(0) elems(4) "" \
""rad(3.01,20) solid(1) do action(0) elems(6) "" ""holes_table_end"" ""edge_fillet_recognition           1"" \
""max_fillet_radius                 5.0"" ""surface_fillet_table_begin"" ""surface_fillet_recognition(1)"" \
""minimize_transitions(1)"" ""rad(0,2.2) wid(3.0,6.2) do split(suppress_on)"" \
""rad(2.2,15) wid(3.4,6.2) do elems(1)"" ""rad(0,25.0) wid(6.2,9.2) do elems(2)"" \
""rad(0,35.0) wid(9.2,12.5) do elems(3)"" ""rad(0,40.0) wid(12.5,25.0) do chordal_deviation(0.2)"" \
""surface_fillet_table_end"" ""del_dupl_surfs_flag               2"" ""del_dupl_surfs_tol                -1"" \
""edges_stitch_flags   0"" ""max_edges_stitch_tol    -1.0"" \
""fix_overlapsurfs_flag             	1"" ""overlapsurfs_maxtangangle         	-1.0"" \
""beads_suppression     	1"" ""beads_recognition        	1"" \
""minimal_beads_height  	1.4"" ""beads_treat_flags      	0"" \
""flange_recognition   	1"" ""flange_elements_across  	3"" \
""flange_max_width       	30.0"" ""flange_min_width      	8.0"" \
""flanges_treat_flags  	1"" ""flange_max_remove_width  -1.0"" \
""appl_tria_reduction   	1"" ""tria_redu_max_elemsize auto"" \
""tria_redu_min_elemsize	 auto"" ""trias_around_holes   	0"" \
""common_mesh_flow        0"" ""extract_thinsolids       	1"" \
""midsurf_method     		3"" ""thinsolid_ratio        		0.3"" \
""max_thickness         	10.0"" ""extract_feature_angle 	25.0"" \
""pre_midsurf_cleanup   	1"" ""direct_midmesh           	0"" \
""ignore_flat_edges   	1"" ""flatten_connections     	0"" \
""defeat_open_width_on   1"" ""defeat_open_width     		1.0"" \
""supp_proxim_edges_on   1"" ""supp_proxim_edges      		0.5"" \
""combine_nonmanifold_on  1"" ""combine_nonmanifold     	0.5"" \
""midmesh_extact_elem_size   10.0"" ""remove_logo      	1"" \
""logo_max_size    			30.0"" ""logo_max_height     		1.4"" \
""logo_min_concavity    	1.0"" ""threads_removal     		0"" \
""threads_toremove_max_depth   	5.0"" ""threads_replacediametertype  	-2"" \
""folded_elems_angle   150.0"" ""smooth_elems_target     0.2"" \
""fillets_mesh_flow   	0"" ""failed_elems_cleanup_flgs  8"" \
""move_nodes_across_feature_edges   1"" ""featureedge_nodes_moveacross_max  0.1"" \
""move_nodes_across_free_edges      1"" ""freeedge_nodes_moveacross_max     0.05"" \
""move_normal_flag     	1"" ""move_normal_dist       		0.8"" \
""divide_warped_quads  	1"" ""ignore_comps_boundary  	0"" \
""gen_topology_prepare_flags 7"" ""cleanup_comp_flag 	0 "" \
""comp_select         "" ""use_wildcards_for_compsnames  	0"" \
""cleanup_tolerances      auto"" ""suppress_features_rate   0"" \
""feat_charsize_method 0"" ""custom_feat_suppr_maxangle 25.0"" \
""uncond_constr_lines_suppress      	0"" ""aggressive_fillet_lines_suppress  	0""
*createbatchparamsfromstrings 1 105
*createmark elements 1 displayed 
*rebuild_mesh_advanced 1 keep_selection=1 ""flow_guides=2 308.746697 719.296657 906.673771 339.768568 714.811262 904.452529""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1878,*redohistorystate ,"Description
Redoes one or more history states.
","Inputs

count
The number of history states to redo.

","Example
To redo two history states:
*redohistorystate 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1879,*refine_by_patterns,"Description
Refines a zone elements using an all quad pattern. The zone is described by a refinement
        box and center node. The refined mesh is then connected to the existing mesh using an all
        quad pattern through the transition zone, described by a transition box. 
The refinement box will contain the refined elements, while the region between the
        refinement box and the transition box will contain quads patterns used to transition between
        the refined mesh and base mesh size.
","Inputs

mark_id
The ID of the mark containing the elements to refine. Valid values are 1 and 2. Generally, it is best to select displayed elements and allow the
            proper elements within the box to be selected internally.
node_id
The ID of the node defining the center of the refinement box.
strings
A string that contains the additional input parameters. Each string must be space
            separated, including between = and the value. All strings are mandatory. 
Valid strings are:
auto_transition = <value>
Currently unused and should be set to 0.
refine_zone_height = <value>
Defines the height of the refinement zone.
refine_zone_length = <value>
Defines the length of the refinement zone.
refine_zone_size = <value>
Defines the mesh size within the refinement zone.
refine_zone_width = <value>
Defines the width of the refinement zone.
squeez = <value>
Currently unused and should be set to 1.
system_id = <value>
The ID of a local coordinate system to which the zones are oriented. A default
                  of 0 (global system) is used if not specified.
transition_zone_height = <value>
Defines the height of the transition zone.
transition_zone_length = <value>
Defines the length of the transition zone.
transition_zone_width = <value>
Defines the width of the transition zone.



","Example
To refine elements around node 60 with refinement size 1 using a refinement box of
        dimension (10,15,20) and transition box of dimension (40,50,45):
*createmark elements 1 ""displayed""
*refine_by_patterns 1 60 ""refine_zone_size = 1 auto_transition = 0 transition_zone_length = 40 transition_zone_width = 50 transition_zone_height = 45 refine_zone_length = 10 refine_zone_width = 15 refine_zone_height = 20 system_id = 0 squeez = 1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1880,*refineelementsbydeviation ,"Description
Refine elements to chordal deviation.
","Inputs

mark
The ID of the mark which contains the elements to be refined. 
deviation
The maximum chordal deviation.
minlength
The minimum element edge size.

","Example
To refine the elements to chordal deviation:
*createmark(elements,1) 86 88 113
*refineelementsbydeviation(1,0.01,0.1)

*createmark() is required.
","Errors
None.
"
1881,*reflectmark,"Description
This command reflects a selection of entities about a plane.
","Inputs

entity_type
The type of entity to reflect.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the reflection. This is defined using the *createplane
            command.

","Example
To reflect element 15 about a plane normal to the x-axis with its base at the origin:
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*createmark elems 1 15
*reflectmark elems 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1882,*rejectmark ,"Description
Rejects the entities held on the reject mark. 
","Errors
None.
",,
1883,*relativerotatedummyjoint ,"Description
Rotates a dummy joint relative to its current location.
","Inputs

entities
The entity type. Currently, only components is supported.
collectorId
The id of the collector that is part of the parent/child system. The parent or child
            system itself will be rotated, depending on the parentChild toggle.
axis
The axis of the child that we want to rotate about.
0 X axis 
1 Y axis 
2 Z axis


rotAngle
The number of degrees to rotate about the axis.
parentChild
If set to 0, the child is rotated about its own axis. If set to 1, the parent is
            rotated about the child’s axis.

","Example
To rotate a joint around the child’s X axis by 25 degrees specifying the collector that
        contains the system for the elbow joint:
*relativerotatedummyjoint(components, 1, 0, 25, 0)
","Errors
None.
"
1884,*remesh_element_intersection,"Description
Remeshes 2D elements at intersection locations. Elements are distributed into groups based
        on their connectivity. The elements belonging to different components may be in the same
        group. Only different groups are taken as counterparts for the intersection calculation.
        Moreover, elements sharing a node are not counterparts of the intersection calculation on
        checking element/element intersection.
","Inputs

entity_type
The type of entities to remesh. Valid values are comps and elems.
mark_id
The ID of the mark containing the entities to remesh. Valid values are 1 and 2.
params
The parameters of re-meshing along the cut, defined as ""keyword value"" format. 
For example: ""angle 30.0 generate_intersect_segments_only 0 remove_internal_shell 1
            do_only_remove_internal_shell 0 num_remesh_layers 2"" 
Valid keywords and values are:
angle
Values used to define feature edges on mesh. Default if not specified is
                  30.0.
break_shell_along_component_boundaries
All elements connected to each other are classified as a group. This defines how
                  that grouping occurs: 
0 - Do not break element grouping at component boundaries (default) 
1 - Element grouping stops at component boundaries. This means that elements in
                  an element group belong to a single component.
close_small_intersection_gaps
Specifies whether to close small gaps along intersection lines and free shell
                  mesh boundaries. 
0 - Do not close (default) 
1 - Close
do_only_remove_internal_shell
Indicates that the command only removes internal elements. It requires that all
                  intersecting elements are conformal along the common intersecting element edge
                  lines. 
0 - Do not apply (default) 
1 - Only remove internal shells. If specified,
                    remove_internal_shell must be 1 or undefined and
                    generate_intersect_segments_only must be 0 or not
                  defined.
gap_close_method
Specifies the method for closing small gaps. Gaps are closed by extending free
                  edge elements to the intersecting target mesh. 
1 - Tangent extension 
2 - Free edge normal projection
generate_intersect_segments_only
Indicates that the command only creates intersection segments. 
0 - Do not apply (default) 
1 - Only generate intersection segments. If specified,
                    do_only_remove_internal_shell must be 0 or undefined.
intersection_gap_close_limit
The gap close size limit. Must be specified if
                    close_small_intersection_gaps=1.
keep_intersect_edges
Specifies whether to store mesh intersections as 1D elements. 
0 - Do not store (default) 
1 - Store
num_remesh_layers
Defines the number of element layers attached to intersecting elements
                  considered for remeshing. Valid values are: 
-1 - Intersecting elements are split and stitched to obtain conformal element
                  connectivity. 
0 - Remesh only intersecting elements. 
> 0 - Remesh specified additional layers in addition to intersecting
                  elements.
num_threads
Specifies the number of threads to use: 
-1 - Multi-teading with no limit (default) 
0 - No multi-threading 
> 0 - The exact number of threads
remove_internal_shell
0 - Do not remove internal elements when selected elements form two or more
                  watertight shells. 
1 - Remove internal elements when selected elements form two or more watertight
                  shells (default).
remove_small_penetration
Specifies whether to remove small penetrations. A penetration consists of a
                  group of connected elements whose boundaries are only intersection lines and free
                  shell mesh boundaries. 
0 - Do not remove (default) 
1 - Remove
tria_remesh_growth_ratio
The element size growth ratio used by the adaptive tria mesher when
                    use_adaptive_tria_remesh=1. Default if not specified is 1.5.
tria_remesh_span_angle
The maximum element normal angle deviation used by the adaptive tria mesher when
                    use_adaptive_tria_remesh=1. Default if not specified is
                  35.0.
trim_removal_limit
The maximum distance between intersection lines and free element edges in small
                  penetrations to be removed. Must be specified if
                    remove_small_penetration=1.
use_adaptive_tria_remesh
Specifies whether to use the adaptive tria mesher when re-meshing triangular
                  elements. 
0 - Do not use (default) 
1 - Use



","Example
To trim displayed components, removing internal shells and remeshing using 2 additional
        layers:
*createmark comps 1 ""displayed""
*remesh_element_intersection comps 1 ""generate_intersect_segments_only 0 remove_internal_shell 1 do_only_remove_internal_shell 0 num_remesh_layers 2 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1885,*remesh_optistruct,"Description
Remeshes 2D elements at intersection locations. Only elements belonging to different
        components are taken as counterparts for the intersection calculation. Moreover, elements
        sharing a node are not counterparts for the intersection calculation.
","Inputs

string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each argument can be either comma or space separated. There are at most six string
            parameters, depending on the user inputs required. 
Valid strings are:
""fgrd: filepath_grid""
This sting is optional, indicating the .grid file to be
                  applied to update the shape of the model.
filepath_grid
The full name and path to the OptiStruct
.grid results file generated from the optimization.
""fsh: filepath_sh""
This sting is optional, indicating the .sh file to be used
                  in remeshing.
filepath_sh
The full name and path to the OptiStruct
.sh results file generated from the optimization.
""fdesvar: filepath_desvar""
This sting is optional, indicating the .desvar file to be used in
                  remeshing.
filepath_desvar
The full name and path to the OptiStruct
.desvar file generated from the optimization.
""fhist: filepath_hist""
This sting is optional, indicating the .hist file to be
                  used in remeshing.
filepath_hist
The full name and path to the OptiStruct
.hist file generated from the optimization.
""skipgs: id1 id2 ...""
This string is only required when there are grids which will be unchanged during
                  remeshing. Note that grids in a SET named as '^skipgs' will be excluded, as
                  well.
id1 id2 ...
ID list of grid sets which will keep unchanged during remeshing.
""skiges: id1 id2 ...""
This string is only required when there are elements which will be unchanged
                  during remeshing. Note that grids in a SET named as '^skipes' will be excluded, as
                  well.
id1 id2 ...
ID list of element sets which will keep unchanged during remeshing.


number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray.

","Example
To executes the function on the current model, taking the optimized grid coordinates from
        the file C:/test/torquearm.grid, and performing remeshing with grids in
        SET number 2 fixed:
*createstringarray 2 ""fgrd: C:/test/ torquearm.grid"" ""skipgs: 2""
*remesh_optistruct 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1886,*remove_solid_holes ,"Description
Detects and removes holes in 3D geometry, up to a maximal diameter. The shape of the hole
        cross-section can optionally be filtered, limiting to circular holes only or/and rounded
        slots. Optionally fixed points and tags can be placed at the center of the removed holes. 
When a hole cannot be removed, the surfaces of such holes can optionally be moved to
        auto-created components with auto-generated names. 
Optionally any number of additional ranges of holes for removal with different shape and
        post-processing options can be specified using a flexible string input.
","Inputs

entity_type
The name of entity to consider. Valid values are surfaces and solids. 
If surfaces are being used as input, all surfaces constituting each considered 3D body
            should be selected to generate proper results. If all surfaces of a 3D body are not
            selected, the command result is unpredictable.
mark_ID
The ID of the mark containing the entities. Valid values are 1 and 2.
max_diam
The maximum diameter for holes to be removed. For holes of arbitrary shape, the
            ""effective"" diameter is found as the cross section perimeter/Pi. If the hole shape is
            limited by rounded slots, the hole diameter is taken as the hole rounded tip
            diameter.
cross_sect_size_max
The maximum size of the cross-section (normal to the axes) for rounded slots or
            elliptical holes. This must exceed max_diam.
options
Flags that indicate different options for cross-section recognition and additional
            hole removal post-processing parameters.. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
 0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round holes should be detected.
Bit1
0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round slots should be detected.
Bit2
 0 - Do not place fixed points. 
1 - Place fixed points at the centers of end cross-sections of removed
                  holes.
Bit3
0 - Do not place tags. 
1 - Place tags containing the hole size attached to the center fixed points.
                  Bit2 must be used.
Bit4
0 - Failed hole surfaces are not organized. 
1 - The surfaces of holes that failed to be removed are organized to
                  auto-created components with auto-generated names. This can be used for manual
                  removal of such holes.


string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
All input strings (each one in separate quotation marks) have the same format and
            contain user defined diameter ranges. Each range string has the following format
              : ""min_range_diam max_range_diam options"" 
The diameters ranges should not overlap but may have gaps between them. 
The options string is derived from the options argument and can be customized for each
            range.
number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray.

","Examples
To remove all holes with diameters from 0 to 8.0 and remove round holes and rounded slots
        only in the range from 8.0 to 20.0 with maximal rounded slot length 25.0. No options are
        used for the lower range, but a value of 15 is used for the upper range (find only rounded
        holes and slots, and place fixed points with tags).
*createmark surfaces 1 all
*createstringarray 1 ""8.0 20.0 15""
*remove_solid_holes surfaces 1 8.0 25.0 0 1 1 
To remove only round holes up to a diameter of 12.0, put fixed points at the centers, and
        move any failed hole surfaces to the auto-created component:
*createmark solids 1 all
*remove_solid_holes solids 1 12.0 15.0 21 1 0 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1887,*removecrbrelation ,"Description
Removes a master-slave relationship for LS-DYNA
        *CONSTRAINED_RIGID_BODIES keyword.
 If a master component is removed, then the constrainedrigidbodies entity is deleted. If
        all slave components are removed, the constrainedrigidbodies entity is deleted.
","Inputs

mark_id
The ID of the mark containing the components.

","Example
To remove slave rigid component 200:
*createmark comps 1 200
*removecrbrelation 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1888,*removeelemsfromcontactsurf ,"Description
Removes elements from a contactsurf. If all elements are removed the empty contactsurf
        still exists.
","Inputs

name
The name of the contactsurf.
elem_mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.

","Example
To remove elements 100 and 101 from the contactsurf ""test"":
*createmark elems 1 100 101
*removeelemsfromcontactsurf  ""test"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1889,*removefilletbetweennodes ,"Description
 Removes the edge fillet between two nodes.
","Inputs

nodes
The array of nodes from the node list. The first two nodes in the nodes array are used
            to remove fillets.

","Example
*createentity node x=-25.7203277 y=-212.155023 z=104.852423
*createentity node x=71.47504 y=-213.224288 z=96.3130724
*createlist nodes 1 1 2
*removefilletbetweennodes 1
","Errors
None.
"
1890,*removeincludefromdisplay,"Description
This command un-displays/masks all of the entities in the specified include file from
          theHyperMesh
modeling window.
","Inputs

id
The ID of the include file. An ID of 0 selects the master file. If not specified,
            should be blank """".
shortname
The shortname of the include file. This value can be blank when id is specified. If
            not specified, should be blank """".

","Example
To remove the entities in the include with ID 3 from the display:
*removeincludefromdisplay 3 """"
To remove the entities in the include with shortname elems.fem from the display:
*removeincludefromdisplay """" elems.fem
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1891,*removesubmodel,"Description
Deletes a solversubmodel or include file, optionally removing all of its contents as
        well.
If both id and shortname are empty, this command
        removes all solversubmodels and include files from the database (but does not delete the
        contents). If the contents are not deleted, they move to the parent include file.
","
Inputs



submodel_type

Use solversubmodel to remove a solver submodel or includefile to remove an include
            file.

id

The entity ID, or 0 to use shortname.

shortname

The short name of the solver submodel or include file. This can be empty if
              id is specified other than 0.

remove

0 - Do nore remove the contents of the object when deleting.
1 - If either id or shortname selects a single
            object, then all of the contents of that object will be deleted from the database.

","Examples
To remove the solversubmodel entity with ID 10 and delete its contents:
*removesubmodel solversubmodels 10 """" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1892,*removetransformation,"Description
Removes transformations from positions.
Alternatively, *setvalue can be used.
","
Inputs



mark_id1

The ID of the mark containing the position entities to which the transformations in
              mark_id2 must be removed from.

mark_id2

The ID of the mark containing the transformation entities to be removed.

","Examples
To remove all the transformations from all the positions:
*createmark positions 1 all
*createmark transformations 1 all
*removetransformation 1 1
",
1893,*renamecollector,"Description
Renames a collector. 
","Inputs

entity type
The type of collector being renamed. 
collector name
The name of the collector to be renamed. 
new name
The new name which should be assigned to the collector. 

","Example
To rename component oldname to newname: 
*renamecollector(component,oldname,newname)

","Errors
None.
"
1894,*renamefile ,"Description
Renames a file. 
","Inputs

oldname
The current name of the file being renamed. 
newname
The new name for the file. 

","Example
To rename the file junk to stuff: 
*renamefile(junk,stuff)
","Errors
None.
"
1895,*renumber,"Description
This command renumbers the internalHyperMesh IDs for entities
        of entity_type contained on mark_id.

This command only renumbers HyperMesh internal IDs, even if the
        selected entities have solver IDs (see *renumbersolverid).
","Inputs

entity_type
The type of entity selected for renumbering.
mark_id
The mark that contains the entities. Valid values are 1 and 2.
start_id
Integer value > 0 specifying the starting value.
incr_val
Integer value > 0 specifying the renumbering increment.
offset_val
Integer value to use for offsetting. Can be positive or negative as long as after
            renumbering all entities will have a positive ID.
offset_flag
Flag to specify whether to use offsetting: 
0 Use start_id and incr_val and ignore
              offset_val. 
1 Use offset_val and ignore start_id and
              incr_val.

","Example
To renumber the internal HyperMesh IDs of the displayed
        elements starting from 100 with an increment of 1:
*createmark elems 1 displayed
*renumber elems 1 100 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1896,*renumberelemsnodesasmapgrid ,"Description
Orders nodes and elements in grid format and renumber nodes and elements with specified
        start ID.
","Inputs

elem_mark_id
The ID of the mark containing the elements to renumber. Only quad elements are
            allowed. Valid values are 1 and 2.
origin_node_id
The ID of the node to use as the origin of the grid.
x_ref_node_id
The ID of the node to use as the x-axis of the grid.
elem_start_id
The starting ID to use for renumbering the elements.
node_start_id
The starting ID to use for renumbering the nodes.

","Example
To renumber all elements, using node 4 as the origin, node 1 as the x-axis, with IDs
        starting at 100 for both nodes and elements:
*createmark elems 1 all
*renumberelemsnodesasmapgrid 1 4 1 100 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1897,*renumbersolverid,"Description
This command renumbers the solver IDs for entities of entity_type
        contained on mark_id. 
This command works in two ways depending on the entities selected. If the selected entities
        have solver IDs, the command will renumber the solver IDs and not the HyperMesh internal IDs. However, if the selected entities do not have
        solver IDs, the command will renumber the HyperMesh internal IDs
        (see *renumber).
","Inputs

entity_type
The type of entity selected for renumbering.
mark_id
The mark that contains the entities. Valid values are 1 and 2.
start_id
Integer value > 0 specifying the starting value.
incr_val
Integer value > 0 specifying the renumbering increment.
offset_val
Integer value to use for offsetting. Can be positive or negative as long as after
            renumbering all entities will have a positive ID.
offset_flag
Flag to specify whether to use offsetting. 
0 Use start_id and incr_val and ignore
              offset_val. 
1 Use offset_val and ignore start_id
              and incr_val.
reserved_1
Reserved for future development. Value = 0.
reserved_2
Reserved for future development. Value = 0.
reserved_3
Reserved for future development. Value = 0.0.

","Example
To renumber the solver IDs of the displayed elements starting from 100 with an increment of
        1:
*createmark elems 1 displayed
*renumbersolverid elems 1 100 1 0 0 0 0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1898,*reorderinclude,"Description
Changes the order of the include files in a model.
","Inputs

id_to_move
The ID of the include file that should move.
id_of_predecessor
The ID of an include file after which the id_to_move include file
            should be placed in the database.
reparent_flag
Determines whether the predecessor file also becomes the parent of the include file
            that moves:
1 the predecessor file becomes the parent 
0 the predecessor file and moved include file are at the same level in
                hierarchy



","Example
HyperMesh writes out include files in ID-order. This means that
        reordering include files is equivalent to renumbering some include files, with the added
        possibility of a change in the hierarchy.
","Errors
None.
"
1899,*reparammark ,"Description
Reparameterizes the lines on a mark. 
","Inputs

mark_id
The ID of the mark containing the lines to be reparameterized.  Valid values are 1 and
            2.

","Examples
To reparameterize lines 1 and
        2:*createmark lines 1 2
*reparammark 1
","Errors
None.
"
1900,*replacentitywithentity,"Description
This command replaces a single component.
","Inputs

mode
The replace mode. Valid values are:
0 - Undo/reject replace operation. 
1 - Initial replace operation. 
2 - Finish/accept replace operation.


entity_type
The type of entity to replace. Currently only supported for comps.
existing_id
The ID of the existing/old entity.
incoming_id
The ID of the incoming/new entity.
string_array
The ID of the string array that contains the input options. The string array is
            created using the *createstringarray command. This should always be
            set to 1. 
The supported options and values are:
tolerance=value
The replacement tolerance. Right now it is a global tolerance, meaning the same
                  tolerance is applied for all replace entities. The default is 0.01.
keep_src_prop=value
0 - Do not reuse/keep the property assigned to the outgoing component (default) 
1 - Reuse/ assign property of source component to the outgoing component.
keep_src_mat=value
0 - Do not reuse/keep the material assigned to the outgoing component (default) 
1 - Reuse/assign material of source component to the outgoing component.
keep_src_comp_cardimage=value
0 - Do not reuse/keep the card image assigned to the outgoing component
                  (default) 
1 - Reuse/ assign source component card image to the outgoing component.
keep_src_include=value
0 - Do not organize the incoming component to the outgoing component include
                  (default) 
1 - Organize the incoming component and its nodes/elements/reference entities to
                  the outgoing component include.
log_file=value
If a log file is desired, value should be set to the full path and file name to
                  write to.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To replace component 301 with component 501 using a tolerance of 0.5, keeping the source
        material, property and card image:
*createmark comps 1 100
*replacesetentitydata componentmark=1 componentpairingstring={{301 501}}
*createstringarray 4 ""tolerance=0.5"" ""keep_src_prop=1"" ""keep_src_mat=1"" ""keep_src_comp_cardimage=1""
*replacentitywithentity 1 comps 301 501 1 4

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1901,*replacesetentitydata,"Description
Sets the data required for part replacement. This must precede any calls to *replacentitywithentity or *replacentitywithentitymark.
The input options may be specified in any order.
","Inputs

componentname=<value>
The mark ID containing the components to be replaced.  Valid values are 1 and 2.
componentpairstring=<value>
The list of existing and incoming component name pairs.
incomingonlyentities=<value>
The list of entity types that are set as 'accept incoming'.
preservemark=<value>
The mark ID for 'accept incoming' entities to be preserved.  Valid values are 1 and
            2.

","Example
To replace components 301 and 302 with 501 and 502 respectively:
*createmark comps 1 301 302
*replacesetentitydata componentmark=1
*createmark sets 1 20 30
*createmark groups 1 20 30
*replacesetentitydata preservemark=1 incomingonlyentities={sets groups} componentpairingstring={{301 501} {302 502}}
*createstringarray 4 ""tolerance=0.5"" ""keep_src_prop=1"" ""keep_src_mat=1"" ""keep_src_comp_cardimage=1""
*createmark comps 1 301 302
*createmark comps 2 501 502
*replacentitywithentitymark 1 1 2 1 4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1902,*reset_elemsize_criteria ,"Description
Adjusts the current quality criteria to the specified ideal element size.
The current quality criteria must be previously set. If the quality criteria was not set,
        the command creates current criteria adjusted to the element size using one of the
        following:

interactive mode:
Criteria from the quality index panel.
batch mode:
Default quality criteria adjusted to the current ElementSize.

In interactive mode, this command also resets the current values in the Quality Index
        panel.
","Inputs

elementsize 
The double value of the ideal element size for the criteria to be set.

","Example
*reset_elemsize_criteria 15.0
","Errors
None.
"
1903,*resetcuttingplanesbase,"Description
Sets the origin coordinates for all cutting planes.
","Inputs

x
The x coordinate of the origin.
y
The y coordinate of the origin.
z
The z coordinate of the origin.

","Example
To set the cutting plane origin to (5,0,7):
*resetcuttingplanesbase 5.0 0.0 7.0
","Errors
None.
"
1904,*resize ,"Description
Sets the resize flag in HyperMesh. 
","Inputs

on
Set to 0 if the full-size plots should not be resized to the size of the window;
            otherwise, set to 1. 

","Errors
None.
",
1905,*restoreviewmask ,"Description
Restores a view saved using *saveviewmask. The orientation and visible
        entities can be restored.
","Inputs

view_name
The name of the view to restore.
visible
A flag indicating whether to restore the visible entities or not. Valid values are: 
0 - Restore the visible entities and view orientation. 
1 - Restore the view orientation only. 
2 - Restore the visible entities only.

","Example
To restore the view with the name ""my_view"", including the orientation and visible
        entities:
*restoreviewmask ""my_view"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1906,*reversecontactsurfnormals ,"Description
Change normals (inward to outward, vice versa) of contactsurf.
","Inputs

Name
Name of the contactsurf being created.
Elemmark
Elements whose normal need to be reversed.
Indelems
Flag for reversing normals of all or individual elements of a contactsurf (0 = all
            elements and 1 = individual elements).

","Example
Reverse normals of contactsurf ""test"" for the elements on mark 1 
*reversecontactnormals(""test"", 1, 0)
If indelems flag = 0 then the mark is empty as all elements in contactsurf are
        selected.
","Errors
None.
"
1907,*reviewclearall ,"Description
This command removes/clears all entities from the review list.
","Example
To clear all entities from the review list:
*reviewclearall
","Errors
None.
",
1908,*reviewclearbymark,"Description
This command removes/clears entities from the review list based on a mark.
","Inputs

entity_type
The type of entity to remove from to the review list. Valid values are:
nodes 
elems 
points 
lines 
surfs 
solids 
connectors 
loads 
equations 
systs 
vectors


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.

","Example
To remove elements 1-100 from the review list:
*createmark elems 1 1-100
*reviewclearbymark elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1909,*reviewentity,"Description
This command graphically reviews a specified entity.
","Inputs

entity_type
The type of entity to review.
search_type
The method used to specify the entity. The entity is specified using the
              id_name argument. Valid values are: 
""by name"" - Entity is specified using the entity name. 
""by id"" - Entity is specified using the entity ID.
id_name
The ID or name of the entity, depending on search_type.
color
The color used to review the entity. Valid values are 1-64. 
If specified as 0, the entity will be reviewed with its respective entity color (not
            yet available).
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray. The valid strings are: 
showcomps - This indicates that components in which elements/geometry are referred
            will also be reviewed. If not provided, only specified elements/geometry are
            reviewed.

","Examples
To review component with ID 3 using color 10:
*reviewentity comps ""by id"" 3 10 1 0
To review element with ID 4, along with its component, using color 10:
*createstringarray 1 showcomps
*reviewentity comps ""by id"" 3 10 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1910,*reviewmaterialorientation ,"Errors
None.
",,,
1911,*reviewreferencegeometry ,"Description
Reviews reference geometry control volume. 
","Inputs

entities
Nodes used to create the reference geometry are reviewed.
markmask
Source of nodes used to review reference geometry. 
(1-nodes selected by user)
name
Name of the reference geometry. 

","Example
To review reference geometry (called ""airbag"") using elements selected by user:
*createcontrolvol(elements,""airbag"")
","Errors
None.
"
1912,*reviewtwomark ,"Description
Graphically reviews two mark of nodes with different colors.
","Inputs

mark_id1
The first mark of nodes.
mark_id2
The second mark of nodes.
color1
The color used to review the nodes on mark 1. Valid values are 1-64. 
If specified as 0, the entity will be reviewed with its respective entity color (not
            yet available).
color2
The color used to review the nodes on mark 2. Valid values are 1-64. 
If specified as 0, the entity will be reviewed with its respective entity color (not
            yet available).

","Example
To review nodes 1-100 with color 4 and nodes 201-300 with color 6:
*createmark nodes 1 1-100
*createmark nodes 2 201-300
*reviewtwomark 1 2 4 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1913,*rigidlink ,"Description
Creates a rigid link element between an independent node and multiple dependent nodes.
","Inputs

independent
The independent node of the element.
mark
The ID of the mark containing the dependent nodes.
dof
The degree of freedom code for which all of nodes of the element are active (any of
            the digits 1-`6).

","Example
To create a rigid link element with independent node 100 and dependent nodes 101, 102, and
        103 with nodes having all six degrees of freedom:
*createmark(nodes,2) 101 102 103
*rigidlink(100,2,123456)

A *createmark() command is required to define the mark. 
","Errors
None.
"
1914,*rigidlinkinodecalandcreate ,"Description
Creates a rigidlink elem by calculating the independent node based on selection of
        dependent nodes. Location of independent nodes will be at the geometric center of dependent
        nodes.
","Inputs

node_mark1
Mark for multiple dependent nodes. 
set_id
Set that contains dependent nodes. Set type should be of nodes.
attach_set_option
Options for attaching set to rigidlink: 
0- set will not be created when multiple dependent nodes are selected. 
1- set will be created when multiple dependent nodes are selected and then assigned to
            rigidlink.
dof
Degrees of freedom. This is a six digit number.

","Example
For creating a rigidlink elem by selecting only dependent nodes without the attach set
        option: 
*rigidlinkinodecalandcreate(2,0,0,123456)

For creating a rigidlink elem by selecting only dependent nodes with the attach set
        option:
*rigidlinkinodecalandcreate(2,0,1,123456)

For creating a rigidlink elem by selecting only dependent node set with the attach set
        option:
*rigidlinkinodecalandcreate(0,2,1,123456)
*createmark() for nodes is required if a dependent node set is not
        selected.
","Errors
None.
"
1915,*rigidlinkupdatecalcinodebycollector ,"Description
This command updates the rigid link by calculating the independent node based on selection
        of dependent nodes defined by comps, mats, assems, props sets and nodes.
","Inputs

element_id
The ID of the rigid link.
mark_id
Collector put on mark. Valid values are 1 and 2.
entity_type
The type of entity for dependent nodes. Valid entity types are comps, mats, assems,
            props, sets and nodes.

","Example
To update a rigid link element ID 7 by selecting dependent node specified by comps ID 1 and
        2 put on a mark 1: 
*createmark comps 1 1 2
*rigidlinkupdatecalcinodebycollector 7 1 comps

","Errors
None.
"
1916,*rigidlinkwithset_twonodes ,"Description
Create a rigid link element ""55"" between two nodes, with a dependent node attached as a
        node set connected with the element. 
","Inputs

independent
The independent node of the element.
dependent
The dependent node of the element.
dof
The degrees of freedom for which the element is active (any of the digits 1-6). 

","Example
To create a rigid link element with dependent nodes attached as a set between nodes 100 and
        101 in all six degrees of freedom: 
 *rigidlinkwithset_twonodes(100,101,123456)
A node set with an automatically generated name is created and a dependent node is placed
        in this set.
","Errors
None.
"
1917,*rigidwall_geometry,"Description
Adds geometric definition to a rigid wall.
","Inputs

name
The name of the rigid wall.
geometrytype
Use:
 1 infinite plane 
2 finite plane 
3 infinite prism 
4 finite prism 
5 cylinder 
6 sphere 
7 MADYMO plane 
8 MADYMO ellipse


basenode
The ID of the base node for the rigid wall.
vectors 
The normal vector.
n1, n2
The ID of the nodes used to define the rigid wall.
geomvar1 
The length in the x directon or radius. This is also used for the MADYMO plane/ellipse ID value.
geomvar2 
The length in the y direction.
geomvar3
The length in the z direction.

","Errors
None.
",
1918,*rlinkcalcinodeandcreateforcollector,"Description
This command creates the rigid link by calculating the independent node based on selection
        of dependent nodes defined by collector. The supported collectors are comps, mats, assems,
        props and sets
","Inputs

entity_type
Entity type of collector. Valid entity types are comps, mats, assems, props and
            sets.
mark_id
Collector put on mark. Valid values are 1 and 2.
dofs
The degree of freedom for which the element is active. Valid values are any of the
            digits 1-6.

","Example
To create a rigid link element by selecting dependent node specified by comps ID 1 and 2
        put on a mark 1 with DOF 123456: 
*createmark comps 1 1 2
*rlinkcalcinodeandcreateforcollector comps 1 123456
","Errors
None.
"
1919,*rotate ,"Description
Rotates the model based on a user-defined rotation axis. 
","Inputs

axis angle
The angle in degrees which defines how far from horizontal the rotation axis is. 
rotation angle
The angle in degrees which the model rotates.

","Example
To rotate a model about the horizontal screen axis 15 degrees: 
*rotate(0.0,15.0)
To rotate a model about the vertical screen axis 15 degrees: 
*rotate(90.0,15.0)
The rotation axis is defined by a line which runs horizontally through the center of the
        screen if the axis angle is zero. As the axis angle increases in magnitude, the axis of
        rotation rotates about the vector normal to the screen axis angle degrees. 
","Errors
None.
"
1920,*rotatedummy ,"Description
Rotates the dummy by an arbitrary axis that is specified by the
          *createplane() command.
","Inputs

entities
The entity type selected that recognizes the dummy. Currently, only components is
            supported.
collectorid
The id of the entity recognizing the dummy.
plane
The plane defining the arbitrary axis that the dummy rotates about.
increment
The number of degrees to rotate the dummy.

","Example
To rotate about the x axis by 90 degrees, specify a component that exists within the dummy
        (and is included in the parent/child system): 
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*rotatedummy(components,1,1,90)

","Errors
None.
"
1921,*rotatemark,"Description
This command rotates a selection of entities about a plane.
","Inputs

entity_type
The type of entity to rotate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the rotation. The normal of this plane will be used as
            the axis of rotation. This is defined using the *createplane
            command.
angle
The angle to rotate in degrees.

","Example
To rotate element 56 and 57 about the z axis (30 degrees) with an origin of
        (3.0,4.0,0.0):
*createplane 1 0.0 0.0 1.0 3.0 4.0 0.0
*createmark elems 1 56 57
*rotatemark elems 1 1 30.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1922,*savefailednodesvectors,"Description
Saves the location, magnitude, and direction of the penetrated areas.
","Inputs

mark
The mark of entity to be modified.
reduction
The average thickness reduction.
scale
The thickness scale factor.
segment
The segment orientation option.
magnitude_mode
Determines if a magnitude percentage or a uniform size is to be used.
1 magnitude percentage 
0 uniform size



","Example
To save the information of the penetration areas:
*createmark(groups, 1) ""E2E""
*savefailednodesvectors(1,0,1,1,0)

*createmark() and *templatefileset() are
        required.
","Errors
None.
"
1923,*saveviewmask ,"Description
Saves the currently view orientation and visible entities. Views are stored in the
        database.
","Inputs

view_name
The name of the view to save. The numbers 1-5 are reserved and cannot be used.
visible
A flag indicating whether to save the visible entities or not. Valid values are:
0 - Save the visible entities and view orientation. 
1 - Save only the view orientation.



","Example
To save a view with the visible entities, with the name ""my_view"":
*saveviewmask ""my_view"" 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1924,*scalemark ,"Description
This command scales a selection of entities by multiplying the coordinates.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
scale_x
The multiplication factor for the x-coordinate.
scale_y
The multiplication factor for the y-coordinate.
scale_z
The multiplication factor for the z-coordinate.
origin
The node ID defining the origin of the scaling. If set to 0, the global origin is
            used. 

","Example
To scale component top uniformly 10 times about node 3:
*createmark comps 1 top
*scalemark comps 1 10.0 10.0 10.0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1925,*screencopy,"Description
Allows users to create a bitmap of the screen and send it to the printer. 
","Errors
None.
",,
1926,*screenfile,"Description
Allows users to create a bitmap of the screen and save it in a file. 
","Errors
None.
",,
1927,*section_plane_mesh ,"Description
Generates a shell mesh from a selection of planar boundary elements.
","Inputs

entity_type
The type of entity to use as input for the boundary. Valid values are comps and
            elems.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
mesh_type
Flag indicating the type of mesh to generate. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_size
The target element size.
connectivity
Manage the connection with input boundary/overlay elements. Valid values are:
0 - Generate mesh using given element size. Ignore
                  elem_mark_id.

1 - Manage connection with the user given boundary elements. Ignore
                  elem_mark_id. 
2 - Manage connection with elements specified with elem_mark_id. Elements on
                  elem_mark_id should be part of mark_id as
                well. 
3 - Manage connection with boundary elements which are not on
                  elem_mark_id. 
4 - Manage connection with overlapped elements on
                elem_mark_id. Overlapped elements should not be tagged as
                boundary elements on mark_id. 
5 - Manage connection with boundary elements which do not overlap
                  elem_mark_id elements. Overlapped elements should not be tagged
                as boundary elements on mark_id.


elem_mark_id
The ID of the mark containing the boundary/overlay elements used to manage the
            connectivity. Valid values are 1 and 2.

Ignored if connectivity is set to 0 or 1.
tol
The tolerance to use for overlay check. If set as 0, the tolerance will attempt to be
            automatically detected.

","Example
To create a section plane quad mesh of size 2.0, using elements 10-30 as boundary input,
        and elements 1-5 as overlapped:
*createmark elems 1 10-30
*createmark elems 2 1-5
*section_plane_mesh elems 1 1 2.0 4 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1928,*segmentsetaddfacesusingfacenumber,"Description
Adds faces of elements using a specific face number to a segment set.
","
Inputs


name
The name of the segment set to update.
mark_id
The ID of the mark containing the elements to add.  Valid values are 1 and 2.
face_number
The face number of the element (starting from 0).
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal
element_id
If non-zero, specifies the single element to use instead of
            mark_id.  option must be set non-zero.
option
If non-zero, specifies to use element_id instead of
              mark_id.

","Examples
To add elements 1 through 100 using face number 2 to segment set
        ""test"":*createmark elems 1 1-100
*segmentsetaddfacesusingfacenumber ""test"" 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1929,*segmentsetaddshells,"Description
Adds selected 1D and 2D elements to a segment set.
","
Inputs


name
The name of the segment set to update.
mark_id
The ID of the mark containing the elements to add.  Valid values are 1 and 2.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal

","Examples
Add elements 10, 11, 12 and 13 to segment set
        ""test"":*createmark elements 1 10 11 12 13
*segmentsetaddshells ""test"" 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1930,*segmentsetcreateusingfacenumber,"Description
Creates a segment set using 2D element edges or 2D/3D element faces.
","
Inputs


name
The name of the segment set to create.
color
The color of the segment set.  Valid values are 1-64.
mark_id
The ID of the mark containing the elements to use.  Valid values are 1 and 2.
face_number
The face number of the element (starting from 0).
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal
element_id
If non-zero, specifies the single element to use instead of
            mark_id. option must be set non-zero.
option
If non-zero, specifies to use element_id instead of
              mark_id.

","Examples
To create a segment set named ""test"" with elements 1-100 using face number
        3:*createmark elems 1 1-100
*segmentsetcreateusingfacenumber ""test"" 5 1 3 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1931,*segmentsetcreatewithmixedfaces,"Description
Creates a segment set using a mixture of solid elements and shell elements.
","
Inputs


name
The name of the segment set to create.
color
The color of the segment set.  Valid values are 1-64.
elem_mark_id
The ID of the mark containing the elements to use. Valid values are 1 and 2.
node_mark_id
The ID of the mark containing the nodes that define an edge or a face of an element.
            Valid values are 1 and 2.
break_angle
The break angle for finding adjacent elements.
reverse_normals
Create segment set:
0 - Along element normal
1 - Opposite element normal

","Examples
To create a segment set named ""test"" with elements 1-100 with faces defined by nodes 1-5
        and a breakangle of
        30.0:*createmark elems 1 1-100
*createmark nodes 1 1-5
*segmentsetcreatewithmixedfaces ""test"" 5 1 1 30.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1932,*segmentsetremoveelems,"Description
Removes elements from a segment set.  If all elements are removed, the empty segment set
        still exists.
","
Inputs


name
The name of the segment set to update.
mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.

","Examples
To remove elements 100 and 101 from the segment set
        ""test"":*createmark elems 1 100 101
*segmentsetremoveelems  ""test"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1933,*segmentsetreversenormals,"Description
Reverse normals of a segment set.
","
Inputs


name
The name of the segment set to update.
mark_id
The ID of the mark containing the elements to reverse when
              reverse_flag is 1. Valid values are 1 and 2.
reverse_flag
0 - Reverse all, mark_id is ignored
1 - Reverse individual, mark_id is used

","Examples
Reverse normals of segment set ""test"" for the elements on mark
        1:*createmark elements 1 100-150
*segmentsetreversenormals ""test"" 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1934,*selfstitchcombine ,"Description
This command performs equivalencing of edges within surfaces or/and between surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to operate on. Valid values are 1 and 2.
mode
The mode options for performing the stitching. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 64*StitchOption).
Bit0
0 - Do not consider self-stitching. 
1 - Consider self-stitching (same surface edges).
Bit1
0 - Do not stitch edges between different surfaces. 
1 - Stitch edges between different surfaces.
Bit2
0 - Consider free edges only. 
1 - Consider all edges.
Bit3
0 - Equivalence between components. 
1 - Do not equivalence between components.
Bit4
0 - Do not collapse small edges. 
1 - Collapse small edges.
StitchOption
0 - Honor the value set by Bit3. 
1 - Do not equivalence between components (same as Bit3=1). Bit3 is ignored. 
2 - Equivalence between components (same as Bit3=0). Bit3 is ignored. 
3 - Equivalence between selected surfaces and surfaces connected to selection.
                  Bit3 is ignored. 
4 - Equivalence only within the subset of selected surfaces. Bit3 is
                  ignored.


tolerance1
Equivalencing tolerance for edges of different surfaces.
tolerance2
Equivalencing tolerance for edges within one surface. 

","Example
To equivalence edges between all displayed surfaces using a tolerance of 0.2:
*selfstitchcombine 1 2 0.2 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1935,*separate_holes_in_3d_body_new ,"Description
This command takes as input a mark of surfaces or solids of a 3D body. It finds holes in
        the 3D body, collects the found connected holes in tubes, and groups the tubes by diameter
        either according to the user- specified diameter ranges or by autocreating the groups from
        the user-specified tolerance. The command creates a component with an autogenerated name for
        each diameter group and moves the relevant surfaces of the tubes to the corresponding
        components. Blind-holes and through-holes are considered as different groups, so they are
        grouped separately. Optionally, the surfaces of the detected holes can be put to an output
        mark. 
The command parameters have the following meaning:
","Inputs

entity_type
The type of selected input entites. surfaces and solids are supported: 
If the surfaces mark is being used as input, it should be applied to all surfaces
            constituting each considered 3D body. If the surfaces mark is not applied to all
            surfaces of a 3D body, the result is unpredictable.
input_mark_id
The input surfaces or solids mark id of the input. Valid values are 1 and 2.
output_mark_id
The mark ID to mark the surfaces of the detected holes. Valid values are 0, 1 or 2. If
            set to 0 the detected holes’ surfaces are not marked.
flags
Sets a filter for the shape of cross sections of holes to be recognized. Supported
            values are:
0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round holes are detected. 
2 - Only rounded slots are detected. 
3 - Both round holes and rounded slots are detected.


string_array
The ID of the string array that contains the fillet width and radius group
            information. The string array is created using the *createstringarray
            command. This should always be set to 1. 
The first (optional) string in quotations may contain the following parameters as
            keywords followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
cross_sect_size_max 
Maximum length of the holes normal to the holes axes cross sections. This
                  applies only to elongated holes (rounded slots or elliptical holes). If
                    cross_sect_size_max = 0, then no limitation is applied. The
                  default value is 0.
diam_tolerance
If this option is set, then the holes tube groups are to be autodefined by this
                  specified tolerance and any group diameter ranges are ignored.
diam_min
Minimum diameter of holes for recognition. Default value is 0.
diam_max
Maximum diameter of holes for recognition. If specified to be 0, then no limit
                  is applied. Default value is 0.
diams_ratio_max
Maximum ratio of diameters of adjacent co-axial cylindrical hole sections when
                  the sections are considered within the same tube. Default value is 2.5.
All other strings may contain up to 3 quoted values. These indicate the group
                  diameter ranges. It is not necessary to specify the string name, just the
                  values:
min_group_diam
(double) 
max_group_diam
(double) 
group_flag (int) (optional)
Value of 0 (disable group) or 1 (enable group) indicating if that diameter group
                  is considered. Default is 1 for all groups.  
The group ranges should not overlap but may have gaps between them.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To recognize round holes with diameters from 0 to 50 in 3D model, separate them in groups
        by diameter according the ranges: 10-11, 12-15, 17-20, 20-30 and 30-50, allow adjacent tube
        sections diameter ratio of up to 3.0 and to mark the detected holes surfaces on mark 2:

*createmark surfaces 2 """"
*createmark surfaces 1 ""all""
*createstringarray 6 ""cross_sect_size_max = 50 diams_ratio_max = 3.0"" ""10 11"" ""12 15"" ""17 20"" ""21 30"" ""30 50""
*separate_holes_in_3d_body_new surfs 1 2 0 1 6
The same example but the diameters range 12-15 should be disabled without removing it from
        the input:
        *createmark surfaces 2 """"
*createmark surfaces 1 ""all""
*createstringarray 6 ""cross_sect_size_max = 50 diams_ratio_max = 3.0"" ""10 11"" ""12 15 0"" ""17 20"" ""21 30"" ""30 50""
*separate_holes_in_3d_body_new surfs 1 2 0 1 6

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1936,*set_default_quality_criteria,"Description
 Sets the default criteria, adjusted to a specified element size, as the current quality
        criteria.
","Inputs

elementsize
The double value of the ideal element size for the criteria to be set.

","Example
In interactive mode, this command also resets the current values in the quality index
        panel. 
*set_default_quality_criteria(3.5)
","Errors
None.
"
1937,*set_meshedgeparams,"Description
This command sets the edge-specific parameters for the automeshing module. It controls both
        standard and chordal mesh algorithm parameters.
","Inputs

edge_index
The index of the edge in the particular surface under consideration. This is a 0-based
            index that operates on the edges in the order they are returned from
              hm_getsurfaceedges. One can query the edges for a surface using
              hm_getsurfaceedges, and then the index of each edge in the returned
            list (starting from 0) are the possible indices.
elem_density
The density of elements to use along the given edge.
alg_type
1 - Use size & biasing algorithm 
2 - Use chordal deviation algorithm. When the command is being called for the first
            time for an edge, or when any of the chordal deviation parameters have been changed, the
              elem_density parameter is ignored and the edge element density is
            set to the value required by the chordal deviation parameters. Subsequent calls of the
            command with the same chordal deviation parameters reset the edge element density to the
            specified value with the same along edge density distribution. Calling the command with
              elem_density = 0 results in the resetting of the edge element
            density to the value required by the chordal deviation parameters.
bias_style
The style of biasing to use. Valid values are:
0 - linear 
1 - exponential 
2 - bell curve


bias
The biasing value of the element length to use along the given edge.
min_size
The minimum element size for the edge for chordal deviation meshing.
max_size
The maximum element size for the edge for all alg_type.
chordal_dev
The maximum chordal deviation distance for the element for the edge.
max_angle
The maximum turn angle value (in degrees) between adjacent element links for the edge
            for chordal deviation meshing.

","Example
To create specify deviation based node seeding for edge 29 with minimum element size 0.5,
        maximum element size 15.0, maximum chordal deviation 0.2, and maximum element links turn
        angle 25 degrees with the element density required by the chordal deviation parameters:
*set_meshedgeparams 29 0 0 0 0 0.5 15 0.2 25
Same example as above, but with element density 4 requiring that the command be applied
        twice:
*set_meshedgeparams 29 4 0 0 0 0.5 15 0.2 25
*set_meshedgeparams 29 4 0 0 0 0.5 15 0.2 25
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1938,*set_midsurface_z_offset,"Description
This command sets the z-offset value assigned to a midsurface. The thickness assigned to a
        midsurface interprets the z-offset value according to three possible thickness origins:
Centered midsurface - When the thickness is assigned to the midsurface positioned in
            the middle between the plate sides.
Midsurface with base z-offset - When the thickness is assigned to the midsurface which
            is shifted from the center to accommodate steps or a base surface.
Midsurface side - When the thickness is assigned to the sides of the plate during the
            midsurface extraction.


Currently, this command will set the thickness origin to be ""Centered midsurface"". However,
        if this command is used to set a constant z-offset value on a variable thickness surface, it
        is no longer possible to position the variable thickness correctly. Therefore, this command
        should only be used for constant thickness surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to update. Valid values are 1 and 2.
z_offset
The constant z-offset value to assign to the surfaces.
reserved
Reserved for future use. Must be set to 0.

","Example
To set the z-offset value of surfaces 1-4 to 0.25:
*createmark surfs 1 1-4
*set_midsurface_z_offset 1 0.25 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1939,*setautoupdatesets,"Description
Controls automatic updating of sets, segment sets, and contact surfaces during mesh
        changes.  To query the current value, use hm_getoption.
This is not supported in the Radioss profile.
","
Inputs


mode
0 - Disabled
1 - Enabled

","Examples
To enable:
*setautoupdatesets 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1940,*setcleanupglobalflags,"Description
This command takes as input a mask of flags used for controlling some of the default modes
        for geometry autocleanup, element cleanup and element QI smoothing. It sets or clears the
        global cleanup flags according to the specified mode.
 The commands which can be affected by resetting the global cleanup default flags are as
        follows:
*autotopocleanup
*hm_auto_elem_cleanup_new
*hm_batchmesh
*hm_failed_elements_cleanup
*optimsmooth
*qismoothfixfailed
*qismoothconstrained
","Inputs

flags
Flags bit value that indicate the global settings to set. To set multiple flags at
            once, sum the bit values for the requested flags. The default bit value for each flag is 0.
1 - Ignore component boundaries flag. 
2 - Do not allow preservation of special transversal surfaces on lines generated
                during geometry autocleanup and batchmeshing flag. 
4 - Fixed vertices created by geometry autocleanup do not remain fixed after
                completion flag.


mode
The mode of the manipulation of the global cleanup flags. The supported modes are as follows:
0 - resets all flags bits to 0. 
1 - sets the bits specified by flags without changing other flag bits. 
2 - sets all flags at once to the specified bit value.



","Examples
Assign the current word of all flags to the variable prv_flgs. Setup the
        flags to ignore component boundaries and to not create auxiliary surfaces. Then element QI
        smoothing is performed. Finally, all flags are restored to their original state:
set prv_flags [hm_getcleanupglobalflags 0]
*setcleanupglobalflags 3 1

*createmark elements 1 ""all""
*createmark nodes 1 """"
*optimsmooth 1 1 ""C:/Altair/hw10.0/hm/batchmesh/8mm.criteria"" 30.0 0.20 5 0 

*setcleanupglobalflags $prv_flags 2 
To set the auxiliary surface generation to the default:
*setcleanupglobalflags 2 0
To clear the ignore component boundaries flag without changing any other flags:
*setcleanupglobalflags 1 0
To clear all supported flags:
*setcleanupglobalflags 0 2
or:
*setcleanupglobalflags 7 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1941,*setcomponentdisplayattributes ,"Description
Sets a component to the specified style and color. 
","Inputs

name
The name of the component.
style
Set to:
0 - Wire frame 
1 - Hidden line 
2 - Hidden line with mesh 
3 - Hidden line with features 
4 - Hidden line transparent


colortype
Determines how the component is colored. The options are:
0 - None 
1 - Component color 
2 - Assigned plots 
3 - Contours 



","Errors
None.
",
1942,*setcurrentinclude,"Description
Specifies the include file into which HyperMesh should place
        newly created entities.
","Inputs

id
The ID of the file. If this is 0, then HyperMesh uses the
            shortname to find the file.
shortname
The shortname of the file, as defined when creating the include (see
              *createinclude() ).

","Example
If the ID is 0, and the shortname is empty (""""), then HyperMesh
        will place newly created entities in the main output file instead of an include file.
","Errors
None.
"
1943,*setcuttingplaneactive,"Description
Turns the specified cutting plane on/off.
","Inputs

axis
The axis that is normal to the plane. Valid values are:
0 - the plane with x-axis as its normal 
1 - the plane with y-axis as its normal 
2 - the plane with z-axis as its normal


state
0 - off 
1 - on

","Example
To turn off the cutting plane with y-axis as its normal:
*setcuttingplaneactive 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1944,*setcuttingplanesbase ,"Description
Sets the origin coordinates for all cutting planes.
","Inputs

x
The x coordinate of the origin.
y
The y coordinate of the origin.
z
The z coordinate of the origin.

","Example
 To set the cutting plane origin to (5,0,7):
*setcuttingplanesbase 5.0 0.0 7.0
","Errors
None.
"
1945,*setcuttingplanethicknesson,"Description
Turns the specified cutting plane thickness on/off.
","Inputs

axis
 The axis that is normal to the plane. Valid values are:
0 - the plane with x-axis as its normal 
1 - the plane with y-axis as its normal 
2 - the plane with z-axis as its normal


state
Specifies the thickness state for the specified cutting plane. Valid values are:
0 - off 
1 - on



","Example
To turn off the thickness for cutting plane with y-axis as its normal:
*setcuttingplanethicknesson 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1946,*setedgedensitylink,"Description
This command sets the method for linking opposite edge densities during automeshing. This
        forces opposite edges of a surface to use consistent edge densities, provided that the
        starting densities are close enough. This creates tapered lines of elements, instead of
        using trias to transition between inconsistent densities. This is only valid for size and
        bias or edge deviation surface meshing.
","Inputs

method
Specifies the method to use for edge density linking. Valid values are:
0 - Do not link opposite edge densities. 
1 - Attempt to link opposite edge densities.



","Example
To mesh surface 12 with first order elements of size 0.5, and specifying an edge density
        link:
*setedgedensitylink 1
*setoption element_order=1
*createmark surfaces 1 12
*interactiveremeshsurf 1 1 2 2 2 1 1
*set_meshfaceparams 0 2 2 0 0 1 0.5 1 1 
*set_meshedgeparams 0 32 1 0 0 0 1 0 0
*set_meshedgeparams 3 5 1 0 0 0 1 0 0
*automesh 0 2 2
*storemeshtodatabase 1
*ameshclearsurface
","Errors
None.
"
1947,*setedgedensitylinkwithaspectratio,"Description
This command sets the method for linking opposite edge densities during automeshing. This
        forces opposite edges of a surface to use consistent edge densities, provided that the
        starting densities are close enough. This creates tapered lines of elements, instead of
        using trias to transition between inconsistent densities. This is only valid for size and
        bias or edge deviation surface meshing.
","Inputs

aspectratio
Specifies the aspect ratio to use for edge density linking. Valid values are:
-1 - Do not link opposite edge densities. 
0 - Attempt to link opposite edge densities with default value. 
> 0 - Attempt to link opposite edge densities with specified value.



","Example
To mesh surface 12 with first order elements of size 0.5, and specifying an edge density
        link using a value of 2:
*setedgedensitylinkwithaspectratio 2
*setoption element_order=1
*createmark surfaces 1 12
*interactiveremeshsurf 1 1 2 2 2 1 1
*set_meshfaceparams 0 2 2 0 0 1 0.5 1 1 
*set_meshedgeparams 0 32 1 0 0 0 1 0 0
*set_meshedgeparams 3 5 1 0 0 0 1 0 0
*automesh 0 2 2
*storemeshtodatabase 1
*ameshclearsurface
","Errors
None.
"
1948,*setelemparamcolor ,"Description
This command is related to the element quality view mode. It sets the color for a specified
        element quality parameter for elements violating the threshold.
","Inputs

param_id
Specifies the element quality check parameter ID to update. Valid values are:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation 
11 - quality index


color
The color to use. Valid values are 1-64.

","Example
To set ""aspect ratio"" color to brown:
*setelemparamcolor 2 28
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1949,*setelemparamsvisualpriorities,"Description
This command is related to the element quality view mode. It sets the priority for all
        element quality parameters when reviewing multiple criteria.
","Inputs

double_array
The ID of the double array containing the priority values for each quality parameter.
            Must always be set to 1. 
There are currently 11 quality parameters that can be set. The priority for each
            parameter must be specified, using a unique value of 0-10. The order of the parameters is:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation


number_of_doubles
Must currently be set to 11.

","Example
To set the priorities for all parameters:
*createdoublearray 11 3 4 7 2 1 10 8 9 0 5 6 
*setelemparamvisualpriorities 1 11
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1950,*setelemqualityparamactive,"Description
This command is related to the element quality view mode. It sets the on/off state for a
        specified element quality parameter.
","Inputs

param_id
Specifies the element quality check parameter ID to update. Valid values are:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation


active


0 - Inactive/off 
1 - Active/on



","Examples
To activate ""warpage"" parameter:
*setelemqualityparamactive 3 1
To disable ""Jacobian"" parameter:
*setelemqualityparamactive 9 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1951,*setfacetfactor,"Description
This command refines geometry graphical facets based on user settings.
","Inputs

refine_max
The number of times facets should be refined. Valid values are:
-1 - Return to unrefined display and clear all refinement memory usage. 
0 - Return to unrefined display but do not clear memory. 
> 0 - The number of times to refine the facets.


deviation_factor
A value between 0 and 1. The max chordal deviation of all facets is calculated. The
            chordal deviation of each facet from its surface will be calculated and if the deviation
            value is more than the tolerance*max chordal deviation, the facet
            will be refined.
angle
If the angle between the lines connecting the facet vertices and the max chordal
            deviation location for a facet exceed this value, the facet will be refined.
total
Ignores all other parameters and tries to refine the model to the specified number of
            total facets. 

","Examples
To refine facets based on a factor of 0.1 and an angle of 10:
*setfacetfactor 1 0.1 10 0
 To refine facets based on a total of 500 facets:
*setfacetfactor 1 0.1 10 500
To clear memory and return to the unrefined display:
*setfacetfactor -1 0.1 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1952,*setglobalply_option,"Description
Sets the ply/layer name to review. The element ply direction of that ply will be plotted
        for each selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_name
The name of the ply to review.
only_orient


0 - The new x-element directions are shown as continuous gradient lines starting
                and ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the
                element centroid.


normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64.
option
Option for review customization. Valid values are:
1 - Abaqus rebar layer will be reviewed



","Example
To review the ply directions for the second ply named ""ply45"" for the displayed elements
        with blue vectors of size 3:
*createmark elems 1 displayed
*setglobalply_option elems 1 ""ply45"" 1 3 7 1
*vectorsoff

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1953,*sethistorylimit,"Description
Sets the maximum number of history states to allow.
","Inputs

count
The number of history states to allow. 
0 - Disables all history recording, including potential legacy use cases. 
-1 - Indicates unlimited.



","Example
To set the maximum number of history steps to allow to 100:
*sethistorylimit 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1954,*sethistoryrecord ,"Description
Sets whether history recording is enabled or disabled.
","Inputs

state


0 - Disables all history recording, including potential legacy use cases 
1 - Enables history recording



","Example
To disable all history recording:
*sethistoryrecord 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1955,*setlegendbackgroundcolor,"Description
This command sets the HyperMesh legend background color. This
        applies to all HyperMesh legends.
","Inputs

red
The red color value, from 0.0 to 1.0.
green
The green color value, from 0.0 to 1.0.
blue
 The blue color value, from 0.0 to 1.0.
alpha
The alpha transparency value, from 0.0 to 1.0.

","Examples
To set the legend background color to red with no transparency:
*setlegendbackgroundcolor 1.0 0.0 0.0 1.0
Set legend background color to gray with some transparency:
*setlegendbackgroundcolor 0.5 0.5 0.5 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1956,*setmacrofile ,"Description
This command may be used to specify the macro file to use when HyperMesh starts. The default is hm.mac.
","Errors
None.
",,
1957,*setmarktopologydisplay ,"Description
This command sets the topology visualization style for the marked geometric entities.
","Inputs

entity_type
The type of entity to modify. Currently, only comps are supported.
mark_id
The ID of the mark containing the entities of entity_type. Valid values are 1 and 2.
vis_flag


0 - Wireframe geometry 
1 - Shaded geometry and surface edges 
2 - Shaded geometry no surface edges 
3 - Geometry with surface lines



","Example
To set the visualization for the displayed components to shaded with surface edges:
*createmark comps 1 ""displayed""
*setmarktopologydisplay comps 1 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1958,*setmeshparams,"Description
Sets 2D meshing edge and face parameters used during surface and element meshing.
For surface meshing, the edge definition is by surface edge entity ID or mark, and the face
        definition is by surface entity ID or mark. For element remeshing, the edge definition is by
        pair of node IDs of element edges, and the face definition is by element ID. While
        remeshing, topology is built with the user-defined feature option. A topological edge is
        assigned a user given edge parameter if it is part of a user given element edge, and
        similarly for face parameters.
","
Inputs



entity_type

The type of entity to set parameters for.  Valid values are surfaces and lines for
            surface meshing, and elements and nodes for element remeshing.
<select_type>=<selection>
The entity or entities that are to be set. There are several ways to provide the
            entities to be set. Only one option can be used at a time:
id=<id>
The ID of the single entity to consider.
id=<id1 id2>
The IDs of the two nodes to consider. These two nodes should be part of an
                  element edge. Valid only when entity_type is nodes.
EdgeMark=<mark_id>
The ID of the mark containing the surface edges to consider.  Valid only when
                    entity_type is surfaces or lines.
FaceMark=<mark_id>
The ID of the mark containing the surfaces or elements to consider.  Valid only
                  when entity_type is surfaces or elements.



EdgeAlgType=<value>

Flag indicating the edge algorithm type. Valid for entity_type as
            lines or nodes. Valid values are:
1 - Size and biasing 
2 - Chordal deviation. When the command is being called for the first time for an
            edge, or when any of the chordal deviation parameters have been changed, the
              elem_density parameter is ignored and the edge element density is
            set to the value required by the chordal deviation parameters. Subsequent calls of the
            command with the same chordal deviation parameters reset the edge element density to the
            specified value with the same along edge density distribution. Calling the command with
              elem_density=0 results in the resetting of the edge element density
            to the value required by the chordal deviation parameters.

EdgeBiasing=<value>

The biasing value of the element length to use along the edge. Valid for
              entity_type as lines or nodes.

EdgeBiasStyle=<value>

The style of biasing to use. Valid for entity_type as lines or
            nodes.  Valid values are:
0 - Linear
1 - Exponential
3 - Bell curve

EdgeChordalDeviation=<value>

The maximum chordal deviation distance for the element for the edge. Valid for
              entity_type as lines or nodes.

EdgeDensity=<value>

The element density for the edge. Valid for entity_type as lines or
            nodes.

EdgeDistribution=<value>

The user-defined internal node distribution (e.g. ""{0.1 0.3 0.6 0.9}"") for the edge.
            Valid for entity_type as lines or nodes.

EdgeElemSize=<value>

The element size for the edge. Valid for entity_type as lines or
            nodes.

EdgeMaxAngle=<value>

The maximum turn angle value (in degrees) between adjacent element links for the edge
            for chordal deviation meshing. Valid for entity_type as lines or
            nodes.

EdgeMaxSize=<value>

The maximum element size for the edge for EdgeAlgType=2. Valid for
              entity_type as lines or nodes.

EdgeMinSize=<value>

The minimum element size for the edge for all EdgeAlgType values.
            Valid for entity_type as lines or nodes.

FaceAlgType=<value>

Flag indicating the face algorithm type. Valid for entity_type as
            surfaces or elements. Valid values are:
0 - Standard surface meshing
1 - Meshing with flow ""align"" control
3 - Meshing with flow ""align"" and ""size"" control

FaceElemType=<value>

Flag indicating the elements generated for mapped meshing algorithms. Valid for
              entity_type as surfaces or elements. Valid values are:
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
4 - Quads only
5 - No meshing

FaceElemType2=<value>

Flag indicating the elements generated for free meshing algorithms. Valid for
              entity_type as surfaces or elements. Valid values are:
0 - Trias
1 - Quads
2 - Mixed
3 - Right trias
4 - Quads only
5 - No meshing

FaceMeshAlgorithm=<value>

Determines the surface-based mesh generation algorithm to use when creating elements
            on the face. Valid for entity_type as surfaces or elements. Valid
            values are:
1 - Auto-decide
2 - Map as rectangle
3 - Map as triangle
4 - Map as pentagon
5 - Map as circle
6 - Free shape
FaceMeshMapPoint1=<value>
FaceMeshMapPoint2=<value>

FaceMeshMapPoint3=<value>

FaceMeshMapPoint4=<value>

FaceMeshMapPoint5=<value>

For map algorithms, the optional mapping corner point IDs. Valid for
              entity_type as surfaces or elements.

FaceSizeControl=<value>

Flag indicating whether to create uniformly sized elements. Valid for
              entity_type as surfaces or elements. Valid values are:
0 - Do not create uniformly sized elements
1 - Create uniformly sized elements

FaceSkewControl=<value>

Flag indicating whether to create optimally shaped elements when using mapping
            algorithms. Valid for entity_type as surfaces or elements. Valid
            values are:
0 - Do not create optimally shaped elements
1 - Create optimally shaped elements

FaceSmoothMethod=<value>

The smoothing method to use. Valid for entity_type as surfaces or
            elements. Valid values are:
0 - Auto-decide 
1 - Size corrected
2 - Shape corrected

FaceSmoothTolerance=<value>

Applies the smoothing algorithm until the largest adjustment made to a nodal position
            is less than this value. Valid vales are > 0.0. Valid for entity_type
            as surfaces or elements.

","Examples
To set parameters and perform surface meshing:
*setmeshparams lines id=8 EdgeDensity=8 EdgeAlgType=1
*setmeshparams lines id=6 EdgeDistribution={0.125 0.25 0.375 0.5 0.625 0.75 0.875} EdgeAlgType=3
*setmeshparams surfs id=1 FaceElemType=2 FaceElemType2=5 FaceMeshAlgorithm=5 FaceAlgType=0
*setedgedensitylinkbytypeandaspectratio 0 -1
*createmark surfaces 2 1
*defaultremeshsurf 2 1 2 2 0 1 1 1 1 0 0 0 0
To set parameters and perform element meshing:
*setmeshparams nodes id={559 661} EdgeDistribution={0.111111 0.222222 0.333333 0.444444 0.555556 0.666667 0.777778 0.888889} EdgeAlgType=3
*setmeshparams nodes id={577 648} EdgeDensity=9 EdgeAlgType=1
*setmeshparams elems id=131 FaceElemType=2 FaceElemType2=5 FaceMeshAlgorithm=5 FaceAlgType=0
*setusefeatures 8
*setedgedensitylinkbytypeandaspectratio 1 0
*createmark elements 1 81-130
*defaultremeshelems 1 1 2 2 1 1 1 1 0 0 0 0 0 30
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1959,*setoffsetconflictoptionmessage,"Description
Set the message option when there is offset conflict during drag-and-drop.
","
Inputs



mode

0 - Do not keep the user input for all following drag-and-drop operations
1 - Keep the user input for all following drag-and-drop operations

","Examples
To keep the user input for all following drag-and-drop operations:
*setoffsetconflictoptionmessage 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1960,*setparameter,"Description
Parameterizes a data name or attribute on a single entity.
","Inputs

name
The name of parameter entity to assign.
entity_type
The type of entity to parameterize.
entity_id
The ID of the entity to parameterize.
data_name_or_attribute
The data name or attribute name/ID to parameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.
reserved
Must be set to 0.

","Example
To parameterize attribute LSD_DA1 on entity set 5 with the parameter named param1:
*setparameter param1 sets 5 LSD_DA1 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1961,*setply ,"Description
Sets the ply number to review. The element ply direction of that ply will be plotted for
        each selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_number
The number of the ply to review.
only_orient
0 - the new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - the new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64. 

","Example
To review the ply directions for the ply with ID 2 for the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*setply elems 1 2 1 3 7
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1962,*setqualitycriteria,"Description
Defines the current element quality criteria via flexible string input. This may be useful
        for autocleanup, interactive QI meshing, QI node optimization, element cleanup, etc...
","Inputs

string_array
The ID of the string array that contains the element quality criteria information. The
            string array is created using the *createstringarray command. This
            should always be set to 1. 
There are two types of strings, quality parameters and threshold penalty values. 
The 13 quality parameter strings have the following structure: ?line_number? tag switch weight ideal good warn failed worst ?method?
line_number(optional)
Line number.
tag
The unique parameter tag. Valid values are: 
min length 
max length 
aspect ratio 
warpage 
max angle quad 
min angle quad 
max angle tria 
min angle tria 
skew 
jacobian 
chordal dev 
taper 
% of trias


switch
0 - Disables 
1 - Enables the parameter.
weight
The dimensionless parameter weight in the composite quality index (1.0 is
                  default).
ideal good warn fail worst
A sequence of parameters value thresholds defining the start value of the
                  corresponding parameter range. The sequence should be monotonic, either increasing
                  or decreasing according to the specific parameter.
method (optional)
The method solver ID used for calculation of the parameter. See the list of the
                  methods IDs in the description of *elementchecksettings
                  command. If the method is omitted, then the default method is
                  applied.


The threshold penalty string has the following structure:?line_number? tag ideal_rate good_rate warn_rate fail_rate worst_rate
line_number (optional)
 Line number.
tag
The string 'penalty value'.
ideal_rate good_rate warn_rate fail_rate worst_rate
A non-decreasing sequence of dimensionless ratings corresponding to the
                  parameters' thresholds and used for calculation of the composite quality index by
                  each parameter value. The default penalties values are 0.0, 0.8, 1.0, 10.0. It is
                  not recommended to change the ratings for ideal and fail thresholds from the
                  default values.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.
mode
0 - The criteria are reset completely for all the elements quality parameters. Any
            omitted parameters are disabled. 
1 - The criteria data are changed only for the input elements quality parameters. Any
            omitted parameters remain unchanged.

","Examples
Completely reset the quality criteria using default methods:
*createstringarray 14 \
"" 0 penalty value      0.00    0.00    0.80    1.00   10.00"" \
"" 1 min length        1 1.0   3.000   2.749   1.502   1.000   0.749  1"" \
"" 2 max length        1 1.0   3.000   3.600   4.500   6.000   9.000  0"" \
"" 3 aspect ratio      1 1.0   1.000   2.000   4.400   5.000  10.000  0"" \
"" 4 warpage           1 1.0   0.000   5.000  13.000  15.000  30.000  0"" \
"" 5 max angle quad    1 1.0  90.000 110.000 134.000 140.000 160.000  0"" \
"" 6 min angle quad    1 1.0  90.000  70.000  46.000  40.000  20.000  0"" \
"" 7 max angle tria    1 1.0  60.000  80.000 112.000 120.000 150.000  0"" \
"" 8 min angle tria    1 1.0  60.000  50.000  34.000  30.000  15.000  0"" \
"" 9 skew              1 1.0   0.000  10.000  34.000  40.000  70.000  0"" \
""10 jacobian          1 1.0   1.000   0.900   0.700   0.600   0.300  0"" \
""11 chordal dev       0 1.0   0.000   0.300   0.800   1.000   2.000  0"" \
""12 taper             1 1.0   0.000   0.200   0.500   0.600   0.900  0"" \
""13 % of trias        1 1.0   0.000   6.000  10.000  15.000  20.000  0""
*setqualitycriteria 1 14 0
Reset aspect ratio and skew thresholds using ANSYS (solver 9)
        methods. Keep all other criteria
        unchanged:*createstringarray 2 ""aspect ratio 1 1.0 1.000 1.500 3.000 4.000 10.000 9"" ""skew 1 1.0 0.000 8.000 30.00 35.00 60.000 9""
*setqualitycriteria 1 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1963,*setqualitythresholdscolors,"Description
This command is related to the element quality view mode. It sets the color for all element
        quality index ranges.
","Inputs

double_array
The ID of the double array containing the color values for each quality index range.
            Must always be set to 1.
There are currently 5 quality index ranges that can be set. The color for each range
            must be specified, using a value of 1-64. The order of the parameters is:
0 - Ideal (ideal <= QI < good) 
1 - Good (good <= QI < warn) 
2 - Warn (warn <= QI < fail) 
3 - Fail (fail <= QI < worst) 
4 - Worst (worst <= QI)


number_of_doubles
Must currently be set to 5.

","Example
To assign the quality index thresholds colors: ideal 56 (green), good 41 (cyan), warn 28
        (brown), fail 57 (yellow) and worst 3 (red):
*createdoublearray 5 56 41 28 57 3
*setqualitythresholdscolors 1 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1964,*setreviewbyid ,"Description
This command adds entities to the review list based on an entity ID.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are blocks and groups. 
id
The ID of the entity.
color
The color to use for review of the entity. Valid values are 1-64.
review_type
The review type to control.
For blocks:
1 = nodes 
2 = elems


For groups:
1 = slave only 
2 = master only 
3 = master & slave



","Example
To review only slave elements from group 5 with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyid groups 5 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1965,*setreviewbymarkenhanced,"Description
This command adds entities to the enhanced review list based on a mark. This is similar to
          *setreviewbymark, but allows for entity shading and edge
        visualization.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are:
nodes 
elems 
points 
lines 
surfs 
solids 
connectors 
loads 
equations 
systs 
vectors


mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
color
The color to use for review of the entity. Valid values are 1-64.
shaded
If set to 1, surfaces and elements are put into shaded mode.
edges
If set to 1, surface and element edges are drawn in black.

","Example
To review elements 1-100 with color 4 and enabling shading and edge visualization, with all
        other non-reviewed entities having transparency and gray color:
*createmark elems 1 1-100
*setreviewbymarkenhanced elems 1 4 1 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1966,*setreviewcolormode,"Description
This command sets the color mode for non-review list entities.
","Inputs

mode
0 - gray 
1 - normal

","Example
To review slave elements only for group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
None.
"
1967,*setreviewtransparentmode ,"Description
This command sets the transparency mode for non-review list entities.
","Inputs

mode
0 - Normal 
1 - Transparent (polystipple)

","Example
To review slave elements only for group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
None.
"
1968,*setsolverusessegmentsets,"Description
Enables/disables support for segment sets.
Currently supported for OptiStruct, Radioss, Abaqus, EXODUS and Nastran.
","Inputs

flag
0 - Disable
1 - Enable

","Example
To enable support:
*setsolverusessegmentsets 1
",
1969,*setsubmodeltype,"Description
Sets the sub-model type supported by ID manaager.
","Inputs

type
The sub-model type.  Valid values are HM_INCLUDEFILES and MODULES.

","Example
To set the sub-model type to MODULES:
*setsubmodeltype MODULES
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1970,*setsystem,"Description
Sets the element (material) orientation by setting the angle. This angle is measured from
        the I-J (1-2) edge of the element around the normal of the element. Re-orients and
        visualizes the element (material) coordinate systems for selected elements. 
","Inputs

entities
Determines the selected entity, which can only be elements.
markmask
Determines the selected elements.
setangle
Determines the constant angle offset. 
onlyorient
1 -  The new x-element directions are shown as vectors starting from the element
              center.0 - The new x-element directions are shown as continuous gradient lines
              starting and ending on free edges.

normal_size
If onlyorient = 1, this determines the size of the vectors to be
            displayed.
color
Determines the color of the vector or line. The color ID number ranges from 1 to
            64.

","Example
To set a constant 45 degree offset for the I-J edge rotation in the element plane of four
        selected elements and display the projection as blue vectors (color 7) with size = 3:
*createmark(elements,2) 376 377 389 418
*setsystem(elements,2,45,1,3,7)
*vectorsoff()
The *createmark() and *vectorsoff() commands are
        required.
","Errors
None.
"
1971,*settrimcuttingplanes ,"Description
Turns the cutting plane trim option on/off.
","Inputs

state
Specifies the trim plane option for all cutting planes. Valid values are: 
0 - off 
1 - on

","Example
To turn off the trim cutting plane option:
*settrimcuttingplanes 0
","Errors
None.
"
1972,*setusefeatures ,"Description
Specifies the mode for defining and using feature edges for element-based re-meshing.
","Inputs

mode
The mode for defining and using feature edges for element-based re-meshing. 
0 - Feature edges will be auto-detected using the simple feature detection algorithm
            (as in the Features panel). The feature angle is set using *setoption
              feature_angle. 
1 - The selected mark of 1D plot elements will be used to form feature edges. This is
            also useful for using the Features panel to detect and manually edit features. The
            elements are specified using *elementsaddelemsfixed.

3 - Feature edges will be auto-detected by specifying the connected feature detection
            algorithm. The feature angle is set using *setoption feature_angle. 
7 - Use associated surface edges.
8 - Feature edges will be auto-detected by specifying the connected feature detection
            algorithm, keeping 1D elements which are part of 2D mesh edges and existing FE edges
            with nodes already associated to surface edges.
9 - Feature edges will be created from the selected mark of 1D plot elements, keeping
            1D elements which are part of 2D mesh edges and existing FE edges with nodes already
            associated to surface edges.

","Examples
To remesh the displayed elements and keep lines formed by plot elements with IDs
        1600-2220:
*createmark elems 1 ""displayed""
*setusefeatures 1
*createmark elems 2 1600-2220
*elementsaddelemsfixed 2
*defaultremeshelems 1 3.0 2 2 0 1 1 1 0 0 0 0 0 30
To remesh the displayed elements with auto detected feature edges with a feature angle of
        80 degrees:
*createmark elems 1 ""displayed""
*setusefeatures 0
*setoption feature_angle=80
*defaultremeshelems 1 3.0 2 2 1 1 1 1 0 0 0 0 2 30
","Errors
None.
"
1973,*setviewangles,"Description
Sets the view based on angles. 
","Inputs

thetax
The angle of rotation about the x axis. 
thetay
The angle of rotation about the y axis. 
thetaz
The angle of rotation about the z axis. 

","Errors
None.
",
1974,*shapevarupdate_xproduct,"Description
Updates a shape variable created from the cross product of two other shape variables.
","Inputs

markid
The ID of the mark that contains the shape variable to update.
basenode
The ID of the node where the base of the result is located after it is updated.
shape variable A
The ID of the first shape variable in the cross product.
shape variable B
The ID of the 2nd shape variable in the cross product.
baseflag
A flag (0,1) to update the base node of the shape variable.
directionflag
A flag (0,1) to update the direction and magnitude of the shape variable.
magnitude
Magnitude of vectors.

","Errors
None.
",
1975,*shelloffset ,"Description
Offsets shells along their element normal direction.
","Inputs

mark_id
The ID of the mark containing the shell elements to be offset. Valid values are 1 and 2.
corner_type
0 - Offset the elements using square corners. 
1 - Offset the elements using rounded corners. 
8 - Offset the elements using CFD corners. When this option is specified, an
            additional mark of surfaces and elements can be specified to specify the geometry to
            follow.
distance_type
0 - Offset elements using distance parameter. 
1 - Offset elements using half the element thickness value.
distance
The distance to move the elements. Only valid when distance_type=0.
offset_type
0 - Offset the elements in the positive normal direction. 
1 - Offset the elements in the negative normal direction.

","Example
To offset the displayed shell elements along their positive normal by a value of 0.2, using
        square corners:
*createmark elements 1 displayed
*shelloffset 1 0 0 0.2 0
To offset the displayed shell elements along their positive normal by a value of 0.2, using
        CFD corners, with surfaces 1 and 2 as along geometry:
*createmark elements 1 displayed
*createmark surfaces 2 1 2
*shelloffset 1 8 0 0.2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1976,*show_new_target ,"Description
Draws a segment in the new target component. This segment connects the point to offset with
        the target point.
","Inputs

face
Index of the surface to be offset.
offsetpoint_x
X coordinate of the point to be offset.
offsetpoint_y
 Y coordinate of the point to be offset.
offsetpoint_z
Z coordinate of the point to be offset.
target_x
X coordinate of the pilot point.
target_y
Y coordinate of the pilot point.
target_z
Z coordinate of the pilot point.
code


0  The target point is a midpoint between the offset point and the pilot point. 
1  The target point is the pilot point. 
2  The target point is a midpoint between the offset point and the pilot point.
                If the offset point is at a vertex of the surface to offset, the target is combined
                with any existing targets for that vertex and displays the combined target in the
                new target component. 
3  The target point is the pilot point. If the offset point is at a vertex of the
                surface to offset, the target is combined with any existing targets for that vertex
                and displays the combined target in the new target component. 
4  Behaves exactly as option 2, but also displays the targets being combined and
                the target planes in the targets being combined component. 
5  Behaves exactly as option 3, but also displays the targets being combined and
                the target planes in the targets being combined component. 
-1  The command combines the targets that existed at the vertex; the pilot point
                is ignored. 
-5  As for option -1, but also displays the targets being combined
                component.



","Example
Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in). 
","Errors
None.
"
1977,*showentity,"Description
Turns on the display of an entity.
","Inputs

entity_type
The type of entity to display.
search_type
The method used to specify the entity. The entity is specified using the
              id_name argument. Valid values are: 
""by name"" - Entity is specified using the entity name. 
""by id"" - Entity is specified using the entity ID.
id_name
The ID or name of the entity, depending on search_type.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To show geometry and elements for component with ID 3:
*showentity comps ""by id"" 3
To show elements only for component with ID 3:
*createstringarray 2 geometry_off
*showentity comps ""by id"" 3 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1978,*showview,"Description
Shows the entities with respect to a view saved using *saveviewmask.
","
Inputs


name
The name of the view to show.
entity_type_id
The entity type ID to show.

","Examples
Show the comps (entity type ID 3) in view
        View2:*showview View2 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1979,*simulationsetangle,"Description
Sets the angle used to evaluate complex results. The evaluated results are used in contour
        and assigned plots.
","Inputs

angle 
The angle used to evaluate complex results.

","Errors
None.
",
1980,*sl_feature_mesh ,"Description
Performs feature-based meshing of surfaces using meshcontrols.
","Inputs

surface_mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 0 (inactive), 1
            and 2.
meshcontrol_mark_id
The ID of the mark containing the meshcontrols to use. Valid values are 1 and 2.
mode
0 - Global, body and feature controls will be meshed. At least one global or body
            control is needed. 
1 - Feature controls only are meshed. Global/body controls are optional.
Any surfaces defined in a feature meshcontrol must also be selected via the
              surface_mark_id, or also be defined in a body control. Otherwise,
            they will be ignored. The surfaces defined in the feature controls are meshed first, and
            the remainder are meshed by the global or body control as appropriate.

","Examples
The mesh all surfaces in the model using meshcontrols 1-3:
*createmark surfs 1 all
*createmark meshcontrols 1 1 2 3
*sl_feature_mesh 1 1 0
To mesh using all meshcontrols, with only feature controls expected to be meshed:
*createmark meshcontrols 1 all
*sl_feature_mesh 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1981,*slivertetrafix,"Description
This command is used to fix sliver tetra and wedge elements and performs node position
        optimization of poor elements using quality criteria measurements.
","Inputs

mark_id
The ID of the mark containing the tetra elements to fix. Valid values are 1 and 2.
options
This parameter constructs a table of values that comprise both the methods that should
            be used to fix the sliver elements, along with quality criteria that are used optimize
            poor element nodes.  Valid fixing methods include:
fix_sliver


0 - Do not fix sliver tetras. 
1 - Fix sliver tetras.


fix_wedge


0 - Do not fix wedge tetras. 
1 - Fix only the internal edge of wedge tetras. 
> 1 - Fix both internal and boundary edges of wedge tetras.


optimize_node


0 - Poor element nodes will not be optimized. 
1 - Optimize only internal nodes of poor elements. 
> 1 - Optimize both internal and boundary nodes of poor elements.



The user can neglect one or more of the above options and the command will use the default
        values (fix_sliver 1, fix_wedge 1,
          optimize_node 0).
The following quality measurements are available for fixing nodes when optimize_node is ≥
        1. Each measurement includes the measurement name, failed value, warn value, good value,
        weight, and solver ID (currently only HyperMesh solver ID = 0 is
        supported). Valid quality measurements include:
aspect_ratio 
tet_collapse 
vol_skew 
skew 
vol_ar 
warpage 
min_interior_angle 
max_interior_angle 
jacobian
For every item, you can chose to only input the name and some values; in this case, the
        remainder will use the default values. 
","Examples
To fix sliver and internal wedge tetras of displayed elements:
*createmark elems 1 displayed
set table """"
*slivertetrafix 1 $table
Fix the displayed poor elements and optimize the internal nodes by using the
          tet_collapse and vol_skew quality measurements. Only
        the element’s whose tet_collapse is < 0.01 and
          vol_skew is > 0.9 will be optimized. The weight of
          vol_skew is 2. All others values are used as the default:
 *createmark elems 1 displayed
set table ""optimize_node 1 tet_collapse 0.01 vol_skew 0.90 0.60 0.10 2""
*slivertetrafix 1 $table

","Errors
Invalid or inconsistent input parameters in *slivertetrafix result in a
          Tcl error. To detect errors, you can use the catch
        command:
if { [ catch {* slivertetrafix 3 $table} ] } {
# Handle error
}

"
1982,*smoothelements,"Description
In the automeshing module, applies the specified smoothing operator to the mesh (if any)
        found on the face for the given number of times. 
","Inputs

faceindex
The index of the face into the particular surface under consideration. 
smoothmethod
The smoothing method to use.
0 autodecide 
1 size corrected 
2 shape corrected


iterations
The number of times to apply the element smoothing operator. 

","Example
To smooth the elements of the mesh of the first face of the surface twenty-five times,
        using whichever algorithm the automeshing module determines is proper: 
*smoothelements(0,0,25)

The undo function for this command is *unsmoothelements() . 
","Errors
None.
"
1983,*solid_cavity_detect_fill,"Description
Creates solids from detected cavities and optionally merges the created solids with the
        parent.
The command *solid_cavity_detect_start must be called before calling
        this command to generate the cavities as region entities.
","
Inputs



mark_id

The ID of the mark containing the region entities with the cavities to fill.  Valid
            values are 1 and 2.

merge_flag

1 - Merge new solids with parent.
0 - Do not merge new solids with parent.

","Examples
Create a solid representing the cavity attached to a region 10:
*createmark regions 1 10
*solid_cavity_detect_fill 1 0
Merge all identified cavities with the parent body:
*createmark regions 1 all
*solid_cavity_detect_fill 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1984,*solid_cavity_detect_modify_rims,"Description
Modify a partially detected cavity by adding and removing rims.
The command *solid_cavity_detect_start must be called before calling
        this command to generate the cavities as region entities.
","
Inputs



add_mark_id

The ID of the mark containing edges to add as rims.  Valid values are 1 and 2.

remove_mark_id

The ID of the mark containing existing edges to remove as rims.  Valid values are 1
            and 2.

region_id

The ID of the region containing the cavity definition to modify.

add_surfs_flag

1 - The extracted surfaces are added to the cavity.
0 - The extracted surfaces are removed from the cavity.

","Examples
Add a rim represented by a connected set of surface edges with IDs 3 and 4 with a cavity
        represented by region ID 10,and  remove the rim represented by surface edge IDs 7 and 8. Add
        the surfaces, as the volume of cavity increases due to this modification:
*createmark lines 1 3 4
*createmark lines 2 7 8
*solid_cavity_detect_modify_rims 1 2 10 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1985,*solid_cavity_detect_start,"Description
This command finds cavities from solids, which may have been created by volume substraction
        from those solids.  Internally, it merges identified cavities if they belong to the same
        volume.
The output of this command is a list of cavities, created as region entities. Each cavity
        is represented by a connected set of surfaces and one or more rims. Each rim is a connected
        set of edges. Cavities are sorted by descending order of their volume while creating the
        regions.
This command must be followed by a call to *solid_cavity_detect_end.
","
Inputs



mark_id

The ID of the mark containing the input solid surfaces.  Valid values are 1 and
            2.

all_cavities

1 - Cavities of all geometric shapes will be detected.
0 - Only cylindrical (simple cylinder) cavities will be detected.

get_n_cavities

If  0, all identified cavities are found.  If > 0, the first N cavities are found in
            descending order of their volume.

max_radius

The maximum radius for circular cavities to be processed. For cavities of arbitrary
            shape the ""effective"" diameter is found as the cross section perimeter divided by pi.  A
            value of of -1 ignores this option.

max_length

The maximum length of a cavity, mainly applicable for circular cavities.  A value of
            of -1 ignores this option.

min_concavity

The minimum concavity factor.  A value of 0.5 is default.

","Examples
To detect cavities of all geometric types based on default arguments:
*createmark surfaces 1 ""all""
*solid_cavity_detect_start 1 1 0 -1 -1 0.5
*solid_cavity_detect_end
To detect cavities of all geometric types, finding only the first five cavities:
*createmark surfaces 1 ""all""
*solid_cavity_detect_start 1 1 5 -1 -1 0.5
*solid_cavity_detect_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1986,*solid_facesfind,"Description
This command extracts 2D faces from 3D elements in select components. Then, after filtering
        out all pre-existing faces, the resulting faces are added to the ^faces component.
","Inputs

mark_id
The mark of components containing 3D elements to consider. Valid values are 1 and 2.

","Example
To find faces from components 1-3:
*createmark comps 1 1-3
*solid_facesfind 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1987,*solid_fixedptssuppressor,"Description
Suppresses the selected fixed points. Usually paired with
          *solid_fixedptsmaker().
","Inputs

point_mark_id
1 or 2. Fixed points on this mark will be suppressed.

","Example
*solid_fixedptssuppressor(1)
","Errors
None.
"
1988,*solid_prepare_entitylst ,"Description
This command is used by the solid mapping algorithm to setup internal entity arrays. It
        must be used within a *solidmap_prepare_usrdataptr data input block. A
        data input block begins with *solidmap_prepare_usrdataptr and ends with
        either a call to *solidmap_end or the start of another data input
        sub-block.
","Inputs

entity_type
The type of entity contained on mark ID 1. Valid values are lines, surfaces or
            elements. 
For SOURCE data input blocks, elements are required to be specified either directly
            using this command or indirectly by auto-completing the selection based on the input
            geometry. 
For DEST data input blocks, if the elements bit is specified for the
              *solidmap_prepare_usrdataptr command but no elements are specified
            using this command, the selection is auto-completed based on the input geometry. 
reserved
Reserved for future use. Must be set to 0.

","Example
For a solidmap using the following inputs:
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10 
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1989,*solid_split_by_tool,"Description
Splits solid geometry using various tool types.
","
Inputs


extend_trimmer=<value>
Specifies the behavior of extending the trimming surface when
              tool_type=bounding_lines, tool_type=surfaces, or
              tool_type=sweep_lines.  Valid values are:
0 – Do not extend
1 – Extend (default)
line_mark=<value>
The ID of the mark containing the input lines when
              tool_type=bounding_lines or
              tool_type=sweep_lines.  Valid values are 1 and 2.
plane_base=""<value1> <value2> <value3>""
The plane base coordinates when tool_type=plane.
plane_normal=""<value1> <value2> <value3>""
The plane normal direction vector coordinates when
            tool_type=plane.
solid_mark=<value>
The ID of the mark containing the solids to split.  Valid values are 1 and 2.  This is
            mandatory.
split_positions=""<value1x> <value1y> ?<value2x> <value2y>? ...
              ?<valueNx> <valueNy>?""
When tool_type=plane or when extend_trimmer=1,
            the trimmer might cut the solids at several sections. This optionally specifies the
            sections to use for trimming, by giving a point location on each section.
surf_mark=<value>
The ID of the mark containing the trimming surfaces when
              tool_type=surfaces.  Valid values are 1 and 2.
sweep_direction=""<value1> <value2> <value3>""
The sweep direction vector coordinates when
            tool_type=sweep_lines.
sweep_distance=<value>
The optional limited sweep distance when
            tool_type=sweep_lines.
tool_type=<value>
Specifies the tool used to split the solids. This is mandatory.  Valid values
            are:
bounding_lines – Input lines are used to construct surfaces, which are used to split
            solids
plane – An infinite plane is used to split solids
surfaces – Surfaces are used for splitting
sweep_lines – Lines are swept in a direction, either to cover all the solids or for a
            given distance to form surfaces, which are then used to split solids

","Examples
To split solid 2 with line 574, by sweeping the line in the z-direction and then extending
        the result surface to trim the whole
        solid:*createmark solids 1 2
*createmark lines 2 574
*solid_split_by_tool solid_mark=1 tool_type=sweep_lines line_mark=2 ""sweep_direction=0 0 1"" extend_trimmer=1
To split solid 2 with a surface that is first formed by lines 32 and 37, and then extended
        to cover the whole
        solid:*createmark solids 1 2
*createmark lines 2 32 37
*solid_split_by_tool solid_mark=1 tool_type=bounding_lines line_mark=2 extend_trimmer=1
To split solid 2 with a surface that is first formed by lines 32 and 37, at 2 sections that
        are located at points (0.4, -0.8, 0.0) and (0.5, -0.1, -0.7), and then extended to cover the
        whole
        solid:*createmark solids 1 2
*createmark lines 2 32 37
*solid_split_by_tool solid_mark=1 tool_type=bounding_lines line_mark=2 extend_trimmer=1 ""split_positions=0.4 -0.8 0.0 0.5 -0.01 -0.07""

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1990,*solidblock,"Description
This command creates a full or partial cone or cylindrical solid.
","Inputs

base_x, base_y, base_z
The x, y and z coordinates specifying the center point of the cone/cylinder base
            location.
ivec_x, ivec_y, ivec_z
The x, y and z coordinates specifying the first axis vector from the base
            location.
jvec_x, jvec_y, jvec_z
The x, y and z coordinates specifying the second axis vector from the base
            location.
kvec_x, kvec_y, kvec_z
The x, y and z coordinates specifying the third axis vector from the base
            location.

","Example
To create a cube solid with its origin at (10,10,10), aligned with global system axis,
        having size 5:
*solidblock 10 10 10 5 0 0 0 5 0 0 0 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1991,*solidcreatedragsurfalongline ,"Description
This command creates one or more solids by dragging one ore more surfaces along a drag
        line. Lines in the line list are combined into a single line L, called the drag line. The
        direction of the drag line is determined by choosing its start point, S, as the closest end
        of the line to the input surface vertices. 
node_id and refplane arguments are optional and
        determines how the input lines and surfaces are transformed before drag.
The reconfiguration of the geometries before the drag is done as follows. Let P be the
        point referred by the node_id, N be the normal and B be the base point of
        the refplane and T be the tangent vector of drag line at S. First, input surfaces are
        translated by the direction vector PB. If Bit4 of the options is not set, then, the surfaces
        are rotated by the rotation from vector N to vector T. Also, the drag line is translated by
        the direction vector SB. The drag is applied to these surfaces by line L. So, if P is
        selected on an input surface, the new location of P is going to be at B. Moreover, if P is
        one of the vertex points of the input surfaces, one gets an exact geometric copy of the drag
        line at B, no matter which drag method is chosen. This is because, prior to drag, P is moved
        to B and B moves on drag line since it coincides with the start point of the drag line L. 
If node_id is not given, it is chosen as the same point as S, the start
        of the drag line. This means, with the default value of node_id, the drag
        line is not transformed.
If the reference plane is not given, their default values are B at P and N=T. This means,
        with the default value of transformation plane, the input surfaces are not transformed prior
        to drag.Note: The location of P is not important, if fixed frame method is chosen with no
          transformation plane, since each point on the section surface traces an exact geometric
          copy of the drag line in fixed frame method. 

","Inputs

surfs_mark_id
The mark ID containing the surfaces that you wish to drag.
lines_list 
The list ID containing the lines that will be used to from the drag line. 
The first line in this list determines the direction of the drag, which is also shown
            to the user on the screen. If the drag line has corners, then the new solids are split
            at those locations.
method
Parameter specifying the method of how the drag is performed. Valid options are:
0 - Fixed frame 
1 - Follow the drag line only along its tangent direction 
2 - Follow the drag line along its Frenet frame


options
Flags that indicate different modes for the drag. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Only free edges of surfaces are offset. 
1 - Both free and internal edges are offset, thus creating separate solids from
                  surfaces separated by manifold edges.
Bit1
0 - Create solid entities. 
1 - Create only the boundary of solids.
Bit2
 0 - Drag along the direction of the drag line. 
1 - Drag along the opposite direction of the drag line.
Bit3
 0 - Use the ref_plane. input 
1 - Do not use the ref_plane input. Instead, use its default
                  values.
Bit4
0 - Use the whole ref_plane for transformation if it is
                  given. 
1 - Use the only the base point of the reference plane, set the normal as the
                  tangent of the drag line at drag start point.


comp_mode
Parameter specifying how entities are organized into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces. The result
                is not predictable, if the surfaces are originally in different components.


?node_id? (optional)
The ID of the node, which is used as a reference point while determining the way the
            surfaces are transformed prior to drag.
?ref_plane? (optional)
When provided, its value must always be 1. It is used to determine the initial
            reference frame. This plane is created using the *createplane
            command.

","Examples
Assume that you want to drag section-surfaces with ids 39 401 and 388, along the line that
        is formed by combining lines with IDs 37 and 25 using fixed frame method. Assume that you
        want to drag along the direction opposite to the direction of line 37, and want to drag both
        free and internal edges. Moreover, you want the results solids to be in the component of the
        surfaces. Then, options = 1+4 = 5, and comp_mode = 2. If you do not want
        to use any reference plane, use the following commands to create dragged solids. As a result
        one side of the solids will be the input section surfaces, while the opposite side will be
        an exact translated copy of that section surface, and vertices of the section surface will
        trace an exact translated copy of the drag-lines broken at possible vertex points.
*createmark lines 1  39 401 388 
*createlist lines 1  37 25 
*solidcreatedragsurfalongline 1 1 0 5 2

In addition if you now want to use a reference node with ID 12, which happen to lie on one
        of the section surfaces, and a reference plane, then use:
*createmark lines 1  39 401 388 
*createlist lines 1  37 25
*createplane 1 1.0000 1.0000 1.0000 2678.0 -737.7 548.1 
*surfacecreatedraglinealongline 1 1 0 5 2 12 1 
The solid created will be in such a way that the new location of the point on which node 12
        located, will be at the base point (2678.0 -737.7 548.1) of the reference plane.
","Errors
Invalid or inconsistent input parameters in
          *solidcreatedragsurfalongline result in a Tcl
        error. To detect errors, you can use the catch command:
if { [ catch {*solidcreatedragsurfalongline 1 1 0 0 0} ] } {
# Handle error
}
"
1992,*solidcreatespinsurfwithoffsetangle,"Description
This command creates one or more solids by rotating a given set of surfaces around a given
        axis.
","Inputs

surfs_mark_id
The mark containing the surfaces that you wish to rotate to create solids.
rotation_plane
The plane whose normal is used as the rotation axis and its base point used as the
            rotation center. This plane is created using the *createplane
            command.
start_angle
Degrees value of initial rotation angle: selected surfaces are rotated by this value
            before solid ""sweeping"" begins.
end_angle
Degrees value of final rotation angle: solid ""sweeping"" stops at this value.
options
Flags that indicate different modes for solid creation. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3).
Bit0
0 - Only free edges of surfaces are rotated.
1 - Both free and internal edges rotate, thus creating boundaries between solids
                  created from each individual surface.
Bit1
0 - Create solid entities. 
1 - Create only the boundary of solids.
Bit2
0 - Selected surfaces become part of solid boundary. 
1 - Selected surfaces remain intact.
Bit3
0 - Solid surfaces are ignored as input. 
1 - Solid surfaces are copied and the new copied surfaces are used to create
                  spin solids.


comp_mode
Determines how new solids are organized into components. Valid values are:
0 - Solids are created in the current component and boundary surfaces are moved to the
            same component.
1 - Solids are created in the current component but surfaces remain in their original
            component.
2 - Solids are created in the same component as the selected surfaces (the result is
            unpredictable if surfaces from different components become a part of the same solid
            body).

","Example
To create a solid by rotating surface 1 around an axis defined by the direction vector (1 2
        3) with a rotation center at point (4 5 6) and using a full 360 degrees angle, creating a
        solid in the same component as surface 1, and keeping the surface 1 intact:
*createmark surfs 1 1
*createplane 1 1 2 3 4 5 6
*solidcreatespinsurfwithoffsetangle 1 1 0 360 4 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1993,*solidmap_end ,"Description
This command is used by the solid mapping algorithm to indicate the end of a solid mapping
        command block. It must be paired with a *solidmap_begin command. A single
        solidmap mesh is a result of the block of commands. 
In a solidmap command block, all of the commands before *solidmap_end
        are for preparing input data. *solidmap_end is the command that
        actually performs the solid mapping.
","Inputs

options
Flags that indicate different modes for solid mapping. It is not recommended to
            manually set these bits. Instead, use them from an existing command file.
density_or_size
Either the element density or size in the along direction, depending on options in the
            options parameter.
bias_style
The type of biasing to use. Valid values are:
0 - linear 
1 - exponential 
2 - bell curve


biasing
The biasing intensity value. A value of 0 indicates no biasing.

","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1994,*solidmap_initialize_edges,"Description
Initializes the line mesh parameters after resolving the density conflicts of the lines in
        the solid.  Balances all the line densities (resolves all density conflicts), initializes
        the mesh parameters of these lines, and sets all possible source faces as mapped and the
        remainder as free.
Must be called before *solidmap_solids_begin or
          *solidmap_solids_begin2.
","
Inputs


dest_hint_mark=<value>
The ID of the mark of the optional destination hint surfaces.  Valid values are 1 and
            2.
elem_type=<value>
The 2D element type when per face meshing parameters are not available:
0 - Tria
1 - Quad
2 - Mixed (default)
elemsize=<value>
The default element size when the per edge/face meshing parameters are not available.
            This is a mandatory option.
orthogonal_extrusion=<value>
0 - Make the reparameterization of along faces more orthogonal
1 - Make the reparameterization of along faces more like parallelograms
solidmark=<value>
The ID of the mark of the solids to mesh.  Valid values are 1 and 2.  This is a
            mandatory option.


src_hint_mark=<value>
The ID of the mark of the optional source hint surfaces.  Valid values are 1 and
            2.

","Examples
To initialize the mesh parameters of lines of solid 1 without giving any source or
        destination surface hints:
*createmark solids 1 1
*solidmap_initialize_edges solidmark=1024 elemsize=2.000000 elem_type=2 
*defaultremeshsurf 2 2 2 2 0 0 0 0 1 0 0 0 0
*createmark solids 1 1
*solidmap_solids_begin 1 32896 2
*solidmap_solids_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1995,*solidmap_set_source_size,"Description
Sets the source 2D mesh size for the next call to *solidmap_end.  This
        allows setting the along size (density) and the source size independently. The command
        applies only the next call to *solidmap_end.  If this command is not
        called before *solidmap_end, the value of the source size to set to the
        same as the along size. 
","
Inputs



size

The solid map source size.

","Examples
To set the solid map source size to
        1.5:*solidmap_set_source_size 1.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1996,*solidmap_solids_begin2,"Description
This command is used by the multi-solid mapping algorithm to indicate the beginning of a
        solid mapping command block. It must be paired with a
          *solidmap_solids_end command. 
The commands below can appear in a multi-solids solidmap command block between
          *solidmap_solids_begin and *solidmap_solids_end:
        *solidmap_solids_set_density
*solidmap_solids_set_elemsize
*solidmap_solids_set_face_params
*solidmap_solids_set_mapface
","Inputs

solid_mark_id
ID of the mark containing the solids to mesh. Valid values are 1 and 2.
source_surface_mark_id
ID of the mark containing the source surface hints. Valid values are 1 and 2.
destination_surface_mark_id
ID of the mark containing the destination surface hints. Valid values are 1 and 2.
options
Flags that indicate different options for solid mapping. Bit values are used and the
            value is a sum of all the options. Any bits not listed below are unused or for internal
            use (e.g. called in other commands) and are always internally set to their required
            values. Setting them to 0 is recommended, but not mandatory.
Bit0
0 - Reserved, must be set to 0.
Bit1


0 - New elems are organized to the solid component. 
2 - New elems are organized to the current component.


Bit2
0 - Reserved, must be set to 0.
Bit3


0 - Create elems when calling *solidmap_solids_end

8 - Do not create elems when calling *solidmap_solids_end
                      (for expert users only).


Bit4


0 - Create layered solid elements. 
16 - Create layered shell elements.


Bit5,6


0 - Auto decide 
32 - Don't use the fast method. 
64 - Use the fast method 
96 - Unused


Bit8


0 - No additional smoothing steps will occur. 
256 - Perform extra smoothing steps.


Bit9,10,11
2D elem type 1 and 2 passing to the internal call to
                    *defaultremesh when per face meshing parameters are not available:
0 - Tria 
512 - Quad 
1024 - Mixed 
1536 - R-tria 
2048 - Quad only


Bit13


0 - Keep shell meshes on input geometry. 
8192 - Remesh shell meshes on input geometry. 
NOTE: Solid elems on input solids are always deleted.


Bit14


0 - Normal meshing situations. 
16384 - Create internal meshing sequencing structure only. Don't create
                      mesh and internal meshing structure (for expert users only).


Bit15


0 - Do not use meshing parameters saved to the solid map attributes on the
                      geometry. 
32768 - Use meshing parameters saved to the solid map attributes on the
                      geometry.


Bit16


0 - Make the reparameterization of along faces more orthogonal. 
65536 - Make the reparameterization of along faces more like
                      parallelograms.


Bit17


0 - Don’t use per edge/face saved meshing parameters. 
131062 - Use per edge/face saved meshing parameters.


Bit18


0 - Stop meshing when elems with negative Jacobian are generated. 
262144 - Continue meshing regardless of the elem quality.




elem_size
The default element size used when the per edge/face meshing parameters are not
            available.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem size of 1.0, using source surface hints 100-105 and destination surface
        hints 200-205:
*createmark solids 1 32 41
*createmark surfs 1 100-105
*createmark surfs 2 200-205
*solidmap_solid_begin2 1 1 2 0 2.0
   *createmark lines 1 2 4
   *solidmap_solids_set_elemsize 1 1.0
*solidmap_solid_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1997,*solidmap_solids_set_density ,"Description
This command is for setting the per edge elem density for solid map meshing. The density
        value specified is only a target value. Depending on solvability, the resulting mesh may
        take on a modified value. This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

mark_id
The ID of the mark containing the lines/edges to set the element density for. Valid values are 1 and 2.
elem_density
The value to set the density to for the selected lines/edges.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem density of 10.0:

*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
*createmark lines 1 2 4
*solidmap_solids_set_density 1 10.0
*solidmap_solid_end
","Errors
Invalid or inconsistent input parameters in *solidmap_solids_set_density result in a Tcl
        error. To detect errors, you can use the catch
        command:if { [ catch {*solidmap_solids_set_density 3 2.0} ] } {
# Handle error
}

"
1998,*solidmap_solids_set_face_params ,"Description
This command is for setting the per surface mesh type and mesh flags. The command has
        effect only for surfaces for which the mesh type and flags are free to change (e.g not a
        along face of a solid and not linked to a premeshed surface…). 
It can only be called between a *solidmap_solids_begin and
          *solidmap_solids_end command pair.
","Inputs

mark_id
The ID of the mark containing the surfaces to set the meshing flags for. Valid values are 1 and 2.
options
Flags that indicate different options for solid mapping. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6 +
            128*Bit7…). The bits not listed below are unused or for internal use (e.g. called in
            other commands).
Bit0,1
0/1/3 - Non-mapped mesh type. 
2 - Mapped mesh type. The 4 most prominent vertices are used as corners.
Bit2-4
Elem type if non-mapped.
0- Use the same type defined in *solidmap_solids_begin. 
1 - tria 
2 - quad 
3 - mixed 
4 - R-tria


Bit5


0 - Size control off 
1 - Size control on


Bit6


0 - Skew control off 
1 - Skew control on


Bit7


0 - Mesh flow alignment off 
1 - Mesh flow alignment on


Bit8


0 - Global size control off 
1 - Global size control on





","Example
To mesh solids 32 and 41 with a default elem size of 2.0. Additionally, surfaces 5 and 10
        are to be of mapped mesh type by auto determining the corners: 
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *createmark surfs 1 5 10   
   *solidmap_solids_set_face_params 1 2
*solidmap_solid_end

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
1999,*solidmesh9lines,"Description
 Creates a solid mesh on a volume formed by nine lines. 
","Inputs

lines
The line list ID which contains lines that define a solid. 
density1
The density of the elements in the first direction.
density2
The density of the elements in the second direction. 
density3
The density of the elements in the third direction. 

","Example
To create a solid mesh in the volume formed by connected lines 10, 11, 12, connected lines
        1, 2, and 3, and connecting lines 20, 21, and 22, with densities 3, 8 and 12: 
*createlist(lines,1) 10 11 12 1 2 3 20 21 22
*solidmesh9lines(1, 3, 8, 12)
","Errors
None.
"
2000,*solidmeshwithsurfaces ,"Description
Creates a mesh of solid elements by first extruding an existing 2D finite element mesh, and
        then mapping the extruded mesh into a volume. 
","Inputs

type
Identifies which type of geometry is being supplied.
0 - Source and destination
1 - Source and along
2 - Source, destination, and along


sourcetype
Set to nodes, lines, or surfaces, this parameter identifies the geometry used to
            define the source face. 
source
The mark ID which contains the data of the source face.
desttype
Set to nodes, lines, or surfaces, this parameter identifies the geometry used to
            define the destination face.
dest
The mark ID which contains the data of the destination face. 
alongtype
Set to lines or surfaces, this parameter identifies the geometry used to define the
            along faces. 
along
The mark ID which contains the data of the along faces. 
genelems
Currently not used. 
elements
The mark which contains the elements which are to be mapped into the volume. 
density
The number of elements to be created between the source and destination faces.
biasstyle
The type of biasing to use.
biasing
The biasing intensity value.

","Errors
None.
",
2001,*solverconvert,"Description
This command converts a model from one solver to another. 
Supported solvers are:
","Inputs

source_solver
The source solver name or ID.
destination_solver
The destination solver name or ID.
source_type
The source solver template type.
destination_type
The destination solver template type.
batch
Flag that indicates if the conversion should be run in batch mode.
0 - No batch mode 
1 - Batch mode


?config_file_path?
The full path for the configuration file containing the entity mapping details, to be
            used for the conversion.  This is useful when the user has restrictions on modifying the
            file in the installation.  When the configuration file path is not specified or the path
            is not valid, the conversion will use the default configuration file from the
            installation.
It is recommended to use forward slashes while specifying the configuration file.
It is supported for the following conversions:

OptiStruct/Nastran to
                  Abaqus
Abaqus to OptiStruct/Nastran



","Examples
Convert Abaqus Standard3D model to OptiStruct in batch mode:
*solverconvert Abaqus OptiStruct Standard3D """" 1
or
*solverconvert 2 1 Standard3D """" 1
Convert Radioss Block90 model to PAM-CRASH Pamcrash2G2007 without batch mode:
*solverconvert RadiossBlock Pamcrash Block90 Pamcrash2G2007 0
or
*solverconvert 20 18 Block90 Pamcrash2G2007 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2002,*sort_midsurfaces,"Description
Sorts mid-surfaces from the ""Middle Surface"" component into other components. 
All of the middle surfaces from the ""Middle Surface"" component are organized into
        new/existing components, based on the components from which each middle surface was created. 
When creating new components for sorting, the new components are created a duplicates of
        the originals, and organized into the same parts, assemblies and includes as the
        originals.
","Inputs

mode


0 - Create new components named Midsurface #nn, where nn is an incremental
                number. The components are created based on the original components from which the
                middle surfaces were derived. 
1 - Organize the middle surfaces into the original components from which they
                were derived. 
2 - Create new components, replacing the first letter of the original component
                names with the prefix ~. 
3 - Create new components, appending a suffix of ~ to the original component
                names. 
4 - Create new components, incrementing the original component names.



","Example
To sort middle surfaces into original components:
*sort_midsurfaces 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2003,*specialelements,"Description
reates special elements like gasket elements between a source and target, or updates
        penta/hexa elements to special elements like gasket elements.
","Inputs

source_entity_type
The source entity type.  Valid values are surfs, elems and faces.
target_entity_type
The target entity type.  Valid values are surfs, elems and faces.
option=<value>
The following options are available and can be provided in any order:
SourceMark=<mark_id>
The ID of the mark containing the source entities.  Valid values are 1 and 2.
TargetMark=<mark_id>
The ID of the mark containing the target entities.  Valid values are 1 and 2.
ElemSize=<size>
The element size to use when source_entity_type is surfs.
NumLayers=<value>
The number of layers to create.
DestinationComp=<value>
The component to which the special elements will be organized.  This is a mandatory
            option.  Valid values are:
0 - New component
1 - Current component
2 - Surface component
CreatePropMat=<value>
Properties and materials will be assigned to the created elements.  This is a
            mandatory option.  Valid values are:
0 - New property
1 - Existing property

","Example
Create special elements between surfaces 4 and 2, with size 10 and 3 layers:
*createmark surfs 1 4
*createmark surfs 2 2
*specialelements surfs surfs SourceMark=1 TargetMark=2 ElemSize=10 NumLayers=3 DestinationComp=1 CreatePropMat=1
Update penta/hexa elements 101-110 to special elements:
*createmark elems 1 101-110
*specialelements elems elems SourceMark=1 TargetMark=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2004,*sphereclipcenter,"Description
Sets the center for spherical clipping.
","Inputs

x
The new x coordinate of the center of spherical clipping.
y
The new y coordinate of the center of spherical clipping.
z
The new y coordinate of the center of spherical clipping.-----

","Example
To set the center of the spherical clipping to (1,2,3):
*sphereclipcenter(1,2,3)
*setsphereclip() is required to view clipping. 
*sphereclipradius() is required to view clipping. 
","Errors
None.
"
2005,*sphgenerate_new,"Description
Generates SPH particles within bounded, semi-watertight (some small gaps less than pitch
        size allowed), regions. The relative placement of these particles is specified using the
        pitch distance and the fill method parameters. The region(s) can be specified using
        elements, elements belonging to components, and either geometric surfaces or solids. The
        amount and direction of fill can also be specified. The mass of each resulting particle is
        calculated using either an input density or the total mass of the filled space. Full SPH
        functionality is available for Radioss, LS-DYNA and PAM-CRASH user profiles.
        Execution is supported in other profiles, without the creation of solver data.
","Inputs

entity_type
The type of entity that defines the volumes. Valid values are elements, comps
            (elements only), surfs or solids.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
string_array
The ID of the string array that contains the array of meshing parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
String names must be followed by a : (e.g. Config:). Valid strings and values are:
Config
Indicates how the particles are located relative to each other. Valid values are:
0 - Simple cubic 
1 - Face centered cubic


ElemToComps
Specifies the organization of the SPH components. Valid values are:
0 - Create elements in current component 
1 - Create elements in new component 
2 - Create elements in new component per cavity


MassType
Indicates how the mass of each resulting particle is calculated. Valid values
                  are: 
0 - Using the specified density of the material in conjunction with the
                      occupied volume and the number of created particles. 
1 - By dividing the specified total mass by the number of created
                      particles.


MassDensity
If MassType is 0, this is the density of the material.
 If MassType is 1, this is the total mass of the
                  particles.
PartialFill
An option to fill the volume partially. This string contains six values in a
                  fixed sequence as ""is_partial_fill is_percent_or_depth
                    fillpercent_or_depth filldir_x filldir_y filldir_z"".
is_partial_fill


0 - Fill volume fully 
1 - Fill volume partially.


is_percent_or_depth


0 - Fill by depth of volume. Used when
                              is_partial_fill is 1. 
1 - Fill by percentage of volume. Used when
                              is_partial_fill is 1.


fillpercent_or_depth
The percentage value when is_percent_or_depth is 0, or
                        the depth level when is_percent_or_depth is 1.
filldir_x
Fill direction vector x component.
filldir_y
Fill direction vector y component.
filldir_z
Fill direction vector z component.


PitchSize
The numerical value of the pinch distance.
Reference
Specifies an optional reference used to align the SPH grid. This string contains
                  five values in a fixed sequence as use_ref_origin ref_origin_x
                    ref_origin_y ref_origin_z ref_system_id.
use_ref_origin


0 - Do not align to a reference. 
1 - Align the grid to the specified reference.


ref_origin_x
The x-coordinate of the reference origin.
ref_origin_y
 The y-coordinate of the reference origin.
ref_origin_z
The z-coordinate of the reference origin.
ref_system_id
The ID of the reference coordinate system.




VolumeType
Specifies the volume(s) to be considered for meshing. This string contains four
                  values in a fixed sequence as volume_type nth_largest_index
                    enclosed_vol_node_mark exclude_vol_node_mark.
volume_type


0 - All volumes are considered. 
1 - Nth largest volume only considered as given by
                              nth_largest_index. 
2 - Enclosed volumes are considered which contains nodes by
                              enclosed_vol_node_mark. 
3 - Exclude volumes from meshing which contain nodes specified by
                              exclude_vol_node_mark.


nth_largest_index
The volume index to be meshed (starting with 1). Volumes are sorted based
                        on descending order of volume. Used when volume_type is
                        1.
enclosed_vol_node_mark
The ID of the mark containing nodes within enclosed volumes to consider.
                          Valid values are 1 and 2. Used when volume_type is 2.
exclude_vol_node_mark
The ID of the mark containing nodes within volumes to exclude. Valid
                        values are 1 and 2. Used when volume_type is 3.


WallClearance
The wall clearance distance for which particles will not be created.
WallOffset
The wall offset distance for which particles will be created.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.

","Example
To generate SPH elements for all components and all volumes, using a pitch size of 1,
        partial filling with a depth of 50 along the y direction with a reference location of (35.0,
        11.0, -5.0) , a wall clearance of 0.1 and a wall offset of 30:
*createmark components 1 all
*createstringarray 10 ""PitchSize: 1"" ""Config: 0"" ""MassType: 0"" ""MassDensity: 1"" ""PartialFill: 1 1 50 0 1 0"" ""Reference: 1 35.0 11.0 -5.0 0"" ""VolumeType: 0 0 0 0"" ""WallClearance: 0.1"" ""WallOffset: 30"" ""ElemToComps: 1""
*sphgenerate_new components 1 1 10
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2006,*split_elements_by_structure_pattern,"Description
Creates a transition mesh between refined and boundary regions.
","
Inputs



refine_mark_id

The ID of the mark containing the elements in the refinement zone.  Valid values are 1
            and 2.

transition_mark_id

The ID of the mark containing the elements in the transition zone.  Valid values are 1
            and 2.

refine_size

The element size for the refinement zone.

","Examples
To refine element 509 to a size of 0.5, using elements 511-518 as the transition zone:
*createmark elements 1 509
*createmark elements 2 511-518 
*split_elements_by_structure_pattern 1 2 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2007,*split_hex_continuum,"Description
Split solid element layers of any type through all edges that are topologicaly parallel to
        the selected edges while maintaining connectivity and associativity.  The propogation is
        mostly occurring for hex/quad elements spliting along given topological directions.
","Inputs

node_array
The ID of the node array, created using *createarray.  Must always
            be set to 1.
Each pair of nodes represents a directed element edge (action <
            3) or quad diagonal (action >= 3).  Any node pair that is not an
            element edge is ignored.  Any node that is not on the input elements is an error.
For action < 3, the action, input node array and the input elems
            uniquely define the elements continuum (call it ""action elements"") that the action is to
            be operated on.
number_of_nodes
The number of nodes in the node array.  Must be an even number.
entity_type
The type of entity to split.  Valid values are comps and elems.
mark_id
The mark of elements that are candidates to split.  Valid values are 1 and 2.  An
            empty selection means all elements are candidates. Note, if not all elements are
            candidates for split, the connectivity may break in the resulting mesh.
layers
The number of layers (> 2) to split.  Used only for action 0.
growth_rate
The common ratio of thicknesses of consective split layers. 1.0 means constant layer
            thickness. Used only for action 0.
action
0 - Split ""action elements"" along topological parallels of the input element
            edges
1 - Delete the ""action elements""
2 - Combine ""action elements"" to the next layer of existing elements indicated by the
            direction of each input edge. If not combinable, exit with error.
-1 - Preview the ""action elements"" by masking away ""non-action elements"".
-2 - Preview to-be combined elements by masking away all other elements.
>=3 - Internally call the lagacy split command *propagatesplithexas
            with split_type= action-2 and looping through all
            pairs of input nodes.
Each input node pair should represent a daigonal of quad face of hex. The ""action
            elements"" per node pair are a chain of hexes connected by the topologically parallel
            quad faces starting from the face represented by the input node pair.  In the resulting
            mesh, element connectivity may break and association may not be maintained. 
component
0 - New elements go to current component
1 - New elements go to original component

","Example
To split element 2 using nodes 21, 25, 41, 40, 21 and 41:
*createarray 6 21 25 41 40 21 41
*createmark elems 2
*split_hex_continuum 1 6 elems 2 2 1 0 1 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2008,*splitcontactfromcontactgroup,"Description
Disassociates a group (contact pair/tie) entity from a contact group.
","
Inputs


id
The ID of the group entity to disassocaite.

","Examples
To disassociate group 1 from the contact
        group:*splitcontactfromcontactgroup 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2009,*splitelementbyelemselect,"Description
Splits shell element patches using patterns based on the patch shared edges.
","
Inputs


mark_id
The ID of the mark of elements to split.  Valid values are 1 and 2.

","Examples
Example:
*createmark elements 1 4495 4505 4513 4521 4522 4531 4540 4553 4564 4575
*splitelementbyelemselect 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2010,*splitelementswith1D ,"Description
Splits shell elements on all sides, along with all connected 1D elements.
","Inputs

inferred


0 - Do not use an inferred surface if no geometry exists 
1 - Use an inferred surface if no geometry exists


mark_id
The ID of the mark containing the elements to split. Valid values are 1 and 2.

","Examples
To split elements 1-10, along with all connected 1Ds:
*createmark elems 1 1-10
*splitelementswith1D 0 1
To split elements 1-10, along with all connected 1Ds, using an inferred surface:
*createmark elems 1 1-10
*splitelementswith1D 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2011,*splitSurfaceRegions,"Description
Splits regions based on the connectivity of the contained surfaces.
The surfaces contained in the input regions are grouped, the orignal regions are split
        based on the groupings, new regions are created for each group, and the original regions are
        deleted.
","
Inputs


mark=<value>
The ID of the mark of input regions.  Valid values are 1 and 2.
split_mode=<value>
ByAttached - Group the surfaces by attached
ByFace - Group the surfaces by face

","Examples
To split all regions of surfaces by attached:
*createmark regions 1 all
*splitSurfaceRegions mark=1 split_mode=ByAttached
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2012,*springfournoded,"Description
Creates a spring element between four nodes using an orientation vector. It will have
        config 24 and type 1 connecting node1 to node2, node1 to node3 and node1 to node4. This is
        supported for Radioss only.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
node_id3
The ID of the third node.
node_id4
The ID of the fourth node.
dof
The degree of freedom for the element.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.

","Example
To create a four noded spring element between nodes 100, 101, 102 and 103 with DOF 2,
        property jointprop and orientation vector ID 51:
*springfournoded 100 101 102 103 2 jointprop 51
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2013,*springsosupdate ,"Description
Updates a spring element using various orientation methods. 
The orientation may be specified using either vector_id, direction_node_id,
          system_id or individual components (orient_x, orient_y, orient_z).
","Inputs

mark_id
The ID of the mark containing the spring elements to update.
property_flag


0 - Do not update property_name

1 - Update property_name


property_name
The name of the property to assign to the element.
vector_flag


0 - Do not update the orientation vector 
1 - Update the orientation vector


vector_id
The ID of the orientation vector assigned to the element.
direction_node_id
The ID of the direction node assigned to the element.
orient_x
The x-component of the orientation vector.
orient_y
The y-component of the orientation vector.
orient_z
The z-component of the orientation vector.
orient_comps_flag


0 - Do not use individual components to define the orientation 
1 - Use individual components to define the orientation


system_id
The ID of the orientation system assigned to the element.
update_orient_flag


0 - Do not update the orientation vector's component or system 
1 - Update the orientation vector's component or system



","Example
To update spring element s16, 17, and 18 to have property sprate, and an orientation vector
        with components 10,11,12:
*createmark elements 1 16 17 18
*springsosupdate 1 1 ""sprate"" 1 0 0 10 11 12 1 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2014,*springthreenoded,"Description
Creates a spring element between three nodes using an orientation vector. It will have
        config 24 and type 1 connecting node1 to node2, and node 2 to node 3. This is supported for
          Radioss only.
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
node_id3
The ID of the third node.
dof
The degree of freedom for the element.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.

","Example
To create a three noded spring element between nodes 100, 101 and 102 with DOF 2, property
        springprop and orientation vector ID 51:
*springthreenoded 100 101 102 2 springprop 51
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2015,*stackreverse,"Description
Reverses the stack direction of selected entities. Currently only supported for Abaqus continuum shell elements.
","Inputs

entity_type
The type of entity to reverse. Valid values are elements and components.
mark_id
The ID of the mark containing the entities to reverse. Valid values are 1 and 2.
size
The size in model units of the stack display.

","Example
To reverse the stack direction of elements 1-10 using a size of 10.0:
*createmark elems 1 1-10
*stackreverse elems 1 10.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2016,*startnotehistorystate ,"Description
Defines the start of a history state. Must be followed by a call to
          *endnotehistorystate with the same name value. 
This is used to group a set of commands into a single undo/redo operation. All commands
        that appear within the start/end block must be supported for undo/redo.
","Inputs

name
The name of the history state. If the name contains spaces, it must be enclosed in
            curly braces or quotes.

","Example
To execute an element remesh operation on two selections of elements, but consider them as
        a single history operation:
*startnotehistorystate {Remesh two element selections}
*setedgedensitylinkwithaspectratio 0
*setoption element_order=1
*setusefeatures 3
*createmark elements 1 1-100
*defaultremeshelems 1 1 2 2 1 1 1 1 0 0 0 0 2 30
*createmark elements 1 1-1-200
*defaultremeshelems 1 2 2 2 1 1 1 1 0 0 0 0 2 30
*setusefeatures 0
*endnotehistorystate {Remesh two element selections}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2017,*storemeshtodatabase,"Description
 Converts a generated mesh (if any) into elements in the specified component. 
","Inputs

elemstosurfcomp
If nonzero, new elements are created in the surface component to which they belong.
            Otherwise, they are created in the current component. 

","Errors
None.
",
2018,*superelementset,"Description
Sets the super element flag on a group of nodes.
","Inputs

mark
The ID of the mark containing the nodes which should have their super element ID
            updated to super ID.
super id
The super element ID in which the above nodes should be placed. 

","Example
To set nodes 155, 125, and 159 to super element 0: 
*createmark(nodes,1) 155 125 159
*superelementset(1,0)

","Errors
None.
"
2019,*surfaceaddnodesfixed,"Description
Adds meshing fixed points to a mark of surfaces, either by breaking edges or adding
        interior fixed points. The coordinates of the fixed points are supplied by a list of
        nodes.
","Inputs

surfacemark
The ID of the mark containing the surface to modify.
nodelist
The ID of the list containing the nodes to use.
tolerance
The closeness tolerance used to decide which points belong to a surface. A point can
            be added to more than one surface out of the mark.
createplot
Defines whether or not a plot element will be created between two points. It will be
            in the ^welds component. 
0 - do not create a weld element 
nonzero - create a weld element

","Example
To add a point to surface 190 whose coordinates correspond to those of node 9:
*createmark(surfaces,1) 190
*createlist(nodes,2) 9
*surfaceaddnodesfixed(1,2,0.05,1)
","Errors
None.
"
2020,*surfaceaddpointsfixed ,"Description
Adds meshing fixed points to a mark of surfaces, either by breaking edges or adding
        interior fixed points. The coordinates for the fixed points are supplied by a pointmark.
","Inputs

surfacemark
The ID of the mark containing the surface to modify.
pointmark
The ID of the mark containing the points to add.
tolerance
The closeness tolerance used to decide which points belong to a surface. A point can
            be added to more than one surface out of the mark.
createplot
Defines whether or not a plot element will be created between two points. It will be
            in the ^welds component.
0 - do not create a weld element 
nonzero create a weld element

","Example
To add point 9 to surface 190:
*createmark(surfaces,1) 190
*createmark(points,2) 9
*surfaceaddpointsfixed(1,2,0.05,1)
","Errors
None.
"
2021,*surfaceconefull ,"Description
Creates a cone with a specified center and radius, and optionally, prepares it for
        immediate use in the automesher. It also can identify a conical region for the automesher to
        use under the mesh without surface option.
","Inputs

top center
A node specifying the top center of the cone. 
bottom center
A node specifying the bottom center of the cone. 
base radius
The radius of the bottom of the cone. 
top radius
The radius of the top of the cone.
aspect ratio
A value less than 1.0 creates an elliptical cone or cylinder. 
height
Height of the cone. 

","Example
To create a circular cone with the top center at node 1, the bottom center at node 2, a
        base radius of 100, top radius of 0, and a radius of 50, but not create any elements:
*surfacemode (4)
*surfaceconefull(1,2,100.0,0.0,1.0,50.0)
If the top radius and base radius are equal, a cylinder is created. 
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2022,*surfacecreatedraglinealongline ,"Description
This command creates surface(s) by dragging section lines(s) along a drag line. Lines in
        the line list are combined into a single line L, called the drag line. The direction of the
        drag line is determined by choosing its start point, S, as the closest end of the line to
        the section line vertices. 
node_id and refplane arguments are optional and
        determines how the input lines are transformed before drag.
The reconfiguration of the geometries before the drag is done as follows. Let P be the
        point referred by the node_id, N be the normal and B be the base point of
        the refplane and T be the tangent vector of drag line at S. First,
        section lines are translated by the direction vector PB. If Bit3 of the
        options is not set, then, the section lines are rotated by the rotation from vector N to
        vector T. Also, the drag line is translated by the direction vector SB. The drag is applied
        to along this line L. So, if P is selected on a section line, the new location of P is going
        to be at B. Moreover, if P is one of the vertex points of the section lines, one gets an
        exact geometric copy of the drag line at B, no matter which drag method is chosen. This is
        because, prior to drag, P is moved to B and B moves on drag line since it coincides with the
        start point of the drag line L. 
If node_id is not given, it is chosen as the same point as S, the start
        of the drag line. This means, with the default value of node_id, the drag
        line is not transformed.
If the reference plane is not given, their default values are B at P and N=T. This means,
        with the default value of transformation plane, the section lines are not transformed prior
        to drag.
Note that, the location of P is not important if fixed frame method is chosen with no
        transformation plane, since each point on the section surface traces an exact geometric copy
        of the drag line in fixed frame method. 
","Inputs

lines_mark_id 
The mark ID containing the lines that you wish to drag.
lines_list 
The list ID containing the lines that will be used to from the drag line. 
The first line in this list determines the direction of the drag, which is also shown
            to the user on the screen. If the drag line has corners, then the new surfaces are split
            at those locations.
method
Parameter specifying the method of how the drag is performed. Valid options are: 
0 - Fixed frame 
1 - Follow the drag line only along its tangent direction 
2 - Follow the drag line along its Frenet frame
options
Flags that indicate different modes for the drag. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3). 
Bit0
0 - Drag along the direction of the drag line. 
1 - Drag along the opposite direction of the drag line.
Bit1
0 - Do not merge input lines. A surface is created for each input line. 
1 - Merge input lines into smooth lines when possible. A surface is created for
                  each group that forms tangentially continuous lines.
Bit2
0 - Use the ref_plane input. 
1 - Do not use the ref_plane input. Instead, use its default
                  values.
Bit3
0 - Use the whole ref_plane for transformation if it is
                  given. 
1 - Use the only the base point of the reference plane, set the normal as the
                  tangent of the drag line at drag start point.


comp_mode
Parameter specifying how entities are organized into components: 
0 - Surfaces are created in the current component. 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.
?node_id? (optional)
The ID of the node that is used as a reference point while determining how the
            surfaces are transformed prior to drag.
?ref_plane? (optional)
When provided, its value must always be 1. It is used to determine the initial
            reference frame. This plane is created using the *createplane
            command.

","Examples
Assume that you want to drag section-lines with IDs 39, 401 and 388 along the line that is
        formed by combining lines with IDs 37 and 25, using the fixed frame method. Assume that you
        want to drag along the direction opposite to the direction of line 37 and want to merge the
        input section lines into smooth line groups when possible. Moreover, you want the resultant
        surfaces to be organized in the component of the lines. Then, options = 1+2 = 3, and
        comp_mode = 1. If you do not want to use any reference plane, use the following commands to
        create dragged surfaces. As a result one edge of the surfaces will be the input section
        lines, while the opposite edge will be an exact translated copy of that section line, and
        the side edged will be an exact translated copy of the drag-lines broken at possible vertex
        points.
*createmark lines 1 39 401 388 
*createlist lines 1 37 25 
*surfacecreatedraglinealongline 1 1 0 3 1
In addition if you now want to use a reference node with ID 12, which happen to lie on one
        of the section lines, and a reference plane, use:
*createmark lines 1 39 401 388 
*createlist lines 1 37 25
*createplane 1 1.0000 1.0000 1.0000 2678.0 -737.7 548.1 
*surfacecreatedraglinealongline 1 1 0 3 1 12 1 
The surfaces created will be in such a way that the new location of the point on which node
        12 located, will be at the base point (2678.0 -737.7 548.1) of the reference plane.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2023,*surfacecreatedraglinealongvector,"Description
This command creates surface(s) by dragging line(s) along a vector. If the distance is
        negative, the opposite direction to vector is used for dragging.
","Inputs

mark_id
The mark ID containing the lines that you wish to drag.
vector
Temporary vector ID defining the direction of the drag.
distance
The length of the drag. Negative values indicate opposite direction to the
            vector.
options
0 - Do not merge input lines. A surface is created for each input line. 
1 - Merge input lines into smooth lines when possible. A surface is created for each
            group that forms tangentially continuous line.
comp_mode
Parameter specifying how entities are organized into components: 
0 - Surfaces are created in the current component. 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.

","Example
To create 3 surfaces by dragging the input lines 35, 27 and 29 along the x-axis 5 units,
        creating the surfaces in the current component:
*createmark lines 1 35 27 29
*createvector 1 1.0 0.0 0.0
*surfacecreatedraglinealongvector 1 1 5.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2024,*surfacecreatenormalfromedges,"Description
Creates surfaces in the normal direction from the edges of adjacent surfaces. The new
        surfaces are created by dragging these surface edges along the normal direction of the
        surfaces to which the master edges belong. In the event the neighbor surfaces are tangent
        enough to each other, the average normal is used as the drag direction. When two or more
        input edges meet at a vertex, result surfaces are separated by a new edge created along that
        vertex.
","Inputs

mark_id
The ID of the mark containing the input surface edges. Valid values are 1 and 2.
distance
The distance to drag along the calculated direction. Both positive and negative values
            are accepted. If the distance is negative, the direction opposite to the normal
            direction is used.
reserved
Reserved for future use. Must be set to 0.
comp_mode


0 - New surfaces are created in the current component. 
1 - New surfaces are created in the same component as the input edges.



","Example
To create surfaces extending normally from edges 75 and 68 by a distance of 12 units. The
        new surfaces will be created in the same component as the input edges:
*createmark lines 1 75 68
*surfacecreatenormalfromedges 1 12.0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2025,*surfacecreateruled,"Description
This command creates surfaces by interpolating linearly or smoothly between input lines.
        Optionally, a list of linking points and/or guiding lines can be provided for better
        interpolation and shape control. The input lines should be given in the correct order,
        grouped into ‘levels’ of the ruled surface. For example, referring to the image below, the
        input line list should first include 3 lines at level 1, then 3 lines at level 2 and then
        the line at level 3.

","
Inputs



line_list_id

The ID of the list containing the input lines. Valid values are 1 and 2.

link_coords_array

The list of x-, y- and z-coordinates for the optional points which are to be linked by
            an edge in the ruled surface(s). Link points should be given in pair or points, since
            each link between input lines is specified by its two end points. When these points are
            given, the final ruled surfaces include a surface edge that connects these points.
            Because of that, the pair of points must not skip levels. For instance, in the image
            below, we cannot skip level 2 by connecting a point at level 1 with a point at level 3.
            If such a skip is detected, the corresponding pair of points is ignored. One point may
            be linked to multiple points at a level above or below it, which results in creation of
            ‘triangular’ surfaces.

The *createdoublearray command must be used to create the array.
            This should always be set to 1.

number_of_link_coords

The size of the link_coords_array.

guide_mark_id

The ID of the mark containing the guiding lines. Valid values are 1 and 2.
Guiding lines are used as part of the boundary of the final interpolating surface. If
            more than one guiding line is selected, the edges of the surfaces between these lines
            are obtained by smoothly interpolating these lines. If ruled_type is
            1, guiding lines are ignored. If a guiding line extends beyond just connecting the input
            lines, that part of the line is ignored.
In order for guiding lines to be valid, they must touch the input lines, but not
            necessarily all of them. However, guiding lines should not skip any level in between the
            levels that they are connecting.

ruled_type

0 - Smooth interpoloation
1 - Linear interpoloation

options

Flags that indicate different modes for surface creation. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1):
Bit0
0 - Merge surfaces at shared input lines
1 - Split surfaces at shared input lines
Bit1
0 - Create open-ended ruled surfaces
1 - Create a closed ring ruled surfaces



comp_mode

0 - Surfaces are created in the current component 
1 - Surfaces are created in the same component as the selected lines. The result is
            not predictable if the lines are originally in different components.

","Examples
Referring to the images above, to create linear ruled surfaces between lines 56, 52, 53,
        58, 57, 59 and 51, without using any guide lines or linked points:
*createlist lines 1 56 52 53 58 57 59 51
*surfacecreateruled 1 1 0 2 1 0 0
To create smooth ruled surfaces interpolating lines 56, 52, 53, 58, 57, 59 and 51 with the
        following conditions: ruled surface will be in the input lines component; split at the input
        lines; links point P1 = (2.3, 4.5, 6.0) and point P2 = (12.3, 2.25, 36.30), uses guide lines
        44:
*createlist lines 1 56 52 53 58 57 59 51
*createdoublearray 6 2.3 4.5 6.0 12.3 2.25 36.30
*createmark lines 2 44
*surfacecreateruled 1 1 6 2 0 3 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2026,*surfacecreatespinnodeswithoffsetangle ,"Description
Spins a list of nodes to create a surface, and optionally, prepares it for immediate use
        within the automesher. It can also identify a region in the shape of a surface of revolution
        for the automesher to use under the mesh without surface option.
","Inputs

nodelist
The ID of the list of nodes to be spun.
rotplane
The axis about which to spin the lines made from nodes (plane normal is used as axis
            vector and the base point of the plane is used as the rotation center).
start_angle
Degrees value of initial rotation angle: lines made from selected nodes are rotated by
            this value before surface ""sweeping"" begins.
end_angle
Degrees value of final rotation angle: surface ""sweeping"" stops at this value.

","Example
To a line made through nodes 8, 9, 10 and 11 from 45 to 90 degrees about an axis given by
        the vector (1 2 3) with rotation center at point (4 5 6), creating a surface of revolution
        but not creating any elements on it:
*surfacemode 4
*createlist nodes 1 8 9 10 11
*createplane 1 1 2 3 4 5 6
*surfacecreatespinnodeswithoffsetangle 1 1 45 90
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2027,*surfacedisplaynormals,"Description
Turns on the display of surface normals. 
The display type is defined by *setsurfacenormalsdisplaytype.
","Inputs

entity_type
The type of entity to display normals for. Valid values are surfaces, solids and
            components.
mark_id
The ID of the mark containing the input entities. Valid values are 1 and 2.
size
Specifies the size of the normal graphics to be drawn, if vector normal display is
            set. If set to zero, the vector is drawn at 10% of the screen size.

","Example
To turn on the display of normals for surfaces 1-10 at 10% screen size:
*createmark surfs 1 1-10
*surfacedisplaynormals surfs 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2028,*surfaceimprintpoints,"Description
Imprints locations/points, given by coordinates, onto surfaces within a given max
        distance.
","
Inputs



mark_id

The ID of the mark containing the surfaces to imprint. Valid values are 1 and 2.
double_array
The ID of the double array that contains the point coordinates to imprint. The double
            array is created using the *createdoublearray command. This should
            always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. This should always be a multiple of 3.

max_distance

The maximum imprint distance. If negative, there is no restriction.

","Examples
To imprint surfaces 5 and 7 with 4 locations:
*createmark surfs 2 5 7
*createdoublearray 12 42.41 -35.16 65.90 42.49 -30.06 65.93 44.49 -32.58 66.97 24.41 -28.13 66.34
*lineimprintpoints 2 1 12 -1.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2029,*surfaceintersectmark2 ,"Description
Creates lines by intersecting surfaces with a plane or other surfaces.
","Inputs

mark_id
The ID of the mark containing the surfaces to intersect. Valid values are 1 and 2.
plane_flag


0 - Use mark_id2 to define the surfaces to use for the
                intersection. 
1 - Use plane_id to define the plane to use for the
                intersection.


plane_id
The ID of the plane to use for the intersection, if plane_flag is
            1. This is defined using the *createplane command.
mark_id2
The ID of the mark containing the surfaces to use for the intersection, if
              plane_flag is 0. Valid values are 1 and 2.
comp_mode


Parameter specifying how lines are organized into components: 
0 - Lines are created in the current component. 
1 - All created intersection lines will be placed in the original surface
                component(s), splitting the lines where necessary if the surfaces selected are
                connected and in different components.



","Examples
To create intersection lines for the xy-plane with a base node of 0,10,0 with the displayed
        surfaces:
*createmark surfaces 1 displayed
*createplane 1 0 0 1 0 10 0
*surfaceintersectmark2 1 0 1 0
To create intersection lines for the intersection of surfaces 1 and 2 with surfaces 10 and
        11:
*createmark surfaces 1 1 2
*createmark surfaces 2 10 11
*surfaceintersectmark2 1 1 1 2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2030,*surfacemark_find_organize_symmetry ,"Description
This command compares surfaces from two different sets, checking whether any surface in one
        set has an identical counterpart in another set after reflection with respect to the input
        plane. Optionally, only one set of surfaces can be provided on input, in which case this
        single set is automatically split into two sets based on the surfaces’ position with respect
        to the input plane. As a result of symmetry calculations, surfaces are either deleted or
        reorganized into newly created components, depending on the chosen options parameter (see
        comments).
","Inputs

surf_set_mark_id1
The mark containing the surfaces in the first set.
surf_set_mark_id2
The mark containing the surfaces in the second set, or zero for no additional
            surfaces.
plane 
The symmetry plane around which surfaces will be reflected & compared.
options 
An integer value representing a combination of flags used to modify command behavior
            (see comments).
tolerance 
Tolerance value used to calculate surfaces identity.
Parameter options description 
As a result of surface sets symmetry calculation, input surfaces are separated into
            four sets:
output_set0 - unmatched (no symmetric counterpart was found) surfaces of
                  input set surf_set_mark_id1. 
output_set1 - matched (symmetric counterpart was found) surfaces of
                  surf_set_mark_id1. 
output_set2 - unmatched (no symmetric counterpart was found) surfaces of input set
                  surf_set_mark_id2. 
output_set3 - matched (symmetric counterpart was found) surfaces of
                  surf_set_mark_id2.


The options parameter is composed of several ""action"" groups, with
            each group consisting of four bits. Each bit in the group corresponds to one of four
            output sets: 
Action group ""move to component"" - bits 0…3: These bits correspond to the output set
            numbers (0-3). Surfaces from the specified output set set are moved into a component
            with a predefined name as described below:
output set
original component name
new component name


output_set0
<name>
<name>_unmatched


output_set1
<name>
<name>_plus


output_set2
<name>
<name>_unmatched


output_set3
<name>
<name>_minus



Action group ""delete"" - bits 4…7 (corresponding to <output set #+4>): surfaces from
            the corresponding output set (4=unmatched/mark1, 5=matched/mark1, 6=unmatched/mark2,
            7=matched/mark2) are deleted (if both ""move to component"" and ""delete"" actions are
            specified for the same output set, this ""delete"" action takes precedence). 
Action group ""highlight"" - bits 8…11 (corresponding to <output set #+8>): surfaces
            from the corresponding output set (8=unmatched/mark1, 9=matched/mark1,
            10=unmatched/mark2, 11=matched/mark2) are also placed into their corresponding input set
            and highlighted. 
The final value for the options parameter is the sum of 2 to the power of the bit
            value for each desired action. For example, the ""move to component"" output set uses bit
            values equal to the output set numbers, so so moving the unmatched surfaces (output_set0
            and output_set2) into a component requires an options value of 2^0 +
            2^2 = 5.

","Example
Suppose you want to find the symmetry between surfaces in a set marked by input mark 1 and
        surfaces marked by input mark 2. You want to use identity tolerance of 0.1. You want to
        reorganize and highlight surfaces that were found to be symmetrical, and to delete surfaces
        that do not have symmetric counterpart. You would then construct the
          options parameter as follows:
Organizing symmetric surfaces - add bits 1 and 3 (action group ""move to component"" for
            output_set1 and output_set3). 
Deleting unmatched surfaces - add bits 4 and 6 (action group ""delete"" for output_set0
            and output_set2). 
Highlighting symmetric surfaces - add bits 9 and 11 (action group ""highlight"" for
            output_set1 and output_set3).


Combining all bits gives the value for options parameter:
options = 2^1 + 2^3 + 2^4 + 2^6 + 2^9 + 2^11 = 2650
So we call the command as:
*surfacemark_find_organize_symmetry 1 2 2650 0.1
","Errors
This command does not return any errors that can be handled.
"
2031,*surfacemarkclipwithline,"Description
Splits a group of surfaces with a line by projecting that line perpendicularly onto the
        surfaces.
","Inputs

mark
The mark ID containing the surfaces.
line
The ID of the line used to split the surfaces.
tolerance
The maximum distance the line may deviate from the surfaces and still be
            projected.

","Example
To split two surfaces using line number 26 and a projection tolerance of
        0.1:*createmark(surfaces,1)171 172
*surfacemarkclipwithline(1,26,0.1)
",
2032,*surfacemarkfeatures,"Description
Reorganize the topology of a given set of surfaces based on various input test parameters.
        There are five separate tests available as well as options to close orphans and update or
        move (explained below). If the arguments to a test are -1, the test is not done. Therefore,
        the command is used for a variety of combinations of various tests.
","Inputs

markmask
The mark containing the surfaces to reorganize.
Test 1
angle_surf, offset_surf  - Preserves green edges between surfaces whose break angle
            (difference in surface normal direction) is more than the input value (angle_surf).
            These normals are calculated and compared at an offset distance (offset_surf) from their
            common shared edge. You can adjust both the angle and the offset distance. These two
            arguments act as a pair. 
Use -1 to turn this test off.
Option 1
close_orphans - An orphan is a shared edge that does not connect to another edge
            (usually generated due to suppression of connecting edges). This option allows you to
            detect such edges and automatically close them (close_ophans has a non-zero value). This
            extends the path of all green edges (by changing connected blue edges to green) so they
            do not stop until they connect with another green or red edge.
Test 2
fillet_min, fillet_max - Preserves the green edges along the line of tangency of the
            surface fillet and its adjacent surfaces. The faces that comprise the length of the
            fillet are combined (their edges are suppressed). You can adjust the minimum
            (fillet_min) and maximum (fillet_max) fillet radii to be considered.
Test 3
angle_vertex - Checks angle vertex to preserve the green edges leading away from a
            surface vertex whose exterior angle is greater than the specified angle (angle_vertex).
            This option works only on suppressed edges and unsuppresses them where this criterion
            fails. Therefore, if you use move mode with this option alone it will not provide
            effective results.
Test 4
edge_min - Detects edges that are smaller than the specified value (edge_min). The
            edges that are detected as small are fixed in three ways: If the small edge contains a
            fixed point that is not required for geometric connectivity, those fixed points are
            suppressed. 
If the edge is much smaller than the minimum specified (less than 1/10th of specified
            value), the edge is degenerated (one of the end points is replaced by the other). In the
            remaining situations, edges are suppressed wherever possible to avoid small length
            edges.
Test 5
shape_discontinuity - Checks for surfaces that have a shape ratio (ratio of the
            lengths of opposite edges)greater than the user-specified value. In such a case, any
            suppressed edges present inside that surface are unsuppressed to reduce the shape ratio.
            Similar to the vertex angle tool, this option works effectively with update mode or in
            combination with other options
Option 2
update_only - In the move mode (update_only = 0), all the green edges between surfaces
            are suppressed, then the green edges are reintroduced into the model based on the
            sequential results for all the active tests. In the update mode (update_only = 1), the
            current state of the green edges is preserved as the starting point for applying the
            sequential results of all the active tests.

","Example
For examples, refer to the Geom Cleanup panel.
",
2033,*surfacemarkremoveallpinholes,"Description
Removes all pinholes of a specified size from the specified surfaces. 
","Inputs

mark
The mark ID containing the surfaces.
diameter
The upper-limit of the pinhole’s diameter.

","Example
To remove all pinholes of all surfaces using a radius of
        5.*createmark(surfs,1) all
*surfacemarkremoveallpinholes(1,5.0)
The *createmark() command is required.
",
2034,*surfacemarkremovepinholes,"Description
Removes pinholes.
","Inputs

mark
The mark ID containing the surfaces.
diameter
The upper-limit of the pinhole’s diameter.
coords
The ID of a double-array listing the center coordinates of the pinholes to remove, in
            the order x1, y1, z1, x2, y2, z2, x3, y3, z3.
arraylength
The array length.

","Examples
To remove 3 pinholes from surface 471, using a radius of 5.0 as a
        guide:*createmark(surfaces,1) 471
*createdoublearray(9) 1577.74 500.9 690.69 1580.8 502.6
683.4 1583.8 504.2 676.207*surfacemarkremovepinholes(1,5,1,12)
The *createmark() and *createdoublearray() commands
        are required.
",
2035,*surfacemarksplitwithlines,"Description
Changes the number of lines used to display an existing surface. 
","Inputs

surf_mark_id
The mark ID containing the surfaces to split. Valid values are 1 and 2.
line_mark_id
The mark ID containing the lines to use for splitting. Valid values are 1 and 2.
vector_id
The vector ID to use for the split direction. This is defined using the
              *createvector command.
trim_flag
Bit value defining the trim options (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3):
Bit0
0 - Sweep using the distance value
1 - Sweep through the entire surface
Bit1
0 - Project using vector_id in both directions
1 - Project using vector_id only in vector direction
Bit2
0 - Project using vector_id if proided and non-zero
                  length
1 - Project normal
Bit3
0 - Do not create fixed points at line ends
1 - Create fixed points at line ends


distance
The distance to sweep, if trim_flag is 0.

","Example
To trim surfaces 15 and 16 with all displayed lines along the z direction, using a max
        distance of 0.5: 
*createmark surfaces 1 15 16
*createmark lines 1 displayed
*createvector 1 0.0000 0.0000 1.0000
*surfacemarksplitwithlines 1 1 1 1 0.5

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2036,*surfacemarksplitwithplane ,"Description
Splits a group of surfaces with an infinite plane.
","Inputs

mark
The ID of the mark containing the surfaces.
plane
The plane used to split the surfaces.

","Example
To split surfaces 10 and 20 with the xy plane (normal equals the z-axis):
*createmark(surfaces,1) 10 20
*createplane(1,0.0000,0.0000,1.0000,0.0000,0.0000,0.0000)
*surfacemarksplitwithplane(1,1)
","Errors
None.
"
2037,*surfacemarkuntrim,"Description
Removes any trim lines from the selected surfaces and lets the surface expand to its
        natural limits. The trim lines are separated from the surface and placed in the current
        component.
","Inputs

surfacemark
The mark of surfaces to be expanded. 

","Example
To untrim the surface with ID 645:
*createmark(surfaces,1) 645
*surfacemarkuntrim(1)

Some surfaces cannot be untrimmed, such as splines created from more than 4 lines. This
        command is used primarily in the cleanup of imported CAD data.
","Errors
None.
"
2038,*surfaceplane,"Description
Creates a square, planar surface, and optionally, prepares it for immediate use within the
        automesher. It can also identify a region in the shape of a square planar surface for the
        automesher to use under the mesh without surface option. 
","Inputs

plane id
The ID of the plane (vector and base) on which the surface will be created. 
size
The length of the edges of the surface. 

","Example
To create a square, planar surface normal to the x axis, with the center at the origin, of
        size 10.0, but not create any elements: 
*surfacemode(4)
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*surfaceplane(1,10.0)
*createplane() is required for this command. The
          *surfacemode(4) directive tells HyperMesh
        not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2039,*surfaceprimitivefrompoints,"Description
This command takes input nodes or points and uses them as target points to construct a
        surface of the specified primitive type. Optionally, a tolerance value can be specified to
        reject a surface that does not fit the input points.
","Inputs

entity_type
Type of input target. Valid values are nodes or points.
mark_id
The mark of input nodes or points.
surf_type
The type of primitive surface to create. Valid values are: 
1 - plane 
2 - sphere 
3 - cylinder 
4 - cone 
5 - general quadric surface 
For surf_type 4, if a cylinder can be fit to the input entities, it
            will be created instead of a cone.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).
Bit0
 Tolerance usage mode. Valid values are:
0 - Tolerance is not used, best possible surface is found for any input set
                      of points. 
1 - Tolerance specified by tol parameter is used to reject surface that
                      does not fit input points.


Bit1
 Component mode. Used only when entity_type is points. Valid
                  values are:
0 - Surface is created in the current component. 
1 - Surface is created in the most common input points component.




tol
Tolerance value used to accept generated surface. Not used if options Bit0 is 0.
            Negative value can be set to specify that the global value of the geometry cleanup
            tolerance set using *setoption cleanup_tolerance should be used.

","Examples
To create a cone surface that fits all displayed points in a best possible way:
*createmark points 1 ""displayed""
*surfaceprimitivefrompoints points 1 4
To try to create sphere that fits nodes 1 through 8 with a deviation not larger than
        0.02:
*createmark nodes 1 1-8
*surfaceprimitivefrompoints nodes 1 2 1 0.02
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2040,*surfaceskin ,"Description
Creates a skin surface across a line list, and optionally, prepares it for immediate use in
        the automesher. It can also identify a region in the shape of a skin surface for the
        automesher to use under the mesh without surface option. 
","Inputs

skin_linelist
The ID of the list of lines forming the ribs of the skin surface.
auto_reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
To create a skin surface across lines 1, 2, 3, and 4 with no elements: 
*surfacemode(4)
*createlist(lines,1) 1 2 3 4
*surfaceskin(1,1)

The *surfacemode(4) tells HyperMesh not to
        proceed with element creation, but to create a surface for later use. The
          *createlist() directive is required for this command. 
","Errors
None.
"
2041,*surfacespherefromthreepoints ,"Description
Creates a full or partial sphere, and optionally, prepares it for immediate use within the
        automesher. It can also identify a region in the shape of such a sphere for the automesher
        to use under the mesh without surface option. 
","Inputs

center
A node specifying the center. 
radius
The radius of the sphere. 
r
A node specifying the r vector. 
theta start
Angle at which theta starts (0.0 to < theta end).
theta end
Angle at which theta ends (> theta start to 360.0). 
angle
A node specifying the angle vector. 
phi start
Angle at which phi starts (-90.0 to < phi end). 
phi end
Angle at which phi ends (> phi start to 90.0). 
angle type
Defines whether the angle vector is to be theta or phi. 
0 - The angle vector will be theta. 
1 - The angle vector will be phi.

","Example
To create one quarter of a sphere with a radius of 10 through using nodes 1, 2 and 3, but
        not create any elements: 
*surfacemode(4)
*surfacespherefromthreepoints(1,10.0,2,0.0,180.0,3,0.0,90.00,0)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2042,*surfacesplinefillholes,"Description
Creates spline surfaces on all loops of selected lines. 
Both topological and free lines can be used for the loop for spline creation.  If lines are
        not connected into a closed loop, it will create connecting lines. If the selected lines are
        topological lines connected to some other surfaces, the tangency of the lines created to
        close the gaps in the loop should match the tangency of the connected surfaces.  The
        tangencies of the created splines match the tangencies of connected surfaces (if any). 
        Created splines are placed into the same components that selected lines belong to.
","Inputs

mark_id
The ID of the mark containing the input lines. Valid values are 1 and 2.

","Example
To create spline surfaces for lines 1-10:
*createmark lines 1 1-10
*surfacesplinefillholes 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2043,*surfacesplinefrommesh ,"Description
Creates geometry on selected 2D mesh elements. Uses selected plot elements to create edges
        between surfaces. 
","Inputs

shellelemmarkmask
Selection markmask for 2D mesh elements that are used to create surfaces.
edgeelemmarkmask
Selection markmask for plot 1D elements that are used to create boundaries between
            created surfaces.
tol
Maximal deviation of mesh points from created surfaces at boundaries. If the value is
            set to 0 or is negative, deviation is calculated internally based on the average size of
            mesh elements.

","Example
To create geometry that fits set of 2D elements selected by markmask 1 and use 1D elements
        selected by markmask 2 to create boundaries between surfaces. Use automatically calculated
        tolerance for created boundaries.
*surfacesplinefrommesh(1, 2, 0)
Selection markmask for elements are created by *createmark command. The
        type of selected elements is being checked internally before processing. Therefore, the
        option for global selection (*createmark(elements,1) ""displayed"", for
        example) can also be used. 
","Errors
None.
"
2044,*surfacesplineonlinesloop,"Description
Create surface spline using lines selected by markmask 1. If lines are not connected into
        closed loop, create connecting lines. If selected lines are topological lines connected to
        some other surfaces, tangency of lines created to close the gaps in the loop should match
        tangency of connected surfaces. Tangency of created spline matches the tangency of connected
        surfaces (if any). Created spline is placed into the same component that selected lines
        belong to.
","Inputs

mark_id
Selection markmask for lines that are used for the loop to create the spline on. Both
            topological and free lines can be used.
fill_gaps
Gap filling mode 
0 - Input lines must be all connected into a closed loop within the internal
            tolerance. 
1 - Connection lines are built for gaps exceeding the internal tolerance. If
              use_surfs is 1, the tangency of the attached surfaces is used to
            construct the filling lines.
use_surfs
Connected surfaces usage mode. 
0 - Tangency constraints are not used. 
1 - Surfaces attached to input lines are used to maintain tangency for the constructed
            spline.
options
Specifies options for creating the surface. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 8*Bit3 + 1024*Bit10).
Bit0
Component mode. Used to determine which component will be used to place created surfaces.
0 - Current component is used. 
1 - Component of input lines is used. If different components are used as
                      input, the component to which the majority of the lines belong is used.


Bit1
Line ends usage mode. Used to control creation of vertices on the constructed
                  spline. Currently works only for planar surfaces.
0 - Vertices are created automatically on constructed surface. 
1 - Vertices are created at input line ends.


Bit3
Surface stitching option. Used to override the default stitching algorithm.
0 - Default stitching algorithm as defined by *setoption
                        geoms_titching command. 
1 - Created surface is not stitched to any of model surfaces.


Bit10
 Mesh stitching option. Used to control the connectivity of the mesh created on
                  the new spline surface in simultaneous meshing modes set by
                    *surfacemode command.
0 - New mesh is not connected. 
1 - In *surfacemode 1, existing mesh nodes on input
                      lines are used if new spline edges are stitched to those lines. In
                        *surfacemode 2, existing mesh nodes on input lines are
                      used to create the mesh on the new spline surface.





","Example
*surfacesplineonlinesloop 1 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2045,*surfacesplitwithcoords,"Description
This command splits an input surface using a line created between points specified by input
        coordinates. The points specified by the input coordinates are expected to be in close
        proximity to the input surface. 
","Inputs

surf_id
The ID of surface to be split.
x1 y1 z1
Coordinates of the first point.
 x2 y2 z2
Coordinates of the second point.

","Example
To split the surface with ID 12 using a line between points specified by coordinates (1, 2,
        3) and (4, 5, 6):
*surfacesplitwithcoords 12 1 2 3 4 5 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2046,*surfacesplitwithplane ,"Description
Splits a surface with an infinite plane. 
","Inputs

surface
The surface to be split. 
plane
The plane used to split the surface

","Example
To split surface 1 with the xy plane (normal equals the z-axis): 
*createplane(2,0.0,0.0,1.0,0.0,0.0,0.0)
*surfacesplitwithplane(1,2)

","Errors
None.
"
2047,*surfacestringcreatemidline,"Description
Creates midlines for strings of narrow surfaces (fillets, rib tops, etc...).  The command
        takes as input a mark of surfaces that can be interpreted as narrow strings sets : one or
        several disconnected strings. Optionally configuration of string could be additionally
        supported with given mark of the strings long sides lines. The result of the command –
        topological midlines created for each of the surfaces strings. The result surfaces are
        placed on the imput mark. Optionally the created midlines could be marked by a given output
        mark. The optional parameters of the command are in “key-value” format. The options order
        and number is arbitrary
","
Inputs


mark_id
 The ID of the mark of narrow surfaces.  Valid values are 1 and 2.
alonglines_mark=<value>
 The ID of a mark containing the along side lines.  Valid values are 1 and 2.  If
            empty (default), the lines are auto-calculated.
midlines_outmrk=<value>
 The ID of the mark of output midlines.  Valid values are 1 and 2.  If empty
            (default), the output midlines are not placed on a mark.

","Examples
Create midlines for surfaces 7054-7077, with the long side lines auto-identified, and do
        not place the created midlines on a
        mark:*createmark surfaces 1 7054-7077
*surfacestringscreatemidline 1
Create midlines for surfaces 7054-7077, with the long side lines auto-identified, and place
        the created midlines on mark
        2:*createmark surfaces 1 7054-7077
*surfacestringscreatemidline 1 midlines_outmrk=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2048,*surfacetorusfromthreepoints,"Description
Creates a torus which passes through the three specified nodes, and optionally, prepares it
        for immediate use in the automesher. It also can identify a toroidal region for the
        automesher to use with the mesh without surface option. 
","Inputs

major center
A node specifying the major center of the torus
minor center
A node specifying the minor center of the torus.
minor radius
A node through which the minor revolution will pass. 

","Example
To create a torus which has the major center at node 1, the minor center at node 5, and the
        minor radius at node 13, and not create any elements: 
*surfacemode(4)
*surfacetorusfromthreepoints(1,5,13)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2049,*surfmark_trim_by_elemmark,"Description
Trims the selected surfaces by selected elements using input lines or edges as
        reference.
","
Inputs


input_surf_mark=<value>
The ID of the mark of surfaces to trim.  Valid values are 1 and 2.
trim_elem_mark=<value>
The ID of the mark of elements to use as the trimmer.  Valid values are 1 and 2.
ref_line_mark=<value>
The ID of the mark containing the lines or edges used as a reference to identify which
            part of the surfaces to trim out.  Valid values are 1 and 2.

","Examples
To trim surface 3425 by a selection of elements, and keeping the portion of the surface
        which has an edge overlapping (partially or fully) with line 255495:
*createmark lines 1 355495
*createmark surfaces 2 3425
*createmark elements 2 175323 175313 175309 175307 175304 175303 175301\ 175299 175298 175297 175296 175295 175293 175292 175291 175290 175289 175287
*surfmark_trim_by_elemmark input_surf_mark=2 ref_line_mark=1 trim_elem_mark=2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2050,*swapcards,"Description
Swaps the card image of an entity. This command is used to swap the
          card image of selected contact entities specific to the supported
        solver profile and retain master and slave entities.Note:

In OptiStruct, it is used to swap groups CONTACT and
              TIE.
In Samcef, it is used to swap groups MCT and STI. New
              master and slave entities are created on swapping based on the entity types supported
              specific to element type and contact type.



","Inputs

entity_type
The type of entity to update. Must be set to groups.
mark_id
The ID of the mark containing the groups to update. Valid values are 1 and 2.
target_cardimage
The target card image to which the entity need to be swapped.
            If not specified, a default mapping is done.

","Example
To swap Samcef MCT contacts with IDs 1 and 2:
*createmark groups 1 1 2
*swapcards groups 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2051,*syncpropertybeamsectionvalues,"Description
Copies the beam section values to property values. Currently valid only for Nastran and OptiStruct.
","
Inputs



mark_id

The ID of the mark containing the properties. Valid values are 1 and 2.

","Examples
To copy beam section values to all 1D properties to which the beam section is attached:
*createmark props 1 all
*syncpropertybeamsectionvalues 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2052,*systemcommand,"Description
Executes a system command.
This is also possible via standard Tcl funcitonality.
","
Inputs


command
The system command to execute.

","Example
To execute the command ABC and redirect it to the file DEF:
*systemcommand ""ABC>DEF""
","Errors
None.
"
2053,*systemcreate3nodes ,"Description
Creates a rectangular coordinate system. 
","Inputs

type
The type of system being created. 
0 - rectangular 
1 - cylindrical 
2 - spherical
origin
The ID of a node which defines the origin.
axisname
A string which identifies the axis being defined with the next parameter (x, y, or
            z).
axispt
The ID of a node which defines a point on the axis defined by axisname.
planename
A string which identifies the plane being defined with the next parameter (xy, xz, or
            yz).
planept
The ID of a node which defines a point on the plane defined by planename.

","Example
To build a cylindrical system with node 1 defining the origin, node 2 defining the x axis,
        and node 3 defining the xy-plane:
*systemcreate3nodes(1,1,x,2,xy,3)
","Errors
None.
"
2054,*tableaddcolumn,"Description
Adds a column of data to the right of a table.
","Inputs

name
The name of the table to update.
data_type
The data type of the column. See *tablecreate for valid
            values.
column_label
The label of the column.
string_array
The ID of the string array that contains the column data to add. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of rows in the
            table.

","Example
To add a column of type integer and label INTEGER to ""table1"" which has 7 rows:
*createstringarray 7 1 2 3 4 5 6 7
*tableaddcolumn ""table1"" int INTEGER 1 7
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2055,*tablecontour ,"Description
Contours node/element data from a table.
","Inputs

table_name
The name of the table containing the data to contour.
table_id_column
The title of the column in the table that contains the IDs of the entities to contour. 
If the column is an integer column, the integers are assumed to be element IDs. If the
            column is an entity type column with type element or node, the values are taken as IDs
            of elements or nodes respectively.
table_value_column
The title of the column in the table that contains the values to use for the contour. 
Currently only double or float values are supported.
legend_title
The title to use for the contour legend.

","Example
To create a contour of data in table ""contour_table"", with the column labeled ""IDs"" as the
        ID column, the column labeled ""Values"" as the value column, and a legend title of ""My
        Values"":
*tablecontour contour_table IDs Values ""My Values""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2056,*tabledeletecolumn ,"Description
Deletes a column of data from a table.
","Inputs

name
The name of the table to update.
column_index
The index of the column to delete. Tables are indexed starting from 1 (1 to n
            columns). If specified as 0, the last column in the table is deleted.

","Examples
To delete the last column from table1, which has 11 columns:
*tabledeletecolumn table1 0
or
*tabledeletecolumn table1 11
To delete column 3 from table1:
*tabledeletecolumn table1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2057,*tableexport ,"Description
Exports data from a table to a file.
","Inputs

name
The name of the table to export.
filename
The full path and filename of the file to write.
delimiter
The character or string to use as the delimiter. The value must be enclosed in quotes.
            If not specified, the default is a comma (CSV).

","Examples
To write out table1 with commas as the separator.
*tableexport table1 C:/table1.txt "",""
or
*tableexport table1 C:/table1.txt
To write out table1 with ABC as the separator.
*tableexport table1 C:/table1.txt ""ABC""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2058,*tableinsertrow,"Description
 Inserts a row of data into a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the row data to insert. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.
row_index
The index of the row to insert. Tables are indexed starting from 1 (1 to n rows).

","Example
To insert a row of data at index 3 to ""table1"" which has 7 columns with data types
        (integer, string, double, elements, integer, double, properties):
*createstringarray 7 1 abc 4.567 500 10 3.14159 100
*tableinsertrow table1 1 7 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2059,*tableupdatecell ,"Description
Updates the value of a cell in a table.
","Inputs

name
The name of the table to update.
row_index
The index of the row to edit. Tables are indexed starting from 1 (1 to n rows).
column_index
The index of the column to edit. Tables are indexed starting from 1 (1 to n
            columns).
value
The value to update.

","Example
To update cell (3.4) of table1:
*tableupdatecell table1 3 4 100.2345
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2060,*tableupdatelabels ,"Description
 Updates the column labels of a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the column labels to update. The string array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.

","Example
To update the labels for table1 with 3 columns:
*createstringarray 3 ""Name"" ""ID"" ""Thickness""
*tableupdatelabels table1 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2061,*tangentbetweenlines ,"Description
 Creates a tangent line between two lines. 
","Inputs

line1 id
The ID of the first line to which the tangent line is to be created.
line2 id
The ID of the second line to which the tangent line is to be created. 
checkpoints
The number of points to check in each line segment for tangency. 
lineselected
The tangent line selected, if more than one exists. 

","Example
To create a tangent between lines 1 and 2: 
*tangentbetweenlines(1,2,10,0)
If more than one tangent line is found, you must select the necessary tangent line. The
        number of this line (based on the order in which the tangents were found) is then used in
        the command string. 
","Errors
None.
"
2062,*templatefileset,"Description
Sets the global template file name. 
","Inputs

filename
The file name of the template file that becomes the global template.

","Errors
None.
",
2063,*tetmesh_create_size_ctrl,"Description
This command generates a special component representing an elem-size-control/refinement box
        for use with the *tetmesh or *tetmesh_set_input
        commands. The name of the created component has the prefix ""^elem_size_ctrl_"", followed by
        an instance number and then the elem size (e.g. ""^elem_size_ctrl_0_0.02""). An instance
        number is used to distinguish different boxes having the same elem size.
","Inputs

string
A double quoted string of 25 space or comma separated real numbers. The first 24
            numbers are the 3D coordinates of the 8 vertices of the box (x1 y1 z1 x2 y2 z2...x8 y8
            z8). The order of these vertices is the same as a first order hex element (vertices 1-4
            on the bottom face with counter-clockwise orientation, vertices 5-8 on the top face with
            the same orientation). The last value is the user specified tetra element size for
            inside and near the box. A well-defined box should be convex.

","Example
To create a size control box with a mesh size of 0.02:
*tetmesh_create_size_ctrl ""205.163,-144.90,24.91,255.09,-144.90,24.91,255.09,-33.68,24.91,205.16,-33.68,24.91,205.16,-144.90,144.90,255.09,
-144.90,144.90,255.09,-33.68,144.90,205.16,-33.68,144.90,0.02""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2064,*time ,"Description
 Prints the current time to the command file. 
","Errors
None.
",,
2065,*titledraw,"Description
 Draws a title. 
","Inputs

titlename
The name of the title which should be drawn. 

","Errors
None.
",
2066,*titlepop,"Description
Pops a title to the front. 
","Inputs

titlename
The name of the title. 

","Errors
None.
",
2067,*titlesetcurrent ,"Description
Sets a title to be the current title. 
","Inputs

titlename
The name of the title which should be made current. 

","Errors
None.
",
2068,*topography_reanalysis ,"Description
Extract the final geometry from OptiStruct topology, topography
        and shape optimization results and inherit the boundary conditions for reanalysis. 
","Inputs

grid_filename
The full name and path to the OptiStruct
.grid results file generated from the optimization.
sh_filename
The full name and path to the OptiStruct
.sh results file generated from the optimization.
autobead
Flag that determines whether to create beads. Valid values are: 
0 - Do not create beads. 
1 - Create beads.
bead_threshold
The threshold value for bead creation (0 <= bead threshold <= 1).
isosurface
Flag that determines whether to create isosurfaces. Valid values are: 
0 - Do not create isosurfaces. 
1 - Create isosurfaces.
mode
Iso-surface mode indicating how to process non-design elements. Valid values are: 
0 - Keep all non-design elements with a half layer around. 
1 - Split only intersected non-design elements. 
2 - Split overlapping non-design elements with a half layer around. 
3 - Split overlapping non-design elements.
density_threshold
Threshold value for topology optimization (0 ≤ density threshold ≤ 1).

","Example
Execute OSSmooth on the C:/test/os1.grid and
          C:/test/os.sh files, loading the geometry back to HyperMesh, creating 1 layer autobead with 0.3 bead threshold, splitting
        all quads on non-design/design interface, with a density threshold of 0.3:
*topography_reanalysis ""C:/test/os1.grid"" ""C:/test/os1.sh"" 1 0.3 1 1 3 0.3

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2069,*translatemark ,"Description
This command translates a selection of entities along a vector.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
vector_id
The ID of the vector to use for the translation. This is defined using the
              *createvector command.
distance
The distance to translate.

","Example
To translate node 1 5 units along the y-axis:
*createvector 1 0.0 1.0 0.0
*createmark nodes 1 1
*translatemark nodes 1 1 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2070,*transparencymark,"Description
Makes the shaded surfaces in components on the mark transparent.
","Inputs

mark
The mark containing the components that will be transparent.

","Example
To make the shaded surfaces in the components on the mark transparent:
*settransparency(1)
*createmark(components,1) ""middle""
*transparencymark(1)
*createmark() is required for this command. 
","Errors
None.
"
2071,*triangle_clean_up,"Description
Fixes sliver/bad quality elements which fail the user-defined aspect ratio.
","
Inputs



entity_type

The type of input entity.  Valid values are elems and comps.

mark_id

The ID of the mark of input entities.  Valid values are 1 and 2.

<criteria>=<value>

There are two possible criteria:



aspect=<value>

The elements failing this given aspect ratio value will be fixed. The aspect
                  ratio is defined as the minimum height/longest edge.

height=<value>

The elements failing this given element height value will be fixed. The minimum
                  height is defined as shortest distance from a node to opposite edge.



","Examples
To correct all elements failing aspect ratio of 8:
*createmark components 1 ""all""
*triangle_clean_up components 1 aspect=8 mode=3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2072,*trim_elements2 ,"Description
Trims 2D elements using 1D or 2D elements. 
","Inputs

base_element_mark
The mark of 2D base elements. Valid values are 1 and 2.
trim_element_mark
The mark of 1D or 2D trimming elements. Valid values are 1 and 2.
mode
Flag to indicate how to connect elements when the trimming elements are 2D elements
            and the boundaries of the selection consist of multiple loops. 
0 - Keep internal elements. 
1 - Elements inside internal loops are removed. For example, no elements inside
            washer.
num_layers
Flag to indicate the number of surrounding element layers will be taken into account
            for remeshing. 
0 - No remeshing 
1 - All elements on base_element_mark will be remeshed
 feature_angle
Parameter used to define feature edge in remeshing.
base_component
Flag to indicate if the imprinted elements should be organized to the same component
            as the base elements. 
0 - Keep original organization for imprinted elements 
1 - Organize all imprinted elements to the same component as the base elements

","Example
To trim elements 1-100 with elements 500-550, removing elements from within internal loops,
        with remeshing, a feature angle of 30 and keeping the original organization:
*createmark elems 1 1-100
*createmark elems 2 500-550
*trim_elements2 1 2 1 1 30 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2073,*trim_mesh_by_mesh,"Description
Trims intersecting meshes using the source, target, or both.
","
Inputs


entity_type_source
The type of source entity.  Valid values are elems and comps.
mark_id_source
The ID of the mark of source entities.  Valid values are 1 and 2.
entity_type_target
The type of source entity.  Valid values are elems and comps.
mark_id_target
The ID of the mark of target entities.  Valid values are 1 and 2.
FetchImprintedEdges=<value>
Enables 1D element creation for the intersected edges:
0 - Disabled
1 - Enabled (default).  See ImprintedEdgesComp.
ImprintedEdgesComp=<value>
If FetchImprintedEdges=1 this specifies the component ID to
            organize the 1D elements.  If not specified, a default component named
            ^intersected_edges is used.
ImprintOnMesh=<value>
Specifies where the imprint of the intersection edges should happen:
0 - Imprint on source entities
1 - Imprint on target entities
2 - Imprint on both source and target entities (default)
NodeMarkMask=<value>
The ID of the mark of nodes to delete or retain (deleting other clusters). If the
            imprint happens on the source, the marked nodes should belong to the source entity.  If
            the imprint happens on the target, the marked nodes should be on the target entity.  If
            the imprint happens on both the source and target, the marked nodes can be on the source
            or the target.
RetainMarkedNodeCluster=<value>
When NodeMarkMask has valid nodes specified, this option determines
            if the cluster attached to the marked nodes, bounded by the imprint edges, is to be
            retained or deleted:
0 - Delete
1 - Retain (default)

","Examples
Example:
*createmark parts 1 ""by ids"" 4
*createmark parts 2 ""by ids"" 6
*trim_mesh_by_mesh elems 1 elems 2 ImprintOnMesh=0 FetchImprintedEdges=1 ImprintedEdgesComp=4
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2074,*trueview ,"Description
 Modifies the view so that a model-defined vector is normal to the screen. 
","Inputs

plane id
The ID of the plane about whose normal the vector is made perpendicular to the screen,
            and whose base will be placed in the center of the screen. 

","Example
To make the vector (1.0, 0.0, 0.0) normal to the screen and to place the point (0.0, 0.0,
        0.0) at the center of the screen: 
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*trueview(1)

","Errors
None.
"
2075,*unlockallentities,"Description
Unlock all entities with the same entity type and ID pool across includes.
","
Inputs



entity_type

The type of entity to unlock.

pool_id

The ID of the solver pool.

dataname

Must be set to id.

","Examples
Unlock all elements with ID pool 2:
*unlockallentities elems 2 id
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2076,*unlockview,"Description
Deletes the saved view with the name ""Lock"".
","
Inputs

 None.
","Examples
To delete the ""Lock"" view:*unlockview
","Errors
 None.
"
2077,*unmaskall2,"Description
Unmasks all supported entities. Only entities in displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors


","Example
To unmask all supported entities in the displayed collectors:
*unmaskall2
","Errors
None.
",
2078,*unmaskentitymark,"Description
This command unmasks the entities of entity_type that are on
          mark_id. Valid mark_ids are 1 and 2. Only entities
        in displayed collectors may be unmasked. 
To unmask connectors and the realized FE, a flag of 1 must be passed. To unmask only
        connectors (excluding realized FE) and all other entity types, a flag of zero must be
        passed. 
Currently supported entity_types for this command are:
connectors 
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
ellipsoids 
mbjoints 
mbplanes 
equations 
loads 
systems 
vectors 
tags 
handles 
domains 
symmetries 
morphconstraints 
comps (connectors, points, lines, surfaces, solids, elements) 
groups (master/slave elements)
 loadcols (equations, loads) 
multibodies (ellipsoids, mbjoints, mbplanes) 
systcols (systems) 
vectorcols (vectors) 


","Examples
To unmask all of the displayed connectors and the realized FE:
*createmark connectors 1 displayed
*unmaskentitymark connectors 1 1
To unmask all elements in components but not elements in groups:
*createmark comps 1 all
*createmark elems 1 ""by comps on mark"" 1
*unmaskentitymark elems 1 0
To unmask all entities in all components:
*createmark comps 1 all
*unmaskentitymark comps 1 0
","Errors
This command does not return any errors that can be handled.
",
2079,*unmaskshown2 ,"Description
Unmasks all supported entities in the current view window. Only entities in displayed
        collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 


","Example
To unmask all supported entities in the displayed collectors that are in the current view
        window:
*unmaskshown2
","Errors
None.
",
2080,*unrealizeengineeringentity,"Description
Unrealize an engineering entity.
","Inputs

entity_type
The type of engineering entity to unrealize.
entity_id
The ID of the engineering entity to unrealize.
unrealize_mode
0 - Delete entities from realization.  Only current solver/profile is affected.
1 - Maintain entities from realization.  Only current solver/profile is affected.
10 - Delete entities from realization.  All entities including other solvers/profiles
            are affected.
11 - Maintain entities from realization.  All entities including other
            solvers/profiles are affected.

","Example
Unrealize mass with ID 10:
*unrealizeengineeringentity masses 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2081,*unsetparametermark ,"Description
Unparameterizes a data name or attribute on a mark of entities.
","Inputs

entity_type
The type of entity to unparameterize.
mark_id
The ID of the mark containing the entities to unparameterize. Valid values are 1 and 2.
data_name_or_attribute
The data name or attribute name/ID to unparameterize.
row
The row index of the attribute in a 1D or 2D array. Must be set to 0 otherwise.
column
The column index of the attribute in a 2D array attribute. Must be set to 0
            otherwise.

","Example
To unparameterize attribute LSD_DA1 on entity sets 5, 6 and 7:
*createmark sets 1 5 6 7
*unsetparametermark sets 1 LSD_DA1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2082,*untrim_selected_edges ,"Description
This command modifies surfaces by removing free edges selected by the user and replacing
        each chain of edges by a new edge that is determined as follows:
In case of ""shortcut"" option, the new straight edge joins the end-points of selected
            edge chain. 
In case of ""extend"" option, the command attempts to finds the intersection of two rays
            along tangents at the edge chain end-points. If such an intersection point exists, the
            new straight edges join the end-points of original edge chains with this intersection
            point. 


The input can include free edges on several surfaces simultaneously, and can include both
        internal and external free edges. The command ignores all non-free edges of the
        selection.
If all edges of an internal or external loop are selected, the command would remove the
        entire loop. In these special cases, the command extends the functionalities of
          *edgesmarkuntrim and *surfacemarkuntrim.
","Inputs

mark_id_lines
The ID of the mark containing the free edges to untrim. Valid values are 1 and 2.
mark_id_surfs
Reserved for future use.
untrim_option
Specifies how the new edges be constructed: 
0 - Use the shortcut option 
1 - Use the extend option
keep_vertices
0 - Vertices at the ends of the selected edge chains might be removed if necessary
            (based on the value of the user-specified ""geom. feature angle"")
1 - Vertices at the ends of the selected edge chains will be preserved
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To untrim the red edges with ID 36800-36802 via shortcut option and to preserve the
        vertices at the ends of the selected edge chains:
*createmark lines 2 36800 36801 36802
*createmark surfaces 2
*untrim_selected_edges 2 2 0 1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2083,*UpdateBinderSections ,"Description
This command updates the binder shape using the current section.
","Inputs

entity_type_1
Must be set to surfaces.
mark_id_1
Must be set to 1.
entity_type_2
Must be set to nodes.
mark_id_2
Must be set to 1.
entity_type_3
Must be set to lines.
mark_id_3
Must be set to 1.
entity_type_3
Must be set to nodes.
mark_id_3
Must be set to 2.
plane
Must be set to 1.
rotate_flag
Must be set to 1.
blend_flag
Must be set to 0.
method_flag
Must be set to 5.
con_flag
Must be set to 1.

","Example
To updates the binder shape using the current section:
*UpdateBinderSections surfaces 1 nodes 1 lines 1 nodes 2 1 1 0 5 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2084,*updatefree1delements,"Description
Updates rigidlink and RBE3 elements to remove free legs and optionally update the weights.
        If all legs of the rigidlink or RBE3 are free, the element is deleted.
","Inputs

input_mark_id
The ID of the mark containing the rigidlink and rbe3 elements to consider. Valid values are 1 and 2.
output_mark_id
The ID of the mark containing any elements that have been modified. Valid values are 1 and 2.
update_weight
Flag to determine whether to update leg weights to 1.0. Valid values are: 
0 - Do not update weights. 
1 - Update weights.
summary_filename (optional)
Log file to output, containing a summary of what was modified. If not needed, use """".
            Otherwise, the full path and filename must be specified. 
The output of the file is as
            follows:DELETED ELEMENTS
[Total # of deleted elements]
[Deleted element ID 1]
[Deleted element ID 2]
[...]
[Deleted element ID N]
UPDATED ELEMENTS
[Total # of updated elements]
[Updated element ID 1, # of original legs, # of final legs, weighting factor before {W1, W2, ..., WN TOTAL}, weighting factor after {W1, W2, ..., WN TOTAL}]
[Updated element ID 2, # of original legs, # of final legs, weighting factor before {W1, W2, ..., WN TOTAL}, weighting factor after {W1, W2, ..., WN TOTAL}]
[...]
[Updated element ID N, # of original legs, # of final legs, weighting factor before {W1, W2, ..., WN TOTAL}, weighting factor after {W1, W2, ..., WN TOTAL}]

","Example
To update all displayed elements, with the affected elements going to mark 2, without
        updating the weights, and write the summary to C:/summary.txt
*createmark elems 1 displayed
*updatefree1delements 1 2 0 C:/summary.txt
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2085,*updateinclude ,"Description
Updates include file basic information.
","Inputs

id
The ID of the include file to update. If 0, the shortname is used
            instead.
shortname_flag
0 - Do not update the file short name 
1 - Update the file short name
shortname
The new short name if shortname_flag is 1, or the short name to use
            to select the file if id is 0.
fullname_flag
0 - Do not update the file full name 
1 - Update the file full name
fullname
The new full name if fullname_flag is 1.
parentid_flag
0 - Do not update the parent ID 
1 - Update the parent ID
parent_id
The new parent ID if parentid_flag is 1.

","Example
To change the include file with ID 1, stored as
          C:/common_files/mats/mat1.dyn from mat1.dyn to
          mat2.dyn and change its parent from the master file to a file with ID
        3:
*updateinclude 1 1 mat2.dyn 1 C:/common_files/mats/mat2.dyn 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2086,*UpdateLatitudeLineDrag ,"Description
This command updates the latitude line shape if int_type value is 6. It
        updates the latitude line shape and the addendum surface shape if
          int_type value is 1.
","Inputs

int_type 
To update the latitude lines its value is 6. 
To update the latitude lines and the addendum surface its value is 1.

","Examples
To update the latitude lines shape:
*UpdateLatitudeLineDrag 6
To update the latitude lines shape and the addendum surface shape:
*UpdateLatitudeLineDrag 1
","Errors
 Incorrect usage of UpdateLatitudeLineDrag results in a Tcl error. The function returns an
        error if the current model does not contain latitude line or addendum surface.
if { [ catch { *UpdateLatitudeLineDrag 6} ] } {
# Handle error here   // I don’t find latitude lines.
}
"
2087,*updatepositions,"Description
Reorganize entities, in case of an add, remove, delete transformations or change in
        transformation order operations.
","
Inputs



mark_id

The ID of the mark containing the position entities to refresh.

","Examples
To update all positions in the model:
*createmark positions 1 all
*updatepositions 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2088,*updatereferencegeometry,"Description
Updates a reference geometry control volume. 
","Inputs

entities
Reference geometry is updated using nodes.
markmask
Source of nodes used to update reference geometry. (1=nodes selected by user)
name
Name of the reference geometry. 

","Example
To update reference geometry (called ""ref"") using elements selected by user:
*createcontrolvol(elements,1,""ref"")
","Errors
None.
"
2089,*vectorcreate_xproduct,"Description
Creates a vector entity by using the cross product of two other vectors.
","Inputs

basenode
The ID of the node where the base of the result is located after it is created.
vector A
The ID of the first vector entity in the cross product.
vector B
The ID of the second vector entity in the cross product.
magnitude
Magnitude of resulting vector.

","Errors
None.
",
2090,*vectorsoff,"Description
Remove review vectors from the screen.
","Example
To turn off the review vectors:
*vectorsoff
","Errors
None.
",
2091,*vertexrelease,"Description
 Unstitches the selected vertex.
","Inputs

vertex 
The ID of the surface vertex to release. 

","Example
The fixed point is released. All the suppressed (blue), shared (green), and nonmanifold
        (yellow) edges that share this fixed point are released, generating free (red) edges. 
","Errors
None.
"
2092,*verticesmarksuppress ,"Description
Removes the selected fixed points from their surfaces, and gives the option to create free
        points at those locations.
","Inputs

mark_id
The ID of the mark containing the points.  Valid values are 1 and 2.
break_angle
The test threshold used to prevent the accidental removal of points that correspond to
            corners,which are necessary for proper mesh generation. 
save_as_points
1 - To create free points at the locations of the removed fixed points. 
0 - Do not create free points. 

","Example
To suppress points 25 and 26, using a 30 degree breakangle:
*createmark points 1 25 26
*verticesmarksuppress 1 30.0 0
","Errors
None.
"
2093,*view,"Description
Modifies the current view.
The rotation angle is defined by *setoption rotation_angle.  
","Inputs

view_name 


View name string
Description


bottom
Bottom view


down
Rotates rotation_angle degrees down


front
Front view


left
Rotates rotation_angle degrees to the left


oside
Other side view


plan
Plan view


rear
Rear view


right
Rotates rotation_angle degrees to the right


side
Side view


up
Rotates rotation_angle degrees up


leftside
Left side view


rightside
Right side view


top
Top view


iso1
Isometric view 1


iso2
Isometric view 2


reverse
Reverse the current view


ccw
Rotates rotation_angle degrees
                  counterclockwise


cw
Rotates rotation_angle degrees clockwise


leftsidenofit
Left side view without fit


rightsidenofit
Right side view without fit


bottomnofit
Bottom view without fit


topnofit
Top view without fit


rearnofit
Rear view without fit


frontnofit
Front view without fit


isonofit
Isometric view without fit





","Errors
None.
",
2094,*viewset,"Description
Sets the model orientation and visable area.  The current values can be queried using
          hm_winfo viewmatrix. 
","Inputs

a00-a33
The 4x4 matrix to use to define the view.  The current values can be queried using
              hm_getcurrentview.
minx
The viewport x-axis minimum value.
miny
The viewport y-axis minimum value.
maxx
The viewport x-axis maximum value.
maxy
The viewport y-axis maximum value.

","Example
To orient the model so that the z-axis is pointing out of the screen, with the max visible
        area set to (-0.5,-0.5) to (0.5,0.5):
*viewset 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 -0.5 -0.5 0.5 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2095,*voxel_lattice_hex_mesh_add_box,"Description
Adds elements within a box to the include entities in the voxel domain.  The elements are
        determined by the box with the given input lower and upper corner coordinates, and
        components of x and y axes of the box along the global axis system.  It internally adds the
        triangulation elements to the voxel mesh creation if there are any gaps, holes, or openings
        between the intersection of the box faces with the shell elements bound by the box.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","
Inputs


entity_type
The type of entity within the box to add.  Valid values are elems.
mark_id
The ID of mark of entities to consider to add.  Valid values are 1 and 2.
x1
The x coordinate of the lower corner in the global system.
y1
The y coordinate of the lower corner in the global system.
z1
The z coordinate of the lower corner in the global system.
x2
The x coordinate of the upper corner in the global system.
y2
The y coordinate of the upper corner in the global system.
z2
The z coordinate of the upper corner in the global system.
i1
The i-th component of the x-axis of the box at the lower corner of the box along the
            global x axis.
j1
The j-th component of the x axis of the box at the lower corner of the box along the
            global x axis.
k1
The k-th component of the x axis of the box at the lower corner of the box along the
            global x axis.
i2
The i-th component of the y axis of the box at the lower corner of the box along the
            global x axis.
j2
The j-th component of the y axis of the box at the lower corner of the box along the
            global x axis.
k2
The k-th component of the y axis of the box at the lower corner of the box along the
            global x axis.

","Examples
To add elements within the box with corners at (100, 100, 100) and (400, 400, 400) and
        generate a voxel mesh of size 5.0:
*voxel_lattice_hex_mesh_init 5.0
*voxel_lattice_hex_mesh_add_box elems 1 100.0 100.0 100.0 400.0 400.0 400.0 1 0 0 0 1 0
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2096,*voxel_lattice_hex_mesh_add_entities,"Description
Adds entities to the voxel domain.  Voxel gridding is done along the intersection profile
        of the entities.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

entity_type
The type of entity to add to the domain.  Valid values are comps, elems, surfs, solids
            and lines.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
mode
1 - Voxelize only the input entity profile.
2 - Voxelize only voids/volumes of the input entity profile.
3 - Voxelize both the input entity and voids/volumes.

","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2097,*voxel_lattice_hex_mesh_add_planar_constraint,"Description
Adds a planar constraint to the voxel session.  This restricts voxel creation to one side
        of the plane. Any number of planar constraints may be added.  Voxel elements are created
        only in the regions that satisfy all of the constraints.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

base_x
The plane base x-coordinate.
base_y
The plane base y-coordinate.
base_z
The plane base z-coordinate.
normal_x
The plane normal x-coordinate.
normal_y
The plane normal y-coordinate.
normal_z
The plane normal z-coordinate.
normal_side
1 - Constrain to plane normal side.
0 - Constrain to plane normal opposite side.

","Example
To create voxels of size 10 for include components 100-110 and exclude components 200-203,
        with a planar constraint at 500,0,0 along the positive x-direction:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_add_planar_constraint 500 0 0 501 0 0 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2098,*voxel_lattice_hex_mesh_create,"Description
Creates voxel elements from the inputs given to the voxel session. This command can be
        called any number of times after modifying the input options.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        either a call to *voxel_lattice_hex_mesh_import or one of the
          *voxel_lattice_hex_mesh_add... commands.
","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
2099,*voxel_lattice_hex_mesh_end,"Description
Clears memory and ends the voxel hex mesh module. This must be preceded by any calls to
          *voxel_lattice_hex_mesh_init and other
          *voxel_lattice_hex_mesh... APIs. 
Unrelated ""major"" database changes made while inside of the voxel module will cause it to
        terminate.
","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
2100,*voxel_lattice_hex_mesh_import,"Description
Imports an existing voxelization in to the current voxel session. Import will be successful
        only if all the elements in the selection are voxels of the size exactly equal to the
        current voxel size and grid aligned to the global axes and (0,0,0).
This must be preceeded by a call to *voxel_lattice_hex_mesh_init.
","Inputs

entity_type
The type of entity to import.  Valid values are elems and comps.
mark_id
The ID of the mark of entities to import.  Valid values are 1 and 2.

","Example
To register voxels in comps 100 and 101 and drag elements 500-600 using the face with nodes
        100-110 by (50,0,0):
*voxel_lattice_hex_mesh_init 10
*createmark comps 1 100 101
*voxel_lattice_hex_mesh_import comps 1
*createmark elems 1 500-600
*createmark nodes 1 100-110
*voxel_lattice_hex_mesh_drag_faces 1 1 50 0 0
*voxel_lattice_mesh_mesh_create
*voxel_lattice_hex_mesh_end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2101,*voxel_lattice_hex_mesh_remove_buffer_layers,"Description
Removes buffer layers from all include entities in the voxel domain.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

num_buffer_layers
The number of buffer layers.

","Example
To create voxels of size 10 for include components 100-110 and exclude components 200-203,
        removing a buffer of 2 layers around the include components:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*voxel_lattice_hex_mesh_remove_buffer_layers 2
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2102,*voxel_lattice_hex_mesh_remove_entities,"Description
Removes entities from the voxel domain.  Voxel gridding is removed along the intersection
        profile of the entities.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init and
        must be followed by a call to *voxel_lattice_hex_mesh_create.
","Inputs

entity_type
The type of entity to remove from the domain.  Valid values are comps, elems, surfs,
            solids and lines.
mark_id
The ID of the mark of entities.  Valid values are 1 and 2.
mode
1 - Remove voxelization only for the input entity profile.
2 - Remove voxelization only for voids/volumes of the input entity profile.
3 - Remove voxelization for both the input entity and voids/volumes.

","Example
To create voxels of size 10 for include components 100-110 and exclude components
        200-203:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*createmark comps 2 200-203
*voxel_lattice_hex_mesh_remove_entities comps 2 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh end
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2103,*voxel_lattice_hex_mesh_renumber_to_grid_position,"Description
Renumbers the voxel  elements according to grid numbering.  Numbering starts from
        hm_max_element_id + 1 at the time of calling this command.
This must be preceeded by a call to *voxel_lattice_hex_mesh_init or
          *voxel_lattice_hex_mesh_create.
","Example
To create voxels of size 10 for include components 100-110, then remove components 200-203,
        then renumber:
*voxel_lattice_hex_mesh_init 10
*voxel_lattice_hex_mesh_fill_voids 0
*createmark comps 1 100-110
*voxel_lattice_hex_mesh_add_entities comps 1 1
*voxel_lattice_hex_mesh_create
*createmark comps 1 200-203
*voxel_lattice_hex_mesh_remove_entities comps 1 1
*voxel_lattice_hex_mesh_create
*voxel_lattice_hex_mesh_renumber_to_grid_position
*voxel_lattice_hex_mesh end
",,
2104,*wadlines_createspheres,"Description
Creates sphere surfaces for testing rear reference line of pedestrian impact.
","
Inputs


double_array
The double array ID that contains the 3D coordinates of the center of each sphere. The
            double array is created using the *createdoublearray command. This
            should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray. This should be 3 times the number of
            spheres.
radius
The radius of each sphere.

","Examples
To create 2 spheres with radius 82.5:
*createdoublearray 6 1431.92088 -727.229931 1025.94747 1430.19016 -722.93938 1025.89459  
*wadlines_createspheres 1 6 82.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2105,*walldisplay ,"Description
Displays a wall. 
","Inputs

blockname
The name of the block which contains the wall. 
function
The function to be performed. 
wallname
The name of the wall.  

","Errors
None.
",
2106,*wind_tunnel_mesh,"Description
Generates a hex mesh for the far-field, a tetra mesh for the interface clearance, and a 3D
        boundary-layer mesh on the body.
","Inputs

mark_id
The ID of the mark containing the body components. Valid values are 1 and 2.
elem_size
The target far-field hex element size.
interface_clearance
Clearance value from body. The tetra mesh will be generated to the clearance
            volume.
front_space
Far-field front space from body.
rear_space
Far-field rear space from body.
side_space
Far-field side space from body.
top_space
Far-field top space from body.
string_array
The ID of the string array that contains the additional meshing parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Mesh parameters are available for the 3D boundary layer for the body, as well as the
            3D boundary layer for the bottom side hex mesh. Valid parameters and their syntax are: 
tet_bl_param: <first layer thickness> <growth rate> <number of boundary
            layers> 
bottom_bl_param: <first layer thickness> <growth rate> <number of boundary
            layers>
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Example
To generate a wind tunnel mesh using all components for the body, a hex size of 10.0, an
        interface clearance of 20, a far-field size of 300 (front)/400 (rear)/200 (side)/200 (top),
        and specific boundary layer meshing parameters:
*createstringarray 2 ""tet_bl_param: 11 0.01 1.2"" ""bottom_bl_param: 5 0.1 1.3""
*createmark components 1 all
*wind_tunnel_mesh 1 10.0 20.0 300 400 200 200 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2107,*window_entitymark,"Description
Fits the view to the entities on the mark.
","
Inputs



entity_type

The type of entity to fit.

mark_id

The ID of the mark of entities to fit.  Valid values are 1 and 2.

","Examples
To fit the view to elements 1-10:
*createmark elems 1 1-10
*window_entitymark elems 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2108,*writefile,"Description
This command saves a binary HyperMesh database.
","Inputs

filename
The full path and filename of the database to save. If this file already exists,
              HyperMesh will prompt to overwrite the file. 
When running in batch mode, *answer (for .cmf
            files) or hm_answernext (for Tcl scripts) must be
            used to specify a yes/no answer to this command when the file already exists.
do_not_write_facets
0 - Geometry facets are written to the file, leading to a larger file but faster load
            time. 
1 - Geometry facets are written to the file, leading to a larger file but faster load
            time. 
2 - Geometry facets are not written to the file, leading to a smaller file but longer
            load time. 

","Examples
To save the model to a file named mymodel.hm in the current working directory:
*writefile mymodel.hm 0
To save the model to a file named C:/mymodel.hm:
*writefile C:/mymodel.hm 0
To overwrite an existing file named C:/mymodel.hm:
hm_answernext yes
*writefile C:/mymodel.hm 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2109,*writemodelcheckresultfile,"Description
Writes out model check results to a file.
","
Inputs



filename

The full path and name of the file to write.  By default it will be given a .txt
            extention if not specified.

filetype

0 or 1 - Only the failed count associated with the checks is written out
2 - Entity type, failed count and count of entities in the model are written against
            the check
3 - Along with the above information, the time taken to run each check is also written
            out
4 - A detailed CSV report with entity type, run status, failed count, comments and
            failed entity IDs against each check is generated
5 - Writes out failed count against only failed checks flagged under user status
            column

","Examples
To write results to the file C:/temp/check_results.txt  
*writemodelcheckresultfile C:/temp/check_resutls.txt 1 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2110,*writeqiviewsettings ,"Description
This command is related to the element quality view mode. It writes the current element
        quality view settings to a text file that can be read by
          *readqiviewsettings.
","Inputs

flag
The full name and path of the file to save the QI view settings.

","Example
To save the current settings to the file C:/settings/qiview.txt:
*writeqiviewsettings ""C:/settings/qiview.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2111,*xelem_bynodelist,"Description
Creates a new element(/XELEM) of config 27 and type 1 using a node list..  This is
        currently only supported for Radioss.
","
Inputs



node_list_id

The ID of the ordered node list to use to create the element.  There must be at least
            2 nodes in the list.  Valid values are 1 and 2.

node_distance

The distance at which intermediate nodes are to be created.  This also creates a node
            set from the new nodes.

","Examples
Create a xelem element with nodes 1, 10, 20 and node distance as 2:
*createlist nodes 1 1 10 20
*xelem_bynodelist 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2112,*xyplotchangemode ,"Description
Changes the mode of an extended plot. 
","Inputs

plotname
Name of the extended (dual) plot to change. 
mode
New mode value (2 or 5).

","Example
*xyplotchangemode(""results"", 5)
Extended (or dual) plots can display data in two modes. In complex mode,
          (mode=2), the Y-axis of the bottom plot is the real component, while
        the Y-axis of the top plot is the imaginary component. In phase/magnitude mode
          (mode=5), the Y-axis of the bottom plot is magnitude (in logarithmic
        form), while the Y-axis of the top plot is phase. Other mode indices (besides 2 and 5) are
        reserved for future use.
","Errors
None.
"
2113,*xyplotcreate,"Description
Creates an xy plot. 
","Inputs

plot name
 The name of the plot to be created. 
like plot
The name of the plot from which the new plot should get its default values. 

","Errors
None.
",
2114,*xyplotcreatecomplex ,"Description
Creates an extended or dual plot that contains two sub-plots. 
","Inputs

plot name
The name of the plot to be created. 

","Errors
None.
",
2115,*xyplotcurvemodify ,"Description
Modifies a curve. 
","Inputs

curve name
The name of the curve being modified. 
item name
The name of the item of data being modified. 
string
The string value of the item. 
value
The value of the item. 
plot
A logical which determines if the current xy plot should be replotted when the change
            is made to the curve

","Errors
None.
",
2116,*xyplotdraw,"Description
Draws an xy plot. 
","Inputs

plot name
The name of the xy plot to be replotted. 

","Errors
None.
",
2117,*xyplotfindcurves ,"Description
Resizes the xy plot window so that the curves on the xy plot are fully visible. 
","Inputs

plot name
The name of the plot to be modified. 

","Errors
None.
",
2118,*xyplotonecurvemath,"Description
Performs a math function on a curve. 
","Inputs

function
The function being performed. 
outputname
The name of the output curve. 
xbased
1 - If the function should work on the x coordinate.
0 - If the function should work on the y coordinate
factor
The factor to be used in the calculation.

","Errors
None.
",
2119,*xyplotpage ,"Description
Pages through the active xy plots making each plot the entire size of the screen, and then
        pausing until a mouse click. 
","Errors
None.
",,
2120,*xyplotpush ,"Description
Pushes an xy plot to the bottom level. 
","Inputs

plot name
The name of the plot to be pushed. 

","Errors
None.
",
2121,*xyplotreadengineeringcurve,"Description
Reads in stress/strain information for HyperForm.
","Inputs

filename
The full path and file name for the file containing the stress/strain
            information.

","Example
To read the file named C:/temp/curves.txt:
*xyplotreadengineeringcurve C:/temp/curves.txt
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2122,*xyplotregisterimporttemplate ,"Description
Registers an import template. 
","Inputs

filename 
The name of your template file. 

","Errors
None.
",
2123,*xyplotsetcurve,"Description
Sets the current curve.
","Inputs

curve name
The name of the current curve. 

","Errors
None.
",
2124,*xyplotsetsecondcurve ,"Description
Sets the second curve to be used when performing mathematical functions on a curve. 
","Inputs

curvename 
The name of the curve. 

","Errors
None.
",
2125,*xyplottwocurvemath ,"Description
Performs a math function on two curves. 
","Inputs

function
The function to be performed. 
outputcurve
The name of the output curve
xbased
1 - If the function should operate on the x coordinate.
0 - If the function should operate on the y coordinate.



","Errors
None.
",
2126,*xyplotzoomout ,"Description
Modifies the window of an xy plot by zooming out (reducing the size of the curves). 
","Inputs

plot name
The name of the plot to be modified. 

","Errors
None.
",
2127,*compositeanalysis,"Description
Analyzes composite materials, plies, sequences or laminates.
","
Inputs


entity_type
The type of entity to modify.
<select_type>=<selection>
The entity or entities that are to be analyzed. There are several ways to provide the
            entities to be modified. Only one option can be used at a time:
id=<id>
The ID of the single entity to modify.
name=<name>
The name of the single entity to modify.
mark=<mark_id>
The ID of the mark containing the entities to modify.


result=<value>
The type of result. Valid values are:
23d-behavior - For material or ply analysis
25d-behavior - For sequence or laminate analysis
output=<value>
The file name of the output .csv file.

","Examples
To analyze material with ID 1:
*compositeanalysis mats id=1 result=23d-behavior output=C:/temp/result.csv
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2128,*hideall,"Description
Turns off the display of all entities.
","Example
To turn off the display of all entities:
*hideall
","Errors
None.
",
2129,*hideentitybymark,"Description
 Turns off the display of a mark of entities.
","Inputs

mark_id
The ID of the mark containing the entities. Valid values are 1 and 2. All entities with a display state on the specified mark,
            regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To hide geometry and elements for components 1-3:
*createmark comps 1 1-3
*hideentitybymark 1
To hide all comps and load collectors, considering only elements:
*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*hideentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2130,*hm_failed_elements_cleanup,"Description
Cleans up the mesh by eliminating reversed and small sized elements. May create new
        elements instead of reversed. 
","Inputs

markmask
Elements of the original mesh.
Elem_type
Determines the type of new elements: 
0 - trias 
1 - mixed type (quads and trias)
min_elemsize
Determines minimum element size of elements in the mesh after cleanup.
max_feature_angle
Determines mesh feature angle for keeping features when possible after cleanup.
max_reverse_angle
Determines maximum angle between adjacent element normals for reversed elements
            detection.

","Example
To eliminate elements in the displayed tria mesh with size less than 1.5, remove reversed
        elements with adjacent normals greater than 150 degrees, trying to keep features greater
        than 60 degrees:
*createmark(elements,1) displayed
*hm_failed_elements_cleanup(1, 0, 1.5, 60, 150)
The *createmark() command is required.
","Errors
None.
"
2131,*hm_trim_elements_with_predefined_box,"Description
Trims shell elements using a predefined box. Shell elements inside the box are kept with
        the elements along any cuts re-meshed. Solid elements with all nodes inside the box are
        kept, while all others are deleted.
","Inputs

mark_id
The ID of the mark containing the elements to cut. Valid values are 1 and 2.
cut_type
A predefined cut name. Valid values are left, right, front, rear, frontleft,
            frontright, rearleft or rearright.
limit
The x value of the box for cut types front, rear, frontleft, frontright, rearleft or
            rearright.
spc_collector_name
The name of the collector in which the SPCs will be created for constraining cut
            elements.
box_collector_name
The name of the collector in which a hexa might be created to show the cutbox.
remesh_params
The parameters of re-meshing along the cut, defined as ""keyword value"" format. 
For example: ""angle 30.0 min_elem_size_rate 0.6 comp_remainder_area_rate 1.0"" 
Valid keywords and values are:
angle
Values used to define feature edges on mesh. Default if not specified is
                  30.0.
min_elem_size_rate
Defines the minimum element size locally. The valid range is between 0.0 and
                  1.0. The minimum element size is calculated locally on the mesh area being
                  re-meshed. The element size is computed for the mesh area and the minimum element
                  size is then the product of min_elem_size_rate and the element
                  size of the area. 
min_elem_size_value
Defines the minimum element size globally.
comp_remainder_elem_numb
Defines the minimum number of elements in a component. After box trimming, any
                  component with an element count less than this value is deleted.
comp_remainder_area_rate
Define the limit of shell element area of components. After box trimming, any
                  component with element areas less than this percent of its original area is
                  deleted. The valid range of the value is between 0.0 and 100.0. 



","Example
To trim displayed elements using a left box, with limit of 50:
*createmark elements 1 ""displayed""
*hm_trim_elements_with_predefined_box 1 ""left"" 50.0 ""abc"" ""efg"" ""min_elem_size_rate 0.6 comp_remainder_elem_rate 0.01 angle 30.0""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2132,*hmmeshlinedrag,"Description
Within the automeshing module, generates quad or tria elements using a surfaceless
        algorithm. Can only be used with *surfacemode 3 and one of the
          *linedrag...toformsurface commands. 
","Inputs

quads 
If nonzero, specifies that the created elements should be quads. 

","Example
To drag the given nodes along lines 2 and 1, trimmed by nodes 29 and 30, and using the
        given plane, create 45 elements: 
*surfacemode 3
*createlist nodes 1 5 9 1 15 18 39
*createlist lines 2 2 1
*createlist nodes 2 29 30
*createplane 1 0.0000 0.0000 1.0000 0.0000 0.0000 100.0000
*linedragnodestoformsurface 1 2 2 1
*set_meshedgeparams 0 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 9.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 9.0 0 0 0 0 0 0 0
*hmmeshlinedrag 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
2133,*hmshrinkwrap,"Description
The shrink wrap function allows a complex FE model to be simplified quickly into an
        approximation of the original FE representation. The capability works by removing and
        blending out features of the original part to remove complexity.
","Inputs

entity_type
Supported types are comps and elems.
entity_markId
Mark of input components or elements.
elems_markId
Mark of feature elements. Should be different from entity_markId. Considered for tight
            wrap only.
wrap_type
1 = Loose wrap mesh. 
2 = Tight wrap mesh.
elem_size
Element size for shrink wrap meshing.
warpage_value
Warpage value, above which the shrink wrap elements will be split. Enabled for tight
            wrap mesh only. 
-1 value will ignore splitting of elements in tight wrap mode. 

","Example
To loose wrap displayed elements with an element size of 2:
*createmark elems 1 ""displayed""
*createmark elems 2 
*hmshrinkwrap elems 1 2 1 2 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2134,*includesuppressactive,"Description
This command sets the active/inactive state of all supported entities contained within the
        include file (but not the include file itself) with include_id and
          include_shortname. Only one of these two options need to be specified,
        however include_id will take precedence if specified. Double quotes """"
        must be used for an argument that is not specified.
Include files do not have an active/inactive state, only the entities contained within
        them. 
","Inputs


include_id


include_shortname


state
The state argument indicates the active/inactive status for the
              supported entities contained in the include. 
0 - Indicates to set the entities to active and turn on their display.
1 - Indicates to set the entities to inactive and remove them from the display. 
2 - Indicates to set the entities to active but not to re-display them.




","Example
To set all supported entities contained within include file ID 5 to active and
        re-display:
*includesuppressactive 5 """" 0
To set all supported entities contained within include file shortname include
          .txt to inactive:
*includesuppressactive """" include.txt 1
To set all supported entities contained within include file ID 5 to active and not
        re-display:
*includesuppressactive 5 """" 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2135,*inputsimulation,"Description
Sets the current simulation and data type for contour and assigned plots, vector plots, and
        animations. The results file must be loaded before executing this command.
","Inputs

simulation
The name of the simulation contained in the results file.
data_type
The name of the data type for the simulation.

","Example
To load the result file named C:/my_results/test.res and generate a
        rendered animation for Subcase 1 with Displacements data type, using a 10.0 model unit
        scaling:
*analysisfileset C:/my_results/test.res
*inputsimulation ""Subcase 1"" ""Displacements""
*animatemodal """" 10.0 4 0
*freesimulation
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2136,*interactivemeshsurf,"Description
Brings a surface into the automeshing module and prepares it for processing, enabling the
        use of all the restricted module commands.
","Inputs

markmask
The surfaces to be meshed. 
elementsize
The default element edge size used to calculate element densities along the edges
            (where necessary). 
elem_type
Flag indicating the elements generated for mapped meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


elem_type_2
Flag indicating the elements generated for free meshing algorithms. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


forcing
If nonzero, any saved surface parameters generated previously with the automesher are
            ignored.
size_control
Determines if uniform size elements in mapping algorithms should be created. 
1 = yes 
0 = no


skew_control
Determines if optimal shape elements in mapping algorithms should be created. 
1 = yes 
0 = no



","Example
In this example, the automeshing module processes a surface with four faces and ten edges.
        To generate a mesh for each face, the module sets up values for element densities and
        biasing with the *set_meshedgeparams command. Automeshing parameters for
        each face are specified with the *set_meshfaceparams command. Each face
        is sent to the *automesh command so it can determine the appropriate
        meshing algorithm and create an all-quads mesh. You then direct HyperMesh to smooth the meshes for ten iterations each. Next, the mesh
        for face two is rejected and a new mesh is created with slightly different element
        densities. The four meshes are saved to the HyperMesh database.
        The automeshing module clears from its memory any information regarding the current surface
        so that a new surface can be processed.
*surfacemode 1
*createmark surfaces 1 1
*interactivemeshsurf 1 1 1 1 1 0 0
*set_meshedgeparams 0 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 1 6.0 0 0 0 0 0 0 0
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
*automesh 0 1 1
*set_meshedgeparams 2 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 3 4.0 0 0 0 0 0 0 0
*set_meshedgeparams 4 4.0 0 0 0 0 0 0 0
*set_meshfaceparams 1 1 1 0 0 0 0.1 0 0
*automesh 1 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 2 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 9 2.0 0 0 0 0 0 0 0
*set_meshedgeparams 10 7.0 0 0 2 0 0 0 0
*set_meshedgeparams 11 3.0 0 0 0 0 0 0 0
*set_meshfaceparams 3 1 1 0 0 0 0.1 0 0
*automesh 3 1 1
*smoothelements 0 1 10
*smoothelements 1 1 10
*smoothelements 2 1 10
*smoothelements 3 1 10
*rejectmesh 2
*set_meshedgeparams 8 6.0 0 0 -2 0 0 0 0
*set_meshedgeparams 5 3.0 0 0 0 0 0 0 0
*set_meshedgeparams 6 5.0 0 0 0 0 0 0 0
*set_meshedgeparams 7 8.0 0 0 0 0 0 0 0
*set_meshfaceparams 2 1 1 0 0 0 0.1 0 0
*automesh 2 1 1
*storemeshtodatabase 0
*ameshclearsurface()
","Errors
None.
"
2137,*isolateonlyentitybymark,"Description
 Turns on the display of a mark of entities and turns off the display of all others across
        types.
","Inputs

mark_id
The ID of the mark containing the entities. Valid values are 1 and 2. All entities with a display state on the specified mark,
            regardless of entity type, are considered.
string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
            *createstringarray. The valid strings are:
elements_off
This indicates that elements in the specified collectors should not be
                  considered. If not provided, the default is to consider elements in the specified
                  collectors.
geometry_off
This indicates that geometry in the specified collectors should not be
                  considered. If not provided, the default is to consider geometry in the specified
                  collectors.
showcomps
This indicates that components in which elements/geometry are referred will also
                  be shown when you show elements/geometry. If not provided, only specified
                  elements/geometry are shown.



","Examples
To isolate only geometry and elements for components 1-3:
*createmark comps 1 1-3
*isolateonlyentitybymark 1
To isolate only all comps and load collectors, considering only elements:
*createmark comps 1 all
*createmark loadcols 1 all
*createstringarray 2 geometry_off
*isolateonlyentitybymark 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2138,*jointelement_sixnoded,"Description
Creates a six-noded joint element.
","Inputs

type
The type of the element (6 or 7 ONLY)
n1, n2, n3, n4, n5, n6
The six nodes of the element.
orientation
Orientation option for the element. Use:
0 - None 
1 - Systems


system1
The orientation systems’ IDs for the element.
property
The property to which the element points.

","Example
To create a six-noded joint element:
*jointelement_sixnoded(7,464,457,456,455,463,462,1,1596,1592,"""")

","Errors
None.
"
2139,*jpegfilenamed,"Description
Captures the graphics area to a JPEG image with the specified name. 
The color and background settings can be specified using the
          *graphicsfilecolor and *graphicscolorblankbackground
        commands.
","Inputs

filename
The full path and file name of the image.

","Example
To capture the graphics area to a JPEG image named
          ""C:/my_images/model.jpg"":
*jpegfilenamed ""C:/my_images/model.jpg""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2140,*legendcolorsmooth,"Description
Performs linear interpolation between two colors. 
","Inputs

color1
The first color. 
color2
The second color. 

","Example
To smooth the colors between color 1 and color 7: 
*legendcolorsmooth(1,7)
","Errors
None.
"
2141,*legendlocate,"Description
Moves the legend to its default location (upper left corner). 
","Errors
None.
",,
2142,*legendon,"Description
Controls the display of the legend.
","Inputs

on
1 for on, 0 for off.

","Example
*legendon(0)
HyperMesh displays the legend by default. If you display the
        legend, the simulation title is also displayed.
","Errors
None.
"
2143,*legendsetbordercolor,"Description
Specifies the legend border and text color from both the hm.cfg file and a command file.
      
","Inputs

color 
The color used to specify the legend border and text color. Color must be between 1
            and 64, inclusively. 

","Errors
None.
",
2144,*linearsolids,"Description
Creates solid elements between two groups of plate elements. 
","Inputs

mark1
The ID of the mark containing the first group of plate elements. 
mark2
The ID of the mark containing the second group of plate elements. 
align1
The ID of the node to be used as an alignment node for the first group of elements.
          
align2
The ID of the node to be used as an alignment node for the first group of elements.
          
align3
The ID of the node to be used as an alignment node for the first group of elements.
          
align4
The ID of the node to be used as an alignment node for the second group of elements.
          
align5
The ID of the node to be used as an alignment node for the second group of elements.
          
align6
The ID of the node to be used as an alignment node for the second group of elements.
          
number
The number of solid elements to be created between the two groups of plate elements.
          
biasstyle
The type of biasing to use.
 biasing
The biasing factor for the mesh.

","Example
To create 8 solids between plates 10, 11, 12, 13 and 20, 21, 22, 23, with alignment node 1
        being node 5 and alignment node 2 being node 6: 
*createmark(element,1) 10 11 12 13
*createmark(element,2) 20 21 22 23
*linearsolids(1,2,5,0,0,6,0,0,8)

*createmark() is required and the marks used must contain plate
        elements. 
","Errors
None.
"
2145,*linearsurfacebetweennodesandline,"Description
Creates a ruled surface between a node list and a trimmed line list, and optionally,
        prepares it for immediate use within the automesher. It can also identify a region in the
        shape of a ruled surface for the automesher to use under the mesh without surface
        option.
","Inputs

list1
The ID of the list of nodes forming one side of the surface. 
linelist1
The ID of the list of lines forming one side of the surface. 
endpoints
The list ID of the list of zero or two nodes which lie on the lines in the line list
            which will be used to trim the line during surface creation. 
reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
This example creates a ruled surface and brings it into the automesher, creates 16 quad
        elements, and stores the elements to the HyperMesh database: 
*surfacemode 1
*createlist nodes 1 160 161 164 168 172
*createlist lines 1 1
*linearsurfacebetweennodesandline 1 1 2 1
*set_meshedgeparams 0 4 1 0 0 0 0 0 0
*set_meshedgeparams 1 4 1 0 0 0 0 0 0
*set_meshedgeparams 2 4 1 0 0 0 0 0 0
*set_meshedgeparams 3 4 1 0 0 0 0 0 0
*set_meshfaceparams 0 1 2 0 0 0 0.1 0 0
*automesh 0 1 1
*storemeshtodatabase 0
*ameshclearsurface
","Errors
None.
"
2146,*linecreatefromnodes,"Description
This command creates a line which passes through a list of nodes.
","Inputs

list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
type
The type of line to generate. Valid values are:
0 - Linear 
1 - Standard 
2 - Smooth 
3 - User controlled, values of break_angle,
              aspect and linear_angle are used.
Adding 8 to any of the values above will create a closed line of that type.
break_angle
Specifies the minimum angle allowed between three points in a line. If the angle
            between a point and the two adjacent points is less than the angle specified, HyperMesh considers this point to be a point of discontinuity in
            the line and places a joint (starts a new NURBS) at this location.  Valid only for
              type 3.
aspect
Specifies the maximum ratio allowed for the distance between a point and the previous
            point in the line and the distance between the same point and the next point in the
            line. If the ratio of the distance between the two adjacent segments exceeds the aspect
            ratio defined, HyperMesh places a joint between the
            segments. Valid only for type 3.
linear_angle
Defines the angle at which HyperMesh should consider a
            line straight. For example, if the line angle between three consecutive points along the
            line is greater than the linear angle specified, HyperMesh
            removes the center point from the line. Valid only for type 3.

","Example
To create a smooth line that passes through nodes 1-4:
*createlist nodes 1 1 2 3 4
*linecreatefromnodes 1 2 0.0 0.0 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2147,*linecreatefromnodesonsurface,"Description
This command creates a line that lines on a surface by interpolating input points on that
        surface. If some of the input points do not reside on the same surface, then the location
        closest to those points on the surface point are used.
","Inputs

surf_type
Input surface type. Valid values are surfs of faces.
surf_id
Input surface ID value.
point_type
Type of entities representing input points. Valid values are nodes or points.
point_list
List ID of the input points or nodes. A minimum of 2 points or nodes must be
            selected.
curve_type
Type of created curve. Valid values are: 
0 - Points are connected by linear segments. 
1 - Points are connected by linear segments into closed line. 
2 - Points are interpolated by a smooth curve. 
3 - Points are interpolated by a smooth closed curve.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).


Bit0
Additional curve construction option. Valid values are:
0 - Curve is created as free line. 
1 - Created curve is used to trim input surface.




Bit1
Specifies how entities are organized into components. Used only when Bit0 is set
                  as 0. Valid values are:
0 - Line is created in the current component. 
1 - Line is created in the surface component.





","Example
To create a spline that interpolates nodes 11, 12 and 13 on surface 10:
*createlist nodes 1 11 12 13
*linecreatefromnodesonsurface surfs 10 nodes 1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2148,*linecreatenurbs,"Description
This command creates a generic NURBS type line using input parameters.
","Inputs

degree
Polynomial degree of the created line.
dimension
Dimension of created line. Valid values are:
2  - Planar line
3 - 3-dimensional line


knot_count
Number of knot values. See Comments section.
pole_count
Number of NURBS control points/poles.
ratnl
Parameter that specifies whether weights are used in addition to control points. Valid
            values are: 
0 - Use weights 
1 - Do not use weights
double_array
The ID of the double array that contains the value of the knots, control points and
            weights (if ratnl is 1). The double array is created using the
              *createdoublearray command. This should always be set to 1.
number_of_doubles
Integer indicating the size (number of doubles) in the double array created using
              *createdoublearray.

To reduce input, the usual NURBS convention that for the curve with polynomial degree first
        and last degree+1 knots must have the same value is enforced internally. Input for this
        command should only contain one value. For all internal knot values, multiplicity should
        still be provided explicitly. All knot values must be provided in non-decreasing order.
","Examples
To create a planar line segment connecting points (0,0) and (1,1):
*createdoublearray 6 0 1 0 0 1 1
*linecreatenurbs 1 2 2 2 0 1 6
To create a 90 degree arc starting at (0,0) and ending at (2.0):
*createdoublearray 11 0 1 0 0 1 1 2 0 1 0.7071067811 1
*linecreatenurbs 2 2 2 3 1 1 11

To create a 180 degree arc:
*createdoublearray 19 0 1 1 2 0 0 1 1 2 0 3 -1 2 -2 1 0.707106 1 0.707106 1
*linecreatenurbs 2 2 4 5 1 1 19
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2149,*linecreatestraight,"Description
This command creates a straight segment line between the given input end point coordinates.
        The distance between the input points must be not smaller than the global value of the
        geometry cleanup tolerance set by *setoption cleanup_tolerance.
","Inputs

x1 y1 z1
Coordinates of segment start point.
x2 y2 z2
Coordinates of segment end point.

","Example
To create straight segment with endpoints (1, 2, 3) and (4, 5, 6):
*linecreatestraight 1 2 3 4 5 6
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2150,*lineeditlength,"Description
This command is applied to a single free line to change its length. If a closed line is
        selected, one can only make its new length shorter. If the new length is chosen to be less
        than 1 tenth of the cleanup tolerance of the model, the line is deleted to avoid creating
        lines that are too short to be compatible with the model tolerance.
","Inputs

id
The ID of the free line to edit.
length
The new length of the line. 
If a closed line is selected, one can only make its new length shorter. 
If the new length is chosen to be less than 1 tenth of the cleanup tolerance of the
            model, the line is deleted to avoid creating lines that are too short to be compatible
            with the model tolerance. 
A negative length is interpreted as first making the length of the line 0.0, in the
            direction given, and the extending in the opposite direction with the absolute value of
            the given length.
derivative
This option is used only when the new length is longer than the current length of the
            line. 
1 - A straight line extension is made that is tangent to the line 
2 - The extension follows the curvature of the line as well
direction
1 - The change is made at the end point of the line, considering 0.0 length as the
            start point of the line. 
-1 - The change is made at the start point of the line, that is in the reverse
            direction to the direction of the line. 

","Example
Edit the length of line 1142, so that its new length is 80.0. If the line is made longer by
        this change, the extension is made only tangentially. The change is made at the start point
        of line:
*lineeditlength 1142 80.0 1 -1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2151,*lineextendtopoint,"Description
Extends the specified line to a point.
","Inputs

line
The ID of the line to extend.
point
The ID of the point to which the line is extended.
capture_radius
If the point at the end of the extension is within the
              capture_radius of the point, then force the end point to have the
            same coordinates as the point.
derivative
1 - Extend the tangent to the line 
2 - Extend following the curvature of the line
direction
1 - Extend the end of the line 
-1 - Extend the beginning of the line

","Errors
None.
",
2152,*linemesh_preparenodeslist1,"Description
Prepares the selected node list for 1D meshing. 
Each call to this command must be paired with a call to
          *linemesh_savedata1 or *linemesh_savedata_bar1 to
        clean up memory.
","Inputs

list_id
The ID of the list containing the nodes. Valid values are 1 and 2.
config
If configuration of the element to create. Only 1D configs are valid.

","Example
To mesh between nodes 16, 17, and 2 with 3 rigid elements between nodes 16 and 17 and with
        2 rigid elements between nodes 17 and 2, with no property assignment:
*createlist nodes 1 16 17 2
*linemesh_preparenodeslist1 1
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
","Errors
None.
"
2153,*linemesh_saveparameters,"Description
Assigns meshing parameters to line or node list segments for 1D meshing. 
Each call to this command must be paired with a call to
          *linemesh_preparedata1 or
          *linemesh_preparenodeslist1.
","Inputs

segment
The ID of the segment within the line or node list selection. This index is 0
            based.
density
The element density to use for that segment.
bias
The biasing value of the element length to use along the given segment.
bias_style
The style of biasing to use. Valid values are: 
0 - linear 
1 - exponential 
2 - bell curve

","Example
To mesh lines 15 and 18 with a 30 degree break angle, with 3 elements in the first segment,
        and 2 elements in the second segment, creating rigid elements with no property:
*createmark lines 1 15 18
*linemesh_preparedata1 lines 1 30 5
*linemesh_saveparameters 0 3 0 0
*linemesh_saveparameters 1 2 0 0
*linemesh_savedata1 1 5 0 0
","Errors
None.
"
2154,*lines_approximate,"Description
 Simplifies curved free lines.
","Inputs

mark_id
The ID of the mark containing the free lines. Valid values are 1 and 2.
type
1 - Each curved line will be replaced with a parabola (2nd degree) that has the same
            end points as the line, and is closest to it. 
2 - Each curved line will be simplified by removal of all internal knots but one
            (known as Bezier simplification).
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To simplify lines 1 and 2 using Bezier simplification:
*createmark lines 1 1 2
*lines_approximate 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2155,*linescreatemidline,"Description
Creates a line that approximates the middle path between two roughly parallel, roughly
        planar, lines.
","Inputs

linelist1
The ID of a list of lines forming one side of the path.
trimnodelist1
The ID of a list of 0 or 2 nodes that mark the endpoints to use to trim the lines
              in linelist1.
linelist2
The ID of a list of lines forming the other side of the path.
trimnodelist2
The ID of a list of 0 or 2 nodes that mark the endpoints to use to trim the lines
              in linelist2.

","Example
The four *createlist() directives are required for this command. 
To create a midline between lines 22 and 23:
*createlist(lines,1) 22
*createlist(nodes,1)
*createlist(lines,2) 23
*createlist(nodes,2)
*linescreatemidline(1,1,2,2)
","Errors
None.
"
2156,*linessmoothtoangle,"Description
 Smooths a line based on a give angle. 
","Inputs

mark 
The ID of the mark containing the lines to smooth.
cosangle
The cosine of the angle used to determine if two joints on a line should be combined
            (smoothed). If the angle between two joints on a line is greater than the angle the two
            joints are combined and smoothed.

","Example
To smooth all joints on line 1 that have an angle greater than 90 degrees:
*createmark(lines,1) 1
*linessmoothtoangle(1,0)
","Errors
None.
"
2157,*loadcreatewithsystemonentity,"Description
Creates a load (forces, temperature, moment, velocity, acceleration, or constraints) on
        nodes, fixed points (surface vertices or weld points), surface edges, and surfaces, defined
        in a local coordinate system.
","Inputs

geomtype
the type of entity that the load is applied to (e.g. SURFS)
markmask
the entity ID
config
the load configuration
type
Solver dependent types of the referenced load config. 
1 force 
2 moment 
3 constraint 
4 pressure 
5 temperature 
6 nodal flux 
8 velocity 
9 acceleration
 component[1-6]
components of the load being applied. 
When applying a force, the active components are 1, 2, and 3, which represent a force
            x, y, and z-axis, respectively. 
When applying a moment, the active components are also 1, 2, and 3, and represent the
            moment about the x, y, and z-axis, respectively. 
For constraints, all of the components are active unless they are set equal to
            -999999.0.  All the other components of the constraints are active in the respective
            directions. 
For pressures, the active components are 1, 2, and 3, which represent the x, y, and
            z-axis, respectively.  To create a pressure that is normal to the element, set all
            components to zero.
system
the ID of the local system to use
transformflag
Indicates which system supplies component values. 
0 - if the component values are supplied in the global coordinate system. 
1 - if the component values are supplied in the local coordinate system

","Example
To apply a force of magnitude 10.0 along the x axis of system 4 to nodes 5 and 25:
*createmark(nodes,1) 12 13 14
*loadcreatewithsystemonentity(nodes,1,1,3,0.0,999999.0,0.0,-999999.0,0.0,   -999999.0, 4,0)
This command is applicable only to files created with HyperMesh
        6.0 and higher. For older HyperMesh files, use
          *loadcreate() instead.
","Errors
None.
"
2158,*loadsettypes,"Description
Sets the global load type variable. 
","Inputs

mark
The mark which contains the loads to be updated.
entities
The type of load to change.

","Example
To set all of the displayed forces to type 5, and all of the displayed moments to type 6:
*loadtype (1,5)
 sets new Forces (1) to type 5 but doesn’t change existing ones 
*loadtype (2,6)
sets new Moments (2) to type 6 (doesn’t change existing ones)
*createmark(loads,1) displayed
places all existing displayed loads into Mark1
*loadsettypes(1)
changes all the entities in Mark1 to use the types already defined for Forces (5)
              and Moments (6)


","Errors
None.
"
2159,*loadsupdatecurve,"Description
Updates the magnitude, direction, coordinate system, and other information of selected
        loads.
","Inputs

markmask
ID of the mark containing the loads to update.
config
The configuration of the load: 
1 - Force 
2 - Moment 
3 - Constraints 
5 - Temperature 
6 - Flux 
8 - Velocity 
9 - Acceleration
type
The type assigned to the load (as defined on the ""load types"" panel).
updatevector
A variable that controls if the direction of the load should be updated.
component[1-6]
Components of the load being applied. When applying a force, the active components are
            1, 2, and 3, which represent a force x, y, and z-axis, respectively. When applying a
            moment, the active components are also 1, 2, and 3, and represent the moment about the
            x, y, and z-axis, respectively. For constraints, all of the components are active unless
            they are set equal to -999999.0. All of the other components of the constraints are
            active in the respective directions. For pressures, the active components are 1, 2, and
            3, which represent the x, y, and z-axis, respectively. To create a pressure that is
            normal to the element, set all components to zero.
updatemag
An integer variable that controls if the magnitude is updated.
magnitude
The new value of magnitude of the load.
update_system
A variable that controls if the system is updated.
system_id
The ID of the local system.
transform_flag
A simple integer variable that controls if the load is created in the local
            system.
updatecurve
A flag to indicate whether the curve should be updated (0=no, 1=yes).
curve_id
The ID of the new curve to use.
updatexscale
A flag to indicate whether the curve’s scale factor should be updated.
0 - No
1 - Yes


xscale
The new value to use for scale factor.
updatedisplaylocation
A flag to indicate whether the curve’s display location should be updated.
0 - No
1 - Yes


xlocation, ylocation, zlocation
The new display location (used only if updatedisplaylocation
            =1)

","Example
Example to update a force to use the curve with ID 7 to define its time-varying
        magnitude:
*createmark(loads,1)  4
*loadsupdatecurve(1,1,1, 0, 0,0,0,0,0,0, 0,0, 0,0,0, 1,7, 0,0, 0,0,0,0)
","Errors
None.
"
2160,*loadtype,"Description
Sets the load types to the current global value. 
","Inputs

config
The load configuration that is to have its type changed. 
type
The type which the configuration should become. 

","Example
To set the type of forces to 2: 
*loadtype(1,2)
After the type has been set, all loads of the corresponding configuration are set to the
        value of type. 
","Errors
None.
"
2161,*maploadtomesh,"Description
Creates loads on an FE mesh that correspond to a load on the underlying geometry. 
","Inputs

markmask
ID of the entity.

","Example
To create temperature loads on an FE mesh that corresponds to the given geometry load
*createmark(loadcols,1) ""m""
*maploadtomesh(1)
This command is applicable only from HyperMesh 6.0 onwards.
","Errors
None.
"
2162,*markdifference,"Description
This command determines the difference between the entity IDs that exist on
          mark_idA on those on mark_idB. The results are then
        placed on mark_idA.
Both entity_typeA and entity_typeB must be the
        same.
","Example
To delete the difference between the elements on marks 1 and 2:
*createmark elems 1 1 2 3 4
*createmark elems 2 4 5 6 7
*markdifference elems 1 elems 2
*deletemark elems 1
This will delete elements 1, 2, and 3. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
2163,*markintersection,"Description
This command determines the intersection between the entity IDs that exist on
          mark_idA on those on mark_idB. The results are then
        placed on mark_idA. 
Both entity_typeA and entity_typeB must be the
        same.
","Example
To delete the intersection between the elements on marks 1 and 2:
*createmark elems 1 1 2 3 4
*createmark elems 2 4 5 6 7
*markintersection elems 1 elems 2
*deletemark elems 1
This will delete element 4. 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
",
2164,*markmovetoincludewithcontents,"Description
This command organizes entities into an include file.
","Inputs

entity_type
The type of entity to organize. Valid values are comps, groups, loadcols, vectorcols,
            systcols, beamsectcols and multibodies.
mark_id
The ID of the mark containing the entities to organize. Valid values are 1 and 2.
include_id
The ID of the include file to organize the entities into.
child_entity_types
The type/types of the child entities to organize. Multiple types can be specified at a
            time. 

","Example
To move system collector systcol1 along with all of its systems into include file number 2: 
*createmark systcols 1 systcol1
*markmovetoincludewithcontents systcols 1 2 ""systems""
To move component comp1 along with all of its nodes and elements into include file number
        2: 
*createmark comps 1 comp2
*markmovetoincludewithcontents comps 1 2 ""nodes elements""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2165,*markprojectnormallytoline,"Description
Projects entities to the line, using the normal to the line as the direction vector.
","Inputs

entities
The type of entity contained on the mark.
mark
The ID of the mark.
projectlinelist
The ID of the list of lines to which the entities are projected.
projectnodelist
The ID of the list of nodes that are on the lines in the projectlinelist. The nodes
            are used to trim the line during projection.

","Errors
None.
",
2166,*maskentitiesincollector,"Description
This command masks the entities contained within the collectors of
          entity_type that are on mark_id. Valid
          mark_ids are 1 and 2. Only entities in displayed collectors may be
        masked.
The six flag arguments indicate the type of entities to mask within the
        specified collectors. If the flag is set to 1, that entity is masked. If the flag is set to
        0, that entity is not modified. See the list below for the currently supported
          entity_types and flags.
","Inputs

comps
flag_1: elements 
flag_2: points 
flag_3: lines 
flag_4: surfaces 
flag_5: solids 
flag_6: connectors
groups
flag_1: master elements 
flag_2: slave elements 
flag_3: flag_6 are not used
loadcols
flag_1: loads 
flag_2: equations 
flag_3: flag_6 are not used
multibodies
flag_1: ellipsoids 
flag_2: mbjoints 
flag_2: mbplanes 
flag_4 through flag_6 are not used

","Example
To mask all of the points and surfaces in the displayed components:
*createmark components 1 displayed
*maskentitiesincollector comps 1 0 1 0 1 0 0
To mask all ellipsoids and mbjoints in all multibodies:
*createmark multibodies 2 all
*maskentitiesincollector multibodies 2 1 1 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2167,*maskreverseall,"Description
Reverses the masking state of supported entities. For collected entities, only entities in
        displayed collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 
tags 
domains 
handles 
morphconstraints 
morphvolumes 
shapes 
symmetries


","Example
To reverse the masking of all supported entities in the displayed collectors:
*maskreverseall
","Errors
None.
",
2168,*mbplanecreate,"Description
 Creates a new mbplane entity.
","Inputs

name
The name of the mbplane.
color
The color value of the mbplane.
type
The MADYMO type definition to be used later.
origin
The center node for the mbplane.
xaxis
The xaxis node for the mbplane.
yaxis
The yaxis node for the mbplane.
multibodyid
The ID of the multibody to which the mbplane is attached.

","Errors
None.
",
2169,*ME_ModuleExport,"Description
Exports the contents of a module to an ASCII export file
        based on an output template.
","Inputs

id
The ID of the part or part assembly to export.
recursive
Specifies option for whether the module hierarchy should be traversed recursively to
            identify all of the entities to be exported. 
If set to 0, only the entities from the specified module will be exported. 
If 1 (or any non-zero), the entities from the specified module and all of its child
            modules will be exported.
filename
The full path and filename of the output file. Paths with spaces must be enclosed in
            quotes.
export_template
The full path and filename of the export template to be used. Paths with spaces must
            be enclosed in quotes.
string_array
The ID of the string array that contains the additional output parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. The valid strings are documented as subtopics
            to *feoutputwithdata. Not all templates support all strings.

","Example
To output using the OptiStruct template, to a file named
          C:/model.fem for all entities in part with ID 10:
*ME_ModuleExport 10 0 ""C:/model.fem"" [hm_info -appinfo SPECIFIEDPATH TEMPLATES_DIR]/feoutput/optistruct/optistruct"" 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2170,*ME_ModuleOccurrenceCreate,"Description
 Creates a module part or part assembly.
","Inputs

name
The name of the module to create.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
parent_id=<id>
The ID of the module part or part assembly you wish to make this module a child
                  of. If not specified, the new module is placed underneath the root model
                  module.
structural_type=<type>
part or assembly. A part is the default if not specified, and can coverts to a
                  part assembly. A part assembly cannot be converted to a part.
udm_id=<string>
The string ID from a UDM XML file for this part, if necessary.



","Example
Create a new Part module named ""mypartname"" as a child of the module with ID 2:
*ME_ModuleOccurrenceCreate mypartname ""parent_id=2, structural_type=part""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2171,*ME_ModuleOccurrencePurge,"Description
Empty the contents of a module part or part assembly.
","Inputs

id
The ID of the module to purge. The module must be an occurrence.
options (optional)
List of input options, passed as a comma separated string enclosed in quotes. Valid
            options are:
excluded_entity_types=type1 type2 … typeN
A space separated list of module entity types to not remove.
reset_representation=<flag>
0 - Keep representation reference information.
1 - Remove representation reference information.
resursive=<flag>
0 - Purge only the local module’s contents. Do not touch the child module’s
                  contents (in the case of a part assembly). 
1 - Recursively purge the module, as well as any child modules.
udm_id=<string>
The string ID from a UDM XML file for this part, if necessary.



","Example
Purge part assembly 168 and any of its children recursively:
*ME_ModuleOccurrencePurge 168 ""recursive=1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2172,*mechadjustjoint,"Description
Actuates a joint to reach a new value.
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the joint to adjust.
direction
The direction along which the new value will be applied: 
0 - Translation along x-axis 
1 - Translation along y-axis 
2 - Translation along z-axis 
3 - Rotation about x-axis 
4 - Rotation about y-axis 
5 - Rotation about z-axis
value
The desired value of the joint (double).
tolerance
The tolerance allowed when adjusting (double).
lock
If set to 1, all joints in the mechanism which are not part of the cycle of the given
            joint are locked.
angle_step
The size of the iterative steps used to solve for the new value of the joint. Only
            used for rotation.
hold_angles
If set to 1, this locks the rotation about axes other than the given direction. If 0,
            rotation occurs in a way such that the given axis doesn’t move. In this case the Euler
            angles about other axes can change. This is only for ball joints.

","Example
To move a joint named TORSO_to_RIGHT_UPPER_LEG to x=20 y=0 z=0 with tolerance 0.001,
        locking other joints and angle step = 0:
*mechadjustjoint ""TORSO_to_RIGHT_UPPER_LEG"" 20.0 0.0 0.0 0.001 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2173,*mechapplybodytotargetpoints,"Description
Moves source points on the bodies of a mechanism to target points. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

bodies_array
The ID of the string array that contains the names of the bodies to update. The array
            is created using the *createstringarray command. This should always
            be set to 1.
number_of_bodies
Integer indicating the size (number of bodies) in the array created using
              *createstringarray. This must be half the
              number_of_point_pairs.
point_pairs_array
The ID of the double 2D array that contains the source and target point pairs. The
            array is created using the *createdoublearray2d command. This should always be set to 1. 
The point pair elements are given in the following order:
The point pair elements are given in the following order: 
p1x p1y p1z (coordinates of source point 1 on body1) 
p2x p2y p2z (coordinates of source point 2 on body2) 
... 
pNx pNy pNz (coordinates of source point N on body2) 
t1x t1y t1z (coordinates of target point 1 on body1) 
t2x t2y t2z (coordinates of target point 2 on body2) 
... 
tNx tNy tNz (coordinates of target point N on body2)
number_of_point_pairs
Integer indicating the rows (number of point pairs) in the array created
              using *createdoublearray2d. 
This must be twice the number_of_bodies.
number_of_point_pair_coordinates
Integer indicating the columns (number of coordinates per pair) in the array created
            using *createdoublearray2d. This must be set to 3.

","Example
To move bodies ""LEFT LOWER LEG"" and ""RIGHT LOWER LEG"", with source-target point pairs as: 
LEFT LOWER LEG: (-156.84033, 47.889306, 31.0028062) to (-148.916035, 72.1107681,
        -10.4045246) 
RIGHT LOWER LEG: (-148.979951, -66.8473281, -34.494296) to (-141.051409, -42.6880283,
        -75.937107)
*createstringarray 2 ""LEFT LOWER LEG"" ""RIGHT LOWER LEG""
*createdoublearray2d 4 3 \
-156.84033 47.889306 31.0028062 \
-148.979951 -66.8473281 -34.494296 \
-148.916035 72.1107681 -10.4045246 \
-141.051409 -42.6880283 -75.937107
*mechapplybodytotargetpoints 1 2 1 4 3

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2174,*mechimportdaf,"Description
Imports the dummy angle file for the current dummy. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

filename
The full name and path of the file to import.

","Example
To import the current dummy DAF file as C:/temp/dummy.daf:
*mechimportdaf ""C:/temp/dummy.daf""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2175,*mechplanetranslatebody,"Description
Moves a body such that the source point on the body reaches the target point, while
        satisfying joints and constraints defined in the mechanism. 
The mechanism must have the enabled flag set to true for this to be possible.
","Inputs

name
The name of the body of the mechanism.
sx
The x-coordinate of the source point on the body.
sy
The y-coordinate of the source point on the body.
sz
The z-coordinate of the source point on the body.
tx
The x-coordinate of the target point.
ty
The y-coordinate of the target point.
tz
The z-coordinate of the target point.
rx
The x-direction rotation angle.
ry
The y-direction rotation angle.
rz
The z-direction rotation angle.
tolerance
The tolerance allowed during the placement.

","Example
To move body Seat_Cushion from (-1447.3297618988, 263.83727318711, 562.87391867592) to
        (-1400.3297618988, 263.83727318711, 562.87391867592) with tolerance 0.001, with no rotation
        angles:
*mechplanetranslatebody ""Seat_Cushion"" -1447.3297618988 263.83727318711 562.87391867592 -1400.3297618988 263.83727318711 562.87391867592 0 0 0 0.001
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2176,*meshdragelements2,"Description
Creates solid elements by dragging 2D elements along a vector.
","Inputs

mark_id
The ID of the mark containing the elements to be dragged. 
vector_id
The ID of the vector along which the elements should be dragged, created
              using *createvector.
distance
The distance which the elements should be dragged. 
on_drag
The number of elements to create along the drag. 
bias_style
0 - Linear
1 - Exponential
2 - Bell curve
biasing
The biasing intensity value.
organize
0 - Elements to current component 
1 - Elements to original component

","Example
To create 5 elements by dragging elements 10 and 11 along a vector defined by (1.0, 0.0,
        0.0) a length of 50 units, and have the resulting elems in the original comp: 
*createvector 1 1.0 0.0 0.0
*createmark elements 1 10 11
*meshdragelements2 1 1 50.0 5 1 0.0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2177,*meshline_display_scaffold,"Description
This command deletes meshlines.
","Inputs

flag
The display state of the scaffolds. Valid values are: 
0 - Do not display scaffolds 
1 - Display scaffolds
reserved
Reserved for future use. Must be set to 0.

","Example
 To turn on display of the meshline scaffolds:
*meshline_display_scaffold 1 0
","Errors
None.
"
2178,*meshline_reject,"Description
This command synchronizes meshline internal structures.
","Inputs

reserved
Reserved for future use. Must be set to 0.

","Example
To synchronize the meshline structures:
*meshline_reject 0
","Errors
None.
"
2179,*meshmode,"Description
Sets the mesh line display mode. 
","Inputs

displaylist
The display list in which the mesh mode is being set. 
mode
The mesh line mode. 
plot
1, if the display should be drawn after the mesh mode is set. 

","Errors
None.
",
2180,*messagefileset,"Description
Writes certain messages to a file. All values below are case insensitive.
","Inputs

type
The type of message to write. Valid values are: 
FEINPUT - any messages passed to HM by an FE-input processes.
HM - all supported type values.
file
The full path and filename of the file to write the messages to. 

","Example
To save all FE-input error messages to a file named C:/test.dat:
*messagefileset ""feinput"" ""C:/test.dat""
*messagefilefilter ""feinput"" ""error""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2181,*metadatamarkdoublearray,"Description
Creates double array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. The undef entity type is used to store
            metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
double_array
The ID of the double array that contains the values. The array is created using
              the *createdoublearray command. This should always be set to
            1.
number_of_doubles
Integer indicating the size (number of doubles) in the array created using
              *createdoublearray. 

","Example
To add metadata named Real_Vals with the values 17.54 and 31.88 to elements 1-100:
*createmark elems 1 1-100
*createdoublearray 2 17.54 31.88
*metadatamarkdoublearray elems 1 ""Real_Vals"" 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2182,*metadatamarkentityidtypearray,"Description
Creates entity ID type array metadata on the specified mark of entities.
","Inputs

entity_type
The type of entities contained on the mark. 
The undef entity type is used to store metadata on the model itself.
mark_id
The ID of the mark containing the entities to which the metadata will be added. Valid
            values are 1 and 2.
name
The name by which the metadata will be referenced.
entity_type_2
The type of entity which the metadata references.
entity_id_array
The ID of the integer array that contains the entity IDs. The array is created using
              the *createarray command. This should always be set to 1.
number_of_entities
Integer indicating the size (number of entity IDs) in the array created using
              *createarray.

","Example
To add metadata named Surfaces with surface 100 and 110 to elements 1-100:
*createmark elems 1 1-100
*createarray 2 100 110
*metadatamarkentityidtypearray elems 1 ""Surface"" surfs 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2183,*midsurface_accept_edge_target_by_number,"Description
Assigns targets for the surface edge. Once assigned, targets can be used to offset a
        midsurface.
","Inputs

face
The index of the surface to offset.
e1_edge_number
The index of a line, which must be an edge of the surface to
            offset.
e2_line
The index of a pilot line.
is_opposite
0 - The target is the e2_line. 
1 - The target is a line located in between e1_line and
              e2_line.

","Example
You cannot manually employ this command, because HyperMesh must
        internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
2184,*midsurface_new_plate,"Description
The command creates a new plate from the surfaces on the input mark. The plate component,
        for visualizing the newly created plate and containing copies of the original model’s
        surfaces, is also created. If the surfaces on the input mark previously had different plate
        attributes, their copies in the temporary plate components are deleted.
If the base surface information is set to be taken into account, the command will also do a
        preliminary check whether the given set of surfaces includes any base surfaces or not. If
        there is any base surface present and the intended merged plate type is ""planar"" or ""sweep"",
        the command will not do anything.
","Inputs

mark_id
The ID of the mark containing the input surfaces. Valid values are 1 and 2.
plate_type
This parameter specifies the type of merged plate to create. Valid values are: 
0 - Create plate of type ""auto"" 
1 - Create plate of type ""planar"" 
2 - Create plate of type ""offset"" 
3 - Create plate of type ""sweep""
use_base_surfaces
This specifies whether the user-defined base surfaces will be taken into account when
            displaying the plate information. Valid values are: 
0 - Base surface information is not taken into account. There is no restriction as to
            which surfaces can be used to merge into a single plate. 
1 - Base surface information is taken into account. If the input mark contains a base
            surface, the command will not do anything in cases when the intended plate type is
            planar or sweep.
reserved
Reserved for future use. Must be set to 0.

","Example
To set the surfaces with ID 5-7 to become a new plate of type offset, without including a
        check for the input mark to contain base surfaces:
*createmark surfaces 1 5 6 7
*midsurface_new_plate 1 2 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2185,*midsurface_remove_display_plate_sides,"Description
Deletes the two components that contain copies of the model surfaces belonging to two sides
        of a given plate.
","Inputs

plate_number
Specifies the plate number for which the plate side information is to be deleted.
reserved1
Reserved for future use. Must be set to 0.
reserved2
Reserved for future use. Must be set to 0.

","Example
To delete the plate information for the plate with plate number 127:
*midsurface_remove_display_plate_sides 127 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2186,*midsurface_remove_edge_target_by_number,"Description
Removes a target from a surface edge specified by a line number. 
","Inputs

face
The index of the surface to offset.
e1_line_number
The edge from which targets are to be removed.

","Example
You cannot manually employ this command, because HyperMesh must
        internally generate the index values (they cannot simply be typed in).
","Errors
None.
"
2187,*midsurface_remove_new_target,"Description
No arguments are required for this command.
","Errors
None.
",,
2188,*minmaxtitlemove,"Description
Moves a minimum or maximum title.
","Inputs

xmin
The x value of the upper left corner of the title (0.0 - 1.0).
ymin
The y value of the upper left corner of the title (0.0 - 1.0).
xmax
The x value of the lower right corner of the title (0.0 - 1.0).
ymax
The y value of the lower right corner of the title (0.0 - 1.0).
type
0 - Node title (contour plot) 
1 - Element title (assigned plot)
minmax
0 - Minimum title 
1 - Maximum title

","Errors
None.
",
2189,*mode,"Description
Sets the operations performed when a full-size plot is generated in a command file. 
","Inputs

type
Defines the mode or operations performed when a full-size plot is generated from a
            command file. 
0 - This is the default action; HyperMeshwill wait for a
            key on the mouse to be struck before continuing. 
1 - Generates a screen copy or a paper plot of the picture generated on the screen. 
2 - Generates a file containing the contents of the screen buffer. 
3 - Generates a PostScript paper copy of the currently displayed screen. 
4 - Generates a PostScript file of the currently displayed screen. 
5 - A value of five or greater causes HyperMesh to pause
            for that number of seconds before continuing. 

","Example
To pause for 10 seconds after a full-size plot is performed, place the following command
        before the full-size plot request: 
*mode(10)
","Errors
None.
"
2190,*ModifySectionHandle,"Description
This command updates the section shape updating the handle position.
","Inputs

xold_coord
x-coordinate of the old handle position.
yold_coord
y-coordinate of the old handle position.
zold_coord
z-coordinate of the old handle position.
xnew_coord 
x-coordinate of the new handle position.
ynew_coord 
y-coordinate of the new handle position.
znew_coord 
z-coordinate of the new handle position.

","Example
To modify the section position updating the handle position:
*ModifySectionHandle 7345.06626 -1077.25964 1419.12497 7334.93373 -1077.05694 1382.59689
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2191,*morphaltercurvectr,"Description
Alter the radius, curvature, or arc angle of edge or 2D domains on mark.
","Inputs

domtype
DOMAINS
dommark
Domain mark number
nodetype
NODES
holdnode
Node mark number
type
The type of alteration to be made: 
0 - Alter radius 
1 - Alter curvature 
2 - Alter arc angle
curve
Numerical value by which to alter the curve; actual effect depends on the type
            previously specified and the value of the add flag listed at the end of the command: 
If type = 0 - New radius 
type = 1 - Curvature multiplier 
type = 2 - New arc angle 
add =1 and type = 0 - Number added to radii 
add =1 and type = 2 - Number added to arc
            angle
sym
0  - Do not use symmetry (only option)
con
Flag to use/not use constraints: 
0 - Do not use constraints 
1 - Use constraints
hold
Specifies which part of the curve to anchor: 
0 - Hold angle 
1 - Hold ends 
2 - Hold center
mode
Method of determining center or edges of curve: 
0 - Edge approximation, use symmetry 
1 - Use axis for center 
2 - Use line for center 
3 - Infer center using normals 
4 - Use node for center 
5 - Edge approximation, do not use symmetry
node
ID of node
plane
Mark number of plane
line
ID of line
project
Flag to project curve edges to a plane: 
0 - Do not project edges to plane 
1 - Project edges to plane
force
Flag to force circular edges when using edge approximation (mode option 5): 
0 - Do not force edges to be circular (edge approximation only) 
1 - Force edges to be circular (edge approximation only)
add
Determines whether the value specified for curve is added to the existing curve’s
            value, or replaces it: 
0 - Use 'curve' as target value 
1 - Add 'curve' to current value(s)

","Example
*morphaltercurvectr (DOMAINS,1,NODES,1,1,5.0,0,1,0,0,32,1,43,0,0,0)
The domains on the marks will have either their radius, curvature, or arc angle altered
        depending on 'type'. If add is set to 1, 'curve; will be added to the
        current radii or arc angle of the selected domains, otherwise the radii or arc angle will be
        set to 'curve'.
This command allows you to choose the mode used to determine the center for the selected
        domains. Only one of 'node', 'plane', or 'line' needs to be filled in depending on mode (or
        none if 0, 3, or 5 is selected).
Setting project to 1 will force the nodes for an edge to lie in a plane
        as part of the altered curve. Setting force to 1 will force the
        calculated center for each node of an edge to be the same point, thus forcing the edge to be
        circular after the curve is altered.
If constraints are used they will be applied to the perturbations. Symmetry is not
        supported for *morphaltercurvectr().
","Errors
None.
"
2192,*morphapplyfesolver,"Description
This command will invoke a finite element solver, specified by the
          fesolver parameter, and solve for the internal perturbations for all
        domains which have fewer elements than that specified by the fesolverlimit parameter using
        enforced displacements applied at the domain handles, edges, and/or faces. The command will
        either use the properties and materials specified for the mesh or generate properties and
        materials automatically depending on the feuser parameter. 
This command has no arguments but uses several parameters when it is executed which are
        described below. These parameters can be updated using the
          *morphupdateparameter command.
","Inputs

fesolver
0 - Linear solver (OptiStruct) 
1 - Nonlinear solver (Radioss)
fesolverlimit
Domains containing less than this number of elements will be updated.
feuser
0 - Use automatically generated properties and materials 
1 - Use properties and materials currently for the mesh

","Example
To invoke the FE solver:
*morphapplyfesolver
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2193,*morphbeziershape,"Description
Create polynomial or spline based shapes for handles on the domains on mark.
","Inputs

dtype
Domains
dmark
Domain mark number
etype
Elemsn
emark
Element mark number
shapeid
ID of shape
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
vvec
Mark number of vector
mag
Magnitude of perturbation
type
1 - Use vector for handle perturbations 
2 - Use element normals for handle perturbations 
3 - Use shape for handle perturbations
meth
0 - Polynomial 
1 - Spline
umark
0 - Use all elements to determine normals 
1 - Use elements on emark to determine normals

","Example
*morphbeziershape (DOMAINS,1,ELEMS,1,12,0,1,1,5.0,3,1,0)
A shape is created for each handle on each domain on the mark using the selected type to
        determine the perturbations. 
If type is 1 or 2, mag will be used as the magnitude
        of the handle perturbations. If type is 3, the perturbations on the shape
        will be used. 
If symmetry is used, all handles linked to marked handles by symmetry will also be
        perturbed. If constraints are used, they will be applied to the perturbations.
","Errors
None.
"
2194,*morphbiasupdate,"Description
Updates the bias factor for the specified handle.
","Inputs

hptr
ID of handle
bias
New bias value

","Example
*morphbiasupdate (1,2.0)
Updates the specified handle to have the given bias factor.
","Errors
None.
"
2195,*morphcombinemorphvolumes,"Description
Combines the specified morph volumes and propagates the combination. 
","Inputs

h1
ID of first morph volume.
h2
ID of second morph volume.
hand
0 - Do not create handles for morph volumes 
1 - Create handles for morph volumes
tangent
0 - No tangency 
1 - Make neighboring morph volume edges continuously tangent

","Example
*morphcombinemorphvolumes (21,22,1,1)
This command will combine the specified morph volumes and propagate the effect through the
        entire morph volume ""matrix"" so that it remains consistent. 
Newly combined morph volumes can optionally have handles and tangency automatically
        applied.
","Errors
None.
"
2196,*morphconstraintapply,"Description
Applies all morph constraints to the model.
","Example
*morphconstraintapply 

This command applies the current constraints to the model. When constraints are created
        they are applied to the model so this command does not need to be called after creation of a
        morph constraint.Note: Constraints are applied via a morph, which can be undone. Undoing
          such a morph does not reject the constraint. 

If the model no longer obeys the constraints, for instance, if the constraints are turned
        off and the model is morphed, this command can be used to restore compliance.
","Errors
None.
",
2197,*morphconstraintcreatearcrad,"Description
Creates a model type constraint based on the radius or arc length of an edge domain.
","Inputs

stype
Must be set to shapes.
smark
The ID of the mark containing the shapes. Valid values are 1 and 2.
atype
NODES or LINES
amark
Mark number of node or line used for radius measurement
type
0 - Measure radius or arc angle using domain 
1 - Measure radius or arc angle using axis 
2 - Measure radius or arc angle using line 
3 - Measure radius or arc angle using node
name
Name of morph constraint
plane
Mark number of plane for axis
dptr
ID of edge domain
radius
Constrained radius or arc angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
arc
0 - Radius 
1 - Arc angle
color
The color of the constraint. Valid values are 1 through 64.

","Example

*morphconstraintcreatearcrad (SHAPES,1,NODES,1,0,""radius"",1,21,5.0,0,0,32)

This command creates a model type constraint for the selected domain with the option of
        having the radius or arc angle measured in the plane of the domain, about an axis, about a
        line or about a node, and the option of having the radius or arc angle forced to be greater
        than, less than, or equal to the specified value. 
If arc is 0, the radius will be constrained. If arc
        is 1 the arc angle will be constrained. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint if possible 
","Errors
None.
"
2198,*morphconstraintcreateelems,"Description
This command creates a mesh type morphconstraint for the selected nodes with the option of
        having those nodes either move along the specified mesh or be bounded by it. 
The extended edges option is available for bounded type morphconstraint (types 1, 3, and 5)
        by adding 8 to the type (9, 11, and 13). This option will extend the edges of the mesh by
        roughly two element lengths so that the nodes which project close to the edges of the mesh
        will project on to the extended edges. 
The depenetration option is available for bounded type morphconstraint (types 1, 3, and 5)
        by adding 16 to the type (17, 19, and 21). This option will treat the center of any element
        attached to the constrained nodes as a constrained node and push the element away from the
        mesh if it is within the specified distance. 
To enable both extended edges and depenetration for a morphconstraint, add 24 to the type
        (thus 1, 3, and 5 become 25, 27, and 29).
","Inputs

ntype
Must be set to nodes.
nmark
The mark ID for the constrained nodes. Valid values are 1 and 2.
etype
Must be set to elems.
emark
The mark ID for elements to which the nodes are constrained. Valid values are 1 and 2.
type
0 - moves along mesh 
1 - bounded by mesh 
3 - remains a set distance from mesh 
5 - maintains its original distance from mesh 
+8 - extend edges of mesh 
+16 - depenetration of elements attached to constrained nodes (+24 - extend edges and
            enable depenetration) 
+32 - enable mesh stretching around constrained nodes
name
The name of the morphconstraint.
p_vec
The ID of the projection vector created using *createvector. Must
            be set to 1.
dist
Distance between node and mesh (types 1 and 3).
ivec
0 - Mesh normal is used for projection. The nodes will be moved normally to the mesh
            when constraining them or measuring the distance the nodes are away from the mesh 
1 - Use p_vec for projection. The nodes will be moved along
              p_vec when constraining them or measuring the distance the nodes
            are away from the mesh
color
The color of the constraint. Valid values are 1-64.

","Example
To create a morphconstraint for nodes to move along a mesh and projected normally to the
        mesh:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateelems nodes 1 elems 1 0 ""mcon"" 1 0.0 0 13
To create a morphconstraint for nodes to be bounded by a mesh at a distance of 5.0 and
        projected along a vector to the mesh with both depenetration and extended edges:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintcreateelems nodes 1 elems 1 27 ""mcon"" 1 5.0 1 13
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2199,*morphconstraintcreatelayer,"Description
This command will create a layer type morphconstraint for the selected nodes such that they
        move relative to the selected elements, effectively mapping nodes in layers to those on the
        selected elements. This option works best for nodes that were created in identical layers,
        such as with the element offset or drag elements functionalities used to create a stack of
        solid elements with a shell mesh. It is intended for use with CFD boundary layer meshes.
The nodes will maintain their original distances relative to the elements when the elements
        are morphed. The nodes will also match the movements of the elements in translation,
        translation and rotation, or be allowed to slide parallel to the normal direction of the
        elements based on the type selected. Also, mesh stretching may be enabled to smooth the
        transition between the constraint and the rest of the mesh.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the nodes to be constrained. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the elements to which the nodes will be constrained. Valid values are 1 and 2.
type
0 - Force inner layers to always be normal to the outer layer 
1 - Allow sliding normal to the outer layer 
2 - Fix only translations between the elements and the layers 
3 - Fix both translation and rotation between the elements and the layers 
+8 - Stretch mesh around the constrained nodes 
+16 - Use ""CFD corners"" method to calculate normals
name
The name of the morphconstraint to be create.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a layer constraint to be fixed in both rotation and translation
          (type = 3), with mesh stretching enabled (type +8)
        and using the cfd corners method (type +16 for a total of 27):
*createmark nodes 1 ""all""
*createmark elements 1 207 213 217 218 220 221 223 225 226
*morphconstraintcreatelayer nodes 1 elements 1 27 ""mcon"" 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2200,*morphconstraintcreatematch,"Description
This command will create a match type morphconstraint between two marks of elements such
        that they maintain a similar shape if the elements of either one mark or both marks are
        morphed. The two meshes do not have to be identical but the more similar they are the better
        the constraint will work.
This type of constraint can be used multiple times on the same set of elements in order to
        make three or more meshes match each other. Note that only shell elements can be matched
        using this constraint.
","Inputs

a_entity_type
Must be set to elems.
a_mark_id
The ID of the mark containing the first set of elems. Valid values are 1 and 2.
b_entity_type
Must be set to elems.
b_mark_id
The ID of the mark containing the second set of elems. Valid values are 1 and 2.
type
0 - Allow to slide normal to the mesh 
1 - Allow sliding normal to the specified vector vec 
2 - Match the shape between the two meshes 
+4 - Stretch mesh around the constrained elements
name
The name of the morphconstraint.
vec
The ID of the projection vector created using *createvector. Must
            be set to 1. Only used for type 1 and 5.
dist
The distance to be maintained between the meshes. Not used for type
            2 and 6.
node_basea
ID of the base node of a local system oriented to the mesh specified by
              a_mark_id. Only used for type 2 and 6.
node_xa
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by a_mark_id. Only used for type 2 and
            6.
node_xya
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
              by b_mark_id. Only used for type 2 and 6.
node_baseb
ID of the base node of a local system oriented to the mesh specified by
              b_mark_id. Only used for type 2 and 6.
node_xb
ID of the node lying in the x direction of a local system oriented to the mesh
            specified by b_mark_id. Only used for type 2 and
            6.
node_xyb
ID of the node lying in the xy-plane of a local system oriented to the mesh specified
              by a_mark_id. Only used for type 2 and 6.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a match constraint which matches the shape between two meshes
          (type = 2) and uses mesh stretching (type +4 for a
        total of 6):
*createmark elements 1 83 84 86-90 93 95 96 98-102 105 107 *createmark elements 2 50-54 57 62-66 69 74-78 81
*createvector 1 1 0 0
*morphconstraintcreatematch elements 1 elements 2 6 ""mcon"" 1 0 133 135 110 60 62 86 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2201,*morphconstraintcreatesurf,"Description
This command creates a surface type morphconstraint for the selected nodes with the option
        of having those nodes either move along the surface or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - Moves along the surface 
1 - Bounded by the surface 
3 - Remains a set distance from the surface 
5 - Remains its original distance from the surface 
+32 - Enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
name
The name of morph constraint.
vec
The ID of the vector created using *createvector. Must be set to
            1.
surface
The ID of the surface.
dist
The minimum distance from the bounding surface.
ivec
0 - The surface normal is used for distance and projection. The nodes will be moved
            normally to the surface when constraining them or measuring the distance the nodes are
            away from the surface. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            plane.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To create a morphconstraint for nodes to move along a surface and projected normally to the
        surface:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintcreatesurf nodes 1 0 ""surface"" 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2202,*morphconstraintupdateangle,"Description
Updates a model type constraint based on the angle between three nodes. 
","Inputs

stype
SHAPES
smark
Mark number of shapes
type
0 - Measure angle node to node 
1 - Measure angle using vector
mcon
ID of morph constraint
n1
First end of angle
n2
Vertex of angle
n3
Second end of angle
vec
The ID of the vector created using *createvector. Must be set to
            1.
angle
Constrained angle 
bound
-1 - Greater than specified angle 
0 - Equal to specified angle 
1 - Less than specified angle
color
The color of the constraint. Valid values are 1 through  64.

","Example
*morphconstraintupdateangle (SHAPES,1,0,5,21,22,23,1,45.0,0,32)

This command updates a model type constraint for the three selected nodes with the option
        of updating those nodes to be measured in the plane that they lie in or to be perpendicular
        to a vector and the option of having the angle forced to be greater than, less than, or
        equal to the specified angle. 
The shapes on the mark will be used to force the model into compliance with the specified
        constraint, if possible.
","Errors
None.
"
2203,*morphconstraintupdatedof,"Description
This command creates a constraint which fixes one or more translational degrees of freedom
        for the selected nodes relative to either the global coordinate system or a specified local
        coordinate system. 
A degree of freedom for a coordinate system is one of the three translational directions.
        For a rectangular coordinate system the three degrees of freedom are along each axis: the
        x-axis, the y-axis, and the z-axis. For a cylindrical coordinate system the three degrees of
        freedom are in the the radial direction, the theta direction, and the z direction. For
        example, for a rectangular coordinate system, if the y-axis degree of freedom is fixed for a
        node, it will be allowed to move only in the x and z directions, remaining in a plane
        perpendicular to the y axis. Similarly, for a cylindrical coordinate system, if the theta
        degree of freedom is fixed for a node, it can move only in the radial and z directions. Note
        that fixing the radial and z degrees of freedom for a cylindrical coordinate system will
        force a node to move in a circle about the axis of that system.
","Inputs

entity_type
Must be set to nodes.
mark_id
The mark ID for the constrained nodes. Valid values are 1 and 2.
dof1
0 - Allow the nodes to move in the x (or radial) direction 
1 - Constrain the nodes from moving in the x (or radial) direction
dof2
0 - Allow the nodes to move in the y (or theta) direction 
1 - Constrain the nodes from moving in the y (or theta) direction
dof3
0 - Allow the nodes to move in the z direction 
1 - Constrain the nodes from moving in the z direction
system_id
The ID of the local coordinate system. Use 0 for the global coordinate system.
options
0 - Does not affect nodes near constrained nodes 
1 - Enable mesh stretching around constrained nodes
id
The ID of morph constraint to update.
color
The color of the constraint. Valid values are 1-64.

","Example
To update a DOF constraint with ID 12 for nodes 1-100 in the radial direction of a local
        coordinate system with ID 5 and mesh stretching enabled:
*createmark nodes 1 1-100
*morphconstraintcreatedof nodes 1 1 0 0 5 1 12 22
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2204,*morphconstraintupdateelems,"Description
This command updates a mesh type morphconstraint for the selected nodes with the option of
        having those nodes either move along the specified mesh or be bounded by it.
The extended edges option is available for bounded type morphconstraint
          (type 1, 3, and 5) by adding 8 to the type (9, 11,
        and 13). This option will extend the edges of the mesh by roughly two element lengths so
        that the nodes which project close to the edges of the mesh will project on to the extended
        edges.
The depenetration option is available for bounded type morphconstraint
          (type 1, 3, and 5) by adding 16 to the type (17, 19,
        and 21). This option will treat the center of any element attached to the constrained nodes
        as a constrained node and push the element away from the mesh, if it is within the specified
        distance.
To enable both extended edges and depenetration for a morphconstraint, add 24 to the type
        (thus 1, 3, and 5 become 25, 27, and 29).
","Inputs

ntype
Must be set to nodes.
nmark
The mark ID for the constrained nodes. Valid values are 1 and 2.
etype
etype
emark
The mark ID for elements to which the nodes are constrained. Valid values are 1 and 2.
type
0 - Moves along mesh 
1 - Bounded by mesh 
3 - Remains a set distance from mesh 
5 - Maintains its original distance from mesh 
+8 - Extend edges of mesh 
+16 - Depenetration of elements attached to constrained nodes 
+24 - Extend edges and enable depenetration 
+32 - Enable mesh stretching around constrained nodes
mcon
The ID of morph constraint to update.
p_vec
The ID of the projection vector created using *createvector. Must
            be set to 1.
dist
Distance between node and mesh (types 1 and 3).
ivec
0 - Mesh normal is used for projection. The nodes will be moved normally to the mesh
            when constraining them or measuring the distance the nodes are away from the mesh. 
1 - Use p_vec for projection. The nodes will be moved along
              p_vec when constraining them or measuring the distance the nodes
            are away from the mesh.
color
The color of the constraint. Valid values are 1 through 64.

","Examples
To update a morphconstraint for nodes to move along a mesh and projected normally to the
        mesh:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateelems nodes 1 elems 1 0 12 1 0.0 0 13
To update a morphconstraint for nodes to be bounded by a mesh at a distance of 5.0 and
        projected along a vector to the mesh with both depenetration and extended edges:
*createmark nodes 1 1 2 3 4 5
*createmark elems 1 11 12 13 14 15
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateelems nodes 1 elems 1 27 12 1 5.0 1 13
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2205,*morphconstraintupdatelayer,"Description
This command will update a layer type morphconstraint for the selected nodes such that they
        move relative to the selected elements, effectively mapping nodes in layers to those on the
        selected elements. This option works best for nodes that were created in identical layers,
        such as with the element offset or drag elements functionalities used to create a stack of
        solid elements with a shell mesh. It is intended for use with CFD boundary layer meshes.
The nodes will maintain their original distances relative to the elements when the elements
        are morphed. The nodes will also match the movements of the elements in translation,
        translation and rotation, or be allowed to slide parallel to the normal direction of the
        elements based on the type selected. Also, mesh stretching may be enabled to smooth the
        transition between the constraint and the rest of the mesh.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The ID of the mark containing the nodes to be constrained. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_mark_id
The ID of the mark containing the elements to which the nodes will be constrained. Valid values are 1 and 2.
type
0 - Force inner layers to always be normal to the outer layer 
1 - Allow sliding normal to the outer layer 
2 - Fix only translations between the elements and the layers 
3 - Fix both translation and rotation between the elements and the layers 
+8 - Stretch mesh around the constrained nodes 
+16 - Use ""cfd corners"" method to calculate normals 
morphconstraint_id
The ID of the morphconstraint to be updated.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a layer constraint to be fixed in both rotation and translation
          (type = 3), with mesh stretching enabled (type +8)
        and using the CFD corners method (type +16 for a total of 27):
*createmark nodes 1 ""all""
*createmark elements 1 207 213 217 218 220 221 223 225 226
*morphconstraintupdatelayer nodes 1 elements 1 27 1 38
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2206,*morphconstraintupdateline,"Description
This command updates a line type morphconstraint for the selected nodes with the option of
        having those nodes either move along the line or be bounded by it.
","Inputs

ntype
Must be set to nodes.
nmark
The ID of the mark for the constrained nodes. Valid values are 1 and 2.
type
0 - moves along the line 
1 - bounded by the line 
3 - remains a set distance from the line 
5 - remains its original distance from the line 
+32 - enable mesh stretching around constrained nodes. Add this value to the type
            (thus 1, 3, and 5 become 33, 35, and 37).
mcon
The ID of the morph constraint to update.
vec
The ID of the vector created using *createvector. Must be set to
            1.
line
The ID of the line.
dist
The minimum distance from the bounding line.
ivec
0 - The line normal is used for distance and projection. The nodes will be moved
            normally to the line when constraining them or measuring the distance the nodes are away
            from the line. 
1 - The vector is used for distance and projection. The nodes will be moved along the
            vector when constraining them or measuring the distance the nodes are away from the
            line.
color
The color of the constraint. Valid values are 1-64.

","Example
To update a morphconstraint for nodes to move along a line and projected normally to the
        line:
*createmark nodes 1 1 2 3 4 5
*createvector 1 1.0 0.0 0.0
*morphconstraintupdateline nodes 1 0 12 1 12 0.0 0 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2207,*morphconstraintupdatesmooth,"Description
This command updates a smooth type morphconstraint for the selected nodes. During morphing,
        the perturbations of the nodes or dependent handles will be modified using a spline based
        approximation so that edge domains running along the selected entities will have smooth
        contours.
","Inputs

nlist
The ID of the list containing the nodes. Valid values are 1 and 2.
type
0 - Apply to nodes. All handles on the node list serve as anchors for the spline curve
            and nodes are adjusted to the curve based on influences 
1 - Apply to dependent handles. Only the independent handles on the node list serve as
            anchors and the dependent handles are adjusted to the curve based on influences
closed
0 - Open ended 
1 - Loop. The first node on the list will be added to the end to form a loop
mcon
The ID of the morph constraint to update.
color
The color of the constraint. Valid values are 1 through 64.

","Example
To update a smooth morphconstraint for nodes 1-5 with a closed loop:
*createlist nodes 1 1 2 3 4 5
*morphconstraintupdatesmooth 1 0 1 12 32
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2208,*morphdeleteall,"Description
Deletes all morphing entities. 
","Example
*morphdeleteall ()
Deletes all handles, domains, shapes, symmetries, morph volumes, and morph constraints in
        the model. 
","Errors
None.
",
2209,*morphdisplaysymmetries,"Description
Displays dependencies for handles on mark.
","Inputs

entities
Handles or Symmetries
markmask
Handle or symmetry mark number

","Example
*morphdisplaysymmetries (HANDLES,1)
For handles, all handles symmetric to the selected handles are displayed as vectors.
          Note: For symmetry types which link multiple handles, only one handle (the keystone
          handle) will point to the others. The other handles will point back to the keystone
          handle.

For symmetries, all handles linked via the symmetries on the mark are displayed as
        vectors.
If the mark is blank, the vectors are cleared from the screen.
","Errors
None.
"
2210,*morphfittosurface,"Description
This command will map domains, elements, or morph volume faces to surfaces or a mesh,
        fitting the boundaries of the entities to the edges of the surfaces or mesh and projecting
        the interior nodes on to the target entities. In the case of domains and morph volume faces
        being fit to surfaces, multiple entities may be fitted to multiple surfaces with the intent
        of matching them one to one. In those cases, the interior edges of the entities will be
        mapped to interior edges of the surfaces as well.
This command can be used as a one step solution or in conjunction with the
          *morphmaptshp, *morphmaptshpedge, and
          *morphmaptshpface commands if you want to place handles, edge domains,
        2D domains, or morph volume faces before applying the fit operation.
When mapping domains to surfaces one to one, this command can also be used in conjunction
        with the *morphstorematch command which allows you to manually set which
        domains should be mapped to which surfaces or automatically have it determine matches based
        on which domains currently lie on which surfaces.
","Inputs

n_entity_type
Must be set to nodes.
n_mark_id
The mark ID of the nodes on the entities to be fitted. The mark is for internal use
            and may be left empty. Valid values are 1 and 2.
e_entity_type
Valid values are domains, elems, hypercubes.
e_mark_id
The mark ID of the entities to be fitted. Valid values are 1 and 2.
h_entity_type
Must be set to handles.
h_mark_id
The mark ID of the follower handles. Valid values are 1 and 2.
s_entity_type
Valid values are surfs and elems.
s_mark_id
The mark ID of the surfaces or elements onto which the entities will be fitted. Valid values are 1 and 2.
face
The mark ID of selected morph volume edges and faces to be fitted. Valid values are 0
            and 1. See the commands *morphmanageedgemark and
              *morphmanagefacemark for information on how to fill this mark.


nhand
The number of handles per edge any morph volume faces will be updated to having during
            the fitting operation. The maximum value is 5. If you want to retain the current number
            of handles on the edges, set this value to -1.
sym
0 - Do not use symmetry
con
1 - Use constraints
mode
0 - Match as group. Use with handle, edge, and face mapping commands. 
1 - Match as group. One step solution. 
2 - Match one to one. Use with handle, edge, and face mapping commands. 
3 - Match one to one. One step solution. 
4 - Match one to one. Use stored matches. Use with handle, edge, and face mapping
            commands. 
5 - Match one to one. Use stored matches. One step solution. 
When fitting to a mark of elements, only modes 0 and 1 are valid.
maxiter
When matching entities one to one (mode 2 - 5), this is the maximum
            number of iterations attempted before settling on the best current solution. For
              mode 0 and 1 it is ignored.

","Examples
To fit a domain to a surface in one step:
*createmark nodes 1
*createmark domains 1 10
*createmark handles 1
*createmark surfaces 1 3
*morphfittosurface nodes 1 domains 1 handles 1 surfaces 1 0 0 0 1 1 0
To fit multiple morph volume faces to multiple surfaces one to one, increasing the handle
        density to 3 handles per edge:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 0 1 3
*morphmanagefacemark 0 0 0 3
*morphmanageedgemark 0 0 1
*morphmanageedgemark 5 0 1
*morphmanageedgemark 1 0 1
*morphmanageedgemark 14 0 1
*morphmanagefacemark 1 4 0 1
*morphmanageedgemark 5 0 1
*morphmanageedgemark 10 0 1
*morphmanageedgemark 6 0 1
*morphmanageedgemark 19 0 1
*morphmanagefacemark 2 4 0 1
*morphmanageedgemark 13 0 1
*morphmanageedgemark 18 0 1
*morphmanageedgemark 14 0 1
*morphmanageedgemark 26 0 1
*morphmanagefacemark 3 4 0 1
*morphmanageedgemark 18 0 1
*morphmanageedgemark 23 0 1
*morphmanageedgemark 19 0 1
*morphmanageedgemark 29 0 1
*morphmanagefacemark 4 4 0 1
*createmark nodes 1
*createmark morphvolumes 1 1-4
*createmark handles 1
*createmark surfaces 1 1-4
*morphfittosurface nodes 1 morphvolumes 1 handles 1 surfaces 1 0 -1 0 1 3 50
*morphmanageedgemark 0 0 3
*morphmanageedgemark 0 1 3
*morphmanagefacemark 0 0 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2211,*morphhandlecreatenodesnodom,"Description
Creates handles at nodes on mark with no domain given.
","Inputs

nodetype
Nodes
marknode
Node mark number
dhandletype
Handles
dmarkhandle
Dependent handle mark number
name
Name of handle(s) to be created

","Example
*morphhandlecreatenodesnodom (NODES,1,HANDLES,1,""bob"")
Handles are created at the nodes on the mark with dependencies on the handles on the mark.
        The handle mark may be empty.
The domains on which the handles are created are determined automatically based on the node
        selected. Domains which share a common node are selected in the following order: edges, 2D
        domains, 3D domains, 1D domains, general domains, and global domains. Handles touching morph
        volume nodes will not be assigned to any domain.
The name does not need to be unique since this command will create a unique name for each
        new handle by adding numbers after the name. 
","Errors
None.
"
2212,*morphhandlepertnormal,"Description
Perturbs handles on mark normal to elements 
","Inputs

handletype
Handles
markhandle
Handle mark number
elemtype
Elems
markelem
Element mark number
dist
Distance of perturbation
sym
Flag to use symmetry: 
0 - Do not use symmetry 
1 - Use symmetry
con
Flag to use constraints: 
0 - Do not use constraints 
1 - Use constraints
umark
Flag to only use in the mark: 
0 - Use all elements to calculate normals 
1 - Use only the selected elements to calculate normals

","Example
*morphhandlepertnormal (HANDLES,1,ELEMS,1,3.0,1,1,1)
All handles on the mark will be given a perturbation equal to dist in
        the normal direction as determined by either the selected elements or by all elements. If
        symmetry is used,all handles linked to marked handles by symmetry will also be perturbed. If
        constraints are used, they will be applied to the perturbations. 
","Errors
None.
"
2213,*morphhandleprojectline,"Description
This command will move each of the selected handles onto the line defined by the lines and
        nodes on the lists along a direction defined by the projection type. Applying symmetry links
        and constraints is optional. All domains influenced by the selected handles will be morphed
        accordingly. 
If nproj is set to 2, the elements on the mark will be used to determine
        the projection direction for the handles. If no elements are on the mark then all shell
        elements will be used to determine the projection directions. 
Handles linked through symmetry to those selected will be moved in a way that mirrors the
        selected handles which may or may not move them to other lines in the model. 
Constraints may move the perturbed handles off of the selected line after the handles are
        moved to the line.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID containing the handles. Valid values are 1 and 2.
p_entity_type
Must be set to elems.
p_mark_id
The mark ID of the normal elements. Valid values are 1 and 2.
line_list
ID of the line list for line. Valid values are 1 and 2.
node_list
ID of the node list for the line. Valid values are 1 and 2.
nproj
0 - Project along vector proj

1 - Project normal to line 
2 - Project normal to elements in p_mark_id
proj
Temporary projection vector ID
sym
0 - Ignore symmetry links 
1 - Apply symmetry links
con
0 - Ignore constraints 
1 - Apply constraints after perturbing handles

","Examples
To project handles to a line along a vector:
*createmark handles 1 ""all""
*createmark elems 1
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 0 1 1 1
To project handles to a line normal to the line:
*createmark handles 1 ""all""
*createmark elems 1
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 1 1 1 1
To project handles to a line normal to the elements:
*createmark handles 1 ""all""
*createmark elems 1 1 2 3 4 5 6
*createlist lines 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphhandleprojectline handles 1 elems 1 1 1 2 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Could not create line from data."" - occurs if insufficient or contradictory line and node
        data are placed on the lists. If multiple lines are selected they should connect and
        selected nodes should be on those lines.
"
2214,*morphhandlescalexyz,"Description
This command will scale the positions of the selected handles with respect to a reference
        node and system. Scaling factors can be assigned for the x, y, and z directions
        independently. If no system is specified, the scaling factors will apply in the global x, y,
        and z directions. If no node is specified, the handle positions will be averaged to
        determine the position of the reference node. A scaling factor of 1.0 will produce no
        movement of the handle in that direction while a scaling factor of 0.0 will move the handle
        to the x, y, or z position of the node or system origin.
","Inputs

h_entity_type
Must be set to handles.
h_mark_id
The mark ID of the handles. Valid values are 1 and 2.
node_id
ID of the scaling reference node (or 0).
x
Scaling factor in the x direction (1.0 is no scaling).
y
Scaling factor in the y direction (1.0 is no scaling).
z
Scaling factor in the z direction (1.0 is no scaling).
system_id
ID of the scaling reference system (or 0).
sym
0 - Do not use symmetry links between handles 
1 - Use symmetry links between handles
con
0 - Do not apply constraints 
1 - Apply constraints

","Examples
To scale a mark of handles relative to a node and system:
*createmark handles 1 ""all""
*morphscalehandlexyz handles 1 5 2.0 2.0 2.0 2 1 1
To scale a mark of handles relative to the average position of the handles using the global
        system for x, y, and z:
*createmark handles 1 ""all""
*morphscalehandlexyz handles 1 0 2.0 2.0 2.0 0 1 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2215,*morphhypermorphnormal,"Description
Create shapes in the normal direction for handles on mark.
","Inputs

typehand
Handles
markhand
Handle mark number
sym
0 - Do not use symmetry 
1 - Use symmetry
con
0 - Do not use constraints 
1 - Use constraints
mag
Magnitude of perturbation 

","Example
*morphhypermorphnormal (HANDLES,1,1,1,5.0)
A shape is created for each handle on the mark in the direction of the normal for the
        handle node at the given magnitude. If symmetry is used, all handles linked to marked
        handles by symmetry will also be perturbed. If constraints are used, they will be applied to
        the perturbations. 
","Errors
None.
"
2216,*morphlistupdate,"Description
This command will either clear or compress the morphs on the undo/redo list for the given
        range. If start and finish are both set to zero, the entire list will be affected. If a
        morph is cleared while still applied to the model, the morph will not be unapplied during
        clearing and thus will end up being permanently applied.
The API function hm_morph_getinfo will return the current value of the
        counter and the total number of morphs on the undo/redo list.
","Inputs

mode
The type of update to perform. Valid values are: 
0 - Clear selected morphs 
1 - Compress selected morphs
start
Starting morph number (1 or higher).
finish
Finishing morph number (1 or higher).

","Examples
To clear morphs 1, 2, and 3 from the morph list:
*morphlistupdate 0 1 3
To compress morphs 1, 2 and 3 into a single morph. If the morph list contained more morphs,
        the first morph will be the same as the first three morphs applied simultaneously followed
        by the rest of the morphs on the list:
*morphlistupdate 1 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2217,*morphmanagefacemark,"Description
This command allows you to add a face, subtract a face, or clear all faces from a specified
        morph volume face user mark. Because morph volumes can share faces, the morph volume ID for
        the face must also be specified when adding or subtracting a face. When clearing a mark the
        morph volume ID field can hold any value. Since morph volume faces are not treated as
        independent entities, marks containing faces can only be managed through this external
        command. For commands that require face marks as input, this command must be used to place
        faces on the mark. The mark should be cleared before and after use to ensure clean
        operation.
","Inputs

mvol_id
The ID of the morph volume. Can be any value when clearing the mark.
face_id
The ID of the morph volume face.
mlist
The ID of the user mark. Valid values are 0-3.
mode
1 - Add face to mlist

2 - Subtract face from mlist

3 - Clear all faces from mlist

","Examples
To add a face to the mark:
*morphmanagefacemark 2 4 0 1
To clear the first user mark:
*morphmanagefacemark 0 0 0 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2218,*morphmanualinit,"Description
Stores the current node locations for the model so that node movements done through any
        means (morphing or otherwise) can be recorded and saved as a morph after using the
          *morphmanualapplyenvelope command. 
Manually morphed nodes can later be undone and redone, or saved as a shape.
","Example
To manually move nodes and apply them to the mesh as if they were handles using internally
        generated domains with inferred edges, then reject the changes:
*morphmanualinit
(any commands which move nodes)
*createmark nodes 1 21 22 23
*createmark elems 1 ""all""
*morphmanualapplyenvelope elems 1 nodes 1 1 1.0 1.0 2 0.0 0
*morphmanualrestore
","Errors
None.
",
2219,*morphmapdifferencesurf,"Description
This command maps selected nodes from one surface or element mark to the other surface or
        element mark optionally following the curvature differences (rotate) between the surfaces or
        element marks and/or mapping about an axis (axis and plane) or using a number of linear
        mapping options. Note that you can map from a mesh to a surface or surface to a mesh as well
        as mapping from a mesh to a mesh or a surface to a surface.Note: This command does not do
          ""true"" mapping, that is nodes will not be ""fitted"" from one surface or element mark to
          another. Instead, a vector (the plane normal in r_plane) is used to
          find the target point on the target surface or element mark given a reference point on the
          initial surface or element mark.

If blend is set to 1, no fixed nodes have been selected, and no mapped
        nodes are a part of any domain, this command will automatically assign all non-mapped nodes
        as fixed nodes.
If blend is set to 2, the blending will only be applied to nodes which
        lie along the mesh between the fixed nodes and the mapped nodes.
","Inputs

m_entity_type
Must be set to nodes.
m_mark_id
The mark ID for mapped nodes. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_mark_id
The mark ID for fixed nodes. Valid values are 1 and 2.
i_entity_type
Set to surfs or elems.
i_mark_id
The mark ID for initial surfaces or mesh. Valid values are 1 and 2.
t_entity_type
Set to surfs or elems.
t_mark_id
The mark ID for target surfaces or mesh. Valid values are 1 and 2.
r_plane
Plane used for axis of rotation. Valid values are 1 and 2.
rotate
0 - Linear point to point mapping between lines. 
1 - Rotate nodes along with curvature difference between lines
axial
0 - Apply mapping in x, y, z coordinates 
1 - Apply mapping about axis defined by r_plane
sym
0 - Do not use symmetry (only option).
con
0 - Do not use constraints. 
1 - Use constraints
blend
0 - Do not blend unselected nodes. 
1 - Blend all nodes other than mapped and fixed nodes 
2 - Blend only nodes on mesh between mapped and fixed nodes
mbias
Bias factor of mapped nodes.
fbias
Bias factor of fixed nodes.

","Example
To map nodes from one surface mark to another using rotation:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createmark surfs 1 22 23
*createmark surfs 2 32 33
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifferencesurf nodes 1 nodes 2 surfs 1 surfs 2 1 1 0 1 0 1.0 1.0
To map nodes from one surface mark to an element mark about an axis with no rotation,
        blending through the mesh, and biasing factors of 2.0:
*createmark nodes 1 1 2 3
*createmark nodes 2 11 12 13
*createmark surfs 1 22 23
*createmark elems 1 32 33 34 35 36
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmapdifferencesurf nodes 1 nodes 2 surfs 1 elems 1 1 0 1 1 2 2.0 2.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Not enough memory."" - occurs if there is not enough memory to complete the command.
"
2220,*morphmapedgestonodelistoffset,"Description
This command will fit (evenly distribute) or project (along vector or normal) the handles
        on the marked morph volume edges to a line calculated from the specified points.
","Inputs

user_mark_id
The ID of the user mark containing the morph edges. Valid values are 0-3.
node_list_id
The ID of the list containing the input nodes. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to line 
2 or 12 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
number_of_mid_handles
-1 - Do not change the handles on the edges 
0 - 5 - Update the number of mid-handles on the edges to this number
offset
The distance to offset nodes from the target. Not used if project is 2.
The offset will be measured from the closest point on the line for values of project
            of 0 and 1. The offset will be measured along the projection vector normal for values of
              project of 10 and 11.

","Examples
To map edges on mark 0 offset by 1.2 from a node list along a vector leaving the handles
        unchanged:
*morphmanageedgemark 0 0 3
*morphmanageedgemark 2 0 1
*morphmanageedgemark 4 0 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestonodelistoffset 0 1 1 1 0 1 -1 1.2
*morphmanageedgemark 0 0 3
To map edges on mark 1 to a node list along the node list normal with 3 mid-handles per
        edge:
*morphmanageedgemark 0 1 3
*morphmanageedgemark 2 1 1
*morphmanageedgemark 4 1 1
*createlist nodes 1
*createvector 1 1.0 0.0 0.0
*morphmapedgestonodelistoffset 1 1 1 1 1 1 3 0.0
*morphmanageedgemark 0 1 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2221,*morphmaplinestolines,"Description
This command maps selected elements lying on an initial set of lines to an interpolated
        cross section represented by another set of lines optionally rotating trailing nodes and/or
        mapping about an axis (axis and plane) or using a number of linear mapping options.
This command interpolates a number of *morphmapdifference() calls
        between line pairs. It is critical that the order of the initial lines match the order of
        the final lines in their respective lists for this command to function properly. For best
        results the lines should be planar (cross-sections) and should intersect at right
        angles.
If blend is set to 1, no fixed nodes have been selected, and no mapped
        nodes are a part of any domain, this command will automatically assign all non-mapped nodes
        as fixed nodes.
If blend is set to 2, the blending will only be applied to nodes which
        lie along the mesh between the fixed nodes and the mapped nodes.
The axis option allows you to apply section mapping for sections that
        apply about an axis (option 1). Section lines should lie in one or more radial planes or lie
        in planes normal to the axis of rotation.
The axis option is also used to select the type of projection for the
        nodes to the section lines. This projection determines how the section lines influence the
        nodes. Option 0 is preferred, which projects each node normal to the plane of each section
        line. Option 2 approximates the section line as a straight line and projects the nodes
        normal to the line, which is better for non-planar lines. Option 3 projects the nodes along
        a specified vector. Option 4 is like Option 2, but the projection line is forced to be in
        the specified plane, which is better for non-planar lines which you want to behave like
        planar lines. Option 5 does not project the nodes to the lines, but instead uses kriging to
        determine the morphing of the nodes.
","Inputs

m_entity_type
Must be set to elems.
m_mark_id
The mark ID for mapped elements. Valid values are 1 and 2.
t_entity_type
Must be set to nodes.
t_mark_id
The mark ID for trailing nodes. Valid values are 1 and 2.
i_line_list
The mark ID for the line list marking the initial position of the mapped elements. Valid values are 1 and 2.
f_line_list
The mark ID for the line list marking the final position of the mapped elements. Valid values are 1 and 2.
r_plane
Plane used for axis of rotation and projection options 3 and 4. Valid values are 1 and 2.
rotate
0 - Linear point to point mapping between lines. 
1 - Rotate nodes along with curvature difference between lines
blend
0 - Do not blend unselected nodes. 
1 - Blend all nodes other than mapped and fixed nodes 
2 - Blend only nodes on mesh between mapped and fixed nodes
axis
0 - Project nodes to line normal to the plane of the line (preferred) 
1 - Apply mapping about axis defined by r_plane

2 - Project nodes to line normal to the axis of the line 
3 - Project nodes to line along vector (r_plane normal) 
4 - Project nodes to line in plane (r_plane) 
5 - Use kriging to map nodes
sym
0 - Do not use symmetry (only option). 
con
0 - Do not use constraints. 
1 - Use constraints

","Examples
To map a mesh given two sets of three lines each using rotation, no blending, and
        projecting nodes normal to the planes of the lines:
*createmark elems 1 ""all""
*createmark nodes 1
*createlist lines 1 11 12 13
*createlist lines 2 21 22 23
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmaplinestolines elems 1 nodes 1 1 2 1 1 0 0 0 1
To map a mesh given two sets of three lines each about an axis using no rotation, and
        blending through the mesh: 
*createmark elems 1 ""all""
*createmark nodes 1
*createlist lines 1 11 12 13
*createlist lines 2 21 22 23
*createplane 1,1.0 0.0 0.0 1.0 0.0 0.0
*morphmaplinestolines elems 1 nodes 1 1 2 1 1 2 1 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
""Number of lines in each list must be equal."" - occurs if the number of lines found in
          i_line_list is different than the number of lines in
          f_line_list. 
""Not enough memory."" - occurs if there is not enough memory to complete the command.
"
2222,*morphmaptoequationvecoffset,"Description
Maps nodes to, or offset from, an equation using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the equation along a vector, normal to the surface of the
        equation, or normal to the shell elements attached to the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
equation
String containing an equation f(x,y,z). The equation can contain x, y, and z variables
            but should not contain an equals sign. The surface of the function is located where the
            value of the function equals zero.
origin
0 - Use global origin and system 
1 - Use global system with node ID = origin_id as the origin 
2 - Use local system with ID = origin_id as the origin and
            system
origin_id
The ID of node or system specified in origin. Ignored if
              origin is 0.
use_symmetry
0 - Do not use symmetry links 
1 - Use symmetry links
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to surface of equation 
2 or 12 - Project normal to attached shell elements
If offset is non-zero, the offset will be measured from the closest
            point on the equation for values of 0, 1 and 2. The offset will be measured along the
            projection vector or normal for values of 10, 11, and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the equation for values of
            project of 0, 1, and 2. The offset will be measured along the projection vector normal
            for values of project of 10, 11, and 12.

","Examples
To map all nodes to a sphere of radius 10.0 with an offset of 1.2, when not using
          *morphmaprecalc:
*createmark nodes 1 ""all""
*createmark handles 1
*createvector 1 1.0 0.0 0.0
*morphmaptoequationvecoffset nodes 1 handles 1 ""x*x+y*y+z*z-100.0"" 0 0 1 1 1 1 1 1.2
To map all nodes to a sphere of radius 10.0 positioned at a system along a vector:
*createmark nodes 1 ""all""
*createmark handles 1
*createvector 1 1.0 0.0 0.0
*morphmaptoequationvecoffset nodes 1 handles 1 ""x*x+y*y+z*z-100.0"" 2 1 1 1 0 1 1 0.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2223,*morphmaptolinevecoffset,"Description
Maps nodes to, or offset from, a specified line using the temporary shape created
          by *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the line along a vector, normal to the line, or spaced evenly
        along the line (if the nodes belong to edge domains).
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the input nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing the handles. Valid values are 1 and 2.
line_list
The ID of the list containing the input lines. Valid values are 1 and 2.
node_list
The ID of the list containing any nodes to define input lines. Valid values are 1 and 2.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to line 
2 - Fit to line
If offset is non-zero, the offset will be measured from the closest
            point on the line for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target. Not used if project
            is 2.
The offset will be measured from the closest point on the line for values of
              project of 0 and 1. The offset will be measured along the
            projection vector normal for values of project of 10 and 11.

","Example
To project nodes on mark 1 normal to the lines on list 1 with an offset of 1.2 when not
        using *morphmaprecalc:
*morphmaptolinevecoffset nodes 1 handles 1 1 1 0 1 1 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2224,*morphmaptoplanevecoffset,"Description
Maps nodes to, or offset from, the specified plane using the temporary shape created by
          *morphmaptshp and *morphmaptshpedge as a guide.
        Selected handles can optionally follow behind the morphing operation. 
Nodes can be projected on to the plane along a vector, normal to the plane, or projected
        normal to the elements touching the nodes.
","Inputs

entity_type_nodes
Must be set to nodes.
mark_id_nodes
The ID of the mark containing the nodes. Valid values are 1 and 2.
entity_type_handles
Must be set to handles.
mark_id_handles
The ID of the mark containing any following handles. Valid values are 1 and 2.
plane_id
The ID of plane created using *createplane to map to. Must be set
            to 1.
use_symmetry
0 - Do not use symmetry (only option)
use_constraints
0 - Do not use constraints 
1 - Use constraints
project
0 or 10 - Project along vector defined by vector_id

1 or 11 - Project normal to the plane 
2 or 12 - Project normal to shell elements touching nodes
If offset is non-zero, the offset will be measured from the closest
            point on the surfaces for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10, 11 and 12.
vector_id
The ID of vector created using *createvector for the projection
            direction. Must be set to 1.
mode
0 - If *morphmaprecalc has been used to calculate new influences 
1 - To recalculate new influences inside this command
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the plane for values of
              project of 0, 1, and 2. The offset will be measured along the
            projection vector normal for values of project of 10, 11, and
            12.

","Example
To map nodes on mark 1 to the x-y plane with an offset of 1.2 when not using
          *morphmaprecalc:
*createplane 1 0 0 0 1 0 0
*morphmaptoplanevecoffset nodes 1 handles 1 1 0 1 2 1 1 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2225,*morphmvskinsolve,"Description
This command will finish the morphing applied to the model when using morph volumes in
        ""skin only"" mode. When in ""skin only"" mode, only the exterior nodes of a solid element mesh
        will be morphed, leaving the interior unmorphed. This command completes the morphing
        process, allowing you to morph the model many times without needing to wait for all of the
        nodes to be updated. Then you may call this command to solve for the entire model. If the
        morph volumes are unmorphed since the last time this command was called or the morph volumes
        are not in ""skin only"" mode, this command will perform no action. 
Use the command *morphupdateparameter with argument ""mvon"" to set and
        unset the morph volumes to inactive, active, and skin only modes.
","Example
To solve for the interior nodes after morphing morph volumes in skin only mode:
*morphmvskinsolve
","Errors
None.
",
2226,*morphnodeslineoffset,"Description
This command will move the selected nodes to a line. The moving nodes may be projected to
        the line along a vector, normal to the line, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be
          offset from the line by the specified amount.
","Inputs

e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_line_list
The ID of the line list for the line to which the nodes will be moved. Valid values are 1 and 2.
t_node_list
The ID of the node list for the line to which the nodes will be moved. Valid values are 1 and 2.
m_node_list
The ID of the node list for the moving nodes. Valid values are 1 and 2.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to lines 
2 or 12 - Fit nodes to line
If offset is non-zero, the offset will be measured from the closest
            point on the lines for values of 0 and 1. The offset will be measured along the
            projection vector or normal for values of 10 and 11. Offsets will not be applied for a
            value of 2.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. If negative, all nodes beyond a distance calculated by multiplying the total
              perturbation of each moving node by the absolute value of the envelope and extended
              away from each moving node will be fixed.

If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point on the lines for values of nproj of
            0 and 1. The offset will be measured along the projection vector normal for values of
              nproj of 10 and 11.

","Example
To move a mark of nodes to be offset 1.2 from a line normal to the line and stretch all the
        elements in the model using the existing domains:
*createmark elems 1 ""all""
*createmark nodes 1 21 22 23
*createlist lines 1 2
*createlist nodes 1 31 32
*createlist nodes 2 51 52 53 54
*createvector 1 1.0 0.0 0.0
*morphnodeslineoffset elems 1 nodes 1 1 1 2 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2227,*morphnodesplaneoffset,"Description
This command will move the selected nodes to a plane. The moving nodes may be project to
        the plane along a vector, normal to the plane, or normal to any elements attached to the
        nodes. The fixed nodes are held in place and the affected elements (or all unfixed nodes in
        the model if integ is 3 or 6) are stretched according to the value of
          integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is
        positive) or a given multiple of the applied perturbations (if envelope
        is negative) away from the moving nodes.
The bias factors function as they would for handles except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6 all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
t_plane
The ID of the plane created using *createplane to which the nodes
            will be projected. Must be set to 1.
nproj
0 or 10 - Project along vector given by c_vec

1 or 11 - Project normal to target mesh 
2 or 12 - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point on the plane for values of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector or normal for values of 10, 11, 12, 15, and 16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
 The distance to offset nodes from the target.
The offset will be measured from the closest point on the plane for values of
              nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes to be offset 1.2 from a plane and stretch all the elements in the
        model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createplane 1 1.0 0.0 0.0 1.0 0.0 0.0
*createvector 1 1.0 0.0 0.0
*morphnodesplaneoffset nodes 1 elems 1 nodes 2 1 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2228,*morphnodesvectoroffset,"Description
This command will move the selected nodes to a line extending from
          a_node to b_node and extrapolated to infinity in
        both directions. The moving nodes may be projected to the line a long a vector, normal to
        the line, or normal to any elements attached to the nodes. The fixed nodes are held in place
        and the affected elements (or all unfixed nodes in the model if integ is
        3 or 6) are stretched according to the value of integ.
Temporary handles are created for all moving and fixed nodes to determine the stretching of
        the affected elements. If integ is 0, a general domain is temporarily
        created for the affected elements. If integ is 1, the domains currently
        in the model are used. If integ is 2, 1D, 2D, 3D, and edge domains are
        temporarily created for the affected elements, but the 2D domains are not partitioned. If
          integ is 3, then handle influences are applied using a spatial
        relationship rather than through a domain. If integ is 4, only the
        selected moving nodes are moved and all others are held fixed. If integ
        is 5, 1D, 2D, 3D, and edge domains are temporarily created for the affected elements and the
        2D domains are partitioned. Any handles created due to partitioning are moved based on their
        distance from the moving and fixed nodes. If integ is 6, then handle
        influences are applied using the Kriging algorithm. If integ is 7, then
        handle influences extend only up to a given distance (if envelope is positive) or a given
        multiple of the applied perturbations (if envelope is negative) away from
        the moving nodes.
The bias factors function as they would for handles, except that all moving nodes will have
        the mbias value and all fixed nodes will have the
          fbias value.
If no elements are selected and nproj is 2, 5 or 6, all elements in the
        model are used to determine projection vectors.
If integ is set to 3, 6, or 7, nodes on undisplayed elements and
        components can be morphed, fixed, or excluded depending on the value of
          undisplayed.
If offset is non-zero, the moving nodes will be offset from the mesh by
        the specified amount.
","Inputs

m_entity_type
Must be set to nodes.
m_entity_mark
The mark ID of the moving nodes. Valid values are 1 and 2.
e_entity_type
Must be set to elems.
e_entity_mark
The mark ID of the affected elements. Valid values are 1 and 2.
f_entity_type
Must be set to nodes.
f_entity_mark
The mark ID of the fixed nodes. Valid values are 1 and 2.
a_node
The ID of the base node for the vector onto which the nodes will be projected.
b_node
The ID of the pointer node for the vector onto which the nodes will be projected.
nproj
0 or 10 - Project along vector given by c_vec
1 or 11 - Project normal to target mesh 
2 or 12  - Project normal to attached elements 
5 or 15 - Project normal to attached elements using smoothed normals 
6 or 16 - Project normal to attached elements using CFD corners
If offset is non-zero, the offset will be measured from the closest
            point along the target vector for values of 0, 1, 2, 5 and 6. The offset will be
            measured along the projection vector or normal for values of 10, 11, 12, 15, and
            16.
c_vec
The ID of vector created using *createvector for the projection
            direction (nproj=0). Must be set to 1.
integ
0 - Free edges (a single general domain) 
1 - Use existing domains 
2 - Inferred edges (1D, 2D, 3D, and edge domains - no partitioning) 
3 - Morph all nodes using a proximity algorithm 
4 - Morph all moving nodes and fix the unselected nodes 
5 - Partitioned edges (1D, 2D, 3D, and edge domains with partitioning) 
6 - Morph all nodes using the Kriging algorithm 
7 - Morph all nodes within an envelope around the moving nodes
mbias
Bias factor of moving nodes.
fbias
Bias factor of fixed nodes.
envelope
If positive, all nodes beyond the given distance away from the moving nodes will be
            fixed. 
If negative, all nodes beyond a distance calculated by multiplying the total
            perturbation of each moving node by the absolute value of the envelope and extended away
            from each moving node will be fixed.
If integ is set to 7, the calculated distance defines an envelope
            around the moving nodes within which the morphing of those nodes will linearly taper
            from fully matching the nearest moving node to zero at the edge of the envelope. If any
            fixed nodes are within the envelope, they will also reduce the morphing of nearby
            nodes.
undisplayed
If integ is set to 3, 6, or 7, nodes which are not displayed can be
            affected by the morphing. This defines how undisplayed nodes are handled: 
0 - Morph nodes on undisplayed elements 
1 - Fix nodes on undisplayed elements, they will function just like nodes on the fixed
            mark 
2 - Exclude nodes on undisplayed elements, they will not be morphed nor affect the
            morphing
offset
The distance to offset nodes from the target.
The offset will be measured from the closest point along the target vector for values
            of nproj of 0, 1, 2, 5 and 6. The offset will be measured along the
            projection vector normal for values of nproj of 10, 11, 12, 15 and
            16.

","Example
To move a mark of nodes normal and offset 1.2 from a vector defined by nodes 52 and 53 and
        stretch all the elements in the model using the existing domains:
*createmark nodes 1 11 12 13
*createmark elems 1 ""all""
*createmark nodes 2 21 22 23
*createvector 1 1.0 0.0 0.0
*morphnodesvectoroffset nodes 1 elems 1 nodes 2 52 53 0 1 1 1.0 1.0 0.0 0 1.2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2229,*morphorganizedomainsplit,"Description
Splits edge domain at given node.
","Inputs

node
ID of node.
dptr
ID of domain.

","Example
*morphorganizedomainsplit 12 32
This command splits the given edge domain into two edge domains at the given node.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2230,*morphrecalcmvhandles,"Description
none.
","Example
*morphrecalcmvhandles

This command recalculates the influences for all handles on morph volumes. This will
        recalculate the dependent handle influences as well as influences between handles and nodes
        on morph volumes which do not have handles on them.
","Errors
None.
",
2231,*morphremoveconstraint,"Description
Remove constraint(s). 
","Inputs

nodetype
Nodes or morphconstraints 
marknode
Node or morphconstraint mark number.
option
0 - Remove nodes on mark from morph constraints. 
1 - Remove morph constraints on mark. 
2 - Remove all morph constraints.

","Example
*morphremoveconstraint (NODES,1,1)
If option is 0, any constraints on the nodes on the mark are removed. 
If option is 1, all constraints are removed. Note: The options have
          changed from HyperMesh versions prior to 8.0.

","Errors
None.
"
2232,*morphsavedata,"Description
Saves global handles and shapes to a file. 
","Inputs

morphdatafile
Name of file to be written.

","Example
*morphsavedata (""global.dat"")
Global handles and all shapes that use global handles are written to the specified file in
          ASCII format.
","Errors
None.
"
2233,*morphsaveshape,"Description
Reads local shapes stored in the specified file. 
","Inputs

stype
Shapes
smark
Mark number of shapes.
savefile
Name of file to be saved.
filetype
0 - Grid IDs and perturbations 
1 - Grids, elements, and perturbations

","Example
*morphsaveshape (SHAPES,1,""morphing.shp"",1)

Saves the shapes on the mark as either nodes and perturbations
        (filetype=0), or as nodes, node perturbations, and elements
          (filetype 1). 
Shapes saved as filetype =0 will be saved in the same format as OptiStruct shape variables. 
Shapes saved as filetype =1 can later be read in and applied to a file
        with a completely different mesh with the saved shapes being applied to the nearest nodes in
        the new model. The saved shapes can also be read in as their original elements and
        perturbations (see *morphloadshape). 
","Errors
None.
"
2234,*morphsetsmoothtests,"Description
Sets the element test criteria used for shape combination checking via
          *morphshapesmooth. 
This command allows you to edit the element test criteria for shape combination checking
        used by the *morphshapesmooth command. You can make every supported test
        active or inactive for each of the six basic element types (trias, quads, tetras, pyras,
        pentas, and hexas) as well as set any thresholds for the warning, error, and invalid limits.
        Currently only aspect ratio, skew, minimum angle, maximum angle, warpage, tetra collapse,
        and jacobian tests are supported. 
","Inputs

mode
0 - Set all element tests to be inactive 
1 - Set all element tests to the default values 
2 - Set one individual test to be active or inactive and set limits for the test

","Example
To clear all tests and then assign values of 0.3, 0.2, and 0.1 for quad element
        Jacobian:
*morphsetsmoothtests 0 0 0 0 0.0 0.0 0.0
*morphsetsmoothtests 2 1 1 6 0.3 0.2 0.1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2235,*morphshapeapplynodes,"Description
Applies the shapes on the mark to only the selected nodes.
","Inputs

shtype
Shapes
shmark
Shape mark number.
ntype
Nodes
nmark
Node mark number.
mult
Multiplier to applied shapes.

","Example
*morphshapeapplynodes (SHAPES,1,NODES,1,2.0)
Shapes on the mark are applied to the model consecutively and scaled up or down by the
        multiplier. Shapes will only be applied to the selected nodes.
","Errors
None.
"
2236,*morphshapecreateorthogonalbound,"Description
This command will convert all the shapes on the first mark into shapes, design variables,
        equations, and dlink2 entities when using the constraint and system methods. An initial
        value along with upper and lower bounds can be set for the design variables.
For the constraint method, a non-linear shape will be deduced by applying each shape on
          the s_mark_id by a number of factors from 0.0 to 1.0 equal to the value
        of prec, enforcing any active constraints, and fitting a curve through
        the intermediate positions for each node.
For the mid-shape method, a non-linear shape will be deduced by fitting a shape through a
        curve beginning at the unperturbed position, traveling through the position attained when
        the shape on the md_mark_id is applied, and ending at the position
        attained when the shape on the s_mark_id is applied.
For the system method, each shape on s_mark_id will be assumed to rotate
        about the z-axis of the selected system instead of moving linearly in the xy plane. A
        non-linear shape will be deduced from the circular node paths.
For all methods, the non-linear paths of the nodes are represented by a
        pair of linear shape variables, plus a corrective shape variable, which are linked together
        via equations and dlink2 entities. The result is a single design variable which, when
        changed, applies the linear shape variables in such a way that the nodes move along
        non-linear paths.
For the constraint and system methods, if multiple shapes are selected,
        conflicts between each pair of shapes (such as when the application of one shape causes
        another to violate constraints) are detected and resolved by adding a corrective shape which
        is linked to those two shapes through an equation and a dlink2 entity.
","Inputs

s_entity_type
Must be set to shapes.
s_mark_id
The ID of the mark containing the shapes. Valid values are 1 and 2.
md_entity_type
Must be set to shapes.
mdmark
The ID of the mark containing the mid-shapes (for mid-shape method). Valid values are 1 and 2.
system_id
The ID of the system about which shapes are defined (for system method).
method
0 - non-linearity is due to constraints 
1 - non-linearity is deduced from mid-shape 
2 - non-linearity is due to rotation about a system
prec
Number of intermediate positions for non-linear approximation.
tol
Tolerance for establishing linear versus non-linear.
initial
The initial value of the design variables.
l_bound
The lower bound of the design variables.
u_bound
The upper bound of the design variables.

","Examples
To create non-linear shapes, equations, etc., for all the shapes in the model using the
        constraint method, with 0.5 as the initial value, and lower and upper bounds of 0.0 and
        1.0:
*createmark shapes 1 ""all""
*morphshapecreateorthogonalbound shapes 1 shapes 1 0 0 10 0.001 0.5 0.0 1.0
To create non-linear shapes, equations, etc., for shape ""full"" using shape ""mid"" as the
        mid-shape, with 0.5 as the initial value, and lower and upper bounds of 0.0 and 1.0:
*createmark shapes 1 ""full""
*createmark shapes 2 ""mid""
*morphshapecreateorthogonal shapes 1 shapes 2 0 1 10 0.001 0.5 0.0 1.0
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphshapecreateorthogonalbound...} ] } {
   # Handle error
}
"
2237,*morphshapelinkedpush,"Description
This command will add the specified shape to an internal list along with the multiplier for
        the shape which you wish to apply. The list may contain one or more shapes. Calling the
          command *morphshapelinkedapply will apply all the shapes on the list at
        their specified multiplier values. It will also apply any shapes linked to the applied
        shapes via desvar, deqatn, and dlink2 cards, such as those created during non-linear design
        variable generation. Calling *morphshapelinkedapply will clear the
        internal list of shapes and multipliers.
","Inputs

shape_id
The ID of the shape to add.
mult
The multiplication factor for the shape.

","Example
To mark shape ID 3 with multiplier of 0.5:
*morphshapelinkedpush 3 0.5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2238,*morphshrinkmvols,"Description
This command performs one or more iterations of shrinking to the selected morph volumes
        with the objective of meeting the target buffer percentage regardless of the shape of the
        mesh. 
Two methods are supported: implicit and explicit; and can be set with the
          iface option. Explicit is the older, slower method which uses
        externally calculated sensitivities for the interior nodes, and implicit is the newer,
        faster method which uses internally calculated sensitivities for the interior nodes. After
        using the intrinsic method, this command should be called with iface = 6
        to clear the memory allocated for quicker iterations. 
To perform iterations one at a time, call this command with itermax set
        to -1 for the first iteration and then decrement the value for each subsequent iteration
        (i.e. -1 first, then -2, -3, etc.). This enables proper convergence while retaining the
        option to abort the process at any time. 
Assigning a vector and setting the uvec flag will restrict the movements
        of the nodes which define the morph volumes so that they can only move in the direction of
        the vector. This will apply to all the nodes of the morph volumes.
","Inputs

ctype
morphvolumes
cmark
Mark ID of morph volumes to be shrunk. Valid values are 1 and 2.
buffer
Percentage buffer zone target.
iface
0 - extrinsic mode + do not allow inner faces to move 
1 - extrinsic mode + allow inner faces to move 
3 - extrinsic mode + grow faces to full height 
4 - intrinsic mode + do not allow inner faces to move 
5 - intrinsic mode + allow inner faces to move 
6 - intrinsic mode, clear memory allocated (no shrinking is performed)
itermax
A positive value indicates the maximum number of iterations allowed. 
A negative value indicates that one iteration is performed.
uvec
0 - Allow morph volume nodes to move in all directions. 
1 - Limit morph volume nodes to move only along vector.
vec
Vector constraining the movement of morph volume nodes.

","Examples
To shrink all the morph volumes in the model while allowing internal face movement and not
        restricting the movement of the corner nodes for four iterations:
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 4 0 1
 To shrink all the morph volumes in the model, allowing internal face movement and not
        restricting the movement of the corner nodes, for four consecutive iterations:
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 0 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -1 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -2 0 1
*createvector 1 1.0 0.0 0.0
*createmark morphvolumes 1 ""all""
*morphshrinkmvols morphvolumes 1 10.0 1 -3 0 1
","Errors
This command does not return any errors that can be handled.
"
2239,*morphstoredomains,"Description
Stores or restores a copy of current domains, handles, and shapes.
","Inputs

mode
The mode you want to use the command in:
1 - Store domains 
2 - Restore domains 
3 - Free (empty) the memory used for storage



","Example
*morphstoredomains (1)
This command either stores a copy of all the handles, domain, and shapes in the database,
        restores that copy - replacing the current entities in the database, or clears the memory
        where the stored copy was kept. This is how HyperMorph enables
        the reject command for the extensive changes which can result from domain creation or
        updating. 
Typical usage would be to call this command with mode = 1, call any
        command which modifies handles, domains, and shapes, and then call this command with
          mode = 2 if you want to reject the previous changes. Then make sure to
        call this command with mode = 3 to free up the memory used for
        storage.
","Errors
None.
"
2240,*morphstoremorphvolumes,"Description
Stores or restores a copy of current morph volumes and handles.
","Inputs

mode
1 = store morph volumes 
2 = restore morph volumes 
3 = free memory used for storage

","Example
*morphstoremorphvolumes (1)

This command either stores a copy of all the morph volumes and handles in the database,
        restores that copy - replacing the current entities in the database, or clears the memory
        where the stored copy was kept.This is how HyperMorph enables the reject command for the
        extensive changes which can result from morph volume creation or updating. 
Typical usage would be to call this command with mode = 1, call any command which modifies
        morph volumes, and then call this command with mode = 2 if you wish to reject the changes.
        Be sure to call this command with mode = 3 to free up the memory used for storage. 
","Errors
None.
"
2241,*morphsymmetrycreateaxis,"Description
Creates symmetry dependent on system.
","Inputs

name
Name of symmetry.
sysptr
ID of system.
domaintype
Domains
markdomain
Domain mark number.
enforce
0 = approximate 
1 = enforced
multilat
0 = unilateral 
1 = multilateral
type
Type of symmetry.
ucyc
Number of cycles for cyclical symmetry.
orient
0 = default 
1 = x-axis 
2 = y-axis 
3 = z-axis
mv
0 = do not apply to morph volumes 
1 = apply to morph volumes

","Example
*morphsymmetrycreateaxis (""mirror"",2,DOMAINS,1,1,1,10,3,1,0)

Creates a symmetry dependent on the specified system for the domains on the mark. The
        symmetry has the values given in ‘enforce’, ‘multilat’, type, ucyc, orient, and mv.
","Errors
None.
"
2242,*morphsymmetryupdatebyd,"Description
Update symmetries for a domain.
","Inputs

dptr
ID of domain.
symtype
Symmetries
marksym
Symmetry mark number.

","Example
*morphsymmetryupdatebyd (4,SYMMETRYS,1)
Domain will be updated to use the symmetries on the mark.
","Errors
None.
"
2243,*morphupdatedisplay,"Description
Updates the display of morphing entities.
","Inputs

type
0 = all morphing entities 
1 = global handles and domains 
2 = local handles and domains 
3 = morphvolumes 
4 = morphconstraints 
5 = symmetries 
6 = shapes
mode
0 = turn off 
1 = turn on 
2 = turn on only for entities on displayed elements 

","Example
*morphupdatedisplay (0,0)
Note that if the type is set to zero (all morphing entities) the mode will be the same for
        all types.
","Errors
None.
"
2244,*morphupdateendbymvol,"Description
This command will update the end conditions (free, fixed, master-slave, or continuous) for
        edges on the morph volumes specified in the marks. Connecting edges from one group of morph
        volumes to another is supported as well as specifically dealing with radial and tangential
        edges for cylindrical morph volume matrices. The results depend on the selected mode.
","Inputs

a_entity_type
Must be set to hypercubes.
a_mark_id
The mark ID of the hypercubes for end 'a'. Valid values are 1 and 2.
b_entity_type
Must be set to hypercubes.
b_mark_id
The mark ID of the hypercubes for end 'b'. Valid values are 1 and 2.
vector
Temporary fixed end orientation vector ID.
system_id
The ID of the origin system for radial and tangential connections (modes 8, 9, 10, and
            11).
mode
1 - Free all edges on mvols on a_mark_id

2 - Free edges on mvols on a_mark_id from those on mvols on
              b_mark_id 
3 - Fix all edges on mvols on a_mark_id to vector which are within
            45 degrees 
4 - Free all edges on mvols on a_mark_id within 45 degrees of
            vector 
5 - Create master-slave connection between all edges on mvols on
              a_mark_id to all on mvols on b_mark_id within 60
            degrees of each other 
6 - Create continuous connection for all edges on mvols on
              a_mark_id within 60 degrees of each other 
7 - Create continuous connection between all edges on mvols on
              a_mark_id to all on mvols on b_mark_id within 60
            degrees of each other 
8 - Free all edges on mvols on a_mark_id which run radially from
            the selected system 
9 - Free all edges on mvols on a_mark_id which run tangentially
            about the selected system 
10 - Create continuous connection for all edges on mvols on
              a_mark_id which run radially from the selected system within 60
            degrees of each other 
11 - Create continuous connection for all edges on mvols on
              a_mark_id which run tangentially about the selected system within
            60 degrees of each other 
12 - Create a continuous connection for all edges on mvols on
              a_mark_id within 30 degrees of vector

","Examples
To create tangencies for all edges which connect roughly parallel end to end:
*createmark hypercubes 1 ""all""
*createmark hypercubes 2
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 0 6
To free tangencies for all edges which run tangentially about a system:
*createmark hypercubes 1 ""all""
*createmark hypercubes 2
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 1 9
To create a master-slave tangency for the edges on one morph volume to the edges on another
        morph volume:
*createmark hypercubes 1 14
*createmark hypercubes 2 15
*createvector 1 1.0 0.0 0.0
*morphupdateendbymvol hypercubes 1 hypercubes 2 1 0 5
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2245,*morphupdatemvedgenodes,"Description
Updates the mid-nodes of the specified morph volume edge.
","Inputs

nodes
Mark number of node list.
hand
0 = do not create handles for morph volumes 
1 = create handles for morph volumes

","Example
*morphupdatemvedgenodes (1,1)
This command changes the nodes for a given morph volume edge to be those of the node list.
        The first and last nodes on the node list should be the original end nodes of the morph
        volume edge.
","Errors
None.
"
2246,*morphupdateparameter,"Description
This command updates integer/real morphing parameters.
","Inputs

parameter
The parameter of interest. Valid parameters are: 
handlesize: radius size of largest global handle (red) 
handletolerance: no larger than 1/10th of handle size - used to calculate a number of
            small tolerance measures in HyperMorph

symsize: symmetry size domaincolor: range is 0 through 63 inclusive 
symcolor: range is 0 through 63 inclusive 
facecolor: range is 0 through 63 inclusive 
globalmethod: method for passing down perturbations of global handles to the mesh:
1 - direct (to nodes) 
2 - hierarchical (to local handles) 
3 - mixed method (to local handles or nodes directly if outside local
                domains)


globalsolve: method for solving global domains
1 - geometric 
2 - spatial 
3 - Kriging (revert to geometric if unselected in options panel) 
4 - Kriging (revert to spatial if unselected in options panel)


domainangle: break angle for domains during partitioning 
curvetolerance: curvature tolerance angle for domains during partitioning 
partitionmethod: algorithm used for partitioning 2D domains which are at least 33% quads
0 - element based 
1 - node based


partitionmethodtria: algorithm used for partitioning 2D domains which are at least 67% trias
0 - element based 
1 - node based


partitionorder:
1 - divide when angle exceeds the domainangle 
2 - divide when angle exceeds the domainangle and when the angle between elements
                changes more than curvetolerance


partitionusegeometry: partition 2D domains along associated surfaces
0 - off 
1 - on


partitionaddgeometry: add partitions found outside of associated surfaces to
            partitions created based on surfaces
0 - off 
1 - on


influencethreshold: 0.0 - 1.0 minimum influence coefficient (must be greater than
            zero) 
globalsystemid: ID of system used for morphing 
debug: flag used for diagnostic file output
0 - off 
1 - on


modechange: flag which denotes changes to the model which will trigger a refresh of
            the domains and handles. If set to 1, call *morphupdatecheck to
            refresh model
0 - unchanged 
1 - changed


bigdomainlimit: smallest number of elements in domain for it to be considered a ""large
            domain"" 
bigdomainsolve: frequency for solving large domains
0 - manual 
1 - on release 
2 - real time


biasstyle: type of biasing used for handles
0 - exponential 
1 - sinusoidal


symlinks: use of symmetry links when perturbing handles
0 - all off 
1 - on (only active symmetries will be used)


constraints: apply constraints after morphing
0 - all off 
1 - on (only active morphconstraints will be applied)


qaparam: type of check used during auto quality and auto remesh - use negative values
            for minimum check, positive values for maximum check
1 - 1D length 
2 - 2D warpage 
3 - 2D skew 
4 - 2D aspect ratio 
5 - 2D length 
6 - 2D jacobian 
7 - 2D chordal deviation 
8 - 2D quad angle 
9 - 2D tria angle 
10 - 3D warpage 
11 - 3D aspect 
12 - 3D tetra altitude aspect 
13 - 3D skew 
14 - 3D volumetric skew 
15- 3D length 
16 - 3D jacobian 
17 - 3D tetra collapse 
18 - 3D quad angle 
19 - 3D tria angle 
20 - 1D time step 
21 - 2D and 3D time step - no added mass 
22 - 2D and 3D time step - added mass 
23 - All elements time step


qavalue: value of qaparam to be measured against 
qaplot: type of plotting of failed elements during qa check
0 - highlight failed elements 
1 - used color assigned plot


qanegjac: check for negative jacobians after morphing
0 - off 
1 - on


smoothmeth: method used for automatic smoothing
0 - none 
1 - autodecide 
2 - size corrected 
3 - shape corrected 
4 - angle corrected 
5 - QI optimized 
6 - kriging (or autodecide for elements outside of local domains) 
7 - kriging (or size corrected for elements outside of local domains) 
8 - kriging (or shape corrected for elements outside of local domains) 
9 - kriging (or angle corrected for elements outside of local domains) 
10 - kriging (or QI optimized for elements outside of local domains) 
11 - kriging (ignore elements outside of local domains)


smoothiter: number of iterations for smoothmeth (options 1 - 4 and 6 - 9 only) 
cubestat: status of morph volume database (internal use only) 
mvcolor: range is 0 through 63 inclusive 
mvdraw: number of points along morph volume edges during drawing 
mvtol: 0.0 - 1.0, determines whether a node is within a given morph volume 
mvmode: method for calculating morph volume edge shape
0 - Lagrange 
1 - spline


mvon: morphing of nodes inside of morph volumes
0 - inactive 
1 - active 
2 - skin only


mvgraph: style of graphics for morph volumes
0 - wireframe 
1 - transparent level 1 (low) 
2 - opaque 
3 - transparent level 2 (medium) 
4 - transparent level 3 (high)


mconcolor: default color for morphconstraints - range is 0 through 63 inclusive 
remesh: frequency of auto-remeshing
0 - off 
1 - manual 
2 - on release


remeshtype: elements used when auto-remeshing
0 - trias 
1 - quads 
2 - mixed 
3 - right trias


remeshsize: use size control when auto-remeshing
0 - off 
1 - on


remeshskew: use skew control when auto-remeshing
0 - off 
1 - on


remeshpres: preserve shapes when auto-remeshing
0 - off 
1 - on


remeshfail: percentage of failed elements needed to trigger auto-remeshing 
remeshtarg: default size of remeshed elements during auto-remeshing 
rmthreed: flag for remeshing 3D elements during auto-remeshing
0 - do not remesh 3D and 2D face domains 
1 - remesh 3D and 2D face domains


rmedges: flag for remeshing edge domains during auto-remeshing
0 - do not remesh edge domains 
1 - remesh edge domains


remeshstat: internal use only 
kriging: frequency of kriging solver
0 - off 
1 - manual 
2 - manual (internal use only) 
3 - automatic


krigtype: kriging will be applied to the following entities:
0 - none 
1 - global domains 
2 - local domains 
3 - local and global domains 
4 - morph volumes 
5 - morph volumes and global domains 
6 - morph volumes and local domains 
7 - morph volumes, local, and global domains


krigdrift: drift value for kriging algorithm
0 - none 
1 - constant 
2 - linear 
3 - quadratic 
4 - cubic 
5 - trigonometric


krigcovar: covariance value for kriging
0 - h 
1 - h^2 * log(h) 
2 - h^3 
3 - exp(-1/x)


krignugget: use nugget value
0 - off 
1 - on


krignugval: value of nugget used in kriging algorithm 
connectors: style of morphing for connectors
0 - off 
1 - solve all as clusters 
2 - solve all as stretchable 
3 - solve seam and area connectors as stretchable and others as clusters


onedmethod: method used for 1D and connector domains
1 - independent 
2 - slave 
3 - master 
4 - cluster


onedrot: rotation of 1D cluster domains and connectors
0 - no rotation 
1 - tilting only (out-of-plane) 
2 - spinning only (in-plane) 
3 - full rotation


fesolver: type of solver to use for domains under the fesolverlimit
0 - influence coefficients 
1 - linear (OptiStruct) 
2 - non-linear (Radioss)


fesolve: frequency of fesolver solution
0 - manual 
1 - on release 
2 - real time (interactive)


fesolverlimit: maximum number of elements in a domain to be solved using the fesolver 
feuser: specifies which properties and material to use for solver
0 - automatically generate properties and materials 
1 - use properties and materials in the model


ires: frequency of fea results plotting for the current model
0 - off 
1 - manual 
2 - on release 
3 - real time


irescon: plotting style for fea results
0 - contour plot 
1 - assign plot


iresmin: set the scale minimum value for fea results plotting
0 - find minimum value 
1 - use value given in iresminval


iresmax: set the scale maximum value for fea results plotting
0 - find maximum value 
1 - use value given in iresmaxval


iresminval: value of scale minimum used when plotting fea results 
iresmaxval: value of scale maximum used when plotting fea results 
iresmesh: color of mesh during fea results plotting (range is 0 through 63 inclusive) 
irescomp: results component for fea results plotting
0 - magnitude 
1 - x component 
2 - y component 
3 - z component


iressolver: Solution called during fea results plotting
1 - Linear Static 
2 - Nonlinear Explicit 
3 - Stamping 1-Step 
4 - Stamping Incremental


iresmmres: minimum/maximum title plotting during fea results plotting
0 - do not plot minimum and maximum titles 
1 - plot minimum and maximum titles


iresplinfo: info title plotting during fea results plotting
0 - do not plot info titles 
1 - plot info titles


iresstmpx: x component of the stamping direction for the 1-step solver 
iresstmpy: y component of the stamping direction for the 1-step solver 
iresstmpz: z component of the stamping direction for the 1-step solver
value
The new value of the parameter.

","Example
To update the current biasing style for handles to sinusoidal:
*morphupdateparameter biasstyle 1
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*morphupdateparameter...} ] } {
   # Handle error
}
"
2247,*morphvolumecreatenodes,"Description
Creates a morph volume for the given nodes enclosing the elements on the mark.
","Inputs

nodes
Mark number of node list.
etype
Elems
emark
Mark number of elements to be enclosed.
han
0 = do not create handles for morph volumes 
1 = create handles for morph volumes
ord
Order of morph volumes.
tan
0 = no tangency 
1 = make neighboring morph volume edges continuously tangent
nauto
0 = do not register all nodes found inside morph volume 
1 = register all nodes found inside morph volume

","Example
*morphvolumecreatenodes (1,ELEMS,1,1,1,1,1)
This command creates a morph volume enclosing the elements on the mark and connecting to
        the specified nodes on the list. 
The selected nodes must either define at least one morph volume face or be eight in number.
        The element mark may be empty, but if it is not the morph volume will be created in such a
        way that it encloses the elements if possible. 
The order of the morph volumes (ord) refers to the number of mid-nodes along each edge with
        an order of one meaning there will be no mid-nodes, an order of two meaning that there will
        be one mid-node, and so forth. 
","Errors
None.
"
2248,*morphvolumeequivalence,"Description
This command will join all morph volumes on the mark whose faces are within a set
        tolerance. Creating tangency between joined morph volumes and automatic registering of nodes
        inside reshaped morph volumes are optional features.
","Inputs

c_entity_type
Must be set to hypercubes.
c_mark_id
The mark ID of the hypercubes. Valid values are 1 and 2.
tol
Maximum distance between morph volumes for joining.
tan
0 - Do not create tangency between edges of joined morph volumes 
1 - Create tangency between edges of joined morph volumes
nauto
0 - Do not register new nodes 
1 - Register new nodes

","Example
To join all morph volumes which are within 10 model units of each other:
*createmark hypercubes 1 ""all""
*morphvolumeequivalence hypercubes 1 10.0 1 1
","Errors
 Incorrect usage of *morphvolumeequivalence results in a Tcl error. To detect errors, you
        can use the catch
        command:if { [ catch {*morphvolumeequivalence hypercubes 1 10.0 1 1} ] } {
# Handle error
}

"
2249,*move_clipping_sphere_to_XYZ_and_fit,"Description
Re-centers the view around a specified point, zooms in or out to fit a specified radius
        around that point, and does all of this in a specified number of frames of animation rather
        than instantly.
","Inputs

x_center

y_center

z_center

radius

n_animation


","Example
 To pan the viewpoint to center on a point with coordinates (22, 17.5, 93) in 90 frames of
        animation, and zoom to display everything within 25 units of that point:
*move_clipping_sphere_to_XYZ_and_fit(22,17.5,93,25,90)

Using frames of animation rather than an instantaneous re-center allows a sense of relative
        location between the initial view point and the new one.
","Errors
None.
"
2250,*moveincludecontents,"Description
This command moves the contents of one include to another, with an option to delete the
        source include.
","Inputs

source_id
The ID of the source include file. If this is not available, use 0 and specify
              source_shortname.
source_shortname
The shortname of the source include file. This is only used if
              source_id is 0 or cannot be found. If this is not required, specify
            double quotes """".
dest_shortname
The shortname of the destination include file.
delete
Flag to indicate if the source include should be deleted. Valid values are: 
0 - Do not delete 
1 - Delete

","Example
To move the contents of include with shortname front_door to include
        with shortname front_door_new, deleting the source include:
*moveincludecontents 0 ""front_door"" ""front_door_new"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2251,*movemarkgroup,"Description
Moves master/slave elements from one group to another.
","Inputs

entity_type
Must be set to elems.
mark_id
The ID of the mark containing the master/slave elements to move. Valid values are 1 and 2.
name
The name of the group to move the entities to.

","Example
To move all elements from group1 to group2: to :
*createmark elems 1 ""by group name"" group1
*movemarkgroup elems 1 group2
","Errors
Incorrect usage results in a Tcl error. To detect errors, you can use the catch
        command:if { [ catch {*movemarkgroup...} ] } {
   # Handle error
}
"
2252,*nameview,"Description
Gives a name to a view.
","Inputs

number
View number (1 - 5)
name
 Name of view (max 16 characters).

","Example
To assign the name primary to view 1:
*nameview(1,""primary"")


","Errors
None.
"
2253,*nodeaddtempmark,"Description
Adds nodes to the temporary node mark. 
","Inputs

node
The node to be added to the temporary node mark. 

","Errors
None.
",
2254,*nodecreateatintersection,"Description
This command creates nodes or points at locations of intersection between two sets of input
        geometries. Only intersections between entities from different sets are calculated and are
        used to create nodes or points. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a surface edge to a parent surface is
        undefined and can return unexpected or varied results.
","Inputs

entity_type1
Type of input entities of the first set. Valid values are lines.
mark_id1
The ID of the mark of the first entity type. Valid values are 1 and 2.
entity_type2
Type of input entities of the second set. Valid values are lines, surfs, faces or
            solids.
mark_id2
The ID of the mark of the second entity type. Valid values are 1 and 2.
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes 
1 - Create points

","Examples
To create nodes at the intersections between line 12 and surface 20:
*createmark lines 1 12
*createmark surfs 1 20
*nodecreateatintersection lines 1 surfs 1 0
 To create points at intersection between lines 12 and 14:
*createmark lines 1 12
*createmark lines 2 14
*nodecreateatintersection lines 1 lines 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2255,*nodecreateatplaneintersection,"Description
This command creates nodes or points at locations of intersection between a selection of
        input geometries and a plane or vector. 
If there is overlap (continuous intersection) between the entities, the result is
        undefined. For example, finding the intersection of a line that lies exactly on the
        specified plane is undefined and can return unexpected or varied results.
","Inputs

entity_type
Type of input entities. 
If plane_use is 0 (plane as input entity), then the only valid
            value is lines. 
If plane_use is 1, 2 or 3 (vector as input entity), then valid
            values are lines, surfs, faces or solids.
mark_id
The ID of the mark of the first entity type. Valid values are 1 and 2.
plane
Input temporary plane ID (if plane_use is 0) created using
              *createplane or vector ID (plane_use is 1, 2 or
            3) created using *createvector. This should always be set to 1.
plane_use
Parameter specifying whether input data specified by plane parameter is interpreted as
            a plane of vector. Valid values are: 
0 - Input data specified by plane parameter is used as plane. 
1 - Input data specified by plane parameter is used as undirected vector (straight
            line that passes through the base point specified by plane parameter in the direction of
            the normal specified by plane parameter). 
2 - Input data specified by plane parameter is used as directed vector (ray that
            starts at base point specified by plane parameter and continues in the direction of
            normal specified by plane parameter). 
3 - Input data specified by plane parameter is used as finite length vector (segment
            that starts at base point specified by plane parameter and ends at the end of normal
            vector specified by plane parameter).
point_flag
Parameter specifying whether nodes or points are created. Valid values are: 
0 - Create nodes 
1 - Create points

","Examples
To create nodes at the intersections between the line with ID 12 and the plane z=2:
*createmark lines 1 12
*createplane 1 0.0 0.0 1.0 0.0 0.0 2.0
*nodecreateatplaneintersection lines 1 1 0 0

To create points at the intersection between surface 10 and a ray that starts at point (1,
        2, 4) and propagates in the direction of y axis:
*createmark surfs 1 10
*createplane 1 0.0 1.0 0.0 1.0 2.0 4.0
*nodecreateatplaneintersection surfs 1 1 2 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2256,*nodecreatebetweennodes,"Description
This command creates nodes or points at points on given line or surface, between given
        nodes. The input nodes are first projected onto the line or surface. The nodes/points are
        created between these projected points.
","Inputs

entity_type
Valid types are ""line"" or ""surf"".
entity_id
ID of the surface or the line, on which nodes are going to be created.
node_list
List of nodes, between which additional nodes are going to be created.
num_intervals_array
Array containing the number of intervals to be created between each node in the
              node_list.
array_size
Size of the array num_intervals_array. Note that this size must be
            always one less than the number of nodes in the node_list.
biasstyle
The type of biasing to use:
0 - Linear biasing 
1 - Exponential biasing 
2 - Bell-curve biasing


biasintensity
The biasing intensity value. This value must be between -20 and 20.
options
Parameter specifying whether nodes or points are created. Valid values are:
0 - Nodes created. 
1 - Points created.



","Example
To create nodes on line 12, between nodes 8, 10 and 11, such that we want 20 intervals
        between nodes 8 and 10, and 5 intervals between nodes 10 and 11: 
*createlist nodes 1 8 10 11 
*createarray 2 20 5
*nodecreatebetweennodes lines 12 1 1 2 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2257,*nodemarkcleartempmark,"Description
Clears a group of nodes from the temporary node mark.
","Inputs

mark 
The ID of the mark containing the nodes to be removed from the temporary node mark. 

","Example
To remove nodes 6, 7, and 8 from the temporary node mark: 
*createmark(nodes,1) 6 7 8
*nodemarkcleartempmark(1)

*createmark() is required.  

","Errors
None.
"
2258,*nodeplaceatxyz,"Description
Moves a node to a location on a surface and associates the node to the surface. 
","Inputs

node
The ID of the node. 
surface
The ID of the surface to which the node should be associated. 
location
The location of the point on the surface where the node is to be moved.

","Example
To move node 115 to surface 1 at location (75,30,86): 
*nodeplaceatxyz(115,1,75,30,86)

","Errors
None.
"
2259,*nodetoelementgapscreate,"Description

","Inputs

gaps_location
The ID of the mark containing the location of the gaps.
target_elems
The ID of the mark containing the elements to which the nodes are projected.
face_nodes
The ID of the mark containing nodes which lie on the face of one or more elements
            (solids only).
break_angle
The break angle of a solid face.
property_name
The name of the property to which the gap elements should point.
tolerance
The maximum distance allowed between the nodes (on gaps location mark) and the
            elements (on target elems mark).
vectorid
The ID of the orientation vector associated with the gap elements.
nodeid
The ID of the orientation node associated with the gap elements.
orient_x
X component of the orientation vector.
orient_Y
Y component of the orientation vector.
orient_Z
Z component of the orientation vector.
comps_flag
Flag to indicate if individual components are used in defining the orientation of the
            elements ( 1if components are used, 0 if they are not).
systemid
The ID of the coordinate system used for orienting the gap elements

","Example
In the example below, nodes 1 to 100 are projected to shell elements 30 to 75 within a
        tolerance of 1.0. The gap elements point to the property gapprop and use components
        (70,120,80) for their orientation:
*createmark(nodes,1) 1-100
*createmark(elements,2) 30-75
*createmark(nodes,2)
*nodetoelementgapscreate(1,2,2,0,""gapprop"",1,0,0,70,120,80,1,0)
Orientation of the gap elements may be specified using either a vector, node, coordinate
        system or individual components 
","Errors
None.
"
2260,*nonstructuralmassupdateall,"Description
Updates a group with non-structural mass configuration for all properties of a specified
          card image.
","Inputs

name
The name of the non-structural mass group to update.
color
The color of the non-structural mass group. Valid values are 1-64.
type
The solver type of the non-structural mass group.
mass
The value of the non-structural mass.
card_image
The card image of the properties to update the non-structural
            mass for. Valid values are:
ELEMENT 
PBAR 
PBARL 
PBEAM 
PBEAML 
PCOMP 
PROD 
PSHEAR 
PSHELL 
PTUBE 
PSHELL



","Examples
To update a non-structural mass named nsm1 of type 1 (NSM1) for properties with PSHELL
          card image with mass value 2.4:
*nonstructuralmassupdateall ""nsm1"" 8 1 2.4 PSHELL
To update a non-structural mass named nsml1 from type 1 (NSM1) to type 2 (NSML1):
*nonstructuralmasscreateall ""nsm1"" 8 2 2.4 PSHELL
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2261,*normalsoff,"Description
Turns off the display of element/surface normals.
","Example
To turn off the display of element/surface normals:
*normalsoff
","Errors
None.
",
2262,*numbersmark,"Description
Places the entities in the mark on the numbers mark. This will display the ID of the
        entity. 
","Inputs

entity type
The type of entity contained on the mark. 
mark
The ID of the mark. 
on
Determines whether the entities will be placed on the numbers mark or removed from the
            numbers mark (1 to put on, 0 to remove). 

","Example
To place nodes 5, 6, and 7 on the numbers mark: 
*createmark(nodes,1) 5 6 7
*numbersmark(nodes,1,1)
","Errors
None.
"
2263,*offset_surfaces_display_offset,"Description
The command will create segments in the component named ""^offset"" with the color pink if
        the surfaces or solids on mark_id are a result of an offset. The segments
        will point to the original position of the surfaces/solids (the position from which the
        offset was made). This is for visualization and review purposes.
There is an exception to this for the 9.0 release that will be removed in subsequent
        releases: If the surfaces are a result of the midsurface extraction or have a manually
        assigned thickness, then the command will always display the thickness even if an offset was
        made later.
","Inputs

entity_type
The type of entity to generate segments for. Valid values are surfs and solids.
mark_id
The mark of containing the surfaces or solids. Valid values are 1 and 2.
reserved_1
Reserved for future use. Should be set to 0.

","Example
To review the offset for the displayed surfaces:
*createmark surfs 1 displayed
*offset_surfaces_display_offset surfs 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2264,*optimized_mesh,"Description
This command is used to create a mesh on a surface using saved or default parameters on
        surfaces and specifying various options. Any elements attached to the input surfaces are
        deleted before the meshing operation.
","Inputs

mark_id
The mark ID containing the surfaces to mesh. Valid values are 1 and 2.
criteria_file
The full path and filename for the user-defined quality index criteria file. If no
            file is given, ""dummy"" should be specified.
elem_size
The default element size used to calculate element densities along edges for topology
            cleanup operations.
elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


smooth_across
Flag indicating whether to ignore surface edges for element smoothing and cleanup
            operations. Valid values are:
0 - Honor surface edges for element smoothing and cleanup. 
1 - Ignore surface edges for element smoothing and cleanup.


feature_angle
The angle, in degrees, specifying the feature lines. This is approximately the minimum
            angle between the elements adjacent to a feature line.
algorithm
Determines the algorithm for surface meshing. Valid values are:
0 - Standard surface meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control


do_remesh
Flag indicating whether to keep or delete existing elements on the surfaces. Valid
            values are:
0 - Keep existing elements on selected surfaces. 
1 - Delete existing elements on selected surfaces.


comp_mode
Parameter specifying how entities are organized into components:
0 - Elements are created in the current component. 
1 - Elements are created in the same components as their parent surfaces.



","Example
To start the optimization process with a criteria file named
          C:/criteria/mycriteria.txt for displayed surfaces, with tria
        elements, element size of 15, feature angle of 35 degrees, ignoring surface edges for
        smoothing and new elements created in their surface components:
*createmark surfaces 1 displayed
*optimized_mesh 1 ""C:/criteria/mycriteria.txt"" 15 0 0 1 35 0 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2265,*orderchangetofirst,"Description
 Converts second order elements to first order. 
","Inputs

mark
The ID of the mark which contains the elements to be converted. 

","Example
*createmark() is required.

","Errors
None.
"
2266,*ossmooth2,"Description
 This command extracts the final design geometry from OptiStruct topology, topography or shape optimization results.
","Inputs

femfile
OptiStruct base input file from which to extract the final
            geometry 
load_op
Execution/load option:
0 - Create .oss file only to be used in standalone version
                (do not execute ossmooth) 
1 - Do not load geom. 
2 - Load geom


outputcode
Output file format:
1 - Nastran

2 - IGES 
3 - STL 
4 - H3D 


tetrameshingcode
Flag indicating whether to create tetramesh after creating isosurface (1=yes, 0=no).
            Only to be used in standalone version.
units
Units to use for IGES output:
1 - inch 
2 - mm 
4 - foot 
6 - meter 
10 - cm


autobead
Flag indicating whether to create an autobead design (1=yes, 0=no).
autobeadthreshold
Threshold value for autobead (real value ≥ 0 and ≤ 1).
autobeadlayer
Layer value for autobead (integer value 0 or 1).
isosurface
Flag indicating whether to create an isosurface (1=yes, 0=no).
surfacecode
The method to use:
0 - no smoothing, isosurface only 
1 - Optimization based smoothing 
2 - no smoothing, element threshold 
3 - Laplacian smoothing


densitythreshold
The density threshold for topology optimization (real value ≥ 0 and ≤ 1).
distancecoefficient
The distance coefficient to use in optimization based smoothing (real value ≥ -50 and
            ≤ 50).
 optismoothboundary
Flag indicating whether to include the boundary or not in optimization based smoothing
            (1=yes, 0=no).
lapiteration
The number of iterations to use in Laplacian smoothing (integer ≥ 0).
lapfeatureangle
The feature angle to use in Laplacian smoothing (real value ≥ 1 and ≤ 80).
lapsmoothboundary
Flag indicating whether to include the boundary or not in Laplacian smoothing (1=yes,
            0=no).
remesh
Flag indicating whether to remesh when creating an autobead design or/and isosurface
            (1=yes, 0=no).
surfacereduction
Flag indicating whether to use surface reduction (1=yes, 0=no).
reductionfeatureangle
The feature angle to use when requesting surface reduction (real value ≥ 1 and ≤
            80).

","Example
The following example executes OSSmooth on the c:/test/os1.fem,
          c:/test/os1.grid and c:/test/os1.sh files,
        loading geometry back to HyperMesh, requesting Nastran output, creating 1 layer autobead with remesh design with 0.3
        bead threshold, no surface reduction, 0.3 topology optimization threshold, Laplacian
        smoothing, 10 iterations, 30 degrees feature angle and include the boundary:
*ossmooth2 ""c:/test/os1.fem"" 2 1 0 1 1 0.3 1 1 3 0.3 0 0 10 30 1 1 0 10
","Errors
None.
"
2267,*penetrationcheckend,"Description
Releases the memory from previous penetration check command operations.
","Example
To check the elements in group E2E for penetration:
*createmark groups 1 E2E
*penetrationcheck groups 1 0
*penetrationcheckend
","Errors
None.
",
2268,*penetrationchecktwo,"Description
Checks penetration for entities selection type groups, elems2elems, nodes2elems, and
        elemsonly. To release the memory after completion, use the command
          *penetrationcheckend. 
A valid template must be loaded for the check to occur.
","Inputs

entity_type1
Type of the first entity.
groups for selection type groups' 
elements for selection type elems2elems 
elements for selection type nodes2elems 
elements for selection type elemsonly


mark1
Mark of the first entity.
undefined   for selection type groups 
elements    for selection type elems2elems 
nodes        for selection type nodes2elems 
undefined   for selection type elemsonly


entity_type2
Type of the second entity.
mark2
Mark of the second entity.
segment_orientation
Flag for taking element normal into consideration for checking penetration.
0 - Elements normal will not be considered 
1 - Elements normal will be considered


partscl_contthk_toggle


1 - If part thickness scale is selected 
2 - If contact thickness is selected


part_scale
Value of part scale factor.
cont_thick
Value of contact thickness.

","Example
 For checking penetration between elems2elems with segment orientation option and part
        thickness scale:
*penetrationchecktwo(elements,1,elements,2,1,1,1,0) 
For checking penetration between nodes2elems without segment orientation option and with
        contact thickness:
*penetrationchecktwo(elements,1,nodes,1,0,2,1,1)
*createmark() for entity type 1 and createmark() for
        entity type 2 are required.
","Errors
None.
"
2269,*permutemark,"Description
Permutes the entities on a mark. 
","Inputs

entity type
The type of entities contained on the mark. 
mark
The ID of the mark which holds the entities to be permuted. 
type
The type of action which should be taken:
0 - Swap x with y 
1 - Swap x with z 
2 - Wwap y with z



","Example
To permute elements 10, 11, and 12 switching the x and y values: 
*createmark(elements,1) 10 11 12
*permutemark(elements,1,0)

*createmark() is required. 
","Errors
None.
"
2270,*plotaxisnodes,"Description
 Plots a curve based on the values of marked nodes ordered along an axis.
","Inputs

mark
The active mark.
axis
The axis index (0 = X, 1 = Y, 2 = Z)

","Example
*createmark(nodes,1) 167 171 175
*plotaxisnodes(1,0)

In order to work, there must be an existing contour and at least one node on the mark.
        Values on the curve are ordered according to their distance along the selected axis.
","Errors
None.
"
2271,*plotnodelist,"Description
Plots a curve based on the values of a contour along a list of nodes.
","Inputs

listid
The ID of the active node list.

","Example
*contourplot("""",0,0,0,0,0,1,0,0,""total disp"",1,0,0)
*xyplotsetcurrent(""untitled1"")
*createlist(nodes, 1) 1601 1600 1599 1598
*plotnodelist(1)
In order to work, there must be an existing contour and a list of nodes (not nodes on a
        mark).
","Errors
None.
"
2272,*plottitlesetfont,"Description
Sets the font for the plot title. 
","Inputs

font 
The font ID for the plot title (1-4). 

","Errors
None.
",
2273,*plynormalsdisplay,"Description
Controls the display of 2D element ply normals.
","Inputs

ply_name
The name of the ply to display normals for.
mark_id
The ID of the mark containing the elements whose normals are to be displayed. Valid values are 1 and 2.
If empty, all plies in the specified ply are considered.
size
Specifies the size of the graphic normal vector. If set to zero, the vector is drawn
            at 10% of the screen size.

","Example
To turn on the display of normals for elements 1-10 in Ply1, at 10% screen size:
*createmark elems 1 1-10
*plynormalsdisplay Ply1 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2274,*prepare_solid_holes_for_meshing,"Description
This command takes as input a mark of surfaces or solids of a 3D body. It finds holes in
        the 3D body, and collects the found connected holes in ""tubes"". It also trim and merges hole
        surfaces to make more surfaces suitable for the mapping mesh algorithm. 
It sets element densities on surface edges. Moreover, independent holes can also be
        removed. 
Optionally, this command groups holes by diameter, and creates a component with auto
        generated name for each holes group and moves the surfaces of the tubes to the corresponding
        components. Blind and through holes are considered as different separation groups, so they
        are grouped separately. the surfaces of the detected holes can be put to an output mark. 
The command parameters have the following meaning
","Inputs

entity_type
The type of input entities. Valid values are surfaces or solids.
input_mark_id
The ID of the input mark. Valid values are 1 and 2.
output_mark_id
The ID of the output mark to put the surfaces of the detected holes. Valid values are
            0, 1 or 2. If set to 0, no surfaces are placed on the mark.
string_array
The ID of the string array that contains the fillet width and radius group
            information. The string array is created using the *createstringarray
            command. This should always be set to 1. 
The first string in quotations should contain the following parameters as keywords
            followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
cross_sect_size_max
Maximum length of the holes normal to the holes axes cross sections. This
                  applies only to elongated holes (rounded slots or elliptical holes). If
cross_sect_size_max
0 - Then no limitation is applied.
diams_ratio_max
Maximum ratio of diameters of adjacent co-axial cylindrical hole sections when
                  the sections are considered within the same tube.
elem_size
The element size used in meshing parameters.
min_elem_size
The minimum element size used in meshing parameters.
separate_holes
The values 0 and 1 are supported. 
1 - Means holes will be distributed into different groups.


All other strings may contain 4 quotes values:
min_diam 
(double) 
max_diam
(double) 
num_of_circumference_elems
(int) - used in seeding the circular edges of a hole.
elem_size_for_longitudinal_edges
(double) - used in seeding operation.


The intervals for min_diam and max_diam should
            not overlap between groups. 
If num_of_circumference_elems is set to 0, the holes in the group
            are removed when possible. In this case,
              elem_size_for_longitudinal_edges is not required. If some holes can
            not be properly removed, then they are seeded normally with
              num_of_circumference_elems set to 3 and elem_size_for
              longitudinal_edges set to elem_size. Currently, only
            independent holes can be removed.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To recognize and prepare holes with diameters in three different intervals 0 - 15, 15 - 20
        and 20.0 - 40.0, and separate them according to different seeding design:
*createmark surfaces 1 ""all""
*createstringarray 4 ""cross_sect_size_max = 100 diams_ratio_max = 2.5 min_elem_size = 2.0 seperate_holes = 1""  
""0 15 6 6.0"" ""15 20 6 8.0"" ""20 40 8 10.0""   
*prepare_solid_holes_for_meshing surfaces 1 2 1 4
To remove holes with diameter in the range 0 - 5.0: 
*createmark surfaces 1 ""all""
*createstringarray 2 ""cross_sect_size_max = 100 diams_ratio_max = 2.5 min_elem_size = 2.0 separate_holes = 1""  
""0 5 0""
*prepare_solid_holes_for_meshing surfaces 1 2 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2275,*projectpointstoedges,"Description
Create surface vertices by projecting the points onto the edges perpendicular to the
        edge.
","Inputs

edge_markmask
The mark containing the edges to project to.
point_markmask
The mark containing the points to project.
distance_tol
The maximum distance a point can be projected.
angle_tol
The minimum angle between an existing vertex, the point being projected, and the
            projected point.

","Example
To add surface vertices on edges 56 and 57 by projecting points 78 and 79 with a maximum
        distance of .5 and a minimum angle of 30:
*createmark(lines,2) 56 57
*createmark(points,1) 78 79
*projectpointstoedges(2,1,.5.30)

Any selected edge, which is within the distance tolerance of any of the points, will have a
        vertex added at the projected point unless there is already another vertex on the edge that
        is within the angle tolerance. Therefore, if two points project to the same edge but are
        within the specified angle tolerance, then only one of the points will be added to that
        edge. It is not defined which point will be added. 
","Errors
None.
"
2276,*propagate_welds,"Description
Use this command to create a series of weld points between surfaces.
","Inputs

surfsmark
The mark containing the surfaces to be welded; valid numbers are 1 and 2, or 0 for the
            entire model.
max_proxim
The maximum distance between a weld point and an edge or between a ""child"" projection
            point and an edge for propagation. This should be 1 to 1.5 times the element size.
min_edge_len
The minimum edge length created by inserted fixed points. This should be 0.3 times the
            element size.
max_angle_dev
The maximum angle deviation of the propagation path from the surface normal.
            Approximately 30° is typical. 
select_exten_flag
This flag controls the propagation of fixed points with respect to selected surfaces.
0 - Ignores the selection and propagates to any connected surfaces. 
1 - Weld propagation is restricted to the selection area, including the selection
                boundary. 
2 - Weld propagation is restricted to the selection area, but not the selection
                boundary.


meshed_touch_flag
Controls the propagation with respect to meshed surfaces.
0 - Does not affect meshed surfaces in any way 
1 - Welds can touch mesh surfaces 
2 - Welds can touch mesh surfaces, but the mesh is deleted when this occurs



","Example
As of this writing, this command is not included in the BatchMesher and does not have an implementation from within the
          HyperMesh environment; it is only usable as a typed-in
        command, such as in user-created macros.
","Errors
None.
"
2277,*quatrotate,"Description

*quatrotate(-0.000125576946, 0.0107329493, -0.000656577404, 0.999942177)

","Example
The model is rotated about the matrix created from the given quaternion. 
","Errors
None.
",
2278,*readfile,"Description
Reads a HyperMesh database into the current session and deletes
        any existing model.
","Inputs

filename
The full path and filename of the database file.

","Example
To read the database named C:/mymodel.hm into the current session:
*readfile C:/mymodel.hm
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2279,*realizeentity,"Description
Realizes an engineering entity into solver data.
","Inputs

entity_type
The type of engineering entity to realize. Currently only supported for fields.
<select_type>=<selection>
The engineering entity to realize. There are several ways to provide the entity to be
            modified. Only one option can be used at a time:
id=<id>
The ID of the single entity to modify.
name=<name>
The name of the single entity to modify.


The remaining option=value strings are documented within the subtopics of each
            supported entity type.

","Example
Examples are provided within the subtopics of each supported entity type.
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2280,*refine_by_patterns_multiple_points,"Description
Refines multiple zones of elements using an all quad pattern. The zones are described by a
        refinement box and multiple center nodes. The refined mesh is then connected to the existing
        mesh using an all quad pattern through the transition zone, described by a transition box. 
The refinement boxes will contain the refined elements, while the regions between the
        refinement boxes and the transition boxes will contain quads patterns used to transition
        between the refined mesh and base mesh size.
","Inputs

mark_id
The ID of the mark containing the refinement box center nodes. Valid values are 1 and 2.
strings
A string that contains the additional input parameters. Each string must be space
            separated, including between = and the value. All strings are mandatory. 
Valid strings are:
auto_transition = <value>
Currently unused and should be set to 0.
refine_zone_height = <value>
Defines the height of the refinement zone.
refine_zone_length = <value>
Defines the length of the refinement zone.
refine_zone_size = <value>
Defines the mesh size within the refinement zone.
refine_zone_width = <value>
Defines the width of the refinement zone.
squeez = <value>
Currently unused and should be set to 1.
system_id = <value>
The ID of a local coordinate system to which the zones are oriented. A default
                  of 0 (global system) is used if not specified.
transition_zone_height = <value>
Defines the height of the transition zone.
transition_zone_length = <value>
Defines the length of the transition zone.
transition_zone_width = <value>
Defines the width of the transition zone.



","Example
To refine elements around nodes 60, 61 and 63 with refinement size 1 using a refinement box
        of dimension (10,15,20) and transition box of dimension (40,50,45):
*createmark nodes 1 60 61 63
*refine_by_patterns_multiple_points 1 ""refine_zone_size = 1 auto_transition = 0 transition_zone_length = 40 transition_zone_width = 50 transition_zone_height = 45 refine_zone_length = 10 refine_zone_width = 15 refine_zone_height = 20 system_id = 0 squeez = 1""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2281,*reflectmarkwithoption,"Description
This command reflects a selection of entities about a plane.
","Inputs

entity_type
The type of entity to reflect.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
plane_id
The ID of the plane to use for the reflection. This is defined using the
              *createplane command.
option
0 - Maintain the z-axis of bar elements during reflection. 
1 - Maintain bar element connectivity during reflection.

","Example
To reflect element 15 about a plane normal to the x-axis with its base at the origin by
        maintaining the z-axis:
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*createmark elems 1 15
*reflectmarkwithoption elems 1 1 0
To reflect element 15 about a plane normal to the x-axis with its base at the origin by
        maintaining the element connectivity:
*createplane 1 1.0 0.0 0.0 0.0 0.0 0.0
*createmark elems 1 15
*reflectmarkwithoption elems 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2282,*relativerotatedummyjoint,"Description
Rotates a dummy joint relative to its current location.
","Inputs

entities
The entity type. Currently, only components is supported.
collectorId
The id of the collector that is part of the parent/child system. The parent or child
            system itself will be rotated, depending on the parentChild toggle.
axis
The axis of the child that we want to rotate about.
0 X axis 
1 Y axis 
2 Z axis


rotAngle
The number of degrees to rotate about the axis.
parentChild
If set to 0, the child is rotated about its own axis. If set to 1, the parent is
            rotated about the child’s axis.

","Example
To rotate a joint around the child’s X axis by 25 degrees specifying the collector that
        contains the system for the elbow joint:
*relativerotatedummyjoint(components, 1, 0, 25, 0)
","Errors
None.
"
2283,*remove_solid_holes,"Description
Detects and removes holes in 3D geometry, up to a maximal diameter. The shape of the hole
        cross-section can optionally be filtered, limiting to circular holes only or/and rounded
        slots. Optionally fixed points and tags can be placed at the center of the removed holes. 
When a hole cannot be removed, the surfaces of such holes can optionally be moved to
        auto-created components with auto-generated names. 
Optionally any number of additional ranges of holes for removal with different shape and
        post-processing options can be specified using a flexible string input.
","Inputs

entity_type
The name of entity to consider. Valid values are surfaces and solids. 
If surfaces are being used as input, all surfaces constituting each considered 3D body
            should be selected to generate proper results. If all surfaces of a 3D body are not
            selected, the command result is unpredictable.
mark_ID
The ID of the mark containing the entities. Valid values are 1 and 2.
max_diam
The maximum diameter for holes to be removed. For holes of arbitrary shape, the
            ""effective"" diameter is found as the cross section perimeter/Pi. If the hole shape is
            limited by rounded slots, the hole diameter is taken as the hole rounded tip
            diameter.
cross_sect_size_max
The maximum size of the cross-section (normal to the axes) for rounded slots or
            elliptical holes. This must exceed max_diam.
options
Flags that indicate different options for cross-section recognition and additional
            hole removal post-processing parameters.. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
 0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round holes should be detected.
Bit1
0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round slots should be detected.
Bit2
 0 - Do not place fixed points. 
1 - Place fixed points at the centers of end cross-sections of removed
                  holes.
Bit3
0 - Do not place tags. 
1 - Place tags containing the hole size attached to the center fixed points.
                  Bit2 must be used.
Bit4
0 - Failed hole surfaces are not organized. 
1 - The surfaces of holes that failed to be removed are organized to
                  auto-created components with auto-generated names. This can be used for manual
                  removal of such holes.


string_array
The ID of the string array that contains the additional input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
All input strings (each one in separate quotation marks) have the same format and
            contain user defined diameter ranges. Each range string has the following format
              : ""min_range_diam max_range_diam options"" 
The diameters ranges should not overlap but may have gaps between them. 
The options string is derived from the options argument and can be customized for each
            range.
number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray.

","Examples
To remove all holes with diameters from 0 to 8.0 and remove round holes and rounded slots
        only in the range from 8.0 to 20.0 with maximal rounded slot length 25.0. No options are
        used for the lower range, but a value of 15 is used for the upper range (find only rounded
        holes and slots, and place fixed points with tags).
*createmark surfaces 1 all
*createstringarray 1 ""8.0 20.0 15""
*remove_solid_holes surfaces 1 8.0 25.0 0 1 1 
To remove only round holes up to a diameter of 12.0, put fixed points at the centers, and
        move any failed hole surfaces to the auto-created component:
*createmark solids 1 all
*remove_solid_holes solids 1 12.0 15.0 21 1 0 
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2284,*removeelemsfromcontactsurf,"Description
Removes elements from a contactsurf. If all elements are removed the empty contactsurf
        still exists.
","Inputs

name
The name of the contactsurf.
elem_mark_id
The ID of the mark containing the elements to remove. Valid values are 1 and 2.

","Example
To remove elements 100 and 101 from the contactsurf ""test"":
*createmark elems 1 100 101
*removeelemsfromcontactsurf  ""test"" 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2285,*removefilletbetweennodes,"Description
 Removes the edge fillet between two nodes.
","Inputs

nodes
The array of nodes from the node list. The first two nodes in the nodes array are used
            to remove fillets.

","Example
*createentity node x=-25.7203277 y=-212.155023 z=104.852423
*createentity node x=71.47504 y=-213.224288 z=96.3130724
*createlist nodes 1 1 2
*removefilletbetweennodes 1
","Errors
None.
"
2286,*removeview,"Description
Deletes a saved view from the database.
","Inputs

name
The name of the view to delete. The view names 1-5 are reserved and cannot be
            deleted.

","Example
To delete the view with the name ""my_view"":
*removeview ""my_view""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2287,*renamefile,"Description
Renames a file. 
","Inputs

oldname
The current name of the file being renamed. 
newname
The new name for the file. 

","Example
To rename the file junk to stuff: 
*renamefile(junk,stuff)
","Errors
None.
"
2288,*renumberelemsnodesasmapgrid,"Description
Orders nodes and elements in grid format and renumber nodes and elements with specified
        start ID.
","Inputs

elem_mark_id
The ID of the mark containing the elements to renumber. Only quad elements are
            allowed. Valid values are 1 and 2.
origin_node_id
The ID of the node to use as the origin of the grid.
x_ref_node_id
The ID of the node to use as the x-axis of the grid.
elem_start_id
The starting ID to use for renumbering the elements.
node_start_id
The starting ID to use for renumbering the nodes.

","Example
To renumber all elements, using node 4 as the origin, node 1 as the x-axis, with IDs
        starting at 100 for both nodes and elements:
*createmark elems 1 all
*renumberelemsnodesasmapgrid 1 4 1 100 100
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2289,*reset_elemsize_criteria,"Description
Adjusts the current quality criteria to the specified ideal element size.
The current quality criteria must be previously set. If the quality criteria was not set,
        the command creates current criteria adjusted to the element size using one of the
        following:

interactive mode:
Criteria from the quality index panel.
batch mode:
Default quality criteria adjusted to the current ElementSize.

In interactive mode, this command also resets the current values in the Quality Index
        panel.
","Inputs

elementsize 
The double value of the ideal element size for the criteria to be set.

","Example
*reset_elemsize_criteria 15.0
","Errors
None.
"
2290,*resize,"Description
Sets the resize flag in HyperMesh. 
","Inputs

on
Set to 0 if the full-size plots should not be resized to the size of the window;
            otherwise, set to 1. 

","Errors
None.
",
2291,*retainmarkselections,"Description
Sets the display state of marked entities.
","Inputs

mode 
1=on, 0 = off (default)

","Example
This command will allow users to control the display of the marked entities when using
          the *createmark command. 
","Errors
None.
"
2292,*reviewclearall,"Description
This command removes/clears all entities from the review list.
","Example
To clear all entities from the review list:
*reviewclearall
","Errors
None.
",
2293,*reviewmaterialorientation,"Errors
None.
",,,
2294,*reviewreferencegeometry,"Description
Reviews reference geometry control volume. 
","Inputs

entities
Nodes used to create the reference geometry are reviewed.
markmask
Source of nodes used to review reference geometry. 
(1-nodes selected by user)
name
Name of the reference geometry. 

","Example
To review reference geometry (called ""airbag"") using elements selected by user:
*createcontrolvol(elements,""airbag"")
","Errors
None.
"
2295,*rigidlink,"Description
Creates a rigid link element between an independent node and multiple dependent nodes.
","Inputs

independent
The independent node of the element.
mark
The ID of the mark containing the dependent nodes.
dof
The degree of freedom code for which all of nodes of the element are active (any of
            the digits 1-`6).

","Example
To create a rigid link element with independent node 100 and dependent nodes 101, 102, and
        103 with nodes having all six degrees of freedom:
*createmark(nodes,2) 101 102 103
*rigidlink(100,2,123456)

A *createmark() command is required to define the mark. 
","Errors
None.
"
2296,*rigidlinkupdatecalcinodebycollector,"Description
This command updates the rigid link by calculating the independent node based on selection
        of dependent nodes defined by comps, mats, assems, props sets and nodes.
","Inputs

element_id
The ID of the rigid link.
mark_id
Collector put on mark. Valid values are 1 and 2.
entity_type
The type of entity for dependent nodes. Valid entity types are comps, mats, assems,
            props, sets and nodes.

","Example
To update a rigid link element ID 7 by selecting dependent node specified by comps ID 1 and
        2 put on a mark 1: 
*createmark comps 1 1 2
*rigidlinkupdatecalcinodebycollector 7 1 comps

","Errors
None.
"
2297,*rigidlinkwithset_twonodes,"Description
Create a rigid link element ""55"" between two nodes, with a dependent node attached as a
        node set connected with the element. 
","Inputs

independent
The independent node of the element.
dependent
The dependent node of the element.
dof
The degrees of freedom for which the element is active (any of the digits 1-6). 

","Example
To create a rigid link element with dependent nodes attached as a set between nodes 100 and
        101 in all six degrees of freedom: 
 *rigidlinkwithset_twonodes(100,101,123456)
A node set with an automatically generated name is created and a dependent node is placed
        in this set.
","Errors
None.
"
2298,*rotate,"Description
Rotates the model based on a user-defined rotation axis. 
","Inputs

axis angle
The angle in degrees which defines how far from horizontal the rotation axis is. 
rotation angle
The angle in degrees which the model rotates.

","Example
To rotate a model about the horizontal screen axis 15 degrees: 
*rotate(0.0,15.0)
To rotate a model about the vertical screen axis 15 degrees: 
*rotate(90.0,15.0)
The rotation axis is defined by a line which runs horizontally through the center of the
        screen if the axis angle is zero. As the axis angle increases in magnitude, the axis of
        rotation rotates about the vector normal to the screen axis angle degrees. 
","Errors
None.
"
2299,*savefailedsurfstomark,"Description
Scans all the displayed surfaces, finds those for which all the meshing algorithms failed,
        and places them on the specified mark. This command is used after one of the commands
        performing meshing by surfaces. 
","Inputs

surfs_mark 
The mark the surfaces failed to be meshed must be placed to. It must be 1 or 2.

","Example
To mesh displayed surfaces and place failed surfaces on mark 2:
*createmark(surfaces,1) ""displayed""
*defaultmeshsurf(1,20,2,2,1,0,1,1,1,0,0,0,0)
*createmark(surfaces,2)
*savefailedsurfstomark(2)
Note that *createmark(surfaces,2) is placed before
          *savefailedsurfstomark(2) to clear all the surfaces from the specified
        mark. 
","Errors
None.
"
2300,*scale_thickness,"Description
This command scales the thickness and sets the scaled thickness back to entity. This
        functionality is currently supported only in the Radioss and
          LS-DYNA user profiles.
","Inputs

entity_type
The type of entity to scale. Currently only supported for elems.
mark_id
The ID of the mark that contains the entities to scale. Valid values are 1 and 2.
string_array
The ID of the string array that contains the array of input parameters. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Each argument can be either space or comma separated.
add : <value>
The value to add to the thickness of each entity. To subtract, use a negative
                  value. If not specified, multiply must be used.
multiply : <value>
The value to multiply the thickness of each entity by. To divide, use a value
                  less than one.
 If not specified, add must be used.
MaxThickness : <value>
Used to limit the maximum thickness. Not mandatory.
MinThickness : <value>
Used to limit the minimum thickness. Not mandatory.


number_of_strings
Integer indicating the size (number of strings) in the string array created
              using *createstringarray.

","Examples
Add 2 to the existing thickness of all elements in the model, with a minimum thickness of
        10 and a maximum thickness of 20:
*createstringarray 3 ""add : 2"" ""MinThickness : 10"" ""MaxThickness : 20""
*createmark elems 1 all
*scale_thickness elems 1 1 3

Multiply element 15-17 thicknesses by 0.5:
*createstringarray 1 ""multiply: 0.5""
*createmark elems 1 15-17
*scale_thickness elems 1 1 1
 Subtract 2 from the thickness of all elements:
*createstringarray 1 ""add: -2""
*createmark elems 2 all
*scale_thickness elems 2 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2301,*scalemarkwithsystem,"Description
This command scales a selection of entities by multiplying the coordinates.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
scale_x
The multiplication factor for the x-axis of the system.
scale_y
The multiplication factor for the y-axis of the system. Only used in rectangular
            coordinate systems.
scale_z
The multiplication factor for the z-axis of the system. Not used in spherical
            coordinate systems.
system_id
The ID of the system which the scaling is in relation to. Note that the type of system
            affects the scaling. For example, specifying scale_x in a cylindrical
            or spherical coordinate system scales the mark radially out from the origin. 
For scaling of rigid walls in the rigid wall local system, specify as 0.
origin
If zero, the scaling is based at the origin of the system. Otherwise, it specifies a
            node ID whose coordinates define the base point of the scaling. 
For scaling of rigid walls in the rigid wall local system, specify as 0.

","Example
To scale nodes 1-8 5 units in the x-direction of system 13 with node 20 as the origin:
*createmark nodes 1 1-8
*scalemarkwithsystem nodes 1 5.0 1.0 1.0 13 20
To scale the rigid wall rwcyl relative to the rigid wall local system:
*createmark groups 1 rwcyl
*scalemarkwithsystem groups 1 3.0 1.0 1.0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2302,*secondorderfix2,"Description
Fixes the middle nodes of second order elements, using parameters to define how the nodes
        can be moved.
","Inputs

mark_id
ID of the mark containing the elements to fix. Valid values are 1 and 2.
min_jacobian
The element Jacobian threshold of the fixed result.
max_midangle
The maximum angle of the curved edge to the straight edge.
min_midratio
The minimum ratio of the two parts of the edge separated by the middle node.
jacobian_method
The evaluation method of the Jacobian. Valid values are:
0 - Evaluate at integration points 
1 - Evaluate at corner points 
2 - Evaluate at corner and mid points 
3 - Evaluate at high order integration points


fix_method
The method used to fix the node.
0 - Just straighten surface edge, internal middle nodes are not moved. 
1 - Move internal nodes only, boundary middle nodes are not moved. 
2 - Move all nodes (both internal and surface), the boundary nodes should be
                moved along the geometry. 
3 - Move internal nodes and straighten surface nodes, the boundary nodes can be
                moved off the geometry.

Any other value - Move all nodes and straighten surface nodes. For the boundary
              nodes, first try to move along geometry. If not able to reach the target, then try to
              move off the geometry.


","Example
Fix the middle nodes of elements 2 and 4. The target Jacobian at the elements’ corner
        points should be not less than 0.1, the angle of the fixed edge to the straight edge which
        is constructed by the two end nodes should be less than 30 degrees, and the ratio of the two
        parts of the edge separated by the middle node should be greater than 0.8. Both the internal
        nodes and boundary nodes can be moved, and the boundary nodes can be kept on the
        geometry:
*createmark elements 1 2 4
*secondorderfix2 1 0.1 30 0.8 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2303,*segregateByPatches,"Description
This command is used to find connected patches of elements and create separate components
        for the elements in each connected patch. The number of new components created will be equal
        to number of clusters of element patches. 
For example, for element patches {1 2 3 4} {5 6 7 8 9} {10 11} there will be 3 new
        components created.
","Inputs

entity_type
Must be set to elems.
mark_id
ID of the mark containing the input shell elements. Valid values are 1 and 2.
component_name
The maximum angle of the curved edge to the straight edge.

","Example
To create new components from element patches in component ToSegregate:
*createmark elems 1 ""by comp"" ToSegregate
*segregateByPatches elems 1 ToSegregate
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2304,*separate_holes_in_3d_body_new,"Description
This command takes as input a mark of surfaces or solids of a 3D body. It finds holes in
        the 3D body, collects the found connected holes in tubes, and groups the tubes by diameter
        either according to the user- specified diameter ranges or by autocreating the groups from
        the user-specified tolerance. The command creates a component with an autogenerated name for
        each diameter group and moves the relevant surfaces of the tubes to the corresponding
        components. Blind-holes and through-holes are considered as different groups, so they are
        grouped separately. Optionally, the surfaces of the detected holes can be put to an output
        mark. 
The command parameters have the following meaning:
","Inputs

entity_type
The type of selected input entites. surfaces and solids are supported: 
If the surfaces mark is being used as input, it should be applied to all surfaces
            constituting each considered 3D body. If the surfaces mark is not applied to all
            surfaces of a 3D body, the result is unpredictable.
input_mark_id
The input surfaces or solids mark id of the input. Valid values are 1 and 2.
output_mark_id
The mark ID to mark the surfaces of the detected holes. Valid values are 0, 1 or 2. If
            set to 0 the detected holes’ surfaces are not marked.
flags
Sets a filter for the shape of cross sections of holes to be recognized. Supported
            values are:
0 - Holes are not filtered by shape (arbitrarily shaped). 
1 - Only round holes are detected. 
2 - Only rounded slots are detected. 
3 - Both round holes and rounded slots are detected.


string_array
The ID of the string array that contains the fillet width and radius group
            information. The string array is created using the *createstringarray
            command. This should always be set to 1. 
The first (optional) string in quotations may contain the following parameters as
            keywords followed by the parameters values. Keywords and the corresponding values can be
            separated by blanks and/or by ""="":
cross_sect_size_max 
Maximum length of the holes normal to the holes axes cross sections. This
                  applies only to elongated holes (rounded slots or elliptical holes). If
                    cross_sect_size_max = 0, then no limitation is applied. The
                  default value is 0.
diam_tolerance
If this option is set, then the holes tube groups are to be autodefined by this
                  specified tolerance and any group diameter ranges are ignored.
diam_min
Minimum diameter of holes for recognition. Default value is 0.
diam_max
Maximum diameter of holes for recognition. If specified to be 0, then no limit
                  is applied. Default value is 0.
diams_ratio_max
Maximum ratio of diameters of adjacent co-axial cylindrical hole sections when
                  the sections are considered within the same tube. Default value is 2.5.
All other strings may contain up to 3 quoted values. These indicate the group
                  diameter ranges. It is not necessary to specify the string name, just the
                  values:
min_group_diam
(double) 
max_group_diam
(double) 
group_flag (int) (optional)
Value of 0 (disable group) or 1 (enable group) indicating if that diameter group
                  is considered. Default is 1 for all groups.  
The group ranges should not overlap but may have gaps between them.


number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray.

","Examples
To recognize round holes with diameters from 0 to 50 in 3D model, separate them in groups
        by diameter according the ranges: 10-11, 12-15, 17-20, 20-30 and 30-50, allow adjacent tube
        sections diameter ratio of up to 3.0 and to mark the detected holes surfaces on mark 2:

*createmark surfaces 2 """"
*createmark surfaces 1 ""all""
*createstringarray 6 ""cross_sect_size_max = 50 diams_ratio_max = 3.0"" ""10 11"" ""12 15"" ""17 20"" ""21 30"" ""30 50""
*separate_holes_in_3d_body_new surfs 1 2 0 1 6
The same example but the diameters range 12-15 should be disabled without removing it from
        the input:
        *createmark surfaces 2 """"
*createmark surfaces 1 ""all""
*createstringarray 6 ""cross_sect_size_max = 50 diams_ratio_max = 3.0"" ""10 11"" ""12 15 0"" ""17 20"" ""21 30"" ""30 50""
*separate_holes_in_3d_body_new surfs 1 2 0 1 6

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2305,*set_meshfaceparams,"Description
This command sets the face-specific parameters for the automeshing module.
","Inputs

face_index
The index of the surface face under consideration.
shape_type
Determines the surface-based mesh generation algorithm to use when creating elements
            on the face. Valid values are:
1 - autodecide 
2 - map as rectangle 
3 - map as triangle 
4 - map as pentagon 
5 - advancing front


elem_type
The type of elements to create. Valid values are:
0 - trias 
1 - quads 
2 - mixed 
3 - right trias 
4 - quads only


alg_type
0 - Standard surface meshing 
1 - Meshing with flow ""align"" control 
3 - Meshing with flow ""align"" and ""size"" control
elem_size
Reserved for future use. Must be set to 0.
smooth_method
The smoothing method to use during the meshing process. Valid values are:
0 - autodecide 
1 - size-corrected 
2 - shape-corrected


smooth_tol
The automesher applies the smoothing algorithm until the largest adjustment made to a
            nodal position is less than this value. Valid vales are > 0.0.
size_control
Determines if uniform size elements should be created in mapping algorithms. Valid
            values are:
0 - Do not create uniformly-sized elements. 
1 - Create uniformly-sized elements.


skew_control
Determines if optimal shape elements are created in mapping algorithms. Valid values are:
0 - Do not optimize element shapes. 
1 - Optimize element shapes.



","Example
To specify meshing parameters on face 0 of a surface for a quad dominant mesh with no size
        or skew control:
*set_meshfaceparams 0 1 1 0 0 0 0.1 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2306,*setcomponentdisplayattributes,"Description
Sets a component to the specified style and color. 
","Inputs

name
The name of the component.
style
Set to:
0 - Wire frame 
1 - Hidden line 
2 - Hidden line with mesh 
3 - Hidden line with features 
4 - Hidden line transparent


colortype
Determines how the component is colored. The options are:
0 - None 
1 - Component color 
2 - Assigned plots 
3 - Contours 



","Errors
None.
",
2307,*setcuttingplanecolor,"Description
Sets the color of the base of the specified cutting plane.
","Inputs

axis
The axis that is normal to the plane. Valid values are:
0 - the plane with x-axis as its normal 
1 - the plane with y-axis as its normal 
2 - the plane with z-axis as its normal


mode
Sets the display mode for the specified cutting plane. Valid values are:
0 - solid color 
1 - contours


color
The color to use when mode=0. Valid values are 1-64.

","Example
To set the cutting plane with y-axis as its normal to use solid color 24:
*setcuttingplanecolor 1 0 24
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2308,*setelemparamcolor,"Description
This command is related to the element quality view mode. It sets the color for a specified
        element quality parameter for elements violating the threshold.
","Inputs

param_id
Specifies the element quality check parameter ID to update. Valid values are:
0 - min size 
1 - max size 
2 - aspect ratio 
3 - warpage 
4 - max interior angle quad 
5 - min interior angle quad 
6 - max interior angle tria 
7 - min interior angle tria 
8 - skew 
9 - Jacobian 
10 - chordal deviation 
11 - quality index


color
The color to use. Valid values are 1-64.

","Example
To set ""aspect ratio"" color to brown:
*setelemparamcolor 2 28
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2309,*setglobalply,"Description
Sets the ply name to review. The element ply direction of that ply will be plotted for each
        selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_name
The name of the ply to review.
only_orient


0 - The new x-element directions are shown as continuous gradient lines starting
                and ending on free edges. 
1 - The new x-element directions are displayed as vectors starting from the
                element centroid.


normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1 through 64.

","Example
To review the ply directions for the second ply named ""ply45"" for the displayed elements
        with blue vectors of size 3:
*createmark elems 1 displayed
*setglobalply elems 1 ""ply45"" 1 3 7
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2310,*sethistoryrecord,"Description
Sets whether history recording is enabled or disabled.
","Inputs

state


0 - Disables all history recording, including potential legacy use cases 
1 - Enables history recording



","Example
To disable all history recording:
*sethistoryrecord 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2311,*setmacrofile,"Description
This command may be used to specify the macro file to use when HyperMesh starts. The default is hm.mac.
","Errors
None.
",,
2312,*setmarktopologydisplay,"Description
This command sets the topology visualization style for the marked geometric entities.
","Inputs

entity_type
The type of entity to modify. Currently, only comps are supported.
mark_id
The ID of the mark containing the entities of entity_type. Valid values are 1 and 2.
vis_flag


0 - Wireframe geometry 
1 - Shaded geometry and surface edges 
2 - Shaded geometry no surface edges 
3 - Geometry with surface lines



","Example
To set the visualization for the displayed components to shaded with surface edges:
*createmark comps 1 ""displayed""
*setmarktopologydisplay comps 1 1

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2313,*setply,"Description
Sets the ply number to review. The element ply direction of that ply will be plotted for
        each selected element with respect to the element (material) orientation. When review is
        complete, the command *vectorsoff must be run.
","Inputs

entity_type
The type of entity to review. Valid values are elements and properties.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
ply_number
The number of the ply to review.
only_orient
0 - the new x-element directions are shown as continuous gradient lines starting and
            ending on free edges. 
1 - the new x-element directions are displayed as vectors starting from the element
            centroid.
normal_size
If only_orient=1, this defines the size of the displayed
            vectors.
color
The color of the vectors or lines. Valid values are 1-64. 

","Example
To review the ply directions for the ply with ID 2 for the displayed elements with blue
        vectors of size 3:
*createmark elems 1 displayed
*setply elems 1 2 1 3 7
*vectorsoff
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2314,*setreviewbyid,"Description
This command adds entities to the review list based on an entity ID.
","Inputs

entity_type
The type of entity to add to the review list. Valid values are blocks and groups. 
id
The ID of the entity.
color
The color to use for review of the entity. Valid values are 1-64.
review_type
The review type to control.
For blocks:
1 = nodes 
2 = elems


For groups:
1 = slave only 
2 = master only 
3 = master & slave



","Example
To review only slave elements from group 5 with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyid groups 5 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2315,*setreviewmode,"Description
This command turns on/off the review list.
","Inputs

mode
0 - turn off review 
1 - turn on review

","Example
To review slave elements only for group CONTACT with color 4, with all other non-reviewed
        entities having transparency and gray color:
*setreviewbyname groups CONTACT 4 1
*setreviewcolormode 0
*setreviewtransparentmode 1
*setreviewmode 1
 To turn off the review:
*setreviewmode 0
","Errors
None.
"
2316,*settransparency,"Description
 Toggles the shaded surface transparency feature on and off.
","Inputs

onoff
Determines whether the shaded surface transparency feature is turned on or off. 
1 on 
0 off

","Example
To make the shaded surfaces in these comps on the mark transparent:
*settransparency(1)
*createmark(components,1) ""middle""
*transparencymark(1)

","Errors
None.
"
2317,*setusefeatures,"Description
Specifies the mode for defining and using feature edges for element-based re-meshing.
","Inputs

mode
The mode for defining and using feature edges for element-based re-meshing. 
0 - Feature edges will be auto-detected using the simple feature detection algorithm
            (as in the Features panel). The feature angle is set using *setoption
              feature_angle. 
1 - The selected mark of 1D plot elements will be used to form feature edges. This is
            also useful for using the Features panel to detect and manually edit features. The
            elements are specified using *elementsaddelemsfixed.

3 - Feature edges will be auto-detected by specifying the connected feature detection
            algorithm. The feature angle is set using *setoption feature_angle. 
7 - Use associated surface edges.
8 - Feature edges will be auto-detected by specifying the connected feature detection
            algorithm, keeping 1D elements which are part of 2D mesh edges and existing FE edges
            with nodes already associated to surface edges.
9 - Feature edges will be created from the selected mark of 1D plot elements, keeping
            1D elements which are part of 2D mesh edges and existing FE edges with nodes already
            associated to surface edges.

","Examples
To remesh the displayed elements and keep lines formed by plot elements with IDs
        1600-2220:
*createmark elems 1 ""displayed""
*setusefeatures 1
*createmark elems 2 1600-2220
*elementsaddelemsfixed 2
*defaultremeshelems 1 3.0 2 2 0 1 1 1 0 0 0 0 0 30
To remesh the displayed elements with auto detected feature edges with a feature angle of
        80 degrees:
*createmark elems 1 ""displayed""
*setusefeatures 0
*setoption feature_angle=80
*defaultremeshelems 1 3.0 2 2 1 1 1 1 0 0 0 0 2 30
","Errors
None.
"
2318,*shelloffset,"Description
Offsets shells along their element normal direction.
","Inputs

mark_id
The ID of the mark containing the shell elements to be offset. Valid values are 1 and 2.
corner_type
0 - Offset the elements using square corners. 
1 - Offset the elements using rounded corners. 
8 - Offset the elements using CFD corners. When this option is specified, an
            additional mark of surfaces and elements can be specified to specify the geometry to
            follow.
distance_type
0 - Offset elements using distance parameter. 
1 - Offset elements using half the element thickness value.
distance
The distance to move the elements. Only valid when distance_type=0.
offset_type
0 - Offset the elements in the positive normal direction. 
1 - Offset the elements in the negative normal direction.

","Example
To offset the displayed shell elements along their positive normal by a value of 0.2, using
        square corners:
*createmark elements 1 displayed
*shelloffset 1 0 0 0.2 0
To offset the displayed shell elements along their positive normal by a value of 0.2, using
        CFD corners, with surfaces 1 and 2 as along geometry:
*createmark elements 1 displayed
*createmark surfaces 2 1 2
*shelloffset 1 8 0 0.2 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2319,*show_new_target,"Description
Draws a segment in the new target component. This segment connects the point to offset with
        the target point.
","Inputs

face
Index of the surface to be offset.
offsetpoint_x
X coordinate of the point to be offset.
offsetpoint_y
 Y coordinate of the point to be offset.
offsetpoint_z
Z coordinate of the point to be offset.
target_x
X coordinate of the pilot point.
target_y
Y coordinate of the pilot point.
target_z
Z coordinate of the pilot point.
code


0  The target point is a midpoint between the offset point and the pilot point. 
1  The target point is the pilot point. 
2  The target point is a midpoint between the offset point and the pilot point.
                If the offset point is at a vertex of the surface to offset, the target is combined
                with any existing targets for that vertex and displays the combined target in the
                new target component. 
3  The target point is the pilot point. If the offset point is at a vertex of the
                surface to offset, the target is combined with any existing targets for that vertex
                and displays the combined target in the new target component. 
4  Behaves exactly as option 2, but also displays the targets being combined and
                the target planes in the targets being combined component. 
5  Behaves exactly as option 3, but also displays the targets being combined and
                the target planes in the targets being combined component. 
-1  The command combines the targets that existed at the vertex; the pilot point
                is ignored. 
-5  As for option -1, but also displays the targets being combined
                component.



","Example
Users cannot manually employ this command, because HyperMesh
        must internally generate the index values (they cannot simply be typed in). 
","Errors
None.
"
2320,*sl_feature_mesh,"Description
Performs feature-based meshing of surfaces using meshcontrols.
","Inputs

surface_mark_id
The ID of the mark containing the surfaces to mesh. Valid values are 0 (inactive), 1
            and 2.
meshcontrol_mark_id
The ID of the mark containing the meshcontrols to use. Valid values are 1 and 2.
mode
0 - Global, body and feature controls will be meshed. At least one global or body
            control is needed. 
1 - Feature controls only are meshed. Global/body controls are optional.
Any surfaces defined in a feature meshcontrol must also be selected via the
              surface_mark_id, or also be defined in a body control. Otherwise,
            they will be ignored. The surfaces defined in the feature controls are meshed first, and
            the remainder are meshed by the global or body control as appropriate.

","Examples
The mesh all surfaces in the model using meshcontrols 1-3:
*createmark surfs 1 all
*createmark meshcontrols 1 1 2 3
*sl_feature_mesh 1 1 0
To mesh using all meshcontrols, with only feature controls expected to be meshed:
*createmark meshcontrols 1 all
*sl_feature_mesh 0 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2321,*solid_extrude_from_surfs,"Description
This command creates solids by extruding a set of selected surfaces along a given
        vector.
","Inputs

mark_id
The ID of the mark containing the surfaces that you wish to extrude in order to create
            solids. Valid values are 1 and 2.
vec_x
X-component of the extrusion vector.
vec_y
Y-component of the extrusion vector.
vec_z
Z-component of the extrusion vector.
options
Flags that indicate different modes for the extrusion. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5).
Bit0
0 - Only free edges of surfaces are extruded. 
1 - Both free and internal edges are extruded, thus creating separate solids
                  from surfaces separated by shared edges.
Bit1
0 - Create solid entities. 
1 - Create only boundary surfaces.
Bit2
0 - Surfaces are extruded in one direction (positive or negative based on the
                  surface normal). 
1 - Surfaces are extruded in both directions.
Bit3
0 - Selected surfaces are disconnected from non-selected attached surfaces
                  before creating solids. 
1 - Connectivity between selected and non-selected surfaces is preserved.
Bit4
0 - When extrusion is made in both directions (Bit2=1), delete original
                  surfaces. 
1 - When extrusion is made in both directions (Bit2=1), keep original surfaces
                  and use them as separating surfaces between created solids.
Bit5
0 - Original selected surfaces become part of created solid boundary. 
1 - Copy of original selected surfaces is made before creating solids.


comp_mode
Determines how new solids are distributed into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces (the result
                is not predictable if the surfaces are originally in different components).



","Example
To create a solid by extrusion of the surface with ID 1, using vector (1,2,3), and creating
        the solid in the surface’s component:
*createmark surfaces 1 1
*solid_extrude_from_surfs 1 1.0 2.0 3.0 0 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2322,*solid_prepare_entitylst,"Description
This command is used by the solid mapping algorithm to setup internal entity arrays. It
        must be used within a *solidmap_prepare_usrdataptr data input block. A
        data input block begins with *solidmap_prepare_usrdataptr and ends with
        either a call to *solidmap_end or the start of another data input
        sub-block.
","Inputs

entity_type
The type of entity contained on mark ID 1. Valid values are lines, surfaces or
            elements. 
For SOURCE data input blocks, elements are required to be specified either directly
            using this command or indirectly by auto-completing the selection based on the input
            geometry. 
For DEST data input blocks, if the elements bit is specified for the
              *solidmap_prepare_usrdataptr command but no elements are specified
            using this command, the selection is auto-completed based on the input geometry. 
reserved
Reserved for future use. Must be set to 0.

","Example
For a solidmap using the following inputs:
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10 
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2323,*solid_untrim,"Description
This command creates a full or partial cone or cylindrical solid.
","Inputs

mark_id
The ID of the mark containing the surfaces to untrim. Valid values are 1 and 2.
force
0 - Only surfaces that separate solids (solid on both sides) are removed. 
1 - Surfaces are deleted even if there is no solid on one of the sides. Normally this
            causes solid destruction but it may be useful as a way to remove solid cavities.

","Example
To untrim surface 100:
*createmark surfs 1 100
*solid_untrim 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2324,*solidcreatedragsurfalongline,"Description
This command creates one or more solids by dragging one ore more surfaces along a drag
        line. Lines in the line list are combined into a single line L, called the drag line. The
        direction of the drag line is determined by choosing its start point, S, as the closest end
        of the line to the input surface vertices. 
node_id and refplane arguments are optional and
        determines how the input lines and surfaces are transformed before drag.
The reconfiguration of the geometries before the drag is done as follows. Let P be the
        point referred by the node_id, N be the normal and B be the base point of
        the refplane and T be the tangent vector of drag line at S. First, input surfaces are
        translated by the direction vector PB. If Bit4 of the options is not set, then, the surfaces
        are rotated by the rotation from vector N to vector T. Also, the drag line is translated by
        the direction vector SB. The drag is applied to these surfaces by line L. So, if P is
        selected on an input surface, the new location of P is going to be at B. Moreover, if P is
        one of the vertex points of the input surfaces, one gets an exact geometric copy of the drag
        line at B, no matter which drag method is chosen. This is because, prior to drag, P is moved
        to B and B moves on drag line since it coincides with the start point of the drag line L. 
If node_id is not given, it is chosen as the same point as S, the start
        of the drag line. This means, with the default value of node_id, the drag
        line is not transformed.
If the reference plane is not given, their default values are B at P and N=T. This means,
        with the default value of transformation plane, the input surfaces are not transformed prior
        to drag.Note: The location of P is not important, if fixed frame method is chosen with no
          transformation plane, since each point on the section surface traces an exact geometric
          copy of the drag line in fixed frame method. 

","Inputs

surfs_mark_id
The mark ID containing the surfaces that you wish to drag.
lines_list 
The list ID containing the lines that will be used to from the drag line. 
The first line in this list determines the direction of the drag, which is also shown
            to the user on the screen. If the drag line has corners, then the new solids are split
            at those locations.
method
Parameter specifying the method of how the drag is performed. Valid options are:
0 - Fixed frame 
1 - Follow the drag line only along its tangent direction 
2 - Follow the drag line along its Frenet frame


options
Flags that indicate different modes for the drag. Bit values are used and the value is
            calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4).
Bit0
0 - Only free edges of surfaces are offset. 
1 - Both free and internal edges are offset, thus creating separate solids from
                  surfaces separated by manifold edges.
Bit1
0 - Create solid entities. 
1 - Create only the boundary of solids.
Bit2
 0 - Drag along the direction of the drag line. 
1 - Drag along the opposite direction of the drag line.
Bit3
 0 - Use the ref_plane. input 
1 - Do not use the ref_plane input. Instead, use its default
                  values.
Bit4
0 - Use the whole ref_plane for transformation if it is
                  given. 
1 - Use the only the base point of the reference plane, set the normal as the
                  tangent of the drag line at drag start point.


comp_mode
Parameter specifying how entities are organized into components:
0 - Solids are created in the current component and boundary surfaces are moved
                to the same component. 
1 - Solids are created in the current component, but surfaces remain in their
                original component. 
2 - Solids are created in the same component as the selected surfaces. The result
                is not predictable, if the surfaces are originally in different components.


?node_id? (optional)
The ID of the node, which is used as a reference point while determining the way the
            surfaces are transformed prior to drag.
?ref_plane? (optional)
When provided, its value must always be 1. It is used to determine the initial
            reference frame. This plane is created using the *createplane
            command.

","Examples
Assume that you want to drag section-surfaces with ids 39 401 and 388, along the line that
        is formed by combining lines with IDs 37 and 25 using fixed frame method. Assume that you
        want to drag along the direction opposite to the direction of line 37, and want to drag both
        free and internal edges. Moreover, you want the results solids to be in the component of the
        surfaces. Then, options = 1+4 = 5, and comp_mode = 2. If you do not want
        to use any reference plane, use the following commands to create dragged solids. As a result
        one side of the solids will be the input section surfaces, while the opposite side will be
        an exact translated copy of that section surface, and vertices of the section surface will
        trace an exact translated copy of the drag-lines broken at possible vertex points.
*createmark lines 1  39 401 388 
*createlist lines 1  37 25 
*solidcreatedragsurfalongline 1 1 0 5 2

In addition if you now want to use a reference node with ID 12, which happen to lie on one
        of the section surfaces, and a reference plane, then use:
*createmark lines 1  39 401 388 
*createlist lines 1  37 25
*createplane 1 1.0000 1.0000 1.0000 2678.0 -737.7 548.1 
*surfacecreatedraglinealongline 1 1 0 5 2 12 1 
The solid created will be in such a way that the new location of the point on which node 12
        located, will be at the base point (2678.0 -737.7 548.1) of the reference plane.
","Errors
Invalid or inconsistent input parameters in
          *solidcreatedragsurfalongline result in a Tcl
        error. To detect errors, you can use the catch command:
if { [ catch {*solidcreatedragsurfalongline 1 1 0 0 0} ] } {
# Handle error
}
"
2325,*solidmap_end,"Description
This command is used by the solid mapping algorithm to indicate the end of a solid mapping
        command block. It must be paired with a *solidmap_begin command. A single
        solidmap mesh is a result of the block of commands. 
In a solidmap command block, all of the commands before *solidmap_end
        are for preparing input data. *solidmap_end is the command that
        actually performs the solid mapping.
","Inputs

options
Flags that indicate different modes for solid mapping. It is not recommended to
            manually set these bits. Instead, use them from an existing command file.
density_or_size
Either the element density or size in the along direction, depending on options in the
            options parameter.
bias_style
The type of biasing to use. Valid values are:
0 - linear 
1 - exponential 
2 - bell curve


biasing
The biasing intensity value. A value of 0 indicates no biasing.

","Example
For a solidmap using the following inputs: 
Source geometry - lines 73 and 51; 
Destination geometry - lines 32 and 41; 
Along geometry - lines 74 and 75, surfaces 100 and 95, nodes 80 and 101-105; 
Element size - 10
*solidmap_begin 1

*solidmap_prepare_userdataptr ""SOURCE"" 10
*createmark lines 1 73 51
*solid_prepare_entitylst lines 0

*solildmap_prepare_userdataptr ""DEST"" 2
*createmark lines 1 32 41
*solid_prepare_entitylst lines 0

*solidmap_prepare_userdataptr ""ALONG"" 7
*createmark lines 1 74 75
*solid_prepare_entitylst lines 0
*createmark surfs 1 100 95
*solid_prepare_entitylst surfs 0
*createlist nodes 2 80 101 102 103 104 105
*solid_prepare_nodeline 0

*solidmap_end 0 10 0 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2326,*solidmap_solids_set_density,"Description
This command is for setting the per edge elem density for solid map meshing. The density
        value specified is only a target value. Depending on solvability, the resulting mesh may
        take on a modified value. This command can only be called between a
          *solidmap_solids_begin and *solidmap_solids_end
        command pair.
","Inputs

mark_id
The ID of the mark containing the lines/edges to set the element density for. Valid values are 1 and 2.
elem_density
The value to set the density to for the selected lines/edges.

","Example
To mesh solids 32 and 41 with a default elem size of 2.0 except on edges 2 and 4 which
        should have an elem density of 10.0:

*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
*createmark lines 1 2 4
*solidmap_solids_set_density 1 10.0
*solidmap_solid_end
","Errors
Invalid or inconsistent input parameters in *solidmap_solids_set_density result in a Tcl
        error. To detect errors, you can use the catch
        command:if { [ catch {*solidmap_solids_set_density 3 2.0} ] } {
# Handle error
}

"
2327,*solidmap_solids_set_face_params,"Description
This command is for setting the per surface mesh type and mesh flags. The command has
        effect only for surfaces for which the mesh type and flags are free to change (e.g not a
        along face of a solid and not linked to a premeshed surface…). 
It can only be called between a *solidmap_solids_begin and
          *solidmap_solids_end command pair.
","Inputs

mark_id
The ID of the mark containing the surfaces to set the meshing flags for. Valid values are 1 and 2.
options
Flags that indicate different options for solid mapping. Bit values are used and the
            value is calculated as (Bit0 + 2*Bit1 + 4*Bit2 + 8*Bit3 + 16*Bit4 + 32*Bit5 + 64*Bit6 +
            128*Bit7…). The bits not listed below are unused or for internal use (e.g. called in
            other commands).
Bit0,1
0/1/3 - Non-mapped mesh type. 
2 - Mapped mesh type. The 4 most prominent vertices are used as corners.
Bit2-4
Elem type if non-mapped.
0- Use the same type defined in *solidmap_solids_begin. 
1 - tria 
2 - quad 
3 - mixed 
4 - R-tria


Bit5


0 - Size control off 
1 - Size control on


Bit6


0 - Skew control off 
1 - Skew control on


Bit7


0 - Mesh flow alignment off 
1 - Mesh flow alignment on


Bit8


0 - Global size control off 
1 - Global size control on





","Example
To mesh solids 32 and 41 with a default elem size of 2.0. Additionally, surfaces 5 and 10
        are to be of mapped mesh type by auto determining the corners: 
*createmark solids 1 32 41
*solidmap_solid_begin 1 0 2.0
   *createmark surfs 1 5 10   
   *solidmap_solids_set_face_params 1 2
*solidmap_solid_end

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2328,*solidmesh12lines,"Description
Creates a solid mesh in a volume formed by twelve lines. 
","Inputs

lines
The line list ID which contains lines that define a solid. 
density1
The density of the elements in the first direction. 
density2
The density of the elements in the second direction. 
density3
The density of the elements in the third direction.

","Errors
None.
",
2329,*solverdeckcleanup,"Description
Deletes or retains certain solver specific entities, based on their validity in the current
        model. This is useful after a box trim operation.
","Inputs

solver
The source solver name. Currently only LsDyna
            is supported.
mark_id
The ID of the mark containing the entities to consider for cleanup. Valid values are 1 and 2.
Supported entity types include groups, controlvols, and loads.

The following operations are performed:
* AIRBAG_ADVANCED_ALE (control volume): Delete if at least one bag ID is not
            defined.
*AIRBAG_INTERACTION (control volume): Delete if the card image
            does not contain both AB1 and AB2 values. Both have to be present for the entity to be
            retained.
*AIRBAG_PARTICLE (control volume): Delete if the card image does not reference either
            a part set ID or part ID corresponding to variables SID1 and SID2. Only one has to be
            present for the entity to be retained.
*AIRBAG_<option> (control volume): Delete if the slave definition is empty.
*ALE_options (ALE group)
*CONSTRAINED_EULER_IN_EULER (group)
*CONSTRAINED_LAGRANGE_IN_SOLID (ALE group)
*CONSTRAINED_RIGID_BODIES (group)
*CONSTRAINED_TIE-BREAK (group)
*CONTACT (group): Delete if either the master or slave definition is missing or
            empty.
*CONSTRAINED_EXTRA_NODE (group): Delete if no nodes or node set are associated. In its
            card image, remove the keyword if PSID is assigned as blank.


The following keywords, if defined, do not need explicit entity definitions as they
        consider the entire model, and will be retained:
*CONTACT (group): If master or slave type is assigned a value of 5.
*LOAD_BLAST
*LOAD_BODY
*LOAD_BRODE
*INITIAL_VELOCITY_<option>
*RIGIDWALL: If variable NSID is assigned a value of 0.


","Example
To cleanup all relevant entities on mark 1:
*solverdeckcleanup LsDyna 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2330,*sphereclipautofit,"Description
Toggles the autofit feature for spherical clipping on or off.
","Inputs

onoff 
Determines whether the autofitting for spherical clipping is turned on or off: 
1 - on 
0 - off

","Example
To turn on autofit for spherical clipping.
* sphereclipautofit (1)
","Errors
None.
"
2331,*splitelementswith1D,"Description
Splits shell elements on all sides, along with all connected 1D elements.
","Inputs

inferred


0 - Do not use an inferred surface if no geometry exists 
1 - Use an inferred surface if no geometry exists


mark_id
The ID of the mark containing the elements to split. Valid values are 1 and 2.

","Examples
To split elements 1-10, along with all connected 1Ds:
*createmark elems 1 1-10
*splitelementswith1D 0 1
To split elements 1-10, along with all connected 1Ds, using an inferred surface:
*createmark elems 1 1-10
*splitelementswith1D 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2332,*springos,"Description
Creates a spring element between two nodes using various orientation methods. 
The orientation may be specified using either vector_id, direction_node_id,
          system_id or individual components (orient_x,
          orient_y, orient_z).
","Inputs

node_id1
The ID of the first node.
node_id2
The ID of the second node.
property_name
The name of the property to assign to the element.
vector_id
The ID of the orientation vector assigned to the element.
direction_node_id
The ID of the direction node assigned to the element.
orient_x
The x-component of the orientation vector.
orient_y
The y-component of the orientation vector.
orient_z
The z-component of the orientation vector.
orient_comps_flag


0 - Do not use individual components to define the orientation 
1 - Use individual components to define the orientation


system_id
The ID of the orientation system assigned to the element.

","Example
To create a spring element between node 100 and node 101 with property springprop, using
        node 51 as the orientation node:
*springos 100 101 ""springprop"" 0 51 0 0 0 0 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2333,*springsupdate,"Description
 Updates the properties of spring elements. 
","Inputs

mark
The ID of the mark which contains the spring elements to be updated. 
dofflag
Set to 1 if the dofs should be updated, otherwise 0.
dof
The degree of freedom which the spring elements should be updated to (one digit of
            1-6). 
propertyflag
Set to 1 if the property should be updated, otherwise 0.
property
The property to which the element should point. 
Vectorflag
Set to 1 if the vector should be updated, otherwise 0.
vectorid
The ID of the orientation vector associated with the spring element.

","Example
To update spring element 16, 17, and 18 to have a degree of freedom of 3 and a property
        reference to sprate, without an orientation vector: 
*createmark(elements,1) 16 17 18
*springsupdate(1,1,3,1,""sprate"",0)
","Errors
None.
"
2334,*startnotehistorystate,"Description
Defines the start of a history state. Must be followed by a call to
          *endnotehistorystate with the same name value. 
This is used to group a set of commands into a single undo/redo operation. All commands
        that appear within the start/end block must be supported for undo/redo.
","Inputs

name
The name of the history state. If the name contains spaces, it must be enclosed in
            curly braces or quotes.

","Example
To execute an element remesh operation on two selections of elements, but consider them as
        a single history operation:
*startnotehistorystate {Remesh two element selections}
*setedgedensitylinkwithaspectratio 0
*setoption element_order=1
*setusefeatures 3
*createmark elements 1 1-100
*defaultremeshelems 1 1 2 2 1 1 1 1 0 0 0 0 2 30
*createmark elements 1 1-1-200
*defaultremeshelems 1 2 2 2 1 1 1 1 0 0 0 0 2 30
*setusefeatures 0
*endnotehistorystate {Remesh two element selections}
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2335,*surfaceaddpointsfixed,"Description
Adds meshing fixed points to a mark of surfaces, either by breaking edges or adding
        interior fixed points. The coordinates for the fixed points are supplied by a pointmark.
","Inputs

surfacemark
The ID of the mark containing the surface to modify.
pointmark
The ID of the mark containing the points to add.
tolerance
The closeness tolerance used to decide which points belong to a surface. A point can
            be added to more than one surface out of the mark.
createplot
Defines whether or not a plot element will be created between two points. It will be
            in the ^welds component.
0 - do not create a weld element 
nonzero create a weld element

","Example
To add point 9 to surface 190:
*createmark(surfaces,1) 190
*createmark(points,2) 9
*surfaceaddpointsfixed(1,2,0.05,1)
","Errors
None.
"
2336,*surfacecopyedges,"Description
Create lines from the edges of a surface. 
","Inputs

surface
A surface that contains edges (a full sphere or torus does not contain edges). 
list
The mark ID of the nodes used to select the surface edges (if
              all_edges is 0). 
all_edges
1 - Copy all edges of the surface to new lines. 
0 - Only copy edges that have a node created on them (from list).

","Example
To copy all edges of surface 1 to new lines: 
*createlist(nodes,2)
*surfacecopyedges(1,2,1)
*createmark() is required for this command.
","Errors
None.
"
2337,*surfacecreatespinlinewithoffsetangle,"Description
Spins lines to create surfaces by specifying a start and end angle.
","Inputs

mark_id
The mark ID containing the lines that you wish to spin.
rotation_plane
The axis about which to spin the lines (plane normal is used as axis vector and the
            base point of the plane is used as the rotation center).
start_angle
Degrees value of initial rotation angle: selected lines are rotated by this value
            before surface ""sweeping"" begins.
end_angle
Degrees value of final rotation angle: surface ""sweeping"" stops at this value.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1).
Bit0
Line merging mode. Valid values are:
 0 - Do not merge input lines. A surface is created for each input line. 
1 - Merge input lines into smooth lines when possible. A surface is created
                      for each group that forms tangentially continuous line.


Bit1
Specifies how entities are organized into components. Valid values are:
 0 - Surfaces are created in the current component. 
1 - Surfaces are created in the most common input lines component.





","Example
To spin line 2 from 45 to 90 degrees about an axis given by the vector (1 2 3) with
        rotation center at point (4 5 6), creating a surface of revolution in current component:
*createmark lines 1 2
*createplane 1 1 2 3 4 5 6
*surfacecreatespinlinewithoffsetangle 1 1 45 90 0

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2338,*surfacefilletremove,"Description
Defeatures/removes selected fillet surfaces. 
When a fillet surface is removed, the replacement surface is built by extending the
        surfaces adjacent to the fillet surface and trimming them by mutual intersections. At the
        free edges of the fillet surface, an imaginary surface is built that intersects the fillet
        surface normally having the free edge. The imaginary surfaces are used to trim the
        replacement surfaces to form free edges. 
Sometimes, it may be necessary to change this default interpretation of fillet surface
        edges. For example, suppose that you want to replace a single fillet in a series of
        connected fillet surfaces. It is necessary to disconnect this fillet from the others by
        selecting the connecting edges and passing them as a second argument to the command. 
Another example involves building replacement surfaces for an isolated fillet surface. An
        isolated fillet does not have adjacent surfaces from which to build extensions. You can
        select edges that are connected to an imaginary surface that is to be extended and pass
        those edges as the first argument to the command. The extension surfaces are built as the
        surface tangent to the fillet surface at the selected edges.
","Inputs

surfs_mark_id
The ID of the mark containing the fillet surfaces to remove. Valid values are 1 and 2.
lines_mark_id1
The ID of the mark containing the fillet surface edges at which the extension surface
            replacing the fillet must be built. The extension surface is built by using the fillet
            surface instead of extending the surface that is adjacent to the fillet surface. Valid values are 1 and 2.
lines_mark_id2
The ID of the mark containing the fillet surface edges that are treated as free edges.
              Valid values are 1 and 2.

","Example
To remove fillet surface 241, while using the edge 635 to build a replacement surface as a
        tangent to the fillet surface, and treating edges 746 and 747 as free:
*createmark surfs 1 241
*createmark lines 1 635
*createmark lines 2 746 747
*surfacefilletremove 1 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2339,*surfacemark_find_organize_symmetry,"Description
This command compares surfaces from two different sets, checking whether any surface in one
        set has an identical counterpart in another set after reflection with respect to the input
        plane. Optionally, only one set of surfaces can be provided on input, in which case this
        single set is automatically split into two sets based on the surfaces’ position with respect
        to the input plane. As a result of symmetry calculations, surfaces are either deleted or
        reorganized into newly created components, depending on the chosen options parameter (see
        comments).
","Inputs

surf_set_mark_id1
The mark containing the surfaces in the first set.
surf_set_mark_id2
The mark containing the surfaces in the second set, or zero for no additional
            surfaces.
plane 
The symmetry plane around which surfaces will be reflected & compared.
options 
An integer value representing a combination of flags used to modify command behavior
            (see comments).
tolerance 
Tolerance value used to calculate surfaces identity.
Parameter options description 
As a result of surface sets symmetry calculation, input surfaces are separated into
            four sets:
output_set0 - unmatched (no symmetric counterpart was found) surfaces of
                  input set surf_set_mark_id1. 
output_set1 - matched (symmetric counterpart was found) surfaces of
                  surf_set_mark_id1. 
output_set2 - unmatched (no symmetric counterpart was found) surfaces of input set
                  surf_set_mark_id2. 
output_set3 - matched (symmetric counterpart was found) surfaces of
                  surf_set_mark_id2.


The options parameter is composed of several ""action"" groups, with
            each group consisting of four bits. Each bit in the group corresponds to one of four
            output sets: 
Action group ""move to component"" - bits 0…3: These bits correspond to the output set
            numbers (0-3). Surfaces from the specified output set set are moved into a component
            with a predefined name as described below:
output set
original component name
new component name


output_set0
<name>
<name>_unmatched


output_set1
<name>
<name>_plus


output_set2
<name>
<name>_unmatched


output_set3
<name>
<name>_minus



Action group ""delete"" - bits 4…7 (corresponding to <output set #+4>): surfaces from
            the corresponding output set (4=unmatched/mark1, 5=matched/mark1, 6=unmatched/mark2,
            7=matched/mark2) are deleted (if both ""move to component"" and ""delete"" actions are
            specified for the same output set, this ""delete"" action takes precedence). 
Action group ""highlight"" - bits 8…11 (corresponding to <output set #+8>): surfaces
            from the corresponding output set (8=unmatched/mark1, 9=matched/mark1,
            10=unmatched/mark2, 11=matched/mark2) are also placed into their corresponding input set
            and highlighted. 
The final value for the options parameter is the sum of 2 to the power of the bit
            value for each desired action. For example, the ""move to component"" output set uses bit
            values equal to the output set numbers, so so moving the unmatched surfaces (output_set0
            and output_set2) into a component requires an options value of 2^0 +
            2^2 = 5.

","Example
Suppose you want to find the symmetry between surfaces in a set marked by input mark 1 and
        surfaces marked by input mark 2. You want to use identity tolerance of 0.1. You want to
        reorganize and highlight surfaces that were found to be symmetrical, and to delete surfaces
        that do not have symmetric counterpart. You would then construct the
          options parameter as follows:
Organizing symmetric surfaces - add bits 1 and 3 (action group ""move to component"" for
            output_set1 and output_set3). 
Deleting unmatched surfaces - add bits 4 and 6 (action group ""delete"" for output_set0
            and output_set2). 
Highlighting symmetric surfaces - add bits 9 and 11 (action group ""highlight"" for
            output_set1 and output_set3).


Combining all bits gives the value for options parameter:
options = 2^1 + 2^3 + 2^4 + 2^6 + 2^9 + 2^11 = 2650
So we call the command as:
*surfacemark_find_organize_symmetry 1 2 2650 0.1
","Errors
This command does not return any errors that can be handled.
"
2340,*surfacemarksplitwithplane,"Description
Splits a group of surfaces with an infinite plane.
","Inputs

mark
The ID of the mark containing the surfaces.
plane
The plane used to split the surfaces.

","Example
To split surfaces 10 and 20 with the xy plane (normal equals the z-axis):
*createmark(surfaces,1) 10 20
*createplane(1,0.0000,0.0000,1.0000,0.0000,0.0000,0.0000)
*surfacemarksplitwithplane(1,1)
","Errors
None.
"
2341,*surfaceprimitivefromlines,"Description
This command takes input lines and uses them as targets to construct surface of specified
        primitive type. Optionally, tolerance value can be specified to reject surface that does not
        fit input lines. 
","Inputs

mark_id
The mark of input lines.
surf_type
The type of primitive surface to create. Valid values are: 
1 - plane 
2 - sphere 
3 - cylinder 
4 - cone 
5 - general quadric surface 
For surf_type 4, if a cylinder can be fit to the input entities, it
            will be created instead of a cone.
tol_mode
0 - Tolerance is not used, best possible surface is found for any input set of points. 
1 - Tolerance specified by tol parameter is used to reject surface
            that does not fit input points.
tol
Tolerance value used to accept generated surface. Not used if
              tol_mode is 0. Negative value can be set to specify that the global
            value of the geometry cleanup tolerance set using *setoption
              cleanup_tolerance should be used.
options
Flags that indicate different modes. Bit values are used and the value is calculated
            as (Bit0 + 2*Bit1). 
Bit0
Trimming mode. Valid values are:
0 - An untrimmed surface is created. 
1 - Created surface is trimmed by input lines and automatically stitched to
                      adjacent surfaces. 
In this case, the value of tol_mode should be set to 1.
                    


Bit1
Specifies how entities are organized into components. Valid values are: 
0 - Surface is created in the current component.
1 - Surface is created in the most common input lines component.





","Examples
To create a cone surface that fits all displayed lines in the best possible way:
*createmark lines 1 ""displayed""
*surfaceprimitivefromlines 1 4
To try to create a sphere that fits lines 1 through 8 with a deviation not larger than
        0.02, and trim the resulted surface with the input lines:
*createmark lines 1 1-8
*surfaceprimitivefromlines 1 2 1 0.02 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2342,*surfaceskin,"Description
Creates a skin surface across a line list, and optionally, prepares it for immediate use in
        the automesher. It can also identify a region in the shape of a skin surface for the
        automesher to use under the mesh without surface option. 
","Inputs

skin_linelist
The ID of the list of lines forming the ribs of the skin surface.
auto_reverse
Indicates whether the lines should be tested for a ""bow tie"" condition and reversed if
            necessary (1 for yes, 0 for no). 

","Example
To create a skin surface across lines 1, 2, 3, and 4 with no elements: 
*surfacemode(4)
*createlist(lines,1) 1 2 3 4
*surfaceskin(1,1)

The *surfacemode(4) tells HyperMesh not to
        proceed with element creation, but to create a surface for later use. The
          *createlist() directive is required for this command. 
","Errors
None.
"
2343,*surfacespherefromthreepoints,"Description
Creates a full or partial sphere, and optionally, prepares it for immediate use within the
        automesher. It can also identify a region in the shape of such a sphere for the automesher
        to use under the mesh without surface option. 
","Inputs

center
A node specifying the center. 
radius
The radius of the sphere. 
r
A node specifying the r vector. 
theta start
Angle at which theta starts (0.0 to < theta end).
theta end
Angle at which theta ends (> theta start to 360.0). 
angle
A node specifying the angle vector. 
phi start
Angle at which phi starts (-90.0 to < phi end). 
phi end
Angle at which phi ends (> phi start to 90.0). 
angle type
Defines whether the angle vector is to be theta or phi. 
0 - The angle vector will be theta. 
1 - The angle vector will be phi.

","Example
To create one quarter of a sphere with a radius of 10 through using nodes 1, 2 and 3, but
        not create any elements: 
*surfacemode(4)
*surfacespherefromthreepoints(1,10.0,2,0.0,180.0,3,0.0,90.00,0)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2344,*surfacesplinefrommesh,"Description
Creates geometry on selected 2D mesh elements. Uses selected plot elements to create edges
        between surfaces. 
","Inputs

shellelemmarkmask
Selection markmask for 2D mesh elements that are used to create surfaces.
edgeelemmarkmask
Selection markmask for plot 1D elements that are used to create boundaries between
            created surfaces.
tol
Maximal deviation of mesh points from created surfaces at boundaries. If the value is
            set to 0 or is negative, deviation is calculated internally based on the average size of
            mesh elements.

","Example
To create geometry that fits set of 2D elements selected by markmask 1 and use 1D elements
        selected by markmask 2 to create boundaries between surfaces. Use automatically calculated
        tolerance for created boundaries.
*surfacesplinefrommesh(1, 2, 0)
Selection markmask for elements are created by *createmark command. The
        type of selected elements is being checked internally before processing. Therefore, the
        option for global selection (*createmark(elements,1) ""displayed"", for
        example) can also be used. 
","Errors
None.
"
2345,*surfacesplineonnodesloop2,"Description
Creates a spline surface using a node list as boundary conditions. 
","Inputs

list_id
The ID of the list containing the input nodes. Valid values are 1 and 2.
The nodes should be selected in an order consistent with the intended trimming
            boundary of the constructed surface. No attempt is made to correct the input by
            rearranging the order of the nodes.
options
If set to 0, input nodes that were not already associated to any geometry get
            associated to the new surface. In addition, in simultaneous meshing modes set by
              *surfacemode, input nodes are taken into account to create
            connections between the new surface mesh and an already existing mesh. 
If set to 1, input nodes are not associated to the new surface and are not taken into
            account in simultaneous meshing modes.

","Example
To build a spline from the nodes 1, 2, 3 and 4:
*surfacemode 1
*createlist nodes 1 1 2 3 4
*surfacesplineonnodesloop2 1 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2346,*surfacesplitwithplane,"Description
Splits a surface with an infinite plane. 
","Inputs

surface
The surface to be split. 
plane
The plane used to split the surface

","Example
To split surface 1 with the xy plane (normal equals the z-axis): 
*createplane(2,0.0,0.0,1.0,0.0,0.0,0.0)
*surfacesplitwithplane(1,2)

","Errors
None.
"
2347,*surfacetorus,"Description
Creates a full or partial torus, and optionally, prepares it for immediate use in the
        automesher. It also can identify a toroidal region for the automesher to use with the mesh
        without surface option. 
","Inputs

center
A node specifying the major center of the torus.
major vector
A node specifying the major axis of the torus.
normal vector
A node specifying the normal axis of the torus.
minor radius
The minor radius of the torus.
major radius
The major radius of the torus.
major start angle
Angle at which the major radius of the torus starts (0.0 to < major end angle).
          
major end angle
Angle at which the major radius of the torus ends (> major start angle to 360.0).
minor start angle
Angle at which the minor radius of the torus starts (0.0 to < minor end
            angle).
minor end angle
Angle at which the minor radius of the torus ends (> minor start angle to 360.0).

","Example
This example creates the bottom half of a torus with center at node 1, normal vector at
        node 12, major vector at node 4, and a major radius of 10 and a minor radius of 2.5, but
        does not continue to the automesher for element creation: 
*surfacemode(4)
*surfacetorus(1,12,4,2.5,10.0,0.0000,360.0000,180.0000,
   360.0000)
The *surfacemode(4) directive tells HyperMesh not to pass the information on to the automesher for element creation. 
","Errors
None.
"
2348,*systemcreate3nodes,"Description
Creates a rectangular coordinate system. 
","Inputs

type
The type of system being created. 
0 - rectangular 
1 - cylindrical 
2 - spherical
origin
The ID of a node which defines the origin.
axisname
A string which identifies the axis being defined with the next parameter (x, y, or
            z).
axispt
The ID of a node which defines a point on the axis defined by axisname.
planename
A string which identifies the plane being defined with the next parameter (xy, xz, or
            yz).
planept
The ID of a node which defines a point on the plane defined by planename.

","Example
To build a cylindrical system with node 1 defining the origin, node 2 defining the x axis,
        and node 3 defining the xy-plane:
*systemcreate3nodes(1,1,x,2,xy,3)
","Errors
None.
"
2349,*tablecreate,"Description
Adds a row of data to the bottom of a table.
","Inputs

name
The name of the table to create.
color
The color of the table. Valid values are 1-64.
config
Currently reserved for future use. Must be set to 1.
string_array
The ID of the string array that contains the data type of each column. The string
            array is created using the *createstringarray command. This should
            always be set to 1. 
Valid column data types are:
bool 
string 
int 
unsignedint 
float 
double 
triple 
HM 
entity 
types (e.g. elements, plies, components, etc...)


number_of_columns
Integer indicating the size (number of strings) in the string array created
              using *createstringarray. This must equal the number of columns in
            the table.
number_of_rows
Integer indicating the number of rows to pre-reserve in the table.

","Example
To create a table named ""table1"" with color 3, 4 columns of data (integer, double, string,
        elements), and no pre-reserved rows:
*createstringarray 4 INT DOUBLE STRING elements
*tablecreate table1 3 1 1 4 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2350,*tableexport,"Description
Exports data from a table to a file.
","Inputs

name
The name of the table to export.
filename
The full path and filename of the file to write.
delimiter
The character or string to use as the delimiter. The value must be enclosed in quotes.
            If not specified, the default is a comma (CSV).

","Examples
To write out table1 with commas as the separator.
*tableexport table1 C:/table1.txt "",""
or
*tableexport table1 C:/table1.txt
To write out table1 with ABC as the separator.
*tableexport table1 C:/table1.txt ""ABC""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2351,*tablepopulate,"Description
Populates an existing table with data from a delimited file. The data in the file must
        match the format of the columns defined in the table. Additional rows are appended to the
        table and existing data remains.
","Inputs

name
The name of the table to populate. The table will be overwritten with the data from
            the file.
filename
The full path and filename of the file to use to populate the table.
delimiter
The character or string to use as the delimiter. The value must be enclosed in quotes.
            If not specified, the default is a comma (CSV).

","Examples
To populate table1 with C:/table1.csv, which is a comma delimited
        file:
*tablepopulate table1 C:/table1.csv "",""
or
*tablepopulate table1 C:/table1.csv
To populate table1 with C:/table1.txt, which is a space delimited
        file:
*tablepopulate table1 C:/table1.txt "" ""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2352,*tableupdatecolumn,"Description
Updates the values in a column of a table.
","Inputs

name
The name of the table to update.
data_flag
A flag defining if the data_type and column data contained in
              string_array should be updated (1) or ignored (0).
data_type
The data type of the column. See *tablecreate for valid values.
            Ignored if data_flag=0.
column_label_flag
A flag defining if the column_label should be updated (1) or
            ignored (0).
column_label
The label of the column. Ignored if column_label_flag=0
string_array
The ID of the string array that contains the column data to update. The string array
            is created using the *createstringarray command. This should always
            be set to 1. Ignored if data_flag=0.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table. Ignored if data_flag=0.
column_index
The index of the column to update. Tables are indexed starting from 1 (1 to n
            columns).

","Example
To update the data of column 3 of ""table1"" which has 7 rows of integers, but ignore the
        label:
*createstringarray 7 1 2 3 4 5 6 7
*tableupdatecolumn table1 1 int 0 """" 1 7 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2353,*tableupdaterow,"Description
Updates the values in a row of a table.
","Inputs

name
The name of the table to update.
string_array
The ID of the string array that contains the row data to update. The string array is
            created using the *createstringarray command. This should always be
            set to 1.
number_of_strings
Integer indicating the size (number of strings) in the string array created using
              *createstringarray. This must equal the number of columns in the
            table.
row_index
The index of the row to update. Tables are indexed starting from 1 (1 to n rows).

","Example
To update row 3 of ""table1"" which has 7 columns with data types (integer, string, double,
        elements, integer, double, properties):
*createstringarray 7 1 abc 4.567 500 10 3.14159 100
*tableupdaterow table1 1 7 3
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2354,*tetmesh_set_input,"Description
Supplies additional input to *tetmesh. 
For the special case that both inputs are inactive, this command clears selections from all
        previous calls to *tetmesh_set_input and *tetmesh.
        This is normally not necessary since such cleanup is normally done at the end of each call
        to *tetmesh.
","Inputs

entity_type1
The first entity type. Valid values are nodes, elems, comps, surfs and solids.
mark_id1
The ID of the mark containing the first entities. Valid values are 0 (inactive input),
            1 and 2.
mode1


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer 
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL, 
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.


entity_type2
The second entity type. Valid values are nodes, elems, comps, surfs and solids.
mark_id2
The ID of the mark containing the second entities. Valid values are 0 (inactive
            input), 1 and 2.
mode2


-1 - Ignored (inactive input) 
0 - Float without boundary layer 
1 - Fixed without boundary layer 
2 - Float with boundary layer
3 - Fixed with boundary layer 
4 - Size control boxes 
5 - Anchor nodes 
6 - 3D re-mesh 
7 - 3D re-mesh with free boundary swappable-float. 
8 - 3D re-mesh with free boundary remeshable-float. 
9 - Remeshable-float without BL 
10 - Remeshable-float with BL 
11 - Elem input for fluid volume selection. Either touched (or normal pointed
                into) are fluid volumes.



","Example
*createstringarray 1 ""tet: 579 1.2 2 0 0.8 0 0""
*createmark comps 1 ""^elem_size_ctrl_0.1"" ""^elem_size_ctrl_0.5""
*tetmesh_set_input comps 1 4 elems 0 -1
*createmark comps 2 ""float_shells""
*createmark comps 1 ""fixed_shells""
*tetmesh comps 2 0 comps 1 1 1 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2355,*titlecreate,"Description
Creates a title. 
","Inputs

name
The name of the title. 
entities
The type of entity to which the title should be attached.
id
The ID of the entity.
pointindex
The point index.
color
The color of the title. 
font
The font to be used to display the title. 
anchorpoint
The anchor point of the title. 
x
The x location of the anchor point (0.0 - 1.0). 
y
The y location of the anchor point (0.0 - 1.0). 

","Errors
None.
",
2356,*titlesetcurrent,"Description
Sets a title to be the current title. 
","Inputs

titlename
The name of the title which should be made current. 

","Errors
None.
",
2357,*topography_reanalysis,"Description
Extract the final geometry from OptiStruct topology, topography
        and shape optimization results and inherit the boundary conditions for reanalysis. 
","Inputs

grid_filename
The full name and path to the OptiStruct
.grid results file generated from the optimization.
sh_filename
The full name and path to the OptiStruct
.sh results file generated from the optimization.
autobead
Flag that determines whether to create beads. Valid values are: 
0 - Do not create beads. 
1 - Create beads.
bead_threshold
The threshold value for bead creation (0 <= bead threshold <= 1).
isosurface
Flag that determines whether to create isosurfaces. Valid values are: 
0 - Do not create isosurfaces. 
1 - Create isosurfaces.
mode
Iso-surface mode indicating how to process non-design elements. Valid values are: 
0 - Keep all non-design elements with a half layer around. 
1 - Split only intersected non-design elements. 
2 - Split overlapping non-design elements with a half layer around. 
3 - Split overlapping non-design elements.
density_threshold
Threshold value for topology optimization (0 ≤ density threshold ≤ 1).

","Example
Execute OSSmooth on the C:/test/os1.grid and
          C:/test/os.sh files, loading the geometry back to HyperMesh, creating 1 layer autobead with 0.3 bead threshold, splitting
        all quads on non-design/design interface, with a density threshold of 0.3:
*topography_reanalysis ""C:/test/os1.grid"" ""C:/test/os1.sh"" 1 0.3 1 1 3 0.3

","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2358,*translatemark,"Description
This command translates a selection of entities along a vector.
","Inputs

entity_type
The type of entity to translate.
mark_id
The ID of the mark containing the entities. Valid values are 1 and 2.
vector_id
The ID of the vector to use for the translation. This is defined using the
              *createvector command.
distance
The distance to translate.

","Example
To translate node 1 5 units along the y-axis:
*createvector 1 0.0 1.0 0.0
*createmark nodes 1 1
*translatemark nodes 1 1 5.0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2359,*trim_elements2,"Description
Trims 2D elements using 1D or 2D elements. 
","Inputs

base_element_mark
The mark of 2D base elements. Valid values are 1 and 2.
trim_element_mark
The mark of 1D or 2D trimming elements. Valid values are 1 and 2.
mode
Flag to indicate how to connect elements when the trimming elements are 2D elements
            and the boundaries of the selection consist of multiple loops. 
0 - Keep internal elements. 
1 - Elements inside internal loops are removed. For example, no elements inside
            washer.
num_layers
Flag to indicate the number of surrounding element layers will be taken into account
            for remeshing. 
0 - No remeshing 
1 - All elements on base_element_mark will be remeshed
 feature_angle
Parameter used to define feature edge in remeshing.
base_component
Flag to indicate if the imprinted elements should be organized to the same component
            as the base elements. 
0 - Keep original organization for imprinted elements 
1 - Organize all imprinted elements to the same component as the base elements

","Example
To trim elements 1-100 with elements 500-550, removing elements from within internal loops,
        with remeshing, a feature angle of 30 and keeping the original organization:
*createmark elems 1 1-100
*createmark elems 2 500-550
*trim_elements2 1 2 1 1 30 0
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2360,*trueview,"Description
 Modifies the view so that a model-defined vector is normal to the screen. 
","Inputs

plane id
The ID of the plane about whose normal the vector is made perpendicular to the screen,
            and whose base will be placed in the center of the screen. 

","Example
To make the vector (1.0, 0.0, 0.0) normal to the screen and to place the point (0.0, 0.0,
        0.0) at the center of the screen: 
*createplane(1,1.0,0.0,0.0,0.0,0.0,0.0)
*trueview(1)

","Errors
None.
"
2361,*unmaskentitiesincollector,"Description
This command unmasks the entities contained within the collectors of
          entity_type that are on mark_id. Valid
          mark_ids are 1 and 2. Only entities in displayed collectors may be
        unmasked. 
The six flag arguments indicate the type of entities to unmask within
        the specified collectors. If the flag is set to 1, that entity is unmasked. If the flag is
        set to 0, that entity is not modified. Currently supported entity_types
        and flags are:
","Inputs

comps
flag_1- elements
flag_2- points
flag_3- lines
flag_4- surfaces
flag_5- solids
flag_6- connectors
groups
flag_1 - master elements
flag_2- slave elements
flag_3through flag_6 are not used.
loadcols
flag_1- loads
flag_2- equations
flag_3through flag_6 are not used.
multibodies
flag_1- ellipsoids
flag_2- mbjoints
flag_2 - mbplanes
flag_4 through flag_6 are not used

","Examples
To unmask all of the points and surfaces in the displayed components:
*createmark components 1 displayed
*unmaskentitiesincollector comps 1 0 1 0 1 0 0
 To unmask all ellipsoids and mbjoints in all multibodies:
*createmark multibodies 2 all
*unmaskentitiesincollector multibodies 2 1 1 0 0 0 0
","Errors
Incorrect usage of *unmaskentitiesincollector results in a Tcl error. To detect errors, you can use the catch command:
if { [ catch {*unmaskentitiesincollector comps 3 1 1 1 1 1 1} ] } {
# Handle error
}
"
2362,*unmaskshown2,"Description
Unmasks all supported entities in the current view window. Only entities in displayed
        collectors are affected. This includes:
points 
lines 
surfaces 
solids 
elements (both in components and groups) 
connectors 
ellipsoids 
mbjoints 
mbplanes 
loads 
equations 
systems 
vectors 


","Example
To unmask all supported entities in the displayed collectors that are in the current view
        window:
*unmaskshown2
","Errors
None.
",
2363,*unsmoothelements,"Description
From within the automeshing module, undoes the last operation of the
          *smoothelements() command for the specified face. 
","Inputs

faceindex
The index of the face into the particular surface under consideration. 

","Errors
None.
",
2364,*UpdateBinderSections,"Description
This command updates the binder shape using the current section.
","Inputs

entity_type_1
Must be set to surfaces.
mark_id_1
Must be set to 1.
entity_type_2
Must be set to nodes.
mark_id_2
Must be set to 1.
entity_type_3
Must be set to lines.
mark_id_3
Must be set to 1.
entity_type_3
Must be set to nodes.
mark_id_3
Must be set to 2.
plane
Must be set to 1.
rotate_flag
Must be set to 1.
blend_flag
Must be set to 0.
method_flag
Must be set to 5.
con_flag
Must be set to 1.

","Example
To updates the binder shape using the current section:
*UpdateBinderSections surfaces 1 nodes 1 lines 1 nodes 2 1 1 0 5 0 1
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2365,*updateidrange,"Description
This command updates an ID range for a submodel.
","Inputs

submodel_type
The type of submodel to update the ID range for. Valid values are includes and
            submodel. Submodel is recommended. 
id
The ID of the submodel. Not required if shortname is used.
shortname
The shortname of the submodel. Not required if id is used.
entity_type
The type of entity to update the ID range for.
min_id
The minimum ID for the range.
max_id
The maximum ID for the range.
pool_id
The ID of the solver pool.
integer_array
The ID of the integer array that contains the locked IDs. The integer array is created
            using the *createarray command. This should always be set to 1.
number_of_integers
Integer indicating the size (number of integers) in the integer array created using
              *createarray.

","Examples
To update an ID range for include 1 with min ID 1,000 and max ID 100,000 for
        components:
*updateidrange includes 1 """" comps 1000 100000 0 1 0
To update an ID range for include 1 with min ID 1,000 and max ID 100,000 for components,
        with locked IDs 2000 and 5000:
*createarray 2 2000 5000
*updateidrange includes 1 """" comps 1000 100000 0 1 2
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2366,*UpdateLatitudeLineDrag,"Description
This command updates the latitude line shape if int_type value is 6. It
        updates the latitude line shape and the addendum surface shape if
          int_type value is 1.
","Inputs

int_type 
To update the latitude lines its value is 6. 
To update the latitude lines and the addendum surface its value is 1.

","Examples
To update the latitude lines shape:
*UpdateLatitudeLineDrag 6
To update the latitude lines shape and the addendum surface shape:
*UpdateLatitudeLineDrag 1
","Errors
 Incorrect usage of UpdateLatitudeLineDrag results in a Tcl error. The function returns an
        error if the current model does not contain latitude line or addendum surface.
if { [ catch { *UpdateLatitudeLineDrag 6} ] } {
# Handle error here   // I don’t find latitude lines.
}
"
2367,*vectorupdate_xproduct,"Description
Updates a vector entity created from the cross product of two other vectors.
","Inputs

markid
The ID of the mark that contains the vectors to update.
basenode
The ID of the node where the base of the result is located after it is updated.
vector A 
The ID of the first vector entity in the cross product.
vector B
The ID of the 2nd vector entity in the cross product.
magnitude
Magnitude of vectors.
baseflag
A flag (0,1) to update the base node of the vector.
directionflag
A flag (0,1) to update the direction and magnitude of the vector

","Errors
None.
",
2368,*verticesmarksuppress,"Description
Removes the selected fixed points from their surfaces, and gives the option to create free
        points at those locations.
","Inputs

mark_id
The ID of the mark containing the points.  Valid values are 1 and 2.
break_angle
The test threshold used to prevent the accidental removal of points that correspond to
            corners,which are necessary for proper mesh generation. 
save_as_points
1 - To create free points at the locations of the removed fixed points. 
0 - Do not create free points. 

","Example
To suppress points 25 and 26, using a 30 degree breakangle:
*createmark points 1 25 26
*verticesmarksuppress 1 30.0 0
","Errors
None.
"
2369,*visualizemode,"Description
 Sets the parameters for visualization mode. 
","Inputs

hiddenline
 Set to 1 for hidden line, 0 for wire frame. 
fillmode
Set to -2 for contours, -1 for element color, or 0-15 for constant color. 
meshmode
Set to -2 for contours, -1 for element color, or 0-15 for constant color. 
plot
Set to 1 to replot the screen after this command has executed, otherwise 0. 

","Example
This command is valid only after the system has entered into visualization mode.
","Errors
None.
"
2370,*weld,"Description
Creates a weld element between two nodes. 
","Inputs

independent
The independent node. 
dependent
The dependent node.
length
The length of the weld. 
systems
Determines if systems should be built at the end of the node (1 for yes, 0 for no).
          
movenode
Set to 1 to move the node perpendicular to the surface of the elements, otherwise 0. 

","Example
To build a weld element between nodes 100 and 101 with length 1.0 and without systems being
        built at the ends of the weld element: 
*weld(100,101,1.0,0,0)
","Errors
None.
"
2371,*writeqiviewsettings,"Description
This command is related to the element quality view mode. It writes the current element
        quality view settings to a text file that can be read by
          *readqiviewsettings.
","Inputs

flag
The full name and path of the file to save the QI view settings.

","Example
To save the current settings to the file C:/settings/qiview.txt:
*writeqiviewsettings ""C:/settings/qiview.txt""
","Errors
Incorrect usage results in a Tcl error. To detect
        errors, you can use the catch
        command:if { [ catch {command_name...} ] } {
   # Handle error
}
"
2372,*xyplotchangemode,"Description
Changes the mode of an extended plot. 
","Inputs

plotname
Name of the extended (dual) plot to change. 
mode
New mode value (2 or 5).

","Example
*xyplotchangemode(""results"", 5)
Extended (or dual) plots can display data in two modes. In complex mode,
          (mode=2), the Y-axis of the bottom plot is the real component, while
        the Y-axis of the top plot is the imaginary component. In phase/magnitude mode
          (mode=5), the Y-axis of the bottom plot is magnitude (in logarithmic
        form), while the Y-axis of the top plot is phase. Other mode indices (besides 2 and 5) are
        reserved for future use.
","Errors
None.
"
2373,*xyplotcreatecomplex,"Description
Creates an extended or dual plot that contains two sub-plots. 
","Inputs

plot name
The name of the plot to be created. 

","Errors
None.
",
2374,*xyplotcurvepermute,"Description
Permutes a curve. 
","Inputs

curve name
The name of the curve to be permuted. 

","Errors
None.
",
2375,*xyplotmodify,"Description
Modifies an xy plot. 
","Inputs

plot name
The name of the plot to be modified
item name
The name of the data item associated with the xy plot which should be modified.
string
The string value of the data item.
value
The value of the data item.
plot
A logical which determines if the xy plot should be redrawn after modification.

","Errors
None.
",
2376,*xyplotpage,"Description
Pages through the active xy plots making each plot the entire size of the screen, and then
        pausing until a mouse click. 
","Errors
None.
",,
2377,*xyplotpush,"Description
Pushes an xy plot to the bottom level. 
","Inputs

plot name
The name of the plot to be pushed. 

","Errors
None.
",
2378,*xyplotregisterimporttemplate,"Description
Registers an import template. 
","Inputs

filename 
The name of your template file. 

","Errors
None.
",
2379,*xyplotsetsecondcurve,"Description
Sets the second curve to be used when performing mathematical functions on a curve. 
","Inputs

curvename 
The name of the curve. 

","Errors
None.
",
2380,*xyplottwocurvemath,"Description
Performs a math function on two curves. 
","Inputs

function
The function to be performed. 
outputcurve
The name of the output curve
xbased
1 - If the function should operate on the x coordinate.
0 - If the function should operate on the y coordinate.



","Errors
None.
",
